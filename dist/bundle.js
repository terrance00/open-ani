(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concentric_ani_1 = require("./src/concentric-ani");
var horizontal_lines_ani_1 = require("./src/horizontal-lines-ani");
var spinning_arcs_1 = require("./src/spinning-arcs");
var concentricAni = new concentric_ani_1.ConcentricAni(document.getElementById("concentricCircles"));
var spinningArcs = new spinning_arcs_1.SpinningArcsAnni(document.getElementById("spinningArcs"));
var horizontalLines = new horizontal_lines_ani_1.HorizontalLinesAni(document.getElementById("horizontalLines"));
},{"./src/concentric-ani":6,"./src/horizontal-lines-ani":8,"./src/spinning-arcs":9}],2:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, (function (exports) { 'use strict';

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `bin/generate-identifier-regex.js`.
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range. They were
  // generated by bin/generate-identifier-regex.js

  // eslint-disable-next-line comma-spacing
  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

  // eslint-disable-next-line comma-spacing
  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords$1 = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  // Checks if an object has a property.

  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 10.
    ecmaVersion: 10,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  // Switch to a getter for 7.0.0.
  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) { return true } // '['
    if (context) { return false }

    if (nextCh === 123) { return true } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$1.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (this.type !== types.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };

  // Parses module export declaration.

  pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseIdent(true);
          this.checkExport(exports, node.exported.name, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };

  // Parses import declaration.

  pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // Verify that a node is an lval — something that can be assigned
  // to.
  // bindingType can be either:
  // 'var' indicating that the lval creates a 'var' binding
  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  // A recursive descent parser operates by defining functions for all

  var pp$3 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
            // Backwards-compat kludge. Can be removed in version 6.0
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var coalesce = this.type === types.coalesce;
        if (coalesce) {
          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
          prec = types.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };

  // Parse call, dot, and `[]`-subscript expressions.

  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types.bracketL);
    if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();

    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); // skip `(`

    // Parse node.source.
    node.source = this.parseMaybeAssign();

    // Verify ending.
    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseImportMeta = function(node) {
    this.next(); // skip `.`

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module")
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call — at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  // Parses yield expression inside generator.

  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };

  // Start an AST node, attaching a start offset.

  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };

  // Finish node at given position

  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Token-specific context update code

  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A /* * */) ||
      state.eat(0x2B /* + */) ||
      state.eat(0x3F /* ? */) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24 /* $ */ ||
      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
      ch === 0x2E /* . */ ||
      ch === 0x3F /* ? */ ||
      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24 /* $ */ &&
      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
      ch !== 0x2E /* . */ &&
      ch !== 0x3F /* ? */ &&
      ch !== 0x5B /* [ */ &&
      ch !== 0x5E /* ^ */ &&
      ch !== 0x7C /* | */
    ) {
      state.advance();
      return true
    }
    return false
  };

  // GroupSpecifier ::
  //   [empty]
  //   `?` GroupName
  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  // GroupName ::
  //   `<` RegExpIdentifierName `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  // RegExpIdentifierName ::
  //   RegExpIdentifierStart
  //   RegExpIdentifierName RegExpIdentifierPart
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  // RegExpIdentifierStart ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
  }

  // RegExpIdentifierPart ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B /* { */) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D /* } */) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50 /* P */ || ch === 0x70 /* p */)
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B /* { */) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D /* } */)
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64 /* d */ ||
      ch === 0x44 /* D */ ||
      ch === 0x73 /* s */ ||
      ch === 0x53 /* S */ ||
      ch === 0x77 /* w */ ||
      ch === 0x57 /* W */
    )
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* ] */)) {
        return true
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D /* ] */) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }

    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true
    }

    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */)
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */)
    }
    return ch - 0x30 /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };

  // ## Tokenizer

  var pp$9 = Parser.prototype;

  // Move to the next token

  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: // ' '
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: // '*'
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.readToken_question = function() { // '?'
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
        }
        return this.finishOp(types.coalesce, 2)
      }
    }
    return this.finishOp(types.question, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46: // '.'
      return this.readToken_dot()

    // Punctuation tokens.
    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)

    case 96: // '`'
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return this.readNumber(false)

    // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return this.readToken_slash()

    case 37: case 42: // '%*'
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: // '|&'
      return this.readToken_pipe_amp(code)

    case 94: // '^'
      return this.readToken_caret()

    case 43: case 45: // '+-'
      return this.readToken_plus_min(code)

    case 60: case 62: // '<>'
      return this.readToken_lt_gt(code)

    case 61: case 33: // '=!'
      return this.readToken_eq_excl(code)

    case 63: // '?'
      return this.readToken_question()

    case 126: // '~'
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } // a
      else if (code >= 65) { val = code - 65 + 10; } // A
      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""))
  }

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };

  // Read an integer, octal integer, or floating-point number.

  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } // '+-'
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val)
  };

  // Read a string value, interpreting backslash-escapes.

  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { // '{'
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }
      // falls through

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" // 'n' -> '\n'
    case 114: return "\r" // 'r' -> '\r'
    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
    case 117: return codePointToString$1(this.readCodePoint()) // 'u'
    case 116: return "\t" // 't' -> '\t'
    case 98: return "\b" // 'b' -> '\b'
    case 118: return "\u000b" // 'v' -> '\u000b'
    case 102: return "\f" // 'f' -> '\f'
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
    case 10: // ' \n'
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return ""
      }
      return String.fromCharCode(ch)
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "7.4.1";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options)
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
/*!
 * Paper.js v0.12.15 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Mar 17 10:49:48 2021 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = function(self, undefined) {

self = self || require('./node/self.js');
var window = self.window,
	document = self.document;

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,
		array = [],
		slice = array.slice,
		create = Object.create,
		describe = Object.getOwnPropertyDescriptor,
		define = Object.defineProperty,

		forEach = array.forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++) {
				iter.call(bind, this[i], i, this);
			}
		},

		forIn = function(iter, bind) {
			for (var i in this) {
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
			}
		},

		set = Object.assign || function(dst) {
			for (var i = 1, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				for (var key in src) {
					if (src.hasOwnProperty(key))
						dst[key] = src[key];
				}
			}
			return dst;
		},

		each = function(obj, iter, bind) {
			if (obj) {
				var desc = describe(obj, 'length');
				(desc && typeof desc.value === 'number' ? forEach : forIn)
					.call(obj, iter, bind = bind || obj);
			}
			return bind;
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res)) {
					res = { value: res, writable: true };
				}
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable != null ? enumerable : !bean;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function Base() {
		for (var i = 0, l = arguments.length; i < l; i++) {
			var src = arguments[i];
			if (src)
				set(this, src);
		}
		return this;
	}

	return inject(Base, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, null, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, obj, l = arguments.length;
					i < l && !(ctor && proto); i++) {
				obj = arguments[i];
				ctor = ctor || obj.initialize;
				proto = proto || obj.prototype;
			}
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = proto || create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}).inject({
		enumerable: false,

		initialize: Base,

		set: Base,

		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src) {
					inject(this, src, src.enumerable, src.beans, src.preserve);
				}
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			set: set,
			each: each,
			create: create,
			define: define,
			describe: describe,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			},

			slice: function(list, begin, end) {
				return slice.call(list, begin, end);
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	enumerable: false,

	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	importJSON: function(json) {
		return Base.importJSON(json, this);
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	set: function(props, exclude) {
		if (props)
			Base.filter(this, props, exclude, this._prioritize);
		return this;
	}
}, {

beans: false,
statics: {
	exports: {},

	extend: function extend() {
		var res = extend.base.apply(this, arguments),
			name = res.prototype._class;
		if (name && !Base.exports[name])
			Base.exports[name] = res;
		return res;
	},

	equals: function(obj1, obj2) {
		if (obj1 === obj2)
			return true;
		if (obj1 && obj1.equals)
			return obj1.equals(obj2);
		if (obj2 && obj2.equals)
			return obj2.equals(obj1);
		if (obj1 && obj2
				&& typeof obj1 === 'object' && typeof obj2 === 'object') {
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				var length = obj1.length;
				if (length !== obj2.length)
					return false;
				while (length--) {
					if (!Base.equals(obj1[length], obj2[length]))
						return false;
				}
			} else {
				var keys = Object.keys(obj1),
					length = keys.length;
				if (length !== Object.keys(obj2).length)
					return false;
				while (length--) {
					var key = keys[length];
					if (!(obj2.hasOwnProperty(key)
							&& Base.equals(obj1[key], obj2[key])))
						return false;
				}
			}
			return true;
		}
		return false;
	},

	read: function(list, start, options, amount) {
		if (this === Base) {
			var value = this.peek(list, start);
			list.__index++;
			return value;
		}
		var proto = this.prototype,
			readIndex = proto._readIndex,
			begin = start || readIndex && list.__index || 0,
			length = list.length,
			obj = list[begin];
		amount = amount || length - begin;
		if (obj instanceof this
			|| options && options.readNull && obj == null && amount <= 1) {
			if (readIndex)
				list.__index = begin + 1;
			return obj && options && options.clone ? obj.clone() : obj;
		}
		obj = Base.create(proto);
		if (readIndex)
			obj.__read = true;
		obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
				? Base.slice(list, begin, begin + amount)
				: list) || obj;
		if (readIndex) {
			list.__index = begin + obj.__read;
			var filtered = obj.__filtered;
			if (filtered) {
				list.__filtered = filtered;
				obj.__filtered = undefined;
			}
			obj.__read = undefined;
		}
		return obj;
	},

	peek: function(list, start) {
		return list[list.__index = start || list.__index || 0];
	},

	remain: function(list) {
		return list.length - (list.__index || 0);
	},

	readList: function(list, start, options, amount) {
		var res = [],
			entry,
			begin = start || 0,
			end = amount ? begin + amount : list.length;
		for (var i = begin; i < end; i++) {
			res.push(Array.isArray(entry = list[i])
					? this.read(entry, 0, options)
					: this.read(list, i, options, 1));
		}
		return res;
	},

	readNamed: function(list, name, start, options, amount) {
		var value = this.getNamed(list, name),
			hasValue = value !== undefined;
		if (hasValue) {
			var filtered = list.__filtered;
			if (!filtered) {
				var source = this.getSource(list);
				filtered = list.__filtered = Base.create(source);
				filtered.__unfiltered = source;
			}
			filtered[name] = undefined;
		}
		return this.read(hasValue ? [value] : list, start, options, amount);
	},

	readSupported: function(list, dest) {
		var source = this.getSource(list),
			that = this,
			read = false;
		if (source) {
			Object.keys(source).forEach(function(key) {
				if (key in dest) {
					var value = that.readNamed(list, key);
					if (value !== undefined) {
						dest[key] = value;
					}
					read = true;
				}
			});
		}
		return read;
	},

	getSource: function(list) {
		var source = list.__source;
		if (source === undefined) {
			var arg = list.length === 1 && list[0];
			source = list.__source = arg && Base.isPlainObject(arg)
				? arg : null;
		}
		return source;
	},

	getNamed: function(list, name) {
		var source = this.getSource(list);
		if (source) {
			return name ? source[name] : list.__filtered || source;
		}
	},

	hasNamed: function(list, name) {
		return !!this.getNamed(list, name);
	},

	filter: function(dest, source, exclude, prioritize) {
		var processed;

		function handleKey(key) {
			if (!(exclude && key in exclude) &&
				!(processed && key in processed)) {
				var value = source[key];
				if (value !== undefined)
					dest[key] = value;
			}
		}

		if (prioritize) {
			var keys = {};
			for (var i = 0, key, l = prioritize.length; i < l; i++) {
				if ((key = prioritize[i]) in source) {
					handleKey(key);
					keys[key] = true;
				}
			}
			processed = keys;
		}

		Object.keys(source.__unfiltered || source).forEach(handleKey);
		return dest;
	},

	isPlainValue: function(obj, asString) {
		return Base.isPlainObject(obj) || Array.isArray(obj)
				|| asString && typeof obj === 'string';
	},

	serialize: function(obj, options, compact, dictionary) {
		options = options || {};

		var isRoot = !dictionary,
			res;
		if (isRoot) {
			options.formatter = new Formatter(options.precision);
			dictionary = {
				length: 0,
				definitions: {},
				references: {},
				add: function(item, create) {
					var id = '#' + item._id,
						ref = this.references[id];
					if (!ref) {
						this.length++;
						var res = create.call(item),
							name = item._class;
						if (name && res[0] !== name)
							res.unshift(name);
						this.definitions[id] = res;
						ref = this.references[id] = [id];
					}
					return ref;
				}
			};
		}
		if (obj && obj._serialize) {
			res = obj._serialize(options, dictionary);
			var name = obj._class;
			if (name && !obj._compactSerialize && (isRoot || !compact)
					&& res[0] !== name) {
				res.unshift(name);
			}
		} else if (Array.isArray(obj)) {
			res = [];
			for (var i = 0, l = obj.length; i < l; i++)
				res[i] = Base.serialize(obj[i], options, compact, dictionary);
		} else if (Base.isPlainObject(obj)) {
			res = {};
			var keys = Object.keys(obj);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				res[key] = Base.serialize(obj[key], options, compact,
						dictionary);
			}
		} else if (typeof obj === 'number') {
			res = options.formatter.number(obj, options.precision);
		} else {
			res = obj;
		}
		return isRoot && dictionary.length > 0
				? [['dictionary', dictionary.definitions], res]
				: res;
	},

	deserialize: function(json, create, _data, _setDictionary, _isRoot) {
		var res = json,
			isFirst = !_data,
			hasDictionary = isFirst && json && json.length
				&& json[0][0] === 'dictionary';
		_data = _data || {};
		if (Array.isArray(json)) {
			var type = json[0],
				isDictionary = type === 'dictionary';
			if (json.length == 1 && /^#/.test(type)) {
				return _data.dictionary[type];
			}
			type = Base.exports[type];
			res = [];
			for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
				res.push(Base.deserialize(json[i], create, _data,
						isDictionary, hasDictionary));
			}
			if (type) {
				var args = res;
				if (create) {
					res = create(type, args, isFirst || _isRoot);
				} else {
					res = new type(args);
				}
			}
		} else if (Base.isPlainObject(json)) {
			res = {};
			if (_setDictionary)
				_data.dictionary = res;
			for (var key in json)
				res[key] = Base.deserialize(json[key], create, _data);
		}
		return hasDictionary ? res[1] : res;
	},

	exportJSON: function(obj, options) {
		var json = Base.serialize(obj, options);
		return options && options.asString == false
				? json
				: JSON.stringify(json);
	},

	importJSON: function(json, target) {
		return Base.deserialize(
				typeof json === 'string' ? JSON.parse(json) : json,
				function(ctor, args, isRoot) {
					var useTarget = isRoot && target
							&& target.constructor === ctor,
						obj = useTarget ? target
							: Base.create(ctor.prototype);
					if (args.length === 1 && obj instanceof Item
							&& (useTarget || !(obj instanceof Layer))) {
						var arg = args[0];
						if (Base.isPlainObject(arg)) {
							arg.insert = false;
							if (useTarget) {
								args = args.concat([{ insert: true }]);
							}
						}
					}
					(useTarget ? obj.set : ctor).apply(obj, args);
					if (useTarget)
						target = null;
					return obj;
				});
	},

	push: function(list, items) {
		var itemsLength = items.length;
		if (itemsLength < 4096) {
			list.push.apply(list, items);
		} else {
			var startLength = list.length;
			list.length += itemsLength;
			for (var i = 0; i < itemsLength; i++) {
				list[startLength + i] = items[i];
			}
		}
		return list;
	},

	splice: function(list, items, index, remove) {
		var amount = items && items.length,
			append = index === undefined;
		index = append ? list.length : index;
		if (index > list.length)
			index = list.length;
		for (var i = 0; i < amount; i++)
			items[i]._index = index + i;
		if (append) {
			Base.push(list, items);
			return [];
		} else {
			var args = [index, remove];
			if (items)
				Base.push(args, items);
			var removed = list.splice.apply(list, args);
			for (var i = 0, l = removed.length; i < l; i++)
				removed[i]._index = undefined;
			for (var i = index + amount, l = list.length; i < l; i++)
				list[i]._index = i;
			return removed;
		}
	},

	capitalize: function(str) {
		return str.replace(/\b[a-z]/g, function(match) {
			return match.toUpperCase();
		});
	},

	camelize: function(str) {
		return str.replace(/-(.)/g, function(match, chr) {
			return chr.toUpperCase();
		});
	},

	hyphenate: function(str) {
		return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	}
}});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function handler() {
			func.apply(this, arguments);
			this.off(type, handler);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = Base.slice(arguments, 1),
			setTarget = event && event.target && !event.currentTarget;
		handlers = handlers.slice();
		if (setTarget)
			event.currentTarget = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) == false) {
				if (event && event.stop)
					event.stop();
				break;
		   }
		}
		if (setTarget)
			delete event.currentTarget;
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var types = this._eventTypes,
			handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		if (types) {
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var entry = types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			insertItems: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1) || {};
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
		if (!this.agent) {
			var user = self.navigator.userAgent.toLowerCase(),
				os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
				platform = os === 'darwin' ? 'mac' : os,
				agent = proto.agent = proto.browser = { platform: platform };
			if (platform)
				agent[platform] = true;
			user.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
				function(match, n, v1, v2, rv) {
					if (!agent.chrome) {
						var v = n === 'opera' ? v2 :
								/^(node|trident)$/.test(n) ? rv : v1;
						agent.version = v;
						agent.versionNumber = parseFloat(v);
						n = { trident: 'msie', jsdom: 'node' }[n] || n;
						agent.name = n;
						agent[n] = true;
					}
				}
			);
			if (agent.chrome)
				delete agent.webkit;
			if (agent.atom)
				delete agent.chrome;
		}
	},

	version: "0.12.15",

	getView: function() {
		var project = this.project;
		return project && project._view;
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, options) {
			var exports = paper.PaperScript.execute(code, this, options);
			View.updateFocus();
			return exports;
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	createCanvas: function(width, height) {
		return CanvasProvider.getCanvas(width, height);
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		var projects = this.projects,
			tools = this.tools;
		for (var i = projects.length - 1; i >= 0; i--)
			projects[i].remove();
		for (var i = tools.length - 1; i >= 0; i--)
			tools[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	},

	getView: function() {
		return this._scope.getView();
	}
});

var CollisionDetection = {
	findItemBoundsCollisions: function(items1, items2, tolerance) {
		function getBounds(items) {
			var bounds = new Array(items.length);
			for (var i = 0; i < items.length; i++) {
				var rect = items[i].getBounds();
				bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
			}
			return bounds;
		}

		var bounds1 = getBounds(items1),
			bounds2 = !items2 || items2 === items1
				? bounds1
				: getBounds(items2);
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {
		function getBounds(curves) {
			var min = Math.min,
				max = Math.max,
				bounds = new Array(curves.length);
			for (var i = 0; i < curves.length; i++) {
				var v = curves[i];
				bounds[i] = [
					min(v[0], v[2], v[4], v[6]),
					min(v[1], v[3], v[5], v[7]),
					max(v[0], v[2], v[4], v[6]),
					max(v[1], v[3], v[5], v[7])
				];
			}
			return bounds;
		}

		var bounds1 = getBounds(curves1),
			bounds2 = !curves2 || curves2 === curves1
				? bounds1
				: getBounds(curves2);
		if (bothAxis) {
			var hor = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, false, true),
				ver = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, true, true),
				list = [];
			for (var i = 0, l = hor.length; i < l; i++) {
				list[i] = { hor: hor[i], ver: ver[i] };
			}
			return list;
		}
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findBoundsCollisions: function(boundsA, boundsB, tolerance,
		sweepVertical, onlySweepAxisCollisions) {
		var self = !boundsB || boundsA === boundsB,
			allBounds = self ? boundsA : boundsA.concat(boundsB),
			lengthA = boundsA.length,
			lengthAll = allBounds.length;

		function binarySearch(indices, coord, value) {
			var lo = 0,
				hi = indices.length;
			while (lo < hi) {
				var mid = (hi + lo) >>> 1;
				if (allBounds[indices[mid]][coord] < value) {
					lo = mid + 1;
				} else {
					hi = mid;
				}
			}
			return lo - 1;
		}

		var pri0 = sweepVertical ? 1 : 0,
			pri1 = pri0 + 2,
			sec0 = sweepVertical ? 0 : 1,
			sec1 = sec0 + 2;
		var allIndicesByPri0 = new Array(lengthAll);
		for (var i = 0; i < lengthAll; i++) {
			allIndicesByPri0[i] = i;
		}
		allIndicesByPri0.sort(function(i1, i2) {
			return allBounds[i1][pri0] - allBounds[i2][pri0];
		});
		var activeIndicesByPri1 = [],
			allCollisions = new Array(lengthA);
		for (var i = 0; i < lengthAll; i++) {
			var curIndex = allIndicesByPri0[i],
				curBounds = allBounds[curIndex],
				origIndex = self ? curIndex : curIndex - lengthA,
				isCurrentA = curIndex < lengthA,
				isCurrentB = self || !isCurrentA,
				curCollisions = isCurrentA ? [] : null;
			if (activeIndicesByPri1.length) {
				var pruneCount = binarySearch(activeIndicesByPri1, pri1,
						curBounds[pri0] - tolerance) + 1;
				activeIndicesByPri1.splice(0, pruneCount);
				if (self && onlySweepAxisCollisions) {
					curCollisions = curCollisions.concat(activeIndicesByPri1);
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j];
						allCollisions[activeIndex].push(origIndex);
					}
				} else {
					var curSec1 = curBounds[sec1],
						curSec0 = curBounds[sec0];
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j],
							activeBounds = allBounds[activeIndex],
							isActiveA = activeIndex < lengthA,
							isActiveB = self || activeIndex >= lengthA;

						if (
							onlySweepAxisCollisions ||
							(
								isCurrentA && isActiveB ||
								isCurrentB && isActiveA
							) && (
								curSec1 >= activeBounds[sec0] - tolerance &&
								curSec0 <= activeBounds[sec1] + tolerance
							)
						) {
							if (isCurrentA && isActiveB) {
								curCollisions.push(
									self ? activeIndex : activeIndex - lengthA);
							}
							if (isCurrentB && isActiveA) {
								allCollisions[activeIndex].push(origIndex);
							}
						}
					}
				}
			}
			if (isCurrentA) {
				if (boundsA === boundsB) {
					curCollisions.push(curIndex);
				}
				allCollisions[curIndex] = curCollisions;
			}
			if (activeIndicesByPri1.length) {
				var curPri1 = curBounds[pri1],
					index = binarySearch(activeIndicesByPri1, pri1, curPri1);
				activeIndicesByPri1.splice(index + 1, 0, curIndex);
			} else {
				activeIndicesByPri1.push(curIndex);
			}
		}
		for (var i = 0; i < allCollisions.length; i++) {
			var collisions = allCollisions[i];
			if (collisions) {
				collisions.sort(function(i1, i2) { return i1 - i2; });
			}
		}
		return allCollisions;
	}
};

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = Base.pick(precision, 5);
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return this.precision < 16
				? Math.round(val * this.multiplier) / this.multiplier : val;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		log2 = Math.log2 || function(x) {
			return Math.log(x) * Math.LOG2E;
		},
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clamp(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	function getDiscriminant(a, b, c) {
		function split(v) {
			var x = v * 134217729,
				y = v - x,
				hi = y + x,
				lo = v - hi;
			return [hi, lo];
		}

		var D = b * b - a * c,
			E = b * b + a * c;
		if (abs(D) * 3 < E) {
			var ad = split(a),
				bd = split(b),
				cd = split(c),
				p = b * b,
				dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
				q = a * c,
				dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
						+ ad[1] * cd[1];
			D = (p - q) + (dp - dq);
		}
		return D;
	}

	function getNormalizationFactor() {
		var norm = Math.max.apply(Math, arguments);
		return norm && (norm < 1e-8 || norm > 1e8)
				? pow(2, -Math.round(log2(norm)))
				: 0;
	}

	return {
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 1e-8,
		GEOMETRIC_EPSILON: 1e-7,
		TRIGONOMETRIC_EPSILON: 1e-8,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		isMachineZero: function(val) {
			return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
		},

		clamp: clamp,

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance) {
					x = nx;
					break;
				}
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return clamp(x, a, b);
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var x1, x2 = Infinity;
			if (abs(a) < EPSILON) {
				if (abs(b) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / b;
			} else {
				b *= -0.5;
				var D = getDiscriminant(a, b, c);
				if (D && abs(D) < MACHINE_EPSILON) {
					var f = getNormalizationFactor(abs(a), abs(b), abs(c));
					if (f) {
						a *= f;
						b *= f;
						c *= f;
						D = getDiscriminant(a, b, c);
					}
				}
				if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
			}
			var count = 0,
				boundless = min == null,
				minB = min - EPSILON,
				maxB = max + EPSILON;
			if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
				roots[count++] = boundless ? x1 : clamp(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
				roots[count++] = boundless ? x2 : clamp(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
				x, b1, c2, qd, q;
			if (f) {
				a *= f;
				b *= f;
				c *= f;
				d *= f;
			}

			function evaluate(x0) {
				x = x0;
				var tmp = a * x;
				b1 = tmp + b;
				c2 = b1 * x + c;
				qd = (tmp + b1) * x + c2;
				q = c2 * x + d;
			}

			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				evaluate(-(b / a) / 3);
				var t = q / a,
					r = pow(abs(t), 1/3),
					s = t < 0 ? -1 : 1,
					td = -qd / a,
					rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
					x0 = x - s * rd;
				if (x0 !== x) {
					do {
						evaluate(x0);
						x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
				boundless = min == null;
			if (isFinite(x) && (count === 0
					|| count > 0 && x !== roots[0] && x !== roots[1])
					&& (boundless || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = boundless ? x : clamp(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(name) {
		if (name) {
			var pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this._set(arg0, hasY ? arg1 : arg0);
			if (reading)
				read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('angle' in obj) {
				this._set(obj.length || 0, 0);
				this.setAngle(obj.angle || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this._set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var args = arguments,
			point = Point.read(args),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(args);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var args = arguments,
			point = Point.read(args),
			tolerance = Base.read(args);
		return this.getDistance(point) <= tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.x) && isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	isInQuadrant: function(q) {
		return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
			&& this.y * (q > 2 ? -1 : 1) >= 0;
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		return this._setter === 'setPosition' ? 4 : 0;
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this._set(arg0, hasHeight ? arg1 : arg0);
			if (reading)
				read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.width) && isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var args = arguments,
			type = typeof arg0,
			read;
		if (type === 'number') {
			this._set(arg0, arg1, arg2, arg3);
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0, 0, 0);
			read = arg0 === null ? 1 : 0;
		} else if (args.length === 1) {
			if (Array.isArray(arg0)) {
				this._set.apply(this, arg0);
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this._set(arg0.x || 0, arg0.y || 0,
						arg0.width || 0, arg0.height || 0);
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this._set(0, 0, 0, 0);
				if (Base.readSupported(args, this)) {
					read = 1;
				}
			}
		}
		if (read === undefined) {
			var frm = Point.readNamed(args, 'from'),
				next = Base.peek(args),
				x = frm.x,
				y = frm.y,
				width,
				height;
			if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
				var to = Point.readNamed(args, 'to');
				width = to.x - x;
				height = to.y - y;
				if (width < 0) {
					x = to.x;
					width = -width;
				}
				if (height < 0) {
					y = to.y;
					height = -height;
				}
			} else {
				var size = Size.read(args);
				width = size.width;
				height = size.height;
			}
			this._set(x, y, width, height);
			read = args.__index;
		}
		var filtered = args.__filtered;
		if (filtered)
			this.__filtered = filtered;
		if (this.__read)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	_fw: 1,
	_fh: 1,

	setSize: function() {
		var size = Size.read(arguments),
			sx = this._sx,
			sy = this._sy,
			w = size.width,
			h = size.height;
		if (sx) {
			this.x += (this.width - w) * sx;
		}
		if (sy) {
			this.y += (this.height - h) * sy;
		}
		this.width = w;
		this.height = h;
		this._fw = this._fh = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fw) {
			var amount = left - this.x;
			this.width -= this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = left;
		this._sx = this._fw = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fh) {
			var amount = top - this.y;
			this.height -= this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = top;
		this._sy = this._fh = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (!this._fw) {
			var amount = right - this.x;
			this.width = this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = right - this.width;
		this._sx = 1;
		this._fw = 0;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (!this._fh) {
			var amount = bottom - this.y;
			this.height = this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = bottom - this.height;
		this._sy = 1;
		this._fh = 0;
	},

	getCenterX: function() {
		return this.x + this.width / 2;
	},

	setCenterX: function(x) {
		if (this._fw || this._sx === 0.5) {
			this.x = x - this.width / 2;
		} else {
			if (this._sx) {
				this.x += (x - this.x) * 2 * this._sx;
			}
			this.width = (x - this.x) * 2;
		}
		this._sx = 0.5;
		this._fw = 0;
	},

	getCenterY: function() {
		return this.y + this.height / 2;
	},

	setCenterY: function(y) {
		if (this._fh || this._sy === 0.5) {
			this.y = y - this.height / 2;
		} else {
			if (this._sy) {
				this.y += (y - this.y) * 2 * this._sy;
			}
			this.height = (y - this.y) * 2;
		}
		this._sy = 0.5;
		this._fh = 0;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length === 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments),
			epsilon = Base.read(arguments) || 0;
		return rect.x + rect.width > this.x - epsilon
				&& rect.y + rect.height > this.y - epsilon
				&& rect.x < this.x + this.width + epsilon
				&& rect.y < this.y + this.height + epsilon;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join(''),
			xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this._set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key),
			internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return !!(this._owner._selection & 2);
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner._changeSelection) {
					owner._changeSelection(2, selected);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg, _dontNotify) {
		var args = arguments,
			count = args.length,
			ok = true;
		if (count >= 6) {
			this._set.apply(this, args);
		} else if (count === 1 || count === 2) {
			if (arg instanceof Matrix) {
				this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
						_dontNotify);
			} else if (Array.isArray(arg)) {
				this._set.apply(this,
						_dontNotify ? arg.concat([_dontNotify]) : arg);
			} else {
				ok = false;
			}
		} else if (!count) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok) {
			throw new Error('Unsupported matrix parameters');
		}
		return this;
	},

	set: '#initialize',

	_set: function(a, b, c, d, tx, ty, _dontNotify) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.getValues(), options, true, dictionary);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(25);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._b, this._c, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._c),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._b), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._b = this._c = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._c;
		this._ty += x * this._b + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var args = arguments,
			scale = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._b *= scale.x;
		this._c *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * c;
		this._b = cos * b + sin * d;
		this._c = -sin * a + cos * c;
		this._d = -sin * b + cos * d;
		this._tx += tx * a + ty * c;
		this._ty += tx * b + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var args = arguments,
			shear = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			b = this._b;
		this._a += shear.y * this._c;
		this._b += shear.y * this._d;
		this._c += shear.x * a;
		this._d += shear.x * b;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var args = arguments,
			skew = Point.read(args),
			center = Point.read(args, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	append: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * c1;
			this._c = b2 * a1 + d2 * c1;
			this._b = a2 * b1 + c2 * d1;
			this._d = b2 * b1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * c1;
			this._ty += tx2 * b1 + ty2 * d1;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	prepend: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * b1;
			this._c = a2 * c1 + b2 * d1;
			this._b = c2 * a1 + d2 * b1;
			this._d = c2 * c1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	appended: function(mx) {
		return this.clone().append(mx);
	},

	prepended: function(mx) {
		return this.clone().prepend(mx);
	},

	invert: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			this._a = d / det;
			this._b = -b / det;
			this._c = -c / det;
			this._d = a / det;
			this._tx = (c * ty - d * tx) / det;
			this._ty = (b * tx - a * ty) / det;
			res = this;
		}
		return res;
	},

	inverted: function() {
		return this.clone().invert();
	},

	concatenate: '#append',
	preConcatenate: '#prepend',
	chain: '#appended',

	_shiftless: function() {
		return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
	},

	_orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isIdentity: function() {
		return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	isInvertible: function() {
		var det = this._a * this._d - this._c * this._b;
		return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
	},

	isSingular: function() {
		return !this.isInvertible();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest._set(
				x * this._a + y * this._c + this._tx,
				x * this._b + y * this._d + this._ty,
				_dontNotify);
	},

	_transformCoordinates: function(src, dst, count) {
		for (var i = 0, max = 2 * count; i < max; i += 2) {
			var x = src[i],
				y = src[i + 1];
			dst[i] = x * this._a + y * this._c + this._tx;
			dst[i + 1] = x * this._b + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j]) {
				min[j] = val;
			} else if (val > max[j]) {
				max[j] = val;
			}
		}
		if (!dest)
			dest = new Rectangle();
		return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			res = dest._set(
					(x * d - y * c) / det,
					(y * a - x * b) / det,
					_dontNotify);
		}
		return res;
	},

	decompose: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			det = a * d - b * c,
			sqrt = Math.sqrt,
			atan2 = Math.atan2,
			degrees = 180 / Math.PI,
			rotate,
			scale,
			skew;
		if (a !== 0 || b !== 0) {
			var r = sqrt(a * a + b * b);
			rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
			scale = [r, det / r];
			skew = [atan2(a * c + b * d, r * r), 0];
		} else if (c !== 0 || d !== 0) {
			var s = sqrt(c * c + d * d);
			rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
			scale = [det / s, s];
			skew = [0, atan2(a * c + b * d, s * s)];
		} else {
			rotate = 0;
			skew = scale = [0, 0];
		}
		return {
			translation: this.getTranslation(),
			rotation: rotate * degrees,
			scaling: new Point(scale),
			skewing: new Point(skew[0] * degrees, skew[1] * degrees)
		};
	},

	getValues: function() {
		return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return this.decompose().scaling;
	},

	getRotation: function() {
		return this.decompose().rotation;
	},

	applyToContext: function(ctx) {
		if (!this.isIdentity()) {
			ctx.transform(this._a, this._b, this._c, this._d,
					this._tx, this._ty);
		}
	}
}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
	var part = Base.capitalize(key),
		prop = '_' + key;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(this.getSignedDistance(point));
	},

	getSignedDistance: function(point) {
		return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isMachineZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (!isInfinite && Numerical.isMachineZero(ccw)) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			  return  vx === 0 ? (vy > 0 ? x - px : px - x)
					: vy === 0 ? (vx < 0 ? y - py : py - y)
					: ((x - px) * vy - (y - py) * vx) / (
						vy > vx
							? vy * Math.sqrt(1 + (vx * vx) / (vy * vy))
							: vx * Math.sqrt(1 + (vy * vy) / (vx * vx))
					);
		},

		getDistance: function(px, py, vx, vy, x, y, asVector) {
			return Math.abs(
					Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',
	_compactSerialize: true,

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this._children = [];
		this._namedChildren = {};
		this._activeLayer = null;
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectionItems = {};
		this._selectionCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this._children, options, true, dictionary);
	},

	_changed: function(flags, item) {
		if (flags & 1) {
			var view = this._view;
			if (view) {
				view._needsUpdate = true;
				if (!view._requested && view._autoUpdate)
					view.requestUpdate();
			}
		}
		var changes = this._changes;
		if (changes && item) {
			var changesById = this._changesById,
				id = item._id,
				entry = changesById[id];
			if (entry) {
				entry.flags |= flags;
			} else {
				changes.push(changesById[id] = { item: item, flags: flags });
			}
		}
	},

	clear: function() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--)
			children[i].remove();
	},

	isEmpty: function() {
		return !this._children.length;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.set(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getLayers: function() {
		return this._children;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this, insert: true });
	},

	getSymbolDefinitions: function() {
		var definitions = [],
			ids = {};
		this.getItems({
			class: SymbolItem,
			match: function(item) {
				var definition = item._definition,
					id = definition._id;
				if (!ids[id]) {
					ids[id] = true;
					definitions.push(definition);
				}
				return false;
			}
		});
		return definitions;
	},

	getSymbols: 'getSymbolDefinitions',

	getSelectedItems: function() {
		var selectionItems = this._selectionItems,
			items = [];
		for (var id in selectionItems) {
			var item = selectionItems[id],
				selection = item._selection;
			if ((selection & 1) && item.isInserted()) {
				items.push(item);
			} else if (!selection) {
				this._updateSelection(item);
			}
		}
		return items;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectionItems = this._selectionItems;
		if (item._selection) {
			if (selectionItems[id] !== item) {
				this._selectionCount++;
				selectionItems[id] = item;
			}
		} else if (selectionItems[id] === item) {
			this._selectionCount--;
			delete selectionItems[id];
		}
	},

	selectAll: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectionItems = this._selectionItems;
		for (var i in selectionItems)
			selectionItems[i].setFullySelected(false);
	},

	addLayer: function(layer) {
		return this.insertLayer(undefined, layer);
	},

	insertLayer: function(index, layer) {
		if (layer instanceof Layer) {
			layer._remove(false, true);
			Base.splice(this._children, [layer], index, 0);
			layer._setProject(this, true);
			var name = layer._name;
			if (name)
				layer.setName(name);
			if (this._changes)
				layer._changed(5);
			if (!this._activeLayer)
				this._activeLayer = layer;
		} else {
			layer = null;
		}
		return layer;
	},

	_insertItem: function(index, item, _created) {
		item = this.insertLayer(index, item)
				|| (this._activeLayer || this._insertItem(undefined,
						new Layer(Item.NO_INSERT), true))
						.insertChild(index, item);
		if (_created && item.activate)
			item.activate();
		return item;
	},

	getItems: function(options) {
		return Item._getItems(this, options);
	},

	getItem: function(options) {
		return Item._getItems(this, options, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	removeOn: function(type) {
		var sets = this._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var children = this._children,
			param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].draw(ctx, param);
		}
		ctx.restore();

		if (this._selectionCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectionItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items) {
				items[id]._drawSelection(ctx, matrix, size, items, version);
			}
			ctx.restore();
		}
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = Base.set({},
					this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_name: null,
	_applyMatrix: true,
	_canApplyMatrix: true,
	_canScaleStroke: false,
	_pivot: null,
	_visible: true,
	_blendMode: 'normal',
	_opacity: 1,
	_locked: false,
	_guide: false,
	_clipMask: false,
	_selection: 0,
	_selectBounds: true,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		locked: false,
		guide: false,
		clipMask: false,
		selected: false,
		data: {}
	},
	_prioritize: ['applyMatrix']
},
new function() {
	var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
	return Base.each(handlers,
		function(name) {
			this._events[name] = {
				install: function(type) {
					this.getView()._countItemEvent(type, 1);
				},

				uninstall: function(type) {
					this.getView()._countItemEvent(type, -1);
				}
			};
		}, {
			_events: {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},

					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},

				onLoad: {},
				onError: {}
			},
			statics: {
				_itemHandlers: handlers
			}
		}
	);
}, {
	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project,
			settings = paper.settings;
		this._id = internal ? null : UID.get();
		this._parent = this._index = null;
		this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (internal || hasProps && props.insert == false
			|| !settings.insertItems && !(hasProps && props.insert === true)) {
			this._setProject(project);
		} else {
			(hasProps && props.parent || project)
					._insertItem(undefined, this, true);
		}
		if (hasProps && props !== Item.NO_INSERT) {
			this.set(props, {
				internal: true, insert: true, project: true, parent: true
			});
		}
		return hasProps;
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._symbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed = undefined;
		}
		if (flags & 16) {
			this._globalMatrix = undefined;
		}
		if (cacheParent
				&& (flags & 72)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project)
			project._changed(flags, this);
		if (symbol)
			symbol._changed(flags);
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var owner = this._getOwner();
		if (name && owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren;
			(namedChildren[name] = namedChildren[name] || []).push(this);
			if (!(name in children))
				children[name] = this;
		}
		this._name = name || undefined;
		this._changed(256);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			key = '_' + name,
			flags = {
				locked: 256,
				visible: 265
			};
		this['get' + part] = function() {
			return this[key];
		};
		this['set' + part] = function(value) {
			if (value != this[key]) {
				this[key] = value;
				this._changed(flags[name] || 257);
			}
		};
	},
{}), {
	beans: true,

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		if (selection !== this._selection) {
			this._selection = selection;
			var project = this._project;
			if (project) {
				project._updateSelection(this);
				this._changed(257);
			}
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return !!(this._selection & 1);
	},

	setSelected: function(selected) {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isFullySelected: function() {
		var children = this._children,
			selected = !!(this._selection & 1);
		if (children && selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(257);
			if (this._parent)
				this._parent._changed(2048);
		}
	},

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		var position = this._position ||
			(this._position = this._getPositionFromBounds());
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	_getPositionFromBounds: function(bounds) {
		return this._pivot
				? this._matrix._transformPoint(this._pivot)
				: (bounds || this.getBounds()).getCenter(true);
	},

	getPivot: function() {
		var pivot = this._pivot;
		return pivot
				? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
				: null;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	}
}, Base.each({
		getStrokeBounds: { stroke: true },
		getHandleBounds: { handle: true },
		getInternalBounds: { internal: true }
	},
	function(options, key) {
		this[key] = function(matrix) {
			return this.getBounds(matrix, options);
		};
	},
{
	beans: true,

	getBounds: function(matrix, options) {
		var hasMatrix = options || matrix instanceof Matrix,
			opts = Base.set({}, hasMatrix ? options : matrix,
					this._boundsOptions);
		if (!opts.stroke || this.getStrokeScaling())
			opts.cacheItem = this;
		var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
		return !arguments.length
				? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
					this, 'setBounds')
				: rect;
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			_matrix = this._matrix,
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			if (!_matrix.isInvertible()) {
				_matrix.set(_matrix._backup
						|| new Matrix().translate(_matrix.getTranslation()));
				bounds = this.getBounds();
			}
			matrix.scale(
					bounds.width !== 0 ? rect.width / bounds.width : 0,
					bounds.height !== 0 ? rect.height / bounds.height : 0);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getBounds: function(matrix, options) {
		var children = this._children;
		if (!children || !children.length)
			return new Rectangle();
		Item._updateBoundsCache(this, options.cacheItem);
		return Item._getBounds(children, matrix, options);
	},

	_getBoundsCacheKey: function(options, internal) {
		return [
			options.stroke ? 1 : 0,
			options.handle ? 1 : 0,
			internal ? 1 : 0
		].join('');
	},

	_getCachedBounds: function(matrix, options, noInternal) {
		matrix = matrix && matrix._orNullIfIdentity();
		var internal = options.internal && !noInternal,
			cacheItem = options.cacheItem,
			_matrix = internal ? null : this._matrix._orNullIfIdentity(),
			cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
				&& this._getBoundsCacheKey(options, internal),
			bounds = this._bounds;
		Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
		if (cacheKey && bounds && cacheKey in bounds) {
			var cached = bounds[cacheKey];
			return {
				rect: cached.rect.clone(),
				nonscaling: cached.nonscaling
			};
		}
		var res = this._getBounds(matrix || _matrix, options),
			rect = res.rect || res,
			style = this._style,
			nonscaling = res.nonscaling || style.hasStroke()
				&& !style.getStrokeScaling();
		if (cacheKey) {
			if (!bounds) {
				this._bounds = bounds = {};
			}
			var cached = bounds[cacheKey] = {
				rect: rect.clone(),
				nonscaling: nonscaling,
				internal: internal
			};
		}
		return {
			rect: rect,
			nonscaling: nonscaling
		};
	},

	_getStrokeMatrix: function(matrix, options) {
		var parent = this.getStrokeScaling() ? null
				: options && options.internal ? this
					: this._parent || this._symbol && this._symbol._item,
			mx = parent ? parent.getViewMatrix().invert() : matrix;
		return mx && mx._shiftless();
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent && item) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		},

		_getBounds: function(items, matrix, options) {
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2,
				nonscaling = false;
			options = options || {};
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				if (item._visible && !item.isEmpty(true)) {
					var bounds = item._getCachedBounds(
						matrix && matrix.appended(item._matrix), options, true),
						rect = bounds.rect;
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
					if (bounds.nonscaling)
						nonscaling = true;
				}
			}
			return {
				rect: isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle(),
				nonscaling: nonscaling
			};
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._applyMatrix
			? null
			: this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	getRotation: function() {
		var decomposed = this._decompose();
		return decomposed ? decomposed.rotation : 0;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			if (decomposed) {
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		}
	},

	getScaling: function() {
		var decomposed = this._decompose(),
			s = decomposed && decomposed.scaling;
		return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling && !current.equals(scaling)) {
			var rotation = this.getRotation(),
				decomposed = this._decomposed,
				matrix = new Matrix(),
				isZero = Numerical.isZero;
			if (isZero(current.x) || isZero(current.y)) {
				matrix.translate(decomposed.translation);
				if (rotation) {
					matrix.rotate(rotation);
				}
				matrix.scale(scaling.x, scaling.y);
				this._matrix.set(matrix);
			} else {
				var center = this.getPosition(true);
				matrix.translate(center);
				if (rotation)
					matrix.rotate(rotation);
				matrix.scale(scaling.x / current.x, scaling.y / current.y);
				if (rotation)
					matrix.rotate(-rotation);
				matrix.translate(center.negate());
				this.transform(matrix);
			}
			if (decomposed) {
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.set.apply(matrix, arguments);
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix;
		if (matrix) {
			var parent = this._parent;
			var parents = [];
			while (parent) {
				if (!parent._globalMatrix) {
					matrix = null;
					for (var i = 0, l = parents.length; i < l; i++) {
						parents[i]._globalMatrix = null;
					}
					break;
				}
				parents.push(parent);
				parent = parent._parent;
			}
		}
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.prepend(parent.getGlobalMatrix(true));
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getViewMatrix: function() {
		return this.getGlobalMatrix().prepend(this.getView()._matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project._view;
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	_getOwner: '#getParent',

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(options) {
		var copy = new this.constructor(Item.NO_INSERT),
			children = this._children,
			insert = Base.pick(options ? options.insert : undefined,
					options === undefined || options === true),
			deep = Base.pick(options ? options.deep : undefined, true);
		if (children)
			copy.copyAttributes(this);
		if (!children || deep)
			copy.copyContent(this);
		if (!children)
			copy.copyAttributes(this);
		if (insert)
			copy.insertAbove(this);
		var name = this._name,
			parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				orig = name,
				i = 1;
			while (children[name])
				name = orig + ' ' + (i++);
			if (name !== orig)
				copy.setName(name);
		}
		return copy;
	},

	copyContent: function(source) {
		var children = source._children;
		for (var i = 0, l = children && children.length; i < l; i++) {
			this.addChild(children[i].clone(false), true);
		}
	},

	copyAttributes: function(source, excludeMatrix) {
		this.setStyle(source._style);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (source.hasOwnProperty(key))
				this[key] = source[key];
		}
		if (!excludeMatrix)
			this._matrix.set(source._matrix, true);
		this.setApplyMatrix(source._applyMatrix);
		this.setPivot(source._pivot);
		this.setSelection(source._selection);
		var data = source._data,
			name = source._name;
		this._data = data ? Base.clone(data) : null;
		if (name)
			this.setName(name);
	},

	rasterize: function(arg0, arg1) {
		var resolution,
			insert,
			raster;
		if (Base.isPlainObject(arg0)) {
			resolution = arg0.resolution;
			insert = arg0.insert;
			raster = arg0.raster;
		} else {
			resolution = arg0;
			insert = arg1;
		}
		if (raster) {
			raster.matrix.reset(true);
		} else {
			raster = new Raster(Item.NO_INSERT);
		}
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			boundsSize = new Size(bottomRight.subtract(topLeft)),
			rasterSize = boundsSize.multiply(scale);
		raster.setSize(rasterSize, true);

		if (!rasterSize.isZero()) {
			var ctx = raster.getContext(true),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
		}
		raster.transform(
			new Matrix()
				.translate(topLeft.add(boundsSize.divide(2)))
				.scale(1 / scale)
		);
		if (insert === undefined || insert) {
			raster.insertAbove(this);
		}
		return raster;
	},

	contains: function() {
		var matrix = this._matrix;
		return (
			matrix.isInvertible() &&
			!!this._contains(matrix._inverseTransform(Point.read(arguments)))
		);
	},

	_contains: function(point) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				if (children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix, true).length > 0;
	}
},
new function() {
	function hitTest() {
		var args = arguments;
		return this._hitTest(
				Point.read(args),
				HitResult.getOptions(args));
	}

	function hitTestAll() {
		var args = arguments,
			point = Point.read(args),
			options = HitResult.getOptions(args),
			all = [];
		this._hitTest(point, new Base({ all: all }, options));
		return all;
	}

	function hitTestChildren(point, options, viewMatrix, _exclude) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				var child = children[i];
				var res = child !== _exclude && child._hitTest(point, options,
						viewMatrix);
				if (res && !options.all)
					return res;
			}
		}
		return null;
	}

	Project.inject({
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTest: hitTestChildren
	});

	return {
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTestChildren: hitTestChildren,
	};
}, {

	_hitTest: function(point, options, parentViewMatrix) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty()) {
			return null;
		}

		var matrix = this._matrix,
			viewMatrix = parentViewMatrix
					? parentViewMatrix.appended(matrix)
					: this.getGlobalMatrix().prepend(this.getView()._matrix),
			tolerance = Math.max(options.tolerance, 1e-12),
			tolerancePadding = options._tolerancePadding = new Size(
					Path._getStrokePadding(tolerance,
						matrix._shiftless().invert()));
		point = matrix._inverseTransform(point);
		if (!point || !this._children &&
			!this.getBounds({ internal: true, stroke: true, handle: true })
				.expand(tolerancePadding.multiply(2))._containsPoint(point)) {
			return null;
		}

		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this.isSelected()
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			match = options.match,
			that = this,
			bounds,
			res;

		function filter(hit) {
			if (hit && match && !match(hit))
				hit = null;
			if (hit && options.all)
				options.all.push(hit);
			return hit;
		}

		function checkPoint(type, part) {
			var pt = part ? bounds['get' + part]() : that.getPosition();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
				return new HitResult(type, that, {
					name: part ? Base.hyphenate(part) : type,
					point: pt
				});
			}
		}

		var checkPosition = options.position,
			checkCenter = options.center,
			checkBounds = options.bounds;
		if (checkSelf && this._parent
				&& (checkPosition || checkCenter || checkBounds)) {
			if (checkCenter || checkBounds) {
				bounds = this.getInternalBounds();
			}
			res = checkPosition && checkPoint('position') ||
					checkCenter && checkPoint('center', 'Center');
			if (!res && checkBounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++) {
					res = checkPoint('bounds', points[i]);
				}
			}
			res = filter(res);
		}

		if (!res) {
			res = this._hitTestChildren(point, options, viewMatrix)
				|| checkSelf
					&& filter(this._hitTestSelf(point, options, viewMatrix,
						this.getStrokeScaling() ? null
							: viewMatrix._shiftless().invert()))
				|| null;
		}
		if (res && res.point) {
			res.point = matrix.transform(res.point);
		}
		return res;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
			return true;
		} else if (type === 'function') {
			return name(this);
		} else if (name === 'match') {
			return compare(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (name === 'class') {
				if (typeof compare === 'function')
					return this instanceof compare;
				value = this._class;
			}
			if (typeof compare === 'function') {
				return !!compare(value);
			} else if (compare) {
				if (compare.test) {
					return compare.test(value);
				} else if (Base.isPlainObject(compare)) {
					return matchObject(compare, value);
				}
			}
			return Base.equals(value, compare);
		}
	},

	getItems: function(options) {
		return Item._getItems(this, options, this._matrix);
	},

	getItem: function(options) {
		return Item._getItems(this, options, this._matrix, null, true)[0]
				|| null;
	},

	statics: {
		_getItems: function _getItems(item, options, matrix, param, firstOnly) {
			if (!param) {
				var obj = typeof options === 'object' && options,
					overlapping = obj && obj.overlapping,
					inside = obj && obj.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					recursive: obj && obj.recursive !== false,
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (obj) {
					options = Base.filter({}, options, {
						recursive: true, inside: true, overlapping: true
					});
				}
			}
			var children = item._children,
				items = param.items,
				rect = param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.appended(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(rect.contains(bounds)
							|| param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(options)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				if (param.recursive !== false) {
					_getItems(child, options, childMatrix, param, firstOnly);
				}
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this ? this.addChild(res) : res;
	},

	addChild: function(item) {
		return this.insertChild(undefined, item);
	},

	insertChild: function(index, item) {
		var res = item ? this.insertChildren(index, [item]) : null;
		return res && res[0];
	},

	addChildren: function(items) {
		return this.insertChildren(this._children.length, items);
	},

	insertChildren: function(index, items) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Base.slice(items);
			var inserted = {};
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i],
					id = item && item._id;
				if (!item || inserted[id]) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
					inserted[id] = true;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i],
					name = item._name;
				item._parent = this;
				item._setProject(project, true);
				if (name)
					item.setName(name);
				if (notifySelf)
					item._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertItem: '#insertChild',

	_insertAt: function(item, offset) {
		var owner = item && item._getOwner(),
			res = item !== this && owner ? this : null;
		if (res) {
			res._remove(false, true);
			owner._insertItem(item._index + offset, res);
		}
		return res;
	},

	insertAbove: function(item) {
		return this._insertAt(item, 1);
	},

	insertBelow: function(item) {
		return this._insertAt(item, 0);
	},

	sendToBack: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(0, this) : null;
	},

	bringToFront: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(undefined, this) : null;
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	addTo: function(owner) {
		return owner._insertItem(undefined, this);
	},

	copyTo: function(owner) {
		return this.clone(false).addTo(owner);
	},

	reduce: function(options) {
		var children = this._children;
		if (children && children.length === 1) {
			var child = children[0].reduce(options);
			if (this._parent) {
				child.insertAbove(this);
				this.remove();
			} else {
				child.remove();
			}
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var owner = this._getOwner();
		if (owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[0];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var owner = this._getOwner(),
			project = this._project,
			index = this._index;
		if (this._style)
			this._style._dispose();
		if (owner) {
			if (this._name)
				this._removeNamed();
			if (index != null) {
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(owner._children, null, index, 1);
			}
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent)
				owner._changed(11, this);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(start, end) {
		if (!this._children)
			return null;
		start = start || 0;
		end = Base.pick(end, this._children.length);
		var removed = Base.splice(this._children, null, start, end - start);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function(recursively) {
		var children = this._children;
		var numChildren = children ? children.length : 0;
		if (recursively) {
			for (var i = 0; i < numChildren; i++) {
				if (!children[i].isEmpty(recursively)) {
					return false;
				}
			}
			return true;
		}
		return !numChildren;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent === item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getPosition(true)));
	};
}, {
	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	transform: function(matrix, _applyRecursively, _setApplyMatrix) {
		var _matrix = this._matrix,
			transformMatrix = matrix && !matrix.isIdentity(),
			applyMatrix = (
				_setApplyMatrix && this._canApplyMatrix ||
				this._applyMatrix && (
					transformMatrix || !_matrix.isIdentity() ||
					_applyRecursively && this._children
				)
			);
		if (!transformMatrix && !applyMatrix)
			return this;
		if (transformMatrix) {
			if (!matrix.isInvertible() && _matrix.isInvertible())
				_matrix._backup = _matrix.getValues();
			_matrix.prepend(matrix, true);
			var style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (fillColor)
				fillColor.transform(matrix);
			if (strokeColor)
				strokeColor.transform(matrix);
		}

		if (applyMatrix && (applyMatrix = this._transformContent(
				_matrix, _applyRecursively, _setApplyMatrix))) {
			var pivot = this._pivot;
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		if (transformMatrix || applyMatrix) {
			this._changed(25);
		}
		var decomp = transformMatrix && bounds && matrix.decompose();
		if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var cache = bounds[key];
				if (cache.nonscaling) {
					delete bounds[key];
				} else if (applyMatrix || !cache.internal) {
					var rect = cache.rect;
					matrix._transformBounds(rect, rect);
				}
			}
			this._bounds = bounds;
			var cached = bounds[this._getBoundsCacheKey(
				this._boundsOptions || {})];
			if (cached) {
				this._position = this._getPositionFromBounds(cached.rect);
			}
		} else if (transformMatrix && position && this._pivot) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++) {
				children[i].transform(matrix, applyRecursively, setApplyMatrix);
			}
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	}
}), {

	_setStyles: function(ctx, param, viewMatrix) {
		var style = this._style,
			matrix = this._matrix;
		if (style.hasFill()) {
			ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
		}
		if (style.hasStroke()) {
			ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
			ctx.lineWidth = style.getStrokeWidth();
			var strokeJoin = style.getStrokeJoin(),
				strokeCap = style.getStrokeCap(),
				miterLimit = style.getMiterLimit();
			if (strokeJoin)
				ctx.lineJoin = strokeJoin;
			if (strokeCap)
				ctx.lineCap = strokeCap;
			if (miterLimit)
				ctx.miterLimit = miterLimit;
			if (paper.support.nativeDash) {
				var dashArray = style.getDashArray(),
					dashOffset = style.getDashOffset();
				if (dashArray && dashArray.length) {
					if ('setLineDash' in ctx) {
						ctx.setLineDash(dashArray);
						ctx.lineDashOffset = dashOffset;
					} else {
						ctx.mozDash = dashArray;
						ctx.mozDashOffset = dashOffset;
					}
				}
			}
		}
		if (style.hasShadow()) {
			var pixelRatio = param.pixelRatio || 1,
				mx = viewMatrix._shiftless().prepend(
					new Matrix().scale(pixelRatio, pixelRatio)),
				blur = mx.transform(new Point(style.getShadowBlur(), 0)),
				offset = mx.transform(this.getShadowOffset());
			ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
			ctx.shadowBlur = blur.getLength();
			ctx.shadowOffsetX = offset.x;
			ctx.shadowOffsetY = offset.y;
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].appended(matrix);
		if (!globalMatrix.isInvertible())
			return;

		viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
				: globalMatrix;

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = Numerical.clamp(this._opacity, 0, 1),
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(viewMatrix);
			if (!bounds.width || !bounds.height) {
				matrices.pop();
				return;
			}
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.appended(matrix)
				: this._canScaleStroke && !this.getStrokeScaling(true)
					&& viewMatrix,
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform) {
			(direct ? matrix : viewMatrix).applyToContext(ctx);
		}
		if (clip) {
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, viewMatrix, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish) {
			ctx.clip(this.getFillRule());
		}
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
		var selection = this._selection,
			itemSelected = selection & 1,
			boundsSelected = selection & 2
					|| itemSelected && this._selectBounds,
			positionSelected = selection & 4;
		if (!this._drawSelected)
			itemSelected = false;
		if ((itemSelected || boundsSelected || positionSelected)
				&& this._isUpdated(updateVersion)) {
			var layer,
				color = this.getSelectedColor(true) || (layer = this.getLayer())
					&& layer.getSelectedColor(true),
				mx = matrix.appended(this.getGlobalMatrix(true)),
				half = size / 2;
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (itemSelected)
				this._drawSelected(ctx, mx, selectionItems);
			if (positionSelected) {
				var pos = this.getPosition(true),
					parent = this._parent,
					point = parent ? parent.localToGlobal(pos) : pos,
					x = point.x,
					y = point.y;
				ctx.beginPath();
				ctx.arc(x, y, half, 0, Math.PI * 2, true);
				ctx.stroke();
				var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
					start = half,
					end = size + 1;
				for (var i = 0; i < 4; i++) {
					var delta = deltas[i],
						dx = delta[0],
						dy = delta[1];
					ctx.moveTo(x + dx * start, y + dy * start);
					ctx.lineTo(x + dx * end, y + dy * end);
					ctx.stroke();
				}
			}
			if (boundsSelected) {
				var coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++) {
					ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				}
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++) {
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
				}
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(key) {
	this['removeOn' + Base.capitalize(key)] = function() {
		var hash = {};
		hash[key] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}), {
	tween: function(from, to, options) {
		if (!options) {
			options = to;
			to = from;
			from = null;
			if (!options) {
				options = to;
				to = null;
			}
		}
		var easing = options && options.easing,
			start = options && options.start,
			duration = options != null && (
				typeof options === 'number' ? options : options.duration
			),
			tween = new Tween(this, from, to, duration, easing, start);
		function onFrame(event) {
			tween._handleFrame(event.time * 1000);
			if (!tween.running) {
				this.off('frame', onFrame);
			}
		}
		if (duration) {
			this.on('frame', onFrame);
		}
		return tween;
	},

	tweenTo: function(to, options) {
		return this.tween(null, to, options);
	},

	tweenFrom: function(from, options) {
		return this.tween(from, null, options);
	}
});

var Group = Item.extend({
	_class: 'Group',
	_selectBounds: false,
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 2050) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i]._clipMask) {
					clipItem = children[i];
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_getBounds: function _getBounds(matrix, options) {
		var clipItem = this._getClipItem();
		return clipItem
			? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),
				Base.set({}, options, { stroke: false }))
			: _getBounds.base.call(this, matrix, options);
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		var clipItem = this._getClipItem();
		return (!clipItem || clipItem.contains(point))
				&& _hitTestChildren.base.call(this, point, options, viewMatrix,
					clipItem);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem();
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			ctx.beginPath();
			param.dontStart = param.dontFinish = true;
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var item = children[i];
			if (item !== clipItem)
				item.draw(ctx, param);
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer() {
		Group.apply(this, arguments);
	},

	_getOwner: function() {
		return this._parent || this._index != null && this._project;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_hitTestSelf: function() {
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_canScaleStroke: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props, point) {
		this._initialize(props, point);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	copyContent: function(source) {
		this.setType(source._type);
		this.setSize(source._size);
		this.setRadius(source._radius);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				this._radius.set(Size.min(this._radius, size.divide(2).abs()));
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius._set(width / 2, height / 2);
			}
			this._size._set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size._set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size);
				} else if (type === 'ellipse') {
					this._size._set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.copyAttributes(this);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		if (insert === undefined || insert)
			path.insertAbove(this);
		return path;
	},

	toShape: '#clone',

	_asPathItem: function() {
		return this.toPath(false);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx, param, viewMatrix);
			if (hasFill) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0),
			style = this._style,
			strokeWidth = options.stroke && style.hasStroke()
					&& style.getStrokeWidth();
		if (matrix)
			rect = matrix._transformBounds(rect);
		return strokeWidth
				? rect.expand(Path._getStrokePadding(strokeWidth,
					this._getStrokeMatrix(matrix, options)))
				: rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var q = 1; q <= 4; q++) {
				var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(
							expand ? corner.add(dir.multiply(expand)) : corner,
							center);
				if (rect.contains(point))
					return { point: center, quadrant: q };
			}
		}
	}

	function isOnEllipseStroke(point, radius, padding, quadrant) {
		var vector = point.divide(radius);
		return (!quadrant || vector.isInQuadrant(quadrant)) &&
				vector.subtract(vector.normalize()).multiply(radius)
					.divide(padding).length <= 1;
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center.point).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
				strokeMatrix) {
			var hit = false,
				style = this._style,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill();
			if (hitStroke || hitFill) {
				var type = this._type,
					radius = this._radius,
					strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
					strokePadding = options._tolerancePadding.add(
						Path._getStrokePadding(strokeRadius,
							!style.getStrokeScaling() && strokeMatrix));
				if (type === 'rectangle') {
					var padding = strokePadding.multiply(2),
						center = getCornerCenter(this, point, padding);
					if (center) {
						hit = isOnEllipseStroke(point.subtract(center.point),
								radius, strokePadding, center.quadrant);
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(padding),
							inner = rect.expand(padding.negate());
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					hit = isOnEllipseStroke(point, radius, strokePadding);
				}
			}
			return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = Base.create(Shape.prototype);
		item._type = type;
		item._size = size;
		item._radius = radius;
		item._initialize(Base.getNamed(args), point);
		return item;
	}

	return {
		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.min(Size.readNamed(args, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, args);
		},

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, args);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: false, handle: false },
	_serializeFields: {
		crossOrigin: null,
		source: null
	},
	_prioritize: ['crossOrigin'],
	_smoothing: 'low',
	beans: true,

	initialize: function Raster(source, position) {
		if (!this._initialize(source,
				position !== undefined && Point.read(arguments))) {
			var image,
				type = typeof source,
				object = type === 'string'
					? document.getElementById(source)
					: type  === 'object'
						? source
						: null;
			if (object && object !== Item.NO_INSERT) {
				if (object.getContext || object.naturalHeight != null) {
					image = object;
				} else if (object) {
					var size = Size.read(arguments);
					if (!size.isZero()) {
						image = CanvasProvider.getCanvas(size);
					}
				}
			}
			if (image) {
				this.setImage(image);
			} else {
				this.setSource(source);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	copyContent: function(source) {
		var image = source._image,
			canvas = source._canvas;
		if (image) {
			this._setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(source._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			this._setImage(copyCanvas);
		}
		this._crossOrigin = source._crossOrigin;
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function(_size, _clear) {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = !_clear && this.getElement();
				this._setImage(CanvasProvider.getCanvas(size));
				if (element) {
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
				}
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		} else if (_clear) {
			this.clear();
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	getLoaded: function() {
		return this._loaded;
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		var that = this;

		function emit(event) {
			var view = that.getView(),
				type = event && event.type || 'load';
			if (view && that.responds(type)) {
				paper = view._scope;
				that.emit(type, new Event(event));
			}
		}

		this._setImage(image);
		if (this._loaded) {
			setTimeout(emit, 0);
		} else if (image) {
			DomEvent.add(image, {
				load: function(event) {
					that._setImage(image);
					emit(event);
				},
				error: emit
			});
		}
	},

	_setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = !!(image && image.src && image.complete);
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(1033);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(_change) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (_change) {
			this._image = null;
			this._changed(1025);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		var image = this._image;
		return image && image.src || this.toDataURL();
	},

	setSource: function(src) {
		var image = new self.Image(),
			crossOrigin = this._crossOrigin;
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (src)
			image.src = src;
		this.setImage(image);
	},

	getCrossOrigin: function() {
		var image = this._image;
		return image && image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		var image = this._image;
		if (image)
			image.crossOrigin = crossOrigin;
	},

	getSmoothing: function() {
		return this._smoothing;
	},

	setSmoothing: function(smoothing) {
		this._smoothing = typeof smoothing === 'string'
			? smoothing
			: smoothing ? 'low' : 'off';
		this._changed(257);
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster._setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.prepend(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var image = this._image,
			src = image && image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (typeof object === 'object') {
			if ('width' in object) {
				bounds = new Rectangle(object);
			} else if ('x' in object) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
		}
		if (!bounds)
			return null;
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var args = arguments,
			point = Point.read(args),
			color = Color.read(args),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	clear: function() {
		var size = this._size;
		this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx, param, viewMatrix) {
		var element = this.getElement();
		if (element && element.width > 0 && element.height > 0) {
			ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

			this._setStyles(ctx, param, viewMatrix);

			var smoothing = this._smoothing,
				disabled = smoothing === 'off';
			DomElement.setPrefixed(
				ctx,
				disabled ? 'imageSmoothingEnabled' : 'imageSmoothingQuality',
				disabled ? false : smoothing
			);

			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var SymbolItem = Item.extend({
	_class: 'SymbolItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: true },
	_serializeFields: {
		symbol: null
	},

	initialize: function SymbolItem(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setDefinition(arg0 instanceof SymbolDefinition ?
					arg0 : new SymbolDefinition(arg0));
	},

	_equals: function(item) {
		return this._definition === item._definition;
	},

	copyContent: function(source) {
		this.setDefinition(source._definition);
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(definition) {
		this._definition = definition;
		this._changed(9);
	},

	getSymbol: '#getDefinition',
	setSymbol: '#setDefinition',

	isEmpty: function() {
		return this._definition._item.isEmpty();
	},

	_getBounds: function(matrix, options) {
		var item = this._definition._item;
		return item._getCachedBounds(item._matrix.prepended(matrix), options);
	},

	_hitTestSelf: function(point, options, viewMatrix) {
		var opts = options.extend({ all: false });
		var res = this._definition._item._hitTest(point, opts, viewMatrix);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this._definition._item.draw(ctx, param);
	}

});

var SymbolDefinition = Base.extend({
	_class: 'SymbolDefinition',

	initialize: function SymbolDefinition(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		if (item)
			this.setItem(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._item],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8)
			Item._clearBoundsCache(this);
		if (flags & 1)
			this.project._changed(flags);
	},

	getItem: function() {
		return this._item;
	},

	setItem: function(item, _dontCenter) {
		if (item._symbol)
			item = item.clone();
		if (this._item)
			this._item._symbol = null;
		this._item = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._symbol = this;
		this._changed(9);
	},

	getDefinition: '#getItem',
	setDefinition: '#setItem',

	place: function(position) {
		return new SymbolItem(this, position);
	},

	clone: function() {
		return new SymbolDefinition(this._item.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this._item.equals(symbol._item)
				|| false;
	}
});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values)
			this.inject(values);
	},

	statics: {
		getOptions: function(args) {
			var options = args && Base.read(args);
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				position: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,
	_selection: 0,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut, selection;
		if (count > 0) {
			if (arg0 == null || typeof arg0 === 'object') {
				if (count === 1 && arg0 && 'point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
					selection = arg0.selection;
				} else {
					point = arg0;
					handleIn = arg1;
					handleOut = arg2;
					selection = arg3;
				}
			} else {
				point = [ arg0, arg1 ];
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
		if (selection)
			this.setSelection(selection);
	},

	_serialize: function(options, dictionary) {
		var point = this._point,
			selection = this._selection,
			obj = selection || this.hasHandles()
					? [point, this._handleIn, this._handleOut]
					: point;
		if (selection)
			obj.push(selection);
		return Base.serialize(obj, options, true, dictionary);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(41);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		this._point.set(Point.read(arguments));
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		this._handleIn.set(Point.read(arguments));
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		this._handleOut.set(Point.read(arguments));
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	isSmooth: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut;
		return !handleIn.isZero() && !handleOut.isZero()
				&& handleIn.isCollinear(handleOut);
	},

	clearHandles: function() {
		this._handleIn._set(0, 0);
		this._handleOut._set(0, 0);
	},

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		var oldSelection = this._selection,
			path = this._path;
		this._selection = selection = selection || 0;
		if (path && selection !== oldSelection) {
			path._updateSelection(this, oldSelection, selection);
			path._changed(257);
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		return !!(this._selection & 7);
	},

	setSelected: function(selected) {
		this._changeSelection(7, selected);
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	smooth: function(options, _first, _last) {
		var opts = options || {},
			type = opts.type,
			factor = opts.factor,
			prev = this.getPrevious(),
			next = this.getNext(),
			p0 = (prev || this)._point,
			p1 = this._point,
			p2 = (next || this)._point,
			d1 = p0.getDistance(p1),
			d2 = p1.getDistance(p2);
		if (!type || type === 'catmull-rom') {
			var a = factor === undefined ? 0.5 : factor,
				d1_a = Math.pow(d1, a),
				d1_2a = d1_a * d1_a,
				d2_a = Math.pow(d2, a),
				d2_2a = d2_a * d2_a;
			if (!_first && prev) {
				var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
					N = 3 * d2_a * (d2_a + d1_a);
				this.setHandleIn(N !== 0
					? new Point(
						(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
						(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
					: new Point());
			}
			if (!_last && next) {
				var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
					N = 3 * d1_a * (d1_a + d2_a);
				this.setHandleOut(N !== 0
					? new Point(
						(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
						(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
					: new Point());
			}
		} else if (type === 'geometric') {
			if (prev && next) {
				var vector = p0.subtract(p2),
					t = factor === undefined ? 0.4 : factor,
					k = t * d1 / (d1 + d2);
				if (!_first)
					this.setHandleIn(vector.multiply(k));
				if (!_last)
					this.setHandleOut(vector.multiply(k - t));
			}
		} else {
			throw new Error('Smoothing method \'' + type + '\' not supported.');
		}
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return !this._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			tmp = handleIn.clone();
		handleIn.set(handleOut);
		handleOut.set(tmp);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(from, to, factor) {
		var u = 1 - factor,
			v = factor,
			point1 = from._point,
			point2 = to._point,
			handleIn1 = from._handleIn,
			handleIn2 = to._handleIn,
			handleOut2 = to._handleOut,
			handleOut1 = from._handleOut;
		this._point._set(
				u * point1._x + v * point2._x,
				u * point1._y + v * point2._y, true);
		this._handleIn._set(
				u * handleIn1._x + v * handleIn2._x,
				u * handleIn1._y + v * handleIn2._y, true);
		this._handleOut._set(
				u * handleOut1._x + v * handleOut2._x,
				u * handleOut1._y + v * handleOut2._y, true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y,
			selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	_set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this._x) && isZero(this._y);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		var owner = this._owner;
		return this === owner._point ? 1
			: this === owner._handleIn ? 2
			: this === owner._handleOut ? 4
			: 0;
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	beans: true,

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (!count) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true, dictionary);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	classify: function() {
		return Curve.classify(this.getValues());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		this._segment1._point.set(Point.read(arguments));
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		this._segment2._point.set(Point.read(arguments));
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		this._segment1._handleOut.set(Point.read(arguments));
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		this._segment2._handleIn.set(Point.read(arguments));
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return !this._segment1._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	}
}, {
	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	divideAt: function(location) {
		return this.divideAtTime(location && location.curve === this
				? location.time : this.getTimeAt(location));
	},

	divideAtTime: function(time, _setHandles) {
		var tMin = 1e-8,
			tMax = 1 - tMin,
			res = null;
		if (time >= tMin && time <= tMax) {
			var parts = Curve.subdivide(this.getValues(), time),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				seg1 = this._segment1,
				seg2 = this._segment2,
				path = this._path;
			if (setHandles) {
				seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
				seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(seg1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				this._changed();
				res = new Curve(segment, seg2);
			}
		}
		return res;
	},

	splitAt: function(location) {
		var path = this._path;
		return path ? path.splitAt(location) : null;
	},

	splitAtTime: function(time) {
		return this.splitAt(this.getLocationAtTime(time));
	},

	divide: function(offset, isTime) {
		return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	split: function(offset, isTime) {
		return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut._set(0, 0);
		this._segment2._handleIn._set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix, straight) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			x1 = p1.x, y1 = p1.y,
			x2 = p2.x, y2 = p2.y,
			values = straight
				? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
				: [
					x1, y1,
					x1 + h1._x, y1 + h1._y,
					x2 + h2._x, y2 + h2._y,
					x2, y2
				];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
			x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
			x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
			x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
			x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
			x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
		return [
			[x0, y0, x4, y4, x7, y7, x9, y9],
			[x9, y9, x8, y8, x6, y6, x3, y3]
		];
	},

	getMonoCurves: function(v, dir) {
		var curves = [],
			io = dir ? 0 : 1,
			o0 = v[io + 0],
			o1 = v[io + 2],
			o2 = v[io + 4],
			o3 = v[io + 6];
		if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
				|| Curve.isStraight(v)) {
			curves.push(v);
		} else {
			var a = 3 * (o1 - o2) - o0 + o3,
				b = 2 * (o0 + o2) - 4 * o1,
				c = o1 - o0,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [],
				n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
			if (!n) {
				curves.push(v);
			} else {
				roots.sort();
				var t = roots[0],
					parts = Curve.subdivide(v, t);
				curves.push(parts[0]);
				if (n > 1) {
					t = (roots[1] - t) / (1 - t);
					parts = Curve.subdivide(parts[1], t);
					curves.push(parts[0]);
				}
				curves.push(parts[1]);
			}
		}
		return curves;
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var v0 = v[coord],
			v1 = v[coord + 2],
			v2 = v[coord + 4],
			v3 = v[coord + 6],
			res = 0;
		if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
				v0 > val && v3 > val && v1 > val && v2 > val)) {
			var c = 3 * (v1 - v0),
				b = 3 * (v2 - v1) - c,
				a = v3 - v0 - c - b;
			res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
		}
		return res;
	},

	getTimeOf: function(v, point) {
		var p0 = new Point(v[0], v[1]),
			p3 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			geomEpsilon = 1e-7,
			t = point.isClose(p0, epsilon) ? 0
			  : point.isClose(p3, epsilon) ? 1
			  : null;
		if (t === null) {
			var coords = [point.x, point.y],
				roots = [];
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					var u = roots[i];
					if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
						return u;
				}
			}
		}
		return point.isClose(p0, geomEpsilon) ? 0
			 : point.isClose(p3, geomEpsilon) ? 1
			 : null;
	},

	getNearestTime: function(v, point) {
		if (Curve.isStraight(v)) {
			var x0 = v[0], y0 = v[1],
				x3 = v[6], y3 = v[7],
				vx = x3 - x0, vy = y3 - y0,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getTimeOf(v,
					new Point(x0 + u * vx, y0 + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 1e-8) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	isFlatEnough: function(v, flatness) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			ux = 3 * x1 - 2 * x0 - x3,
			uy = 3 * y1 - 2 * y0 - y3,
			vx = 3 * x2 - 2 * x3 - x0,
			vy = 3 * y2 - 2 * y3 - y0;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				<= 16 * flatness * flatness;
	},

	getArea: function(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
				+ y1 * (x0 - x2) - x1 * (y0 - y2)
				+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}

		padding /= 2;
		var minPad = min[coord] + padding,
			maxPad = max[coord] - padding;
		if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
				v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
			if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
				add(v0, 0);
				add(v3, 0);
			} else {
				var a = 3 * (v1 - v2) - v0 + v3,
					b = 2 * (v0 + v2) - 4 * v1,
					c = v1 - v0,
					count = Numerical.solveQuadratic(a, b, c, roots),
					tMin = 1e-8,
					tMax = 1 - tMin;
				add(v3, 0);
				for (var i = 0; i < count; i++) {
					var t = roots[i],
						u = 1 - t;
					if (tMin <= t && t <= tMax)
						add(u * u * u * v0
							+ 3 * u * u * t * v1
							+ 3 * u * t * t * v2
							+ t * t * t * v3,
							padding);
				}
			}
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false, this._path);
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(p1, h1, h2, p2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else {
			var v = p2.subtract(p1);
			if (v.isZero()) {
				return false;
			} else if (v.isCollinear(h1) && v.isCollinear(h2)) {
				var l = new Line(p1, p2),
					epsilon = 1e-7;
				if (l.getDistance(p1.add(h1)) < epsilon &&
					l.getDistance(p2.add(h2)) < epsilon) {
					var div = v.dot(v),
						s1 = v.dot(h1) / div,
						s2 = v.dot(h2) / div;
					return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
				}
			}
		}
		return false;
	},

	isLinear: function(p1, h1, h2, p2) {
		var third = p2.subtract(p1).divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function(epsilon) {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
				epsilon);
	};

	this.statics[name] = function(v, epsilon) {
		var x0 = v[0], y0 = v[1],
			x3 = v[6], y3 = v[7];
		return test(
				new Point(x0, y0),
				new Point(v[2] - x0, v[3] - y0),
				new Point(v[4] - x3, v[5] - y3),
				new Point(x3, y3), epsilon);
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	hasLength: function(epsilon) {
		return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
				&& this.getLength() > (epsilon || 0);
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
				< 1e-8;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
				< 1e-8;
	}
}), {
	beans: false,

	getLocationAt: function(offset, _isTime) {
		return this.getLocationAtTime(
				_isTime ? offset : this.getTimeAt(offset));
	},

	getLocationAtTime: function(t) {
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getTimeAt: function(offset, start) {
		return Curve.getTimeAt(this.getValues(), offset, start);
	},

	getParameterAt: '#getTimeAt',

	getTimesWithTangent: function () {
		var tangent = Point.read(arguments);
		return tangent.isZero()
				? []
				: Curve.getTimesWithTangent(this.getValues(), tangent);
	},

	getOffsetAtTime: function(t) {
		return this.getPartLength(0, t);
	},

	getLocationOf: function() {
		return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getTimeOf: function() {
		return Curve.getTimeOf(this.getValues(), Point.read(arguments));
	},

	getParameterOf: '#getTimeOf',

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestTime(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(location, _isTime) {
				var values = this.getValues();
				return Curve[name](values, _isTime ? location
						: Curve.getTimeAt(values, location));
			};

			this[name + 'AtTime'] = function(time) {
				return Curve[name](this.getValues(), time);
			};
		}, {
			statics: {
				_evaluateMethods: methods
			}
		}
	);
},
new function() {

	function getLengthIntegrand(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],

			ax = 9 * (x1 - x2) + 3 * (x3 - x0),
			bx = 6 * (x0 + x2) - 12 * x1,
			cx = 3 * (x1 - x0),

			ay = 9 * (y1 - y2) + 3 * (y3 - y0),
			by = 6 * (y0 + y2) - 12 * y1,
			cy = 3 * (y1 - y0);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			isZero = Numerical.isZero;
		if (isZero(x1 - x0) && isZero(y1 - y0)) {
			x1 = x0;
			y1 = y0;
		}
		if (isZero(x2 - x3) && isZero(y2 - y3)) {
			x2 = x3;
			y2 = y3;
		}
		var cx = 3 * (x1 - x0),
			bx = 3 * (x2 - x1) - cx,
			ax = x3 - x0 - cx - bx,
			cy = 3 * (y1 - y0),
			by = 3 * (y2 - y1) - cy,
			ay = y3 - y0 - cy - by,
			x, y;
		if (type === 0) {
			x = t === 0 ? x0 : t === 1 ? x3
					: ((ax * t + bx) * t + cx) * t + x0;
			y = t === 0 ? y0 : t === 1 ? y3
					: ((ay * t + by) * t + cy) * t + y0;
		} else {
			var tMin = 1e-8,
				tMax = 1 - tMin;
			if (t < tMin) {
				x = cx;
				y = cy;
			} else if (t > tMax) {
				x = 3 * (x3 - x2);
				y = 3 * (y3 - y2);
			} else {
				x = (3 * ax * t + 2 * bx) * t + cx;
				y = (3 * ay * t + 2 * by) * t + cy;
			}
			if (normalized) {
				if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
					x = x2 - x1;
					y = y2 - y1;
				}
				var len = Math.sqrt(x * x + y * y);
				if (len) {
					x /= len;
					y /= len;
				}
			}
			if (type === 3) {
				var x2 = 6 * ax * t + 2 * bx,
					y2 = 6 * ay * t + 2 * by,
					d = Math.pow(x * x + y * y, 3 / 2);
				x = d !== 0 ? (x * y2 - y * x2) / d : 0;
				y = 0;
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		classify: function(v) {

			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
				a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
				a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
				d3 = 3 * a3,
				d2 = d3 - a2,
				d1 = d2 - a2 + a1,
				l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
				s = l !== 0 ? 1 / l : 0,
				isZero = Numerical.isZero,
				serpentine = 'serpentine';
			d1 *= s;
			d2 *= s;
			d3 *= s;

			function type(type, t1, t2) {
				var hasRoots = t1 !== undefined,
					t1Ok = hasRoots && t1 > 0 && t1 < 1,
					t2Ok = hasRoots && t2 > 0 && t2 < 1;
				if (hasRoots && (!(t1Ok || t2Ok)
						|| type === 'loop' && !(t1Ok && t2Ok))) {
					type = 'arch';
					t1Ok = t2Ok = false;
				}
				return {
					type: type,
					roots: t1Ok || t2Ok
							? t1Ok && t2Ok
								? t1 < t2 ? [t1, t2] : [t2, t1]
								: [t1Ok ? t1 : t2]
							: null
				};
			}

			if (isZero(d1)) {
				return isZero(d2)
						? type(isZero(d3) ? 'line' : 'quadratic')
						: type(serpentine, d3 / (3 * d2));
			}
			var d = 3 * d2 * d2 - 4 * d1 * d3;
			if (isZero(d)) {
				return type('cusp', d2 / (2 * d1));
			}
			var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
				f2 = 2 * d1;
			return type(d > 0 ? serpentine : 'loop',
					(d2 + f1) / f2,
					(d2 - f1) / f2);
		},

		getLength: function(v, a, b, ds) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (Curve.isStraight(v)) {
				var c = v;
				if (b < 1) {
					c = Curve.subdivide(c, b)[0];
					a /= b;
				}
				if (a > 0) {
					c = Curve.subdivide(c, a)[1];
				}
				var dx = c[6] - c[0],
					dy = c[7] - c[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
					getIterations(a, b));
		},

		getTimeAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0;
			if (offset === 0)
				return start;
			var abs = Math.abs,
				epsilon = 1e-12,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Curve.getLength(v, a, b, ds),
				diff = abs(offset) - rangeLength;
			if (abs(diff) < epsilon) {
				return forward ? b : a;
			} else if (diff > epsilon) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		},

		getPeaks: function(v) {
			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				ax =     -x0 + 3 * x1 - 3 * x2 + x3,
				bx =  3 * x0 - 6 * x1 + 3 * x2,
				cx = -3 * x0 + 3 * x1,
				ay =     -y0 + 3 * y1 - 3 * y2 + y3,
				by =  3 * y0 - 6 * y1 + 3 * y2,
				cy = -3 * y0 + 3 * y1,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [];
			Numerical.solveCubic(
					9 * (ax * ax + ay * ay),
					9 * (ax * bx + by * ay),
					2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
					(cx * bx + by * cy),
					roots, tMin, tMax);
			return roots.sort();
		}
	}};
},
new function() {

	function addLocation(locations, include, c1, t1, c2, t2, overlap) {
		var excludeStart = !overlap && c1.getPrevious() === c2,
			excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
			t1 <= (excludeEnd ? tMax : 1)) {
			if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
				t2 <= (excludeStart ? tMax : 1)) {
				var loc1 = new CurveLocation(c1, t1, null, overlap),
					loc2 = new CurveLocation(c2, t2, null, overlap);
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc1)) {
					CurveLocation.insert(locations, loc1, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
			recursion, calls, tMin, tMax, uMin, uMax) {
		if (++calls >= 4096 || ++recursion >= 40)
			return calls;
		var fatLineEpsilon = 1e-9,
			q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if (d1 === 0 && d2 === 0
				&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
			|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
			|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return calls;
		var tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
			var t = (tMinNew + tMaxNew) / 2,
				u = (uMin + uMax) / 2;
			addLocation(locations, include,
					flip ? c2 : c1, flip ? u : t,
					flip ? c1 : c2, flip ? t : u);
		} else {
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			var uDiff = uMax - uMin;
			if (tMaxClip - tMinClip > 0.8) {
				if (tMaxNew - tMinNew > uDiff) {
					var parts = Curve.subdivide(v1, 0.5),
						t = (tMinNew + tMaxNew) / 2;
					calls = addCurveIntersections(
							v2, parts[0], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, t);
					calls = addCurveIntersections(
							v2, parts[1], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, t, tMaxNew);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						u = (uMin + uMax) / 2;
					calls = addCurveIntersections(
							parts[0], v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, u, tMinNew, tMaxNew);
					calls = addCurveIntersections(
							parts[1], v1, c2, c1, locations, include, !flip,
							recursion, calls, u, uMax, tMinNew, tMaxNew);
				}
			} else {
				if (uDiff === 0 || uDiff >= fatLineEpsilon) {
					calls = addCurveIntersections(
							v2, v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, tMaxNew);
				} else {
					calls = addCurveIntersections(
							v1, v2, c1, c2, locations, include, flip,
							recursion, calls, tMinNew, tMaxNew, uMin, uMax);
				}
			}
		}
		return calls;
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= 0.5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function getCurveLineIntersections(v, px, py, vx, vy) {
		var isZero = Numerical.isZero;
		if (isZero(vx) && isZero(vy)) {
			var t = Curve.getTimeOf(v, new Point(px, py));
			return t === null ? [] : [t];
		}
		var angle = Math.atan2(-vy, vx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rv = [],
			roots = [];
		for (var i = 0; i < 8; i += 2) {
			var x = v[i] - px,
				y = v[i + 1] - py;
			rv.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		Curve.solveCubic(rv, 1, 0, roots, 0, 1);
		return roots;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
			flip) {
		var x1 = v2[0], y1 = v2[1],
			x2 = v2[6], y2 = v2[7],
			roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
		for (var i = 0, l = roots.length; i < l; i++) {
			var t1 = roots[i],
				p1 = Curve.getPoint(v1, t1),
				t2 = Curve.getTimeOf(v2, p1);
			if (t2 !== null) {
				addLocation(locations, include,
						flip ? c2 : c1, flip ? t2 : t1,
						flip ? c1 : c2, flip ? t1 : t2);
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, include) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, include,
					c1, Curve.getTimeOf(v1, pt),
					c2, Curve.getTimeOf(v2, pt));
		}
	}

	function getCurveIntersections(v1, v2, c1, c2, locations, include) {
		var epsilon = 1e-12,
			min = Math.min,
			max = Math.max;

		if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
			min(v2[0], v2[2], v2[4], v2[6]) &&
			min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
			max(v2[0], v2[2], v2[4], v2[6]) &&
			max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
			min(v2[1], v2[3], v2[5], v2[7]) &&
			min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
			max(v2[1], v2[3], v2[5], v2[7])) {
			var overlaps = getOverlaps(v1, v2);
			if (overlaps) {
				for (var i = 0; i < 2; i++) {
					var overlap = overlaps[i];
					addLocation(locations, include,
							c1, overlap[0],
							c2, overlap[1], true);
				}
			} else {
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					flip = straight1 && !straight2,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							flip ? v2 : v1, flip ? v1 : v2,
							flip ? c2 : c1, flip ? c1 : c2,
							locations, include, flip,
							0, 0, 0, 1, 0, 1);
				if (!straight || locations.length === before) {
					for (var i = 0; i < 4; i++) {
						var t1 = i >> 1,
							t2 = i & 1,
							i1 = t1 * 6,
							i2 = t2 * 6,
							p1 = new Point(v1[i1], v1[i1 + 1]),
							p2 = new Point(v2[i2], v2[i2 + 1]);
						if (p1.isClose(p2, epsilon)) {
							addLocation(locations, include,
									c1, t1,
									c2, t2);
						}
					}
				}
			}
		}
		return locations;
	}

	function getSelfIntersection(v1, c1, locations, include) {
		var info = Curve.classify(v1);
		if (info.type === 'loop') {
			var roots = info.roots;
			addLocation(locations, include,
					c1, roots[0],
					c1, roots[1]);
		}
	  return locations;
	}

	function getIntersections(curves1, curves2, include, matrix1, matrix2,
			_returnFirst) {
		var epsilon = 1e-7,
			self = !curves2;
		if (self)
			curves2 = curves1;
		var length1 = curves1.length,
			length2 = curves2.length,
			values1 = new Array(length1),
			values2 = self ? values1 : new Array(length2),
			locations = [];

		for (var i = 0; i < length1; i++) {
			values1[i] = curves1[i].getValues(matrix1);
		}
		if (!self) {
			for (var i = 0; i < length2; i++) {
				values2[i] = curves2[i].getValues(matrix2);
			}
		}
		var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(
				values1, values2, epsilon);
		for (var index1 = 0; index1 < length1; index1++) {
			var curve1 = curves1[index1],
				v1 = values1[index1];
			if (self) {
				getSelfIntersection(v1, curve1, locations, include);
			}
			var collisions1 = boundsCollisions[index1];
			if (collisions1) {
				for (var j = 0; j < collisions1.length; j++) {
					if (_returnFirst && locations.length)
						return locations;
					var index2 = collisions1[j];
					if (!self || index2 > index1) {
						var curve2 = curves2[index2],
							v2 = values2[index2];
						getCurveIntersections(
								v1, v2, curve1, curve2, locations, include);
					}
				}
			}
		}
		return locations;
	}

	function getOverlaps(v1, v2) {

		function getSquaredLineLength(v) {
			var x = v[6] - v[0],
				y = v[7] - v[1];
			return x * x + y * y;
		}

		var abs = Math.abs,
			getDistance = Line.getDistance,
			timeEpsilon = 1e-8,
			geomEpsilon = 1e-7,
			straight1 = Curve.isStraight(v1),
			straight2 = Curve.isStraight(v2),
			straightBoth = straight1 && straight2,
			flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
			l1 = flip ? v2 : v1,
			l2 = flip ? v1 : v2,
			px = l1[0], py = l1[1],
			vx = l1[6] - px, vy = l1[7] - py;
		if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
			getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
			if (!straightBoth &&
				getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
				straight1 = straight2 = straightBoth = true;
			}
		} else if (straightBoth) {
			return null;
		}
		if (straight1 ^ straight2) {
			return null;
		}

		var v = [v1, v2],
			pairs = [];
		for (var i = 0; i < 4 && pairs.length < 2; i++) {
			var i1 = i & 1,
				i2 = i1 ^ 1,
				t1 = i >> 1,
				t2 = Curve.getTimeOf(v[i1], new Point(
					v[i2][t1 ? 6 : 0],
					v[i2][t1 ? 7 : 1]));
			if (t2 != null) {
				var pair = i1 ? [t1, t2] : [t2, t1];
				if (!pairs.length ||
					abs(pair[0] - pairs[0][0]) > timeEpsilon &&
					abs(pair[1] - pairs[0][1]) > timeEpsilon) {
					pairs.push(pair);
				}
			}
			if (i > 2 && !pairs.length)
				break;
		}
		if (pairs.length !== 2) {
			pairs = null;
		} else if (!straightBoth) {
			var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
				o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
			if (abs(o2[2] - o1[2]) > geomEpsilon ||
				abs(o2[3] - o1[3]) > geomEpsilon ||
				abs(o2[4] - o1[4]) > geomEpsilon ||
				abs(o2[5] - o1[5]) > geomEpsilon)
				pairs = null;
		}
		return pairs;
	}

	function getTimesWithTangent(v, tangent) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			normalized = tangent.normalize(),
			tx = normalized.x,
			ty = normalized.y,
			ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
			ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
			bx = 6 * x2 - 12 * x1 + 6 * x0,
			by = 6 * y2 - 12 * y1 + 6 * y0,
			cx = 3 * x1 - 3 * x0,
			cy = 3 * y1 - 3 * y0,
			den = 2 * ax * ty - 2 * ay * tx,
			times = [];
		if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
			var num = ax * cy - ay * cx,
				den = ax * by - ay * bx;
			if (den != 0) {
				var t = -num / den;
				if (t >= 0 && t <= 1) times.push(t);
			}
		} else {
			var delta = (bx * bx - 4 * ax * cx) * ty * ty +
				(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +
				(by * by - 4 * ay * cy) * tx * tx,
				k = bx * ty - by * tx;
			if (delta >= 0 && den != 0) {
				var d = Math.sqrt(delta),
					t0 = -(k + d) / den,
					t1 = (-k + d) / den;
				if (t0 >= 0 && t0 <= 1) times.push(t0);
				if (t1 >= 0 && t1 <= 1) times.push(t1);
			}
		}
		return times;
	}

	return {
		getIntersections: function(curve) {
			var v1 = this.getValues(),
				v2 = curve && curve !== this && curve.getValues();
			return v2 ? getCurveIntersections(v1, v2, this, curve, [])
					  : getSelfIntersection(v1, this, []);
		},

		statics: {
			getOverlaps: getOverlaps,
			getIntersections: getIntersections,
			getCurveLineIntersections: getCurveLineIntersections,
			getTimesWithTangent: getTimesWithTangent
		}
	};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',

	initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
		if (time >= 0.99999999) {
			var next = curve.getNext();
			if (next) {
				time = 0;
				curve = next;
			}
		}
		this._setCurve(curve);
		this._time = time;
		this._point = point || curve.getPointAtTime(time);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._previous = null;
	},

	_setPath: function(path) {
		this._path = path;
		this._version = path ? path._version : 0;
	},

	_setCurve: function(curve) {
		this._setPath(curve._path);
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		var curve = segment.getCurve();
		if (curve) {
			this._setCurve(curve);
		} else {
			this._setPath(segment._path);
			this._segment1 = segment;
			this._segment2 = null;
		}
		this._segment = segment;
		this._time = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var segment = this._segment;
		if (!segment) {
			var curve = this.getCurve(),
				time = this.getTime();
			if (time === 0) {
				segment = curve._segment1;
			} else if (time === 1) {
				segment = curve._segment2;
			} else if (time != null) {
				segment = curve.getPartLength(0, time)
					< curve.getPartLength(time, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var path = this._path,
			that = this;
		if (path && path._version !== this._version) {
			this._time = this._offset = this._curveOffset = this._curve = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
				that._setCurve(curve);
				return curve;
			}
		}

		return this._curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getTime: function() {
		var curve = this.getCurve(),
			time = this._time;
		return curve && time == null
			? this._time = curve.getTimeOf(this._point)
			: time;
	},

	getParameter: '#getTime',

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var offset = this._curveOffset;
		if (offset == null) {
			var curve = this.getCurve(),
				time = this.getTime();
			this._curveOffset = offset = time != null && curve
					&& curve.getPartLength(0, time);
		}
		return offset;
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = curve && curve.divideAtTime(this.getTime());
		if (res) {
			this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve(),
			path = curve._path,
			res = curve && curve.splitAtTime(this.getTime());
		if (res) {
			this._setSegment(path.getLastSegment());
		}
		return  res;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc;
		if (!res && loc instanceof CurveLocation) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				p1 = c1._path,
				p2 = c2._path;
			if (p1 === p2) {
				var abs = Math.abs,
					epsilon = 1e-7,
					diff = abs(this.getOffset() - loc.getOffset()),
					i1 = !_ignoreOther && this._intersection,
					i2 = !_ignoreOther && loc._intersection;
				res = (diff < epsilon
						|| p1 && abs(p1.getLength() - diff) < epsilon)
					&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
			}
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var time = this.getTime();
		if (time != null)
			parts.push('time: ' + f.number(time));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getTime(),
			t2 = inter.getTime(),
			tMin = 1e-8,
			tMax = 1 - tMin,
			t1Inside = t1 >= tMin && t1 <= tMax,
			t2Inside = t2 >= tMin && t2 <= tMax;
		if (t1Inside && t2Inside)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
			c4 = inter.getCurve(),
			c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
		if (t1 > tMax)
			c2 = c2.getNext();
		if (t2 > tMax)
			c4 = c4.getNext();
		if (!c1 || !c2 || !c3 || !c4)
			return false;

		var offsets = [];

		function addOffsets(curve, end) {
			var v = curve.getValues(),
				roots = Curve.classify(v).roots || Curve.getPeaks(v),
				count = roots.length,
				offset = Curve.getLength(v,
					end && count ? roots[count - 1] : 0,
					!end && count ? roots[0] : 1);
			offsets.push(count ? offset : offset / 32);
		}

		function isInRange(angle, min, max) {
			return min < max
					? angle > min && angle < max
					: angle > min || angle < max;
		}

		if (!t1Inside) {
			addOffsets(c1, true);
			addOffsets(c2, false);
		}
		if (!t2Inside) {
			addOffsets(c3, true);
			addOffsets(c4, false);
		}
		var pt = this.getPoint(),
			offset = Math.min.apply(Math, offsets),
			v2 = t1Inside ? c2.getTangentAtTime(t1)
					: c2.getPointAt(offset).subtract(pt),
			v1 = t1Inside ? v2.negate()
					: c1.getPointAt(-offset).subtract(pt),
			v4 = t2Inside ? c4.getTangentAtTime(t2)
					: c4.getPointAt(offset).subtract(pt),
			v3 = t2Inside ? v4.negate()
					: c3.getPointAt(-offset).subtract(pt),
			a1 = v1.getAngle(),
			a2 = v2.getAngle(),
			a3 = v3.getAngle(),
			a4 = v4.getAngle();
		return !!(t1Inside
				? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
				  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
				: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
				  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
	},

	hasOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve._evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var curve = this.getCurve(),
			time = this.getTime();
		return time != null && curve && curve[get](time, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						1e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 !== path2
				? path1._id - path2._id
				: (loc.getIndex() + loc.getTime())
				- (loc2.getIndex() + loc2.getTime());
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = locations.length - 1; i >= 0; i--) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',
	_selectBounds: false,
	_canScaleStroke: true,
	beans: true,

	initialize: function PathItem() {
	},

	statics: {
		create: function(arg) {
			var data,
				segments,
				compound;
			if (Base.isPlainObject(arg)) {
				segments = arg.segments;
				data = arg.pathData;
			} else if (Array.isArray(arg)) {
				segments = arg;
			} else if (typeof arg === 'string') {
				data = arg;
			}
			if (segments) {
				var first = segments[0];
				compound = first && Array.isArray(first[0]);
			} else if (data) {
				compound = (data.match(/m/gi) || []).length > 1
						|| /z\s*\S+/i.test(data);
			}
			var ctor = compound ? CompoundPath : Path;
			return new ctor(arg);
		}
	},

	_asPathItem: function() {
		return this;
	},

	isClockwise: function() {
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
	},

	setPathData: function(data) {

		var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2) {
					this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
					if (move) {
						start = current;
						move = false;
					}
				}
				control = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				current = current.clone();
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(1e-12);
				current = start;
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = point.isInside(
				this.getBounds({ internal: true, handle: true }))
					? this._getWinding(point)
					: {};
		return winding.onPath || !!(this.getFillRule() === 'evenodd'
				? winding.windingL & 1 || winding.windingR & 1
				: winding.winding);
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix._orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix)._orNullIfIdentity();
		return self || this.getBounds(matrix1).intersects(
				path.getBounds(matrix2), 1e-12)
				? Curve.getIntersections(
						this.getCurves(), !self && path.getCurves(), include,
						matrix1, matrix2, _returnFirst)
				: [];
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	},

	interpolate: function(from, to, factor) {
		var isPath = !this._children,
			name = isPath ? '_segments' : '_children',
			itemsFrom = from[name],
			itemsTo = to[name],
			items = this[name];
		if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
			throw new Error('Invalid operands in interpolate() call: ' +
					from + ', ' + to);
		}
		var current = items.length,
			length = itemsTo.length;
		if (current < length) {
			var ctor = isPath ? Segment : Path;
			for (var i = current; i < length; i++) {
				this.add(new ctor());
			}
		} else if (current > length) {
			this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
		}
		for (var i = 0; i < length; i++) {
			items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
		}
		if (isPath) {
			this.setClosed(from._closed);
			this._changed(9);
		}
	},

	compare: function(path) {
		var ok = false;
		if (path) {
			var paths1 = this._children || [this],
				paths2 = path._children ? path._children.slice() : [path],
				length1 = paths1.length,
				length2 = paths2.length,
				matched = [],
				count = 0;
			ok = true;
			var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);
			for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
				var path1 = paths1[i1];
				ok = false;
				var pathBoundsOverlaps = boundsOverlaps[i1];
				if (pathBoundsOverlaps) {
					for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
						if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
							if (!matched[pathBoundsOverlaps[i2]]) {
								matched[pathBoundsOverlaps[i2]] = true;
								count++;
							}
							ok = true;
						}
					}
				}
			}
			ok = ok && count === length2;
		}
		return ok;
	},

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var args = arguments,
			segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: args
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? args
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._segmentSelection = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	copyContent: function(source) {
		this.setSegments(source._segments);
		this._closed = source._closed;
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			this._length = this._area = undefined;
			if (flags & 32) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 64) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected(),
			length = segments && segments.length;
		this._segments.length = 0;
		this._segmentSelection = 0;
		this._curves = undefined;
		if (length) {
			var last = segments[length - 1];
			if (typeof last === 'boolean') {
				this.setClosed(last);
				length--;
			}
			this._add(Segment.readList(segments, 0, {}, length));
		}
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(41);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine) {
						var dx = curX - prevX,
							dy = curY - prevY;
						parts.push(
							  dx === 0 ? 'v' + f.number(dy)
							: dy === 0 ? 'h' + f.number(dx)
							: 'l' + f.pair(dx, dy));
					}
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							 + ' ' + f.pair( inX - prevX,  inY - prevY)
							 + ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (!length)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	},

	isEmpty: function() {
		return !this._segments.length;
	},

	_transformContent: function(matrix) {
		var segments = this._segments,
			coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selection)
				this._updateSelection(segment, 0, segment._selection);
		}
		if (append) {
			Base.push(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				start = index > 0 && index + amount - 1 === total ? index - 1
					: index,
				insert = start,
				end = Math.min(start + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [start, 0].concat(segs._curves));
				insert += segs._curves.length;
			}
			for (var i = insert; i < end; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(start, end);
		}
		this._changed(41);
		return segs;
	},

	_adjustCurves: function(start, end) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = start; i < end; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && !start ? segments.length - 1
				: start - 1]) {
			curve._segment2 = segments[start] || segments[0];
			curve._changed();
		}
		if (curve = curves[end]) {
			curve._segment1 = segments[end];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		var args = arguments;
		return args.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args))
			: this._add([ Segment.read(args) ])[0];
	},

	insert: function(index, segment1 ) {
		var args = arguments;
		return args.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args, 1), index)
			: this._add([ Segment.read(args, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readList(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readList(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(start, end, _includeCurves) {
		start = start || 0;
		end = Base.pick(end, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(start, end - start),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selection)
				this._updateSelection(segment, segment._selection, 0);
			segment._index = segment._path = null;
		}
		for (var i = start, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = start > 0 && end === count + (this._closed ? 1 : 0)
					? start - 1
					: start,
				curves = curves.splice(index, amount);
			for (var i = curves.length - 1; i >= 0; i--)
				curves[i]._path = null;
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(41);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		var area = this._area;
		if (area == null) {
			var segments = this._segments,
				closed = this._closed;
			area = 0;
			for (var i = 0, l = segments.length; i < l; i++) {
				var last = i + 1 === l;
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[last ? 0 : i + 1],
						null, last && !closed));
			}
			this._area = area;
		}
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this.isSelected() && length > 0 && this._segmentSelection
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelection: function setSelection(selection) {
		if (!(selection & 1))
			this._selectSegments(false);
		setSelection.base.call(this, selection);
	},

	_selectSegments: function(selected) {
		var segments = this._segments,
			length = segments.length,
			selection = selected ? 7 : 0;
		this._segmentSelection = selection * length;
		for (var i = 0; i < length; i++)
			segments[i]._selection = selection;
	},

	_updateSelection: function(segment, oldSelection, newSelection) {
		segment._selection = newSelection;
		var selection = this._segmentSelection += newSelection - oldSelection;
		if (selection > 0)
			this.setSelected(true);
	},

	divideAt: function(location) {
		var loc = this.getLocationAt(location),
			curve;
		return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
				? curve._segment1
				: null;
	},

	splitAt: function(location) {
		var loc = this.getLocationAt(location),
			index = loc && loc.index,
			time = loc && loc.time,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (time > tMax) {
			index++;
			time = 0;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (time >= tMin) {
				curves[index++].divideAtTime(time);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.copyAttributes(this);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	split: function(index, time) {
		var curve,
			location = time === undefined ? index
				: (curve = this.getCurves()[index])
					&& curve.getLocationAtTime(time);
		return location != null ? this.splitAt(location) : null;
	},

	join: function(path, tolerance) {
		var epsilon = tolerance || 0;
		if (path && path !== this) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.isClose(last2._point, epsilon))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.isClose(first2._point, epsilon)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.isClose(first2._point, epsilon))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.isClose(last2._point, epsilon)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.isClose(last._point, epsilon)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	reduce: function(options) {
		var curves = this.getCurves(),
			simplify = options && options.simplify,
			tolerance = simplify ? 1e-7 : 0;
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (!curve.hasLength(tolerance)
					|| simplify && curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		this._changed(9);
	},

	flatten: function(flatness) {
		var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
			parts = flattener.parts,
			length = parts.length,
			segments = [];
		for (var i = 0; i < length; i++) {
			segments.push(new Segment(parts[i].curve.slice(0, 2)));
		}
		if (!this._closed && length > 0) {
			segments.push(new Segment(parts[length - 1].curve.slice(6)));
		}
		this.setSegments(segments);
	},

	simplify: function(tolerance) {
		var segments = new PathFitter(this).fit(tolerance || 2.5);
		if (segments)
			this.setSegments(segments);
		return !!segments;
	},

	smooth: function(options) {
		var that = this,
			opts = options || {},
			type = opts.type || 'asymmetric',
			segments = this._segments,
			length = segments.length,
			closed = this._closed;

		function getIndex(value, _default) {
			var index = value && value.index;
			if (index != null) {
				var path = value.path;
				if (path && path !== that)
					throw new Error(value._class + ' ' + index + ' of ' + path
							+ ' is not part of ' + that);
				if (_default && value instanceof Curve)
					index++;
			} else {
				index = typeof value === 'number' ? value : _default;
			}
			return Math.min(index < 0 && closed
					? index % length
					: index < 0 ? index + length : index, length - 1);
		}

		var loop = closed && opts.from === undefined && opts.to === undefined,
			from = getIndex(opts.from, 0),
			to = getIndex(opts.to, length - 1);

		if (from > to) {
			if (closed) {
				from -= length;
			} else {
				var tmp = from;
				from = to;
				to = tmp;
			}
		}
		if (/^(?:asymmetric|continuous)$/.test(type)) {
			var asymmetric = type === 'asymmetric',
				min = Math.min,
				amount = to - from + 1,
				n = amount - 1,
				padding = loop ? min(amount, 4) : 1,
				paddingLeft = padding,
				paddingRight = padding,
				knots = [];
			if (!closed) {
				paddingLeft = min(1, from);
				paddingRight = min(1, length - to - 1);
			}
			n += paddingLeft + paddingRight;
			if (n <= 1)
				return;
			for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
				knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
			}

			var x = knots[0]._x + 2 * knots[1]._x,
				y = knots[0]._y + 2 * knots[1]._y,
				f = 2,
				n_1 = n - 1,
				rx = [x],
				ry = [y],
				rf = [f],
				px = [],
				py = [];
			for (var i = 1; i < n; i++) {
				var internal = i < n_1,
					a = internal ? 1 : asymmetric ? 1 : 2,
					b = internal ? 4 : asymmetric ? 2 : 7,
					u = internal ? 4 : asymmetric ? 3 : 8,
					v = internal ? 2 : asymmetric ? 0 : 1,
					m = a / f;
				f = rf[i] = b - m;
				x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
				y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
			}

			px[n_1] = rx[n_1] / rf[n_1];
			py[n_1] = ry[n_1] / rf[n_1];
			for (var i = n - 2; i >= 0; i--) {
				px[i] = (rx[i] - px[i + 1]) / rf[i];
				py[i] = (ry[i] - py[i + 1]) / rf[i];
			}
			px[n] = (3 * knots[n]._x - px[n_1]) / 2;
			py[n] = (3 * knots[n]._y - py[n_1]) / 2;

			for (var i = paddingLeft, max = n - paddingRight, j = from;
					i <= max; i++, j++) {
				var segment = segments[j < 0 ? j + length : j],
					pt = segment._point,
					hx = px[i] - pt._x,
					hy = py[i] - pt._y;
				if (loop || i < max)
					segment.setHandleOut(hx, hy);
				if (loop || i > paddingLeft)
					segment.setHandleIn(-hx, -hy);
			}
		} else {
			for (var i = from; i <= to; i++) {
				segments[i < 0 ? i + length : i].smooth(opts,
						!loop && i === from, !loop && i === to);
			}
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.copyAttributes(this, true);
			shape._matrix.prepend(this._matrix);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			if (insert === undefined || insert)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	toPath: '#clone',

	compare: function compare(path) {
		if (!path || path instanceof CompoundPath)
			return compare.base.call(this, path);
		var curves1 = this.getCurves(),
			curves2 = path.getCurves(),
			length1 = curves1.length,
			length2 = curves2.length;
		if (!length1 || !length2) {
			return length1 == length2;
		}
		var v1 = curves1[0].getValues(),
			values2 = [],
			pos1 = 0, pos2,
			end1 = 0, end2;
		for (var i = 0; i < length2; i++) {
			var v2 = curves2[i].getValues();
			values2.push(v2);
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
				end2 = overlaps[0][1];
				break;
			}
		}
		var abs = Math.abs,
			epsilon = 1e-8,
			v2 = values2[pos2],
			start2;
		while (v1 && v2) {
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				var t1 = overlaps[0][0];
				if (abs(t1 - end1) < epsilon) {
					end1 = overlaps[1][0];
					if (end1 === 1) {
						v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
						end1 = 0;
					}
					var t2 = overlaps[0][1];
					if (abs(t2 - end2) < epsilon) {
						if (!start2)
							start2 = [pos2, t2];
						end2 = overlaps[1][1];
						if (end2 === 1) {
							if (++pos2 >= length2)
								pos2 = 0;
							v2 = values2[pos2] || curves2[pos2].getValues();
							end2 = 0;
						}
						if (!v1) {
							return start2[0] === pos2 && start2[1] === end2;
						}
						continue;
					}
				}
			}
			break;
		}
		return false;
	},

	_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			strokeRadius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (strokeRadius !== null) {
			if (strokeRadius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = style.getMiterLimit();
				strokePadding = strokePadding.add(
					Path._getStrokePadding(strokeRadius, strokeMatrix));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			var isJoin = closed || segment._index > 0
					&& segment._index < numSegments - 1;
			if ((isJoin ? join : cap) === 'round') {
				return isCloseEnough(segment._point, strokePadding);
			} else {
				area = new Path({ internal: true, closed: true });
				if (isJoin) {
					if (!segment.isSmooth()) {
						Path._addBevelJoin(segment, join, strokeRadius,
							   miterLimit, null, strokeMatrix, addToArea, true);
					}
				} else if (cap === 'square') {
					Path._addSquareCap(segment, cap, strokeRadius, null,
							strokeMatrix, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (strokeRadius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var time = loc.getTime();
				if (time === 0 || time === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point)
							<= miterLimit * strokeRadius
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var loc = this.getLocationAt(offset);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset) {
		if (typeof offset === 'number') {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength()) {
				return new CurveLocation(curves[curves.length - 1], 1);
			}
		} else if (offset && offset.getPath && offset.getPath() === this) {
			return offset;
		}
		return null;
	},

	getOffsetsWithTangent: function() {
		var tangent = Point.read(arguments);
		if (tangent.isZero()) {
			return [];
		}

		var offsets = [];
		var curveStart = 0;
		var curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i];
			var curveTimes = curve.getTimesWithTangent(tangent);
			for (var j = 0, m = curveTimes.length; j < m; j++) {
				var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);
				if (offsets.indexOf(offset) < 0) {
					offsets.push(offset);
				}
			}
			curveStart += curve.length;
		}
		return offsets;
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		if (size <= 0) return;

		var half = size / 2,
			miniSize = size - 2,
			miniHalf = half - 1,
			coords = new Array(6),
			pX, pY;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i],
				selection = segment._selection;
			segment._transformCoordinates(matrix, coords);
			pX = coords[0];
			pY = coords[1];
			if (selection & 2)
				drawHandle(2);
			if (selection & 4)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (miniSize > 0 && !(selection & 1)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, viewMatrix, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx, param, viewMatrix);
				if (hasFill) {
					ctx.fill(style.getFillRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this, 0.25, 32, false,
								strokeMatrix),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (!segments.length)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				t = Base.pick(Base.read(args), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var args = arguments,
				abs = Math.abs,
				sqrt = Math.sqrt,
				current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(args),
				through,
				peek = Base.peek(args),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(args) <= 2) {
				through = to;
				to = Point.read(args);
			} else if (!from.equals(to)) {
				var radius = Size.read(args),
					isZero = Numerical.isZero;
				if (isZero(radius.width) || isZero(radius.height))
					return this.lineTo(to);
				var rotation = Base.read(args),
					clockwise = !!Base.read(args),
					large = !!Base.read(args),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq = x * x,
					ySq = y * y;
				var factor = sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1) * sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center, true);
				if (centerSide === 0) {
					extent = throughSide * abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			if (extent) {
				var epsilon = 1e-7,
					ext = abs(extent),
					count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (!i) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			}
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				parameter = Base.read(args),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var args = arguments,
				current = getCurrentSegment(this)._point,
				point = current.add(Point.read(args)),
				clockwise = Base.pick(Base.peek(args), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(args)));
			}
		},

		closePath: function(tolerance) {
			this.setClosed(true);
			this.join(this, tolerance);
		}
	};
}, {

	_getBounds: function(matrix, options) {
		var method = options.handle
				? 'getHandleBounds'
				: options.stroke
				? 'getStrokeBounds'
				: 'getBounds';
		return Path[method](this._segments, this._closed, this, matrix, options);
	},

statics: {
	getBounds: function(segments, closed, path, matrix, options, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6)),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = style.hasStroke(),
			strokeWidth = style.getStrokeWidth(),
			strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
			strokePadding = stroke && Path._getStrokePadding(strokeWidth,
				strokeMatrix),
			bounds = Path.getBounds(segments, closed, path, matrix, options,
				strokePadding);
		if (!stroke)
			return bounds;
		var strokeRadius = strokeWidth / 2,
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = style.getMiterLimit(),
			joinBounds = new Rectangle(new Size(strokePadding));

		function addPoint(point) {
			bounds = bounds.include(point);
		}

		function addRound(segment) {
			bounds = bounds.unite(
					joinBounds.setCenter(segment._point.transform(matrix)));
		}

		function addJoin(segment, join) {
			if (join === 'round' || segment.isSmooth()) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
						matrix, strokeMatrix, addPoint);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, strokeRadius, matrix,
						strokeMatrix, addPoint);
			}
		}

		var length = segments.length - (closed ? 0 : 1);
		if (length > 0) {
			for (var i = 1; i < length; i++) {
				addJoin(segments[i], join);
			}
			if (closed) {
				addJoin(segments[0], join);
			} else {
				addCap(segments[0], cap);
				addCap(segments[segments.length - 1], cap);
			}
		}
		return bounds;
	},

	_getStrokePadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var hor = new Point(radius, 0).transform(matrix),
			ver = new Point(0, radius).transform(matrix),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = Math.atan2(b * tan, a),
			ty = Math.atan2(b, tan * a);
		return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, matrix,
			strokeMatrix, addPoint, isArea) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPoint1().transform(matrix),
			normal1 = curve1.getNormalAtTime(1).multiply(radius)
				.transform(strokeMatrix),
			normal2 = curve2.getNormalAtTime(0).multiply(radius)
				.transform(strokeMatrix),
				angle = normal1.getDirectedAngle(normal2);
		if (angle < 0 || angle >= 180) {
			normal1 = normal1.negate();
			normal2 = normal2.negate();
		}
		if (isArea)
			addPoint(point);
		addPoint(point.add(normal1));
		if (join === 'miter') {
			var corner = new Line(point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit * radius) {
				addPoint(corner);
			}
		}
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
			addPoint, isArea) {
		var point = segment._point.transform(matrix),
			loc = segment.getLocation(),
			normal = loc.getNormal()
					.multiply(loc.getTime() === 0 ? radius : -radius)
					.transform(strokeMatrix);
		if (cap === 'square') {
			if (isArea) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			point = point.add(normal.rotate(-90));
		}
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = options.stroke && style.hasStroke(),
			strokePadding,
			joinPadding;
		if (stroke) {
			var strokeMatrix = path._getStrokeMatrix(matrix, options),
				strokeRadius = style.getStrokeWidth() / 2,
				joinRadius = strokeRadius;
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
			strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
			joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
		}
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords);
			for (var j = 0; j < 6; j += 2) {
				var padding = !j ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert == false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props, { insert: true });
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			var args = arguments;
			return createPath([
				new Segment(Point.readNamed(args, 'from')),
				new Segment(Point.readNamed(args, 'to'))
			], false, args);
		},

		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createEllipse(center, new Size(radius), args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.readNamed(args, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, args);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args);
			return createEllipse(ellipse.center, ellipse.radius, args);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var args = arguments,
				from = Point.readNamed(args, 'from'),
				through = Point.readNamed(args, 'through'),
				to = Point.readNamed(args, 'to'),
				props = Base.getNamed(args),
				path = new Path(props && props.insert == false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				sides = Base.readNamed(args, 'sides'),
				radius = Base.readNamed(args, 'radius'),
				step = 360 / sides,
				three = sides % 3 === 0,
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, args);
		},

		Star: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				points = Base.readNamed(args, 'points') * 2,
				radius1 = Base.readNamed(args, 'radius1'),
				radius2 = Base.readNamed(args, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, args);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},
	beans: true,

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items) {
		var list = items,
			first = list[0];
		if (first && typeof first[0] === 'number')
			list = [list];
		for (var i = items.length - 1; i >= 0; i--) {
			var item = list[i];
			if (list === items && !(item instanceof Path))
				list = Base.slice(list);
			if (Array.isArray(item)) {
				list[i] = new Path({ segments: item, insert: false });
			} else if (item instanceof CompoundPath) {
				list.splice.apply(list, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		return insertChildren.base.call(this, index, list);
	},

	reduce: function reduce(options) {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce(options);
			if (path.isEmpty())
				path.remove();
		}
		if (!children.length) {
			var path = new Path(Item.NO_INSERT);
			path.copyAttributes(this);
			path.insertAbove(this);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClosed: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			if (!children[i]._closed)
				return false;
		}
		return true;
	},

	setClosed: function(closed) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].setClosed(closed);
		}
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++) {
			Base.push(curves, children[i].getCurves());
		}
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getLastCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	},

	getLength: function() {
		var children = this._children,
			length = 0;
		for (var i = 0, l = children.length; i < l; i++)
			length += children[i].getLength();
		return length;
	},

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.appended(mx) : _matrix, _precision));
		}
		return paths.join('');
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		return _hitTestChildren.base.call(this, point,
				options.class === Path || options.type === 'path' ? options
					: Base.set({}, options, { fill: false }),
				viewMatrix);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var children = this._children;
		if (!children.length)
			return;

		param = param.extend({ dontStart: true, dontFinish: true });
		ctx.beginPath();
		for (var i = 0, l = children.length; i < l; i++)
			children[i].draw(ctx, param, strokeMatrix);

		if (!param.clip) {
			this._setStyles(ctx, param, viewMatrix);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectionItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectionItems[child._id]) {
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.appended(mx));
			}
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && !children.length)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
			'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
			'arcBy'],
		function(key) {
			this[key] = function() {
				var path = getCurrentPath(this, true);
				path[key].apply(path, arguments);
			};
		}, {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},

			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},

			closePath: function(tolerance) {
				getCurrentPath(this, true).closePath(tolerance);
			}
		}
	);
}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
	this[key] = function(param) {
		var children = this._children,
			res;
		for (var i = 0, l = children.length; i < l; i++) {
			res = children[i][key](param) || res;
		}
		return res;
	};
}, {}));

PathItem.inject(new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		operators = {
			unite:     { '1': true, '2': true },
			intersect: { '2': true },
			subtract:  { '1': true },
			exclude:   { '1': true, '-1': true }
		};

	function getPaths(path) {
		return path._children || [path];
	}

	function preparePath(path, resolve) {
		var res = path
			.clone(false)
			.reduce({ simplify: true })
			.transform(null, true, true);
		if (resolve) {
			var paths = getPaths(res);
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				if (!path._closed && !path.isEmpty()) {
					path.closePath(1e-12);
					path.getFirstSegment().setHandleIn(0, 0);
					path.getLastSegment().setHandleOut(0, 0);
				}
			}
			res = res
				.resolveCrossings()
				.reorient(res.getFillRule() === 'nonzero', true);
		}
		return res;
	}

	function createResult(paths, simplify, path1, path2, options) {
		var result = new CompoundPath(Item.NO_INSERT);
		result.addChildren(paths, true);
		result = result.reduce({ simplify: simplify });
		if (!(options && options.insert == false)) {
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex() ? path2 : path1);
		}
		result.copyAttributes(path1, true);
		return result;
	}

	function filterIntersection(inter) {
		return inter.hasOverlap() || inter.isCrossing();
	}

	function traceBoolean(path1, path2, operation, options) {
		if (options && (options.trace == false || options.stroke) &&
				/^(subtract|intersect)$/.test(operation))
			return splitBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true),
			operator = operators[operation];
		operator[operation] = true;
		if (_path2 && (operator.subtract || operator.exclude)
				^ (_path2.isClockwise() ^ _path1.isClockwise()))
			_path2.reverse();
		var crossings = divideLocations(CurveLocation.expand(
				_path1.getIntersections(_path2, filterIntersection))),
			paths1 = getPaths(_path1),
			paths2 = _path2 && getPaths(_path2),
			segments = [],
			curves = [],
			paths;

		function collectPaths(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				Base.push(segments, path._segments);
				Base.push(curves, path.getCurves());
				path._overlapsOnly = true;
			}
		}

		function getCurves(indices) {
			var list = [];
			for (var i = 0, l = indices && indices.length; i < l; i++) {
				list.push(curves[indices[i]]);
			}
			return list;
		}

		if (crossings.length) {
			collectPaths(paths1);
			if (paths2)
				collectPaths(paths2);

			var curvesValues = new Array(curves.length);
			for (var i = 0, l = curves.length; i < l; i++) {
				curvesValues[i] = curves[i].getValues();
			}
			var curveCollisions = CollisionDetection.findCurveBoundsCollisions(
					curvesValues, curvesValues, 0, true);
			var curveCollisionsMap = {};
			for (var i = 0; i < curves.length; i++) {
				var curve = curves[i],
					id = curve._path._id,
					map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
				map[curve.getIndex()] = {
					hor: getCurves(curveCollisions[i].hor),
					ver: getCurves(curveCollisions[i].ver)
				};
			}

			for (var i = 0, l = crossings.length; i < l; i++) {
				propagateWinding(crossings[i]._segment, _path1, _path2,
						curveCollisionsMap, operator);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i],
					inter = segment._intersection;
				if (!segment._winding) {
					propagateWinding(segment, _path1, _path2,
							curveCollisionsMap, operator);
				}
				if (!(inter && inter._overlap))
					segment._path._overlapsOnly = false;
			}
			paths = tracePaths(segments, operator);
		} else {
			paths = reorientPaths(
					paths2 ? paths1.concat(paths2) : paths1.slice(),
					function(w) {
						return !!operator[w];
					});
		}
		return createResult(paths, true, path1, path2, options);
	}

	function splitBoolean(path1, path2, operation) {
		var _path1 = preparePath(path1),
			_path2 = preparePath(path2),
			crossings = _path1.getIntersections(_path2, filterIntersection),
			subtract = operation === 'subtract',
			divide = operation === 'divide',
			added = {},
			paths = [];

		function addPath(path) {
			if (!added[path._id] && (divide ||
					_path2.contains(path.getPointAt(path.getLength() / 2))
						^ subtract)) {
				paths.unshift(path);
				return added[path._id] = true;
			}
		}

		for (var i = crossings.length - 1; i >= 0; i--) {
			var path = crossings[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return createResult(paths, false, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._previous;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._previous)
				to = to._previous;
			from._next = to;
			to._previous = from;
		}
	}

	function clearCurveHandles(curves) {
		for (var i = curves.length - 1; i >= 0; i--)
			curves[i].clearHandles();
	}

	function reorientPaths(paths, isInside, clockwise) {
		var length = paths && paths.length;
		if (length) {
			var lookup = Base.each(paths, function (path, i) {
					this[path._id] = {
						container: null,
						winding: path.isClockwise() ? 1 : -1,
						index: i
					};
				}, {}),
				sorted = paths.slice().sort(function (a, b) {
					return abs(b.getArea()) - abs(a.getArea());
				}),
				first = sorted[0];
			var collisions = CollisionDetection.findItemBoundsCollisions(sorted,
					null, Numerical.GEOMETRIC_EPSILON);
			if (clockwise == null)
				clockwise = first.isClockwise();
			for (var i = 0; i < length; i++) {
				var path1 = sorted[i],
					entry1 = lookup[path1._id],
					containerWinding = 0,
					indices = collisions[i];
				if (indices) {
					var point = null;
					for (var j = indices.length - 1; j >= 0; j--) {
						if (indices[j] < i) {
							point = point || path1.getInteriorPoint();
							var path2 = sorted[indices[j]];
							if (path2.contains(point)) {
								var entry2 = lookup[path2._id];
								containerWinding = entry2.winding;
								entry1.winding += containerWinding;
								entry1.container = entry2.exclude
									? entry2.container : path2;
								break;
							}
						}
					}
				}
				if (isInside(entry1.winding) === isInside(containerWinding)) {
					entry1.exclude = true;
					paths[entry1.index] = null;
				} else {
					var container = entry1.container;
					path1.setClockwise(
							container ? !container.isClockwise() : clockwise);
				}
			}
		}
		return paths;
	}

	function divideLocations(locations, include, clearLater) {
		var results = include && [],
			tMin = 1e-8,
			tMax = 1 - tMin,
			clearHandles = false,
			clearCurves = clearLater || [],
			clearLookup = clearLater && {},
			renormalizeLocs,
			prevCurve,
			prevTime;

		function getId(curve) {
			return curve._path._id + '.' + curve._segment1._index;
		}

		for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
			var curve = clearLater[i];
			if (curve._path)
				clearLookup[getId(curve)] = true;
		}

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				time = loc._time,
				origTime = time,
				exclude = include && !include(loc),
				curve = loc._curve,
				segment;
			if (curve) {
				if (curve !== prevCurve) {
					clearHandles = !curve.hasHandles()
							|| clearLookup && clearLookup[getId(curve)];
					renormalizeLocs = [];
					prevTime = null;
					prevCurve = curve;
				} else if (prevTime >= tMin) {
					time /= prevTime;
				}
			}
			if (exclude) {
				if (renormalizeLocs)
					renormalizeLocs.push(loc);
				continue;
			} else if (include) {
				results.unshift(loc);
			}
			prevTime = origTime;
			if (time < tMin) {
				segment = curve._segment1;
			} else if (time > tMax) {
				segment = curve._segment2;
			} else {
				var newCurve = curve.divideAtTime(time, true);
				if (clearHandles)
					clearCurves.push(curve, newCurve);
				segment = newCurve._segment1;
				for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
					var l = renormalizeLocs[j];
					l._time = (l._time - time) / (1 - time);
				}
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
		}
		if (!clearLater)
			clearCurveHandles(clearCurves);
		return results || locations;
	}

	function getWinding(point, curves, dir, closed, dontFlip) {
		var curvesList = Array.isArray(curves)
			? curves
			: curves[dir ? 'hor' : 'ver'];
		var ia = dir ? 1 : 0,
			io = ia ^ 1,
			pv = [point.x, point.y],
			pa = pv[ia],
			po = pv[io],
			windingEpsilon = 1e-9,
			qualityEpsilon = 1e-6,
			paL = pa - windingEpsilon,
			paR = pa + windingEpsilon,
			windingL = 0,
			windingR = 0,
			pathWindingL = 0,
			pathWindingR = 0,
			onPath = false,
			onAnyPath = false,
			quality = 1,
			roots = [],
			vPrev,
			vClose;

		function addWinding(v) {
			var o0 = v[io + 0],
				o3 = v[io + 6];
			if (po < min(o0, o3) || po > max(o0, o3)) {
				return;
			}
			var a0 = v[ia + 0],
				a1 = v[ia + 2],
				a2 = v[ia + 4],
				a3 = v[ia + 6];
			if (o0 === o3) {
				if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
					onPath = true;
				}
				return;
			}
			var t =   po === o0 ? 0
					: po === o3 ? 1
					: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
					? 1
					: Curve.solveCubic(v, io, po, roots, 0, 1) > 0
						? roots[0]
						: 1,
				a =   t === 0 ? a0
					: t === 1 ? a3
					: Curve.getPoint(v, t)[dir ? 'y' : 'x'],
				winding = o0 > o3 ? 1 : -1,
				windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
				a3Prev = vPrev[ia + 6];
			if (po !== o0) {
				if (a < paL) {
					pathWindingL += winding;
				} else if (a > paR) {
					pathWindingR += winding;
				} else {
					onPath = true;
				}
				if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
					quality /= 2;
			} else {
				if (winding !== windingPrev) {
					if (a0 < paL) {
						pathWindingL += winding;
					} else if (a0 > paR) {
						pathWindingR += winding;
					}
				} else if (a0 != a3Prev) {
					if (a3Prev < paR && a > paR) {
						pathWindingR += winding;
						onPath = true;
					} else if (a3Prev > paL && a < paL) {
						pathWindingL += winding;
						onPath = true;
					}
				}
				quality /= 4;
			}
			vPrev = v;
			return !dontFlip && a > paL && a < paR
					&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
					&& getWinding(point, curves, !dir, closed, true);
		}

		function handleCurve(v) {
			var o0 = v[io + 0],
				o1 = v[io + 2],
				o2 = v[io + 4],
				o3 = v[io + 6];
			if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
				var a0 = v[ia + 0],
					a1 = v[ia + 2],
					a2 = v[ia + 4],
					a3 = v[ia + 6],
					monoCurves = paL > max(a0, a1, a2, a3) ||
								 paR < min(a0, a1, a2, a3)
							? [v] : Curve.getMonoCurves(v, dir),
					res;
				for (var i = 0, l = monoCurves.length; i < l; i++) {
					if (res = addWinding(monoCurves[i]))
						return res;
				}
			}
		}

		for (var i = 0, l = curvesList.length; i < l; i++) {
			var curve = curvesList[i],
				path = curve._path,
				v = curve.getValues(),
				res;
			if (!i || curvesList[i - 1]._path !== path) {
				vPrev = null;
				if (!path._closed) {
					vClose = Curve.getValues(
							path.getLastCurve().getSegment2(),
							curve.getSegment1(),
							null, !closed);
					if (vClose[io] !== vClose[io + 6]) {
						vPrev = vClose;
					}
				}

				if (!vPrev) {
					vPrev = v;
					var prev = path.getLastCurve();
					while (prev && prev !== curve) {
						var v2 = prev.getValues();
						if (v2[io] !== v2[io + 6]) {
							vPrev = v2;
							break;
						}
						prev = prev.getPrevious();
					}
				}
			}

			if (res = handleCurve(v))
				return res;

			if (i + 1 === l || curvesList[i + 1]._path !== path) {
				if (vClose && (res = handleCurve(vClose)))
					return res;
				if (onPath && !pathWindingL && !pathWindingR) {
					pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
							? 1 : -1;
				}
				windingL += pathWindingL;
				windingR += pathWindingR;
				pathWindingL = pathWindingR = 0;
				if (onPath) {
					onAnyPath = true;
					onPath = false;
				}
				vClose = null;
			}
		}
		windingL = abs(windingL);
		windingR = abs(windingR);
		return {
			winding: max(windingL, windingR),
			windingL: windingL,
			windingR: windingR,
			quality: quality,
			onPath: onAnyPath
		};
	}

	function propagateWinding(segment, path1, path2, curveCollisionsMap,
			operator) {
		var chain = [],
			start = segment,
			totalLength = 0,
			winding;
		do {
			var curve = segment.getCurve();
			if (curve) {
				var length = curve.getLength();
				chain.push({ segment: segment, curve: curve, length: length });
				totalLength += length;
			}
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		var offsets = [0.5, 0.25, 0.75],
			winding = { winding: 0, quality: -1 },
			tMin = 1e-3,
			tMax = 1 - tMin;
		for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
			var length = totalLength * offsets[i];
			for (var j = 0, l = chain.length; j < l; j++) {
				var entry = chain[j],
					curveLength = entry.length;
				if (length <= curveLength) {
					var curve = entry.curve,
						path = curve._path,
						parent = path._parent,
						operand = parent instanceof CompoundPath ? parent : path,
						t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
						pt = curve.getPointAtTime(t),
						dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
					var wind = null;
					if (operator.subtract && path2) {
						var otherPath = operand === path1 ? path2 : path1,
							pathWinding = otherPath._getWinding(pt, dir, true);
						if (operand === path1 && pathWinding.winding ||
							operand === path2 && !pathWinding.winding) {
							if (pathWinding.quality < 1) {
								continue;
							} else {
								wind = { winding: 0, quality: 1 };
							}
						}
					}
					wind =  wind || getWinding(
							pt, curveCollisionsMap[path._id][curve.getIndex()],
							dir, true);
					if (wind.quality > winding.quality)
						winding = wind;
					break;
				}
				length -= curveLength;
			}
		}
		for (var j = chain.length - 1; j >= 0; j--) {
			chain[j].segment._winding = winding;
		}
	}

	function tracePaths(segments, operator) {
		var paths = [],
			starts;

		function isValid(seg) {
			var winding;
			return !!(seg && !seg._visited && (!operator
					|| operator[(winding = seg._winding || {}).winding]
						&& !(operator.unite && winding.winding === 2
							&& winding.windingL && winding.windingR)));
		}

		function isStart(seg) {
			if (seg) {
				for (var i = 0, l = starts.length; i < l; i++) {
					if (seg === starts[i])
						return true;
				}
			}
			return false;
		}

		function visitPath(path) {
			var segments = path._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				segments[i]._visited = true;
			}
		}

		function getCrossingSegments(segment, collectStarts) {
			var inter = segment._intersection,
				start = inter,
				crossings = [];
			if (collectStarts)
				starts = [segment];

			function collect(inter, end) {
				while (inter && inter !== end) {
					var other = inter._segment,
						path = other && other._path;
					if (path) {
						var next = other.getNext() || path.getFirstSegment(),
							nextInter = next._intersection;
						if (other !== segment && (isStart(other)
							|| isStart(next)
							|| next && (isValid(other) && (isValid(next)
								|| nextInter && isValid(nextInter._segment))))
						) {
							crossings.push(other);
						}
						if (collectStarts)
							starts.push(other);
					}
					inter = inter._next;
				}
			}

			if (inter) {
				collect(inter);
				while (inter && inter._previous)
					inter = inter._previous;
				collect(inter, start);
			}
			return crossings;
		}

		segments.sort(function(seg1, seg2) {
			var inter1 = seg1._intersection,
				inter2 = seg2._intersection,
				over1 = !!(inter1 && inter1._overlap),
				over2 = !!(inter2 && inter2._overlap),
				path1 = seg1._path,
				path2 = seg2._path;
			return over1 ^ over2
					? over1 ? 1 : -1
					: !inter1 ^ !inter2
						? inter1 ? 1 : -1
						: path1 !== path2
							? path1._id - path2._id
							: seg1._index - seg2._index;
		});

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				valid = isValid(seg),
				path = null,
				finished = false,
				closed = true,
				branches = [],
				branch,
				visited,
				handleIn;
			if (valid && seg._path._overlapsOnly) {
				var path1 = seg._path,
					path2 = seg._intersection._segment._path;
				if (path1.compare(path2)) {
					if (path1.getArea())
						paths.push(path1.clone(false));
					visitPath(path1);
					visitPath(path2);
					valid = false;
				}
			}
			while (valid) {
				var first = !path,
					crossings = getCrossingSegments(seg, first),
					other = crossings.shift(),
					finished = !first && (isStart(seg) || isStart(other)),
					cross = !finished && other;
				if (first) {
					path = new Path(Item.NO_INSERT);
					branch = null;
				}
				if (finished) {
					if (seg.isFirst() || seg.isLast())
						closed = seg._path._closed;
					seg._visited = true;
					break;
				}
				if (cross && branch) {
					branches.push(branch);
					branch = null;
				}
				if (!branch) {
					if (cross)
						crossings.push(seg);
					branch = {
						start: path._segments.length,
						crossings: crossings,
						visited: visited = [],
						handleIn: handleIn
					};
				}
				if (cross)
					seg = other;
				if (!isValid(seg)) {
					path.removeSegments(branch.start);
					for (var j = 0, k = visited.length; j < k; j++) {
						visited[j]._visited = false;
					}
					visited.length = 0;
					do {
						seg = branch && branch.crossings.shift();
						if (!seg || !seg._path) {
							seg = null;
							branch = branches.pop();
							if (branch) {
								visited = branch.visited;
								handleIn = branch.handleIn;
							}
						}
					} while (branch && !isValid(seg));
					if (!seg)
						break;
				}
				var next = seg.getNext();
				path.add(new Segment(seg._point, handleIn,
						next && seg._handleOut));
				seg._visited = true;
				visited.push(seg);
				seg = next || seg._path.getFirstSegment();
				handleIn = next && next._handleIn;
			}
			if (finished) {
				if (closed) {
					path.getFirstSegment().setHandleIn(handleIn);
					path.setClosed(closed);
				}
				if (path.getArea() !== 0) {
					paths.push(path);
				}
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, dir, closed) {
			return getWinding(point, this.getCurves(), dir, closed);
		},

		unite: function(path, options) {
			return traceBoolean(this, path, 'unite', options);
		},

		intersect: function(path, options) {
			return traceBoolean(this, path, 'intersect', options);
		},

		subtract: function(path, options) {
			return traceBoolean(this, path, 'subtract', options);
		},

		exclude: function(path, options) {
			return traceBoolean(this, path, 'exclude', options);
		},

		divide: function(path, options) {
			return options && (options.trace == false || options.stroke)
					? splitBoolean(this, path, 'divide')
					: createResult([
						this.subtract(path, options),
						this.intersect(path, options)
					], true, this, path, options);
		},

		resolveCrossings: function() {
			var children = this._children,
				paths = children || [this];

			function hasOverlap(seg, path) {
				var inter = seg && seg._intersection;
				return inter && inter._overlap && inter._path === path;
			}

			var hasOverlaps = false,
				hasCrossings = false,
				intersections = this.getIntersections(null, function(inter) {
					return inter.hasOverlap() && (hasOverlaps = true) ||
							inter.isCrossing() && (hasCrossings = true);
				}),
				clearCurves = hasOverlaps && hasCrossings && [];
			intersections = CurveLocation.expand(intersections);
			if (hasOverlaps) {
				var overlaps = divideLocations(intersections, function(inter) {
					return inter.hasOverlap();
				}, clearCurves);
				for (var i = overlaps.length - 1; i >= 0; i--) {
					var overlap = overlaps[i],
						path = overlap._path,
						seg = overlap._segment,
						prev = seg.getPrevious(),
						next = seg.getNext();
					if (hasOverlap(prev, path) && hasOverlap(next, path)) {
						seg.remove();
						prev._handleOut._set(0, 0);
						next._handleIn._set(0, 0);
						if (prev !== seg && !prev.getCurve().hasLength()) {
							next._handleIn.set(prev._handleIn);
							prev.remove();
						}
					}
				}
			}
			if (hasCrossings) {
				divideLocations(intersections, hasOverlaps && function(inter) {
					var curve1 = inter.getCurve(),
						seg1 = inter.getSegment(),
						other = inter._intersection,
						curve2 = other._curve,
						seg2 = other._segment;
					if (curve1 && curve2 && curve1._path && curve2._path)
						return true;
					if (seg1)
						seg1._intersection = null;
					if (seg2)
						seg2._intersection = null;
				}, clearCurves);
				if (clearCurves)
					clearCurveHandles(clearCurves);
				paths = tracePaths(Base.each(paths, function(path) {
					Base.push(this, path._segments);
				}, []));
			}
			var length = paths.length,
				item;
			if (length > 1 && children) {
				if (paths !== children)
					this.setChildren(paths);
				item = this;
			} else if (length === 1 && !children) {
				if (paths[0] !== this)
					this.setSegments(paths[0].removeSegments());
				item = this;
			}
			if (!item) {
				item = new CompoundPath(Item.NO_INSERT);
				item.addChildren(paths);
				item = item.reduce();
				item.copyAttributes(this);
				this.replaceWith(item);
			}
			return item;
		},

		reorient: function(nonZero, clockwise) {
			var children = this._children;
			if (children && children.length) {
				this.setChildren(reorientPaths(this.removeChildren(),
						function(w) {
							return !!(nonZero ? w : w & 1);
						},
						clockwise));
			} else if (clockwise !== undefined) {
				this.setClockwise(clockwise);
			}
			return this;
		},

		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this.getCurves(),
					y = point.y,
					intercepts = [],
					roots = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var v = curves[i].getValues(),
						o0 = v[1],
						o1 = v[3],
						o2 = v[5],
						o3 = v[7];
					if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
						var monoCurves = Curve.getMonoCurves(v);
						for (var j = 0, m = monoCurves.length; j < m; j++) {
							var mv = monoCurves[j],
								mo0 = mv[1],
								mo3 = mv[7];
							if ((mo0 !== mo3) &&
								(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
								var x = y === mo0 ? mv[0]
									: y === mo3 ? mv[6]
									: Curve.solveCubic(mv, 1, y, roots, 0, 1)
										=== 1
										? Curve.getPoint(mv, roots[0]).x
										: (mv[0] + mv[6]) / 2;
								intercepts.push(x);
							}
						}
					}
				}
				if (intercepts.length > 1) {
					intercepts.sort(function(a, b) { return a - b; });
					point.x = (intercepts[0] + intercepts[1]) / 2;
				}
			}
			return point;
		}
	};
});

var PathFlattener = Base.extend({
	_class: 'PathFlattener',

	initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minSpan = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, t1, t2) {
			if ((t2 - t1) > minSpan
					&& !(ignoreStraight && Curve.isStraight(curve))
					&& !Curve.isFlatEnough(curve, flatness || 0.25)) {
				var halves = Curve.subdivide(curve, 0.5),
					tMid = (t1 + t2) / 2;
				computeParts(halves[0], index, t1, tMid);
				computeParts(halves[1], index, tMid, t2);
			} else {
				var dx = curve[6] - curve[0],
					dy = curve[7] - curve[1],
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist > 0) {
					length += dist;
					parts.push({
						offset: length,
						curve: curve,
						index: index,
						time: t2,
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2 || segment1, segments[0]);
		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	_get: function(offset) {
		var parts = this.parts,
			length = parts.length,
			start,
			i, j = this.index;
		for (;;) {
			i = j;
			if (!j || parts[--j].offset < offset)
				break;
		}
		for (; i < length; i++) {
			var part = parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = parts[i - 1],
					prevTime = prev && prev.index === part.index ? prev.time : 0,
					prevOffset = prev ? prev.offset : 0;
				return {
					index: part.index,
					time: prevTime + (part.time - prevTime)
						* (offset - prevOffset) / (part.offset - prevOffset)
				};
			}
		}
		return {
			index: parts[length - 1].index,
			time: 1
		};
	},

	drawPart: function(ctx, from, to) {
		var start = this._get(from),
			end = this._get(to);
		for (var i = start.index, l = end.index; i <= l; i++) {
			var curve = Curve.getPart(this.curves[i],
					i === start.index ? start.time : 0,
					i === end.index ? end.time : 1);
			if (i === start.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var param = this._get(offset);
			return Curve[name](this.curves[param.index], param.time);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path) {
		var points = this.points = [],
			segments = path._segments,
			closed = path._closed;
		for (var i = 0, prev, l = segments.length; i < l; i++) {
			var point = segments[i].point;
			if (!prev || !prev.equals(point)) {
				points.push(prev = point.clone());
			}
		}
		if (closed) {
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}
		this.closed = closed;
	},

	fit: function(error) {
		var points = this.points,
			length = points.length,
			segments = null;
		if (length > 0) {
			segments = [new Segment(points[0])];
			if (length > 1) {
				this.fitCubic(segments, error, 0, length - 1,
						points[1].subtract(points[0]),
						points[length - 2].subtract(points[length - 1]));
				if (this.closed) {
					segments.shift();
					segments.pop();
				}
			}
		}
		return segments;
	},

	fitCubic: function(segments, error, first, last, tan1, tan2) {
		var points = this.points;
		if (last - first === 1) {
			var pt1 = points[first],
				pt2 = points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(error, error * error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < error && parametersInOrder) {
				this.addCurve(segments, curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var tanCenter = points[split - 1].subtract(points[split + 1]);
		this.fitCubic(segments, error, first, split, tan1, tanCenter);
		this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(segments, curve) {
		var prev = segments[segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			abs = Math.abs,
			points = this.points,
			pt1 = points[first],
			pt2 = points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1,
			alpha2;
		if (abs(detC0C1) > epsilon) {
			var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
							: abs(c1) > epsilon ? X[1] / c1
							: 0;
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1,
				pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)),
				pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsOptions: { stroke: false, handle: false },

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	copyContent: function(source) {
		this.setContent(source._content);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(521);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx, param, viewMatrix) {
		if (!this._content)
			return;
		this._setStyles(ctx, param, viewMatrix);
		var lines = this._lines,
			style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (hasFill) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(matrix, options) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var rect = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(rect, rect) : rect;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		namedColors = {
			transparent: [0, 0, 0, 0]
		},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(
				/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
			) || string.match(
				/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
			),
			type = 'rgb',
			components;
		if (match) {
			var amount = match[4] ? 4 : 3;
			components = new Array(amount);
			for (var i = 0; i < amount; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
			type = match[1];
			components = match[2].trim().split(/[,\s]+/g);
			var isHSL = type === 'hsl';
			for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
				var component = components[i];
				var value = parseFloat(component);
				if (isHSL) {
					if (i === 0) {
						var unit = component.match(/([a-z]*)$/)[1];
						value *= ({
							turn: 360,
							rad: 180 / Math.PI,
							grad: 0.9
						}[unit] || 1);
					} else if (i < 3) {
						value /= 100;
					}
				} else if (i < 3) {
					value /= /%$/.test(component) ? 100 : 255;
				}
				components[i] = value;
			}
		} else {
			var color = namedColors[string];
			if (!color) {
				if (window) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					color = namedColors[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				} else {
					color = [0, 0, 0];
				}
			}
			components = color.slice();
		}
		return [type, components];
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = type === 'gradient'
					? name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(
								Array.isArray(value)
									? value
									: arguments, 0, { readNull: true }
							);
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
					: function(value) {
						return value == null || isNaN(value) ? 0 : +value;
					};
			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var args = arguments,
				reading = this.__read,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (reading)
						read = 1;
					args = Base.slice(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (reading) {
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					}
					if (values.length > length)
						values = Base.slice(values, 0, length);
				} else if (argType === 'string') {
					var converted = fromCSS(arg);
					type = converted[0];
					components = converted[1];
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && !i && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (reading && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (reading)
				this.__read = read;
			return this;
		},

		set: '#initialize',

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner) {
				if (this._setter) {
					this._owner[this._setter](this);
				} else {
					this._owner._changed(129);
				}
			}
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this.getAlpha() === col.getAlpha()
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx, matrix) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				highlight = components[3],
				inverse = matrix && matrix.inverted(),
				canvasGradient;
			if (inverse) {
				origin = inverse._transformPoint(origin);
				destination = inverse._transformPoint(destination);
				if (highlight)
					highlight = inverse._transformPoint(highlight);
			}
			if (gradient._radial) {
				var radius = destination.getDistance(origin);
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					offset = stop._offset;
				canvasGradient.addColorStop(
						offset == null ? i / (l - 1) : offset,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			},

			_setOwner: function(color, owner, setter) {
				if (color) {
					if (color._owner && owner && color._owner !== owner) {
						color = color.clone();
					}
					if (!color._owner ^ !owner) {
						color._owner = owner || null;
						color._setter = setter || null;
					}
				}
				return color;
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && Base.isPlainObject(stops)) {
			this.set(stops);
			stops = radial = null;
		}
		if (this._stops == null) {
			this.setStops(stops || ['white', 'black']);
		}
		if (this._radial == null) {
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
		}
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
			this._owners[i]._changed();
		}
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (!this._owners.length)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++) {
			stops[i] = this._stops[i].clone();
		}
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (stops.length < 2) {
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		}
		var _stops = this._stops;
		if (_stops) {
			for (var i = 0, l = _stops.length; i < l; i++)
				_stops[i]._owner = undefined;
		}
		_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
		for (var i = 0, l = _stops.length; i < l; i++)
			_stops[i]._owner = this;
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class) {
			var stops1 = this._stops,
				stops2 = gradient._stops,
				length = stops1.length;
			if (length === stops2.length) {
				for (var i = 0; i < length; i++) {
					if (!stops1[i].equals(stops2[i]))
						return false;
				}
				return true;
			}
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		var color = arg0,
			offset = arg1;
		if (typeof arg0 === 'object' && arg1 === undefined) {
			if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
				color = arg0[0];
				offset = arg0[1];
			} else if ('color' in arg0 || 'offset' in arg0
					|| 'rampPoint' in arg0) {
				color = arg0.color;
				offset = arg0.offset || arg0.rampPoint || 0;
			}
		}
		this.setColor(color);
		this.setOffset(offset);
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._offset);
	},

	_serialize: function(options, dictionary) {
		var color = this._color,
			offset = this._offset;
		return Base.serialize(offset == null ? [color] : [color, offset],
				options, true, dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(129);
	},

	getOffset: function() {
		return this._offset;
	},

	setOffset: function(offset) {
		this._offset = offset;
		this._changed();
	},

	getRampPoint: '#getOffset',
	setRampPoint: '#setOffset',

	getColor: function() {
		return this._color;
	},

	setColor: function() {
		Color._setOwner(this._color, null);
		this._color = Color._setOwner(Color.read(arguments, 0), this,
				'setColor');
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._offset == stop._offset
				|| false;
	}
});

var Style = Base.extend(new function() {
	var itemDefaults = {
		fillColor: null,
		fillRule: 'nonzero',
		strokeColor: null,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		shadowColor: null,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: null
	},
	groupDefaults = Base.set({}, itemDefaults, {
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		leading: null,
		justification: 'left'
	}),
	textDefaults = Base.set({}, groupDefaults, {
		fillColor: new Color()
	}),
	flags = {
		strokeWidth: 193,
		strokeCap: 193,
		strokeJoin: 193,
		strokeScaling: 201,
		miterLimit: 193,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	},
	item = {
		beans: true
	},
	fields = {
		_class: 'Style',
		beans: true,

		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project
					|| paper.project;
			this._defaults = !_owner || _owner instanceof Group ? groupDefaults
					: _owner instanceof TextItem ? textDefaults
					: itemDefaults;
			if (style)
				this.set(style);
		}
	};

	Base.each(groupDefaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath);
			if (applyToChildren) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			}
			if ((key === 'selectedColor' || !applyToChildren)
					&& key in this._defaults) {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old) {
							Color._setOwner(old, null);
							old._canvasStyle = null;
						}
						if (value && value.constructor === Color) {
							value = Color._setOwner(value, owner,
									applyToChildren && set);
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 129);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath),
				value;
			if (applyToChildren && !_dontMerge) {
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (!i) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
			} else if (key in this._defaults) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone) {
						value = value.clone();
					}
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
					}
				}
			}
			if (value && isColor) {
				value = Color._setOwner(value, owner, applyToChildren && set);
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Base.each({
		Font: 'FontFamily',
		WindingRule: 'FillRule'
	}, function(value, key) {
		var get = 'get' + key,
			set = 'set' + key;
		fields[get] = item[get] = '#get' + value;
		fields[set] = item[set] = '#set' + value;
	});

	Item.inject(item);
	return fields;
}, {
	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		function compare(style1, style2, secondary) {
			var values1 = style1._values,
				values2 = style2._values,
				defaults2 = style2._defaults;
			for (var key in values1) {
				var value1 = values1[key],
					value2 = values2[key];
				if (!(secondary && key in values2) && !Base.equals(value1,
						value2 === undefined ? defaults2[key] : value2))
					return false;
			}
			return true;
		}

		return style === this || style && this._class === style._class
				&& compare(this, style)
				&& compare(style, this, true)
				|| false;
	},

	_dispose: function() {
		var color;
		color = this.getFillColor();
		if (color) color._canvasStyle = null;
		color = this.getStrokeColor();
		if (color) color._canvasStyle = null;
		color = this.getShadowColor();
		if (color) color._canvasStyle = null;
	},

	hasFill: function() {
		var color = this.getFillColor();
		return !!color && color.alpha > 0;
	},

	hasStroke: function() {
		var color = this.getStrokeColor();
		return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		var color = this.getShadowColor();
		return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
				|| !this.getShadowOffset().isZero());
	},

	getView: function() {
		return this._project._view;
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		isInserted: function(el) {
			return document.body.contains(el);
		},

		getPrefixed: function(el, name) {
			return el && handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++) {
					var name = parts[i];
					var options = (
						el === document
						&& (name === 'touchstart' || name === 'touchmove')
					) ? { passive: false } : false;
					el.addEventListener(name, func, options);
				}
			}
		}
	},

	remove: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		timer;

	function handleCallbacks() {
		var functions = callbacks;
		callbacks = [];
		for (var i = 0, l = functions.length; i < l; i++)
			functions[i]();
		requested = nativeRequest && callbacks.length;
		if (requested)
			nativeRequest(handleCallbacks);
	}

	return function(callback) {
		callbacks.push(callback);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		}

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		}

		var size;
		if (window && element) {
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'paper-view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userDrag: none,
				userSelect: none,
				touchCallout: none,
				contentZooming: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}

			size = getCanvasSize();

			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
		} else {
			size = new Size(element);
			element = null;
		}
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		if (!this._pixelRatio)
			this._pixelRatio = window && window.devicePixelRatio || 1;
		this._setElementSize(size.width, size.height);
		this._viewSize = size;
		View._views.push(this);
		View._viewsById[this._id] = this;
		(this._matrix = new Matrix())._owner = this;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
		this._itemEvents = { native: {}, virtual: {} };
		this._autoUpdate = !paper.agent.node;
		this._needsUpdate = false;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		var project = this._project;
		if (project._view === this)
			project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(
		Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
		function(name) {
			this[name] = {};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	getAutoUpdate: function() {
		return this._autoUpdate;
	},

	setAutoUpdate: function(autoUpdate) {
		this._autoUpdate = autoUpdate;
		if (autoUpdate)
			this.requestUpdate();
	},

	update: function() {
	},

	draw: function() {
		this.update();
	},

	requestUpdate: function() {
		if (!this._requested) {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (that._animate) {
					that.requestUpdate();
					var element = that._element;
					if ((!DomElement.getPrefixed(document, 'hidden')
							|| PaperScope.getAttribute(element, 'keepalive')
								=== 'true') && DomElement.isInView(element)) {
						that._handleFrame();
					}
				}
				if (that._autoUpdate)
					that.update();
			});
			this._requested = true;
		}
	},

	play: function() {
		this._animate = true;
		this.requestUpdate();
	},

	pause: function() {
		this._animate = false;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._last ? now - this._last : 0;
		this._last = now;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_changed: function() {
		this._project._changed(4097);
		this._bounds = this._decomposed = undefined;
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._setElementSize(size.width, size.height);
		this._viewSize.set(size);
		this._changed();
		this.emit('resize', { size: size, delta: delta });
		if (this._autoUpdate) {
			this.update();
		}
	},

	_setElementSize: function(width, height) {
		var element = this._element;
		if (element) {
			if (element.width !== width)
				element.width = width;
			if (element.height !== height)
				element.height = height;
		}
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	isInserted: function() {
		return DomElement.isInserted(this._element);
	},

	getPixelSize: function(size) {
		var element = this._element,
			pixels;
		if (element) {
			var parent = element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			pixels = parseFloat(pixels);
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		return 0;
	}
}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getCenter(true)));
	};
}, {
	_decompose: function() {
		return this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.translate(this.getCenter().subtract(center));
	},

	getZoom: function() {
		var scaling = this._decompose().scaling;
		return (scaling.x + scaling.y) / 2;
	},

	setZoom: function(zoom) {
		this.transform(new Matrix().scale(zoom / this.getZoom(),
			this.getCenter()));
	},

	getRotation: function() {
		return this._decompose().rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			this.rotate(rotation - current);
		}
	},

	getScaling: function() {
		var scaling = this._decompose().scaling;
		return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling) {
			this.scale(scaling.x / current.x, scaling.y / current.y);
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.set.apply(matrix, arguments);
	},

	transform: function(matrix) {
		this._matrix.append(matrix);
	},

	scrollBy: function() {
		this.translate(Point.read(arguments).negate());
	}
}), {

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	getEventPoint: function(event) {
		return this.viewToProject(DomEvent.getOffset(event, this._element));
	},

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (document && typeof element === 'string')
				element = document.getElementById(element);
			var ctor = window ? CanvasView : View;
			return new ctor(project, element);
		}
	}
},
new function() {
	if (!window)
		return;
	var prevFocus,
		tempFocus,
		dragging = false,
		mouseDown = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[
				target.getAttribute('id')];
	}

	function updateFocus() {
		var view = View._focused;
		if (!view || !view.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				if ((view = View._views[i]).isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, event, point) {
		view._handleMouseEvent('mousemove', event, point);
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {},
		docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML')) {
					var offset = DomEvent.getOffset(event, view._element),
						x = offset.x,
						abs = Math.abs,
						ax = abs(x),
						max = 1 << 25,
						diff = ax - max;
					offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
					handleMouseMove(view, event, view.viewToProject(offset));
				}
			},

			scroll: updateFocus
		};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event);
		if (!dragging) {
			dragging = true;
			view._handleMouseEvent('mousedown', event);
		}
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!mouseDown) {
			var target = getView(event);
			if (target) {
				if (view !== target) {
					if (view)
						handleMouseMove(view, event);
					if (!prevFocus)
						prevFocus = view;
					view = View._focused = tempFocus = target;
				}
			} else if (tempFocus && tempFocus === view) {
				if (prevFocus && !prevFocus.isInserted())
					prevFocus = null;
				view = View._focused = prevFocus;
				prevFocus = null;
				updateFocus();
			}
		}
		if (view)
			handleMouseMove(view, event);
	};

	docEvents[mousedown] = function() {
		mouseDown = true;
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (view && dragging)
			view._handleMouseEvent('mouseup', event);
		mouseDown = dragging = false;
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var called = false,
		prevented = false,
		fallbacks = {
			doubleclick: 'click',
			mousedrag: 'mousemove'
		},
		wasInView = false,
		overView,
		downPoint,
		lastPoint,
		downItem,
		overItem,
		dragItem,
		clickItem,
		clickTime,
		dblClick;

	function emitMouseEvent(obj, target, type, event, point, prevPoint,
			stopItem) {
		var stopped = false,
			mouseEvent;

		function emit(obj, type) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point,
							target || obj,
							prevPoint ? point.subtract(prevPoint) : null);
				}
				if (obj.emit(type, mouseEvent)) {
					called = true;
					if (mouseEvent.prevented)
						prevented = true;
					if (mouseEvent.stopped)
						return stopped = true;
				}
			} else {
				var fallback = fallbacks[type];
				if (fallback)
					return emit(obj, fallback);
			}
		}

		while (obj && obj !== stopItem) {
			if (emit(obj, type))
				break;
			obj = obj._parent;
		}
		return stopped;
	}

	function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
		view._project.removeOn(type);
		prevented = called = false;
		return (dragItem && emitMouseEvent(dragItem, null, type, event,
					point, prevPoint)
			|| hitItem && hitItem !== dragItem
				&& !hitItem.isDescendant(dragItem)
				&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?
					'mousemove' : type, event, point, prevPoint, dragItem)
			|| emitMouseEvent(view, dragItem || hitItem || view, type, event,
					point, prevPoint));
	}

	var itemEventsMap = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleMouseEvent: function(type, event, point) {
			var itemEvents = this._itemEvents,
				hitItems = itemEvents.native[type],
				nativeMove = type === 'mousemove',
				tool = this._scope.tool,
				view = this;

			function responds(type) {
				return itemEvents.virtual[type] || view.responds(type)
						|| tool && tool.responds(type);
			}

			if (nativeMove && dragging && responds('mousedrag'))
				type = 'mousedrag';
			if (!point)
				point = this.getEventPoint(event);

			var inView = this.getBounds().contains(point),
				hit = hitItems && inView && view._project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				hitItem = hit && hit.item || null,
				handle = false,
				mouse = {};
			mouse[type.substr(5)] = true;

			if (hitItems && hitItem !== overItem) {
				if (overItem) {
					emitMouseEvent(overItem, null, 'mouseleave', event, point);
				}
				if (hitItem) {
					emitMouseEvent(hitItem, null, 'mouseenter', event, point);
				}
				overItem = hitItem;
			}
			if (wasInView ^ inView) {
				emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
						event, point);
				overView = inView ? this : null;
				handle = true;
			}
			if ((inView || mouse.drag) && !point.equals(lastPoint)) {
				emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
						event, point, lastPoint);
				handle = true;
			}
			wasInView = inView;
			if (mouse.down && inView || mouse.up && downPoint) {
				emitMouseEvents(this, hitItem, type, event, point, downPoint);
				if (mouse.down) {
					dblClick = hitItem === clickItem
						&& (Date.now() - clickTime < 300);
					downItem = clickItem = hitItem;
					if (!prevented && hitItem) {
						var item = hitItem;
						while (item && !item.responds('mousedrag'))
							item = item._parent;
						if (item)
							dragItem = hitItem;
					}
					downPoint = point;
				} else if (mouse.up) {
					if (!prevented && hitItem === downItem) {
						clickTime = Date.now();
						emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
								: 'click', event, point, downPoint);
						dblClick = false;
					}
					downItem = dragItem = null;
				}
				wasInView = false;
				handle = true;
			}
			lastPoint = point;
			if (handle && tool) {
				called = tool._handleMouseEvent(type, event, point, mouse)
					|| called;
			}

			if (
				event.cancelable !== false
				&& (called && !mouse.move || mouse.down && responds('mouseup'))
			) {
				event.preventDefault();
			}
		},

		_handleKeyEvent: function(type, event, key, character) {
			var scope = this._scope,
				tool = scope.tool,
				keyEvent;

			function emit(obj) {
				if (obj.responds(type)) {
					paper = scope;
					obj.emit(type, keyEvent = keyEvent
							|| new KeyEvent(type, event, key, character));
				}
			}

			if (this.isVisible()) {
				emit(this);
				if (tool && tool.responds(type))
					emit(tool);
			}
		},

		_countItemEvent: function(type, sign) {
			var itemEvents = this._itemEvents,
				native = itemEvents.native,
				virtual = itemEvents.virtual;
			for (var key in itemEventsMap) {
				native[key] = (native[key] || 0)
						+ (itemEventsMap[key][type] || 0) * sign;
			}
			virtual[type] = (virtual[type] || 0) + sign;
		},

		statics: {
			updateFocus: updateFocus,

			_resetState: function() {
				dragging = mouseDown = called = wasInView = false;
				prevFocus = tempFocus = overView = downPoint = lastPoint =
					downItem = overItem = dragItem = clickItem = clickTime =
					dblClick = null;
			}
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof window.HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ Base.slice(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		var ctx = this._context = canvas.getContext('2d');
		ctx.save();
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(ctx,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
		this._needsUpdate = true;
	},

	remove: function remove() {
		this._context.restore();
		return remove.base.call(this);
	},

	_setElementSize: function _setElementSize(width, height) {
		var pixelRatio = this._pixelRatio;
		_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
		if (pixelRatio !== 1) {
			var element = this._element,
				ctx = this._context;
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			ctx.restore();
			ctx.save();
			ctx.scale(pixelRatio, pixelRatio);
		}
	},

	getContext: function() {
		return this._context;
	},

	getPixelSize: function getPixelSize(size) {
		var agent = paper.agent,
			pixels;
		if (agent && agent.firefox) {
			pixels = getPixelSize.base.call(this, size);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		if (!this._needsUpdate)
			return false;
		var project = this._project,
			ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		if (project)
			project.draw(ctx, this._matrix, this._pixelRatio);
		this._needsUpdate = false;
		return true;
	}
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
		this.type = event && event.type;
	},

	prevented: false,
	stopped: false,

	preventDefault: function() {
		this.prevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.stopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getTimeStamp: function() {
		return this.event.timeStamp;
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(type, event, key, character) {
		this.type = type;
		this.event = event;
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	var keyLookup = {
			'\t': 'tab',
			' ': 'space',
			'\b': 'backspace',
			'\x7f': 'delete',
			'Spacebar': 'space',
			'Del': 'delete',
			'Win': 'meta',
			'Esc': 'escape'
		},

		charLookup = {
			'tab': '\t',
			'space': ' ',
			'enter': '\r'
		},

		keyMap = {},
		charMap = {},
		metaFixMap,
		downKey,

		modifiers = new Base({
			shift: false,
			control: false,
			alt: false,
			meta: false,
			capsLock: false,
			space: false
		}).inject({
			option: {
				get: function() {
					return this.alt;
				}
			},

			command: {
				get: function() {
					var agent = paper && paper.agent;
					return agent && agent.mac ? this.meta : this.control;
				}
			}
		});

	function getKey(event) {
		var key = event.key || event.keyIdentifier;
		key = /^U\+/.test(key)
				? String.fromCharCode(parseInt(key.substr(2), 16))
				: /^Arrow[A-Z]/.test(key) ? key.substr(5)
				: key === 'Unidentified'  || key === undefined
					? String.fromCharCode(event.keyCode)
					: key;
		return keyLookup[key] ||
				(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
	}

	function handleKey(down, key, character, event) {
		var type = down ? 'keydown' : 'keyup',
			view = View._focused,
			name;
		keyMap[key] = down;
		if (down) {
			charMap[key] = character;
		} else {
			delete charMap[key];
		}
		if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
			modifiers[name] = down;
			var agent = paper && paper.agent;
			if (name === 'meta' && agent && agent.mac) {
				if (down) {
					metaFixMap = {};
				} else {
					for (var k in metaFixMap) {
						if (k in charMap)
							handleKey(false, k, metaFixMap[k], event);
					}
					metaFixMap = null;
				}
			}
		} else if (down && metaFixMap) {
			metaFixMap[key] = character;
		}
		if (view) {
			view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
					character);
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var key = getKey(event),
				agent = paper && paper.agent;
			if (key.length > 1 || agent && (agent.chrome && (event.altKey
						|| agent.mac && event.metaKey
						|| !agent.mac && event.ctrlKey))) {
				handleKey(true, key,
						charLookup[key] || (key.length > 1 ? '' : key), event);
			} else {
				downKey = key;
			}
		},

		keypress: function(event) {
			if (downKey) {
				var key = getKey(event),
					code = event.charCode,
					character = code >= 32 ? String.fromCharCode(code)
						: key.length > 1 ? '' : key;
				if (key !== downKey) {
					key = character.toLowerCase();
				}
				handleKey(true, key, character, event);
				downKey = null;
			}
		},

		keyup: function(event) {
			var key = getKey(event);
			if (key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		this.type = type;
		this.event = event;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return this.tool[/^mouse(down|up)$/.test(this.type)
				? '_downCount' : '_moveCount'];
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
			'onKeyUp'],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._moveCount = -1;
		this._downCount = -1;
		this.set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_handleMouseEvent: function(type, event, point, mouse) {
		paper = this._scope;
		if (mouse.drag && !this.responds(type))
			type = 'mousemove';
		var move = mouse.move || mouse.drag,
			responds = this.responds(type),
			minDistance = this.minDistance,
			maxDistance = this.maxDistance,
			called = false,
			tool = this;
		function update(minDistance, maxDistance) {
			var pt = point,
				toolPoint = move ? tool._point : (tool._downPoint || pt);
			if (move) {
				if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
					return false;
				}
				if (toolPoint && (minDistance != null || maxDistance != null)) {
					var vector = pt.subtract(toolPoint),
						distance = vector.getLength();
					if (distance < (minDistance || 0))
						return false;
					if (maxDistance) {
						pt = toolPoint.add(vector.normalize(
								Math.min(distance, maxDistance)));
					}
				}
				tool._moveCount++;
			}
			tool._point = pt;
			tool._lastPoint = toolPoint || pt;
			if (mouse.down) {
				tool._moveCount = -1;
				tool._downPoint = pt;
				tool._downCount++;
			}
			return true;
		}

		function emit() {
			if (responds) {
				called = tool.emit(type, new ToolEvent(tool, type, event))
						|| called;
			}
		}

		if (mouse.down) {
			update();
			emit();
		} else if (mouse.up) {
			update(null, maxDistance);
			emit();
		} else if (responds) {
			while (update(minDistance, maxDistance))
				emit();
		}
		return called;
	}

});

var Tween = Base.extend(Emitter, {
	_class: 'Tween',

	statics: {
		easings: new Base({
			linear: function(t) {
				return t;
			},

			easeInQuad: function(t) {
				return t * t;
			},

			easeOutQuad: function(t) {
				return t * (2 - t);
			},

			easeInOutQuad: function(t) {
				return t < 0.5
					? 2 * t * t
					: -1 + 2 * (2 - t) * t;
			},

			easeInCubic: function(t) {
				return t * t * t;
			},

			easeOutCubic: function(t) {
				return --t * t * t + 1;
			},

			easeInOutCubic: function(t) {
				return t < 0.5
					? 4 * t * t * t
					: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
			},

			easeInQuart: function(t) {
				return t * t * t * t;
			},

			easeOutQuart: function(t) {
				return 1 - (--t) * t * t * t;
			},

			easeInOutQuart: function(t) {
				return t < 0.5
					? 8 * t * t * t * t
					: 1 - 8 * (--t) * t * t * t;
			},

			easeInQuint: function(t) {
				return t * t * t * t * t;
			},

			easeOutQuint: function(t) {
				return 1 + --t * t * t * t * t;
			},

			easeInOutQuint: function(t) {
				return t < 0.5
					? 16 * t * t * t * t * t
					: 1 + 16 * (--t) * t * t * t * t;
			}
		})
	},

	initialize: function Tween(object, from, to, duration, easing, start) {
		this.object = object;
		var type = typeof easing;
		var isFunction = type === 'function';
		this.type = isFunction
			? type
			: type === 'string'
				? easing
				: 'linear';
		this.easing = isFunction ? easing : Tween.easings[this.type];
		this.duration = duration;
		this.running = false;

		this._then = null;
		this._startTime = null;
		var state = from || to;
		this._keys = state ? Object.keys(state) : [];
		this._parsedKeys = this._parseKeys(this._keys);
		this._from = state && this._getState(from);
		this._to = state && this._getState(to);
		if (start !== false) {
			this.start();
		}
	},

	then: function(then) {
		this._then = then;
		return this;
	},

	start: function() {
		this._startTime = null;
		this.running = true;
		return this;
	},

	stop: function() {
		this.running = false;
		return this;
	},

	update: function(progress) {
		if (this.running) {
			if (progress >= 1) {
				progress = 1;
				this.running = false;
			}

			var factor = this.easing(progress),
				keys = this._keys,
				getValue = function(value) {
					return typeof value === 'function'
						? value(factor, progress)
						: value;
				};
			for (var i = 0, l = keys && keys.length; i < l; i++) {
				var key = keys[i],
					from = getValue(this._from[key]),
					to = getValue(this._to[key]),
					value = (from && to && from.__add && to.__add)
						? to.__subtract(from).__multiply(factor).__add(from)
						: ((to - from) * factor) + from;
				this._setProperty(this._parsedKeys[key], value);
			}

			if (this.responds('update')) {
				this.emit('update', new Base({
					progress: progress,
					factor: factor
				}));
			}
			if (!this.running && this._then) {
				this._then(this.object);
			}
		}
		return this;
	},

	_events: {
		onUpdate: {}
	},

	_handleFrame: function(time) {
		var startTime = this._startTime,
			progress = startTime
				? (time - startTime) / this.duration
				: 0;
		if (!startTime) {
			this._startTime = time;
		}
		this.update(progress);
	},

	_getState: function(state) {
		var keys = this._keys,
			result = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = this._parsedKeys[key],
				current = this._getProperty(path),
				value;
			if (state) {
				var resolved = this._resolveValue(current, state[key]);
				this._setProperty(path, resolved);
				value = this._getProperty(path);
				value = value && value.clone ? value.clone() : value;
				this._setProperty(path, current);
			} else {
				value = current && current.clone ? current.clone() : current;
			}
			result[key] = value;
		}
		return result;
	},

	_resolveValue: function(current, value) {
		if (value) {
			if (Array.isArray(value) && value.length === 2) {
				var operator = value[0];
				return (
					operator &&
					operator.match &&
					operator.match(/^[+\-\*\/]=/)
				)
					? this._calculate(current, operator[0], value[1])
					: value;
			} else if (typeof value === 'string') {
				var match = value.match(/^[+\-*/]=(.*)/);
				if (match) {
					var parsed = JSON.parse(match[1].replace(
						/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
						'"$2": '
					));
					return this._calculate(current, value[0], parsed);
				}
			}
		}
		return value;
	},

	_calculate: function(left, operator, right) {
		return paper.PaperScript.calculateBinary(left, operator, right);
	},

	_parseKeys: function(keys) {
		var parsed = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = key
					.replace(/\.([^.]*)/g, '/$1')
					.replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
			parsed[key] = path.split('/');
		}
		return parsed;
	},

	_getProperty: function(path, offset) {
		var obj = this.object;
		for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
			obj = obj[path[i]];
		}
		return obj;
	},

	_setProperty: function(path, value) {
		var dest = this._getProperty(path, 1);
		if (dest) {
			dest[path[path.length - 1]] = value;
		}
	}
});

var Http = {
	request: function(options) {
		var xhr = new self.XMLHttpRequest();
		xhr.open((options.method || 'get').toUpperCase(), options.url,
				Base.pick(options.async, true));
		if (options.mimeType)
			xhr.overrideMimeType(options.mimeType);
		xhr.onload = function() {
			var status = xhr.status;
			if (status === 0 || status === 200) {
				if (options.onLoad) {
					options.onLoad.call(xhr, xhr.responseText);
				}
			} else {
				xhr.onerror();
			}
		};
		xhr.onerror = function() {
			var status = xhr.status,
				message = 'Could not load "' + options.url + '" (Status: '
						+ status + ')';
			if (options.onError) {
				options.onError(message, status);
			} else {
				throw new Error(message);
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = Base.exports.CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		if (!window)
			return null;
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
			clear = false;
		}
		var ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('Canvas ' + canvas +
					' is unable to provide a 2D context.');
		}
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		var canvas = this.getCanvas(width, height);
		return canvas ? canvas.getContext('2d') : null;
	},

	release: function(obj) {
		var canvas = obj && obj.canvas ? obj.canvas : obj;
		if (canvas && canvas.getContext) {
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	if (ctx) {
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
							? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	}

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SvgElement = new function() {
	var svg = 'http://www.w3.org/2000/svg',
		xmlns = 'http://www.w3.org/2000/xmlns',
		xlink = 'http://www.w3.org/1999/xlink',
		attributeNamespace = {
			href: xlink,
			xlink: xmlns,
			xmlns: xmlns + '/',
			'xmlns:xlink': xmlns + '/'
		};

	function create(tag, attributes, formatter) {
		return set(document.createElementNS(svg, tag), attributes, formatter);
	}

	function get(node, name) {
		var namespace = attributeNamespace[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		return value === 'null' ? null : value;
	}

	function set(node, attributes, formatter) {
		for (var name in attributes) {
			var value = attributes[name],
				namespace = attributeNamespace[name];
			if (typeof value === 'number' && formatter)
				value = formatter.number(value);
			if (namespace) {
				node.setAttributeNS(namespace, name, value);
			} else {
				node.setAttribute(name, value);
			}
		}
		return node;
	}

	return {
		svg: svg,
		xmlns: xmlns,
		xlink: xlink,

		create: create,
		get: get,
		set: set
	};
};

var SvgStyles = Base.each({
	fillColor: ['fill', 'color'],
	fillRule: ['fill-rule', 'string'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'style']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

new function() {
	var formatter;

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			var point;
			if (matrix.isInvertible()) {
				matrix = matrix._shiftless();
				point = matrix._inverseTransform(trans);
				trans = null;
			} else {
				point = new Point();
			}
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling,
					skew = decomposed.skewing;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (skew.x)
					parts.push('skewX(' + formatter.number(skew.x) + ')');
				if (skew.y)
					parts.push('skewY(' + formatter.number(skew.y) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = SvgElement.create('g', attrs, formatter);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = SvgElement.create('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					SvgElement.set(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages == false && image && image.src
				|| item.toDataURL();
		return SvgElement.create('image', attrs, formatter);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			length = segments.length,
			type,
			attrs = getTransform(item._matrix);
		if (matchShapes && length >= 2 && !item.hasHandles()) {
			if (length > 2) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for (var i = 0; i < length; i++) {
					parts.push(formatter.point(segments[i]._point));
				}
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var start = segments[0]._point,
					end = segments[1]._point;
				attrs.set({
					x1: start.x,
					y1: start.y,
					x2: end.x,
					y2: end.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return SvgElement.create('path', attrs, formatter);
	}

	function exportSymbolItem(item, options) {
		var attrs = getTransform(item._matrix, true),
			definition = item._definition,
			node = getDefinition(definition, 'symbol'),
			definitionItem = definition._item,
			bounds = definitionItem.getStrokeBounds();
		if (!node) {
			node = SvgElement.create('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			node.appendChild(exportSVG(definitionItem, options));
			setDefinition(definition, node, 'symbol');
		}
		attrs.href = '#' + node.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = bounds.width;
		attrs.height = bounds.height;
		attrs.overflow = 'visible';
		return SvgElement.create('use', attrs, formatter);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin(),
				destination = color.getDestination(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
					+ 'Gradient', attrs, formatter);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha(),
					offset = stop._offset;
				attrs = {
					offset: offset == null ? i / (l - 1) : offset
				};
				if (stopColor)
					attrs['stop-color'] = stopColor.toCSS(true);
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(
						SvgElement.create('stop', attrs, formatter));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = SvgElement.create('text', getTransform(item._matrix, true),
				formatter);
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		SymbolItem: exportSymbolItem,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent(),
			style = [];

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SvgStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				if (type === 'style') {
					style.push(entry.attribute + ': ' + value);
				} else {
					attrs[entry.attribute] = value == null ? 'none'
							: type === 'color' ? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array' ? value.join(',')
							: type === 'lookup' ? entry.toSVG[value]
							: value;
				}
			}
		});

		if (style.length)
			attrs.style = style.join(';');

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return SvgElement.set(node, attrs, formatter);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-'
				+ (item._id || item.__id || (item.__id = UID.get('svg')))];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + typeId;
		definitions.svgs[type + '-' + (item._id || item.__id)] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = SvgElement.create('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(SvgElement.create('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new self.XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var children = this._children,
				view = this.getView(),
				bounds = Base.pick(options.bounds, 'view'),
				mx = options.matrix || bounds === 'view' && view._matrix,
				matrix = mx && Matrix.read([mx]),
				rect = bounds === 'view'
					? new Rectangle([0, 0], view.getViewSize())
					: bounds === 'content'
						? Item._getBounds(children, matrix, { stroke: true })
							.rect
						: Rectangle.read([bounds], 0, { readNull: true }),
				attrs = {
					version: '1.1',
					xmlns: SvgElement.svg,
					'xmlns:xlink': SvgElement.xlink,
				};
			if (rect) {
				attrs.width = rect.width;
				attrs.height = rect.height;
				if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
					attrs.viewBox = formatter.rectangle(rect);
			}
			var node = SvgElement.create('svg', attrs, formatter),
				parent = node;
			if (matrix && !matrix.isIdentity()) {
				parent = node.appendChild(SvgElement.create('g',
						getTransform(matrix), formatter));
			}
			for (var i = 0, l = children.length; i < l; i++) {
				parent.appendChild(exportSVG(children[i], options, true));
			}
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	var definitions = {},
		rootSize;

	function getValue(node, name, isString, allowNull, allowPercent,
			defaultValue) {
		var value = SvgElement.get(node, name) || defaultValue,
			res = value == null
				? allowNull
					? null
					: isString ? '' : 0
				: isString
					? value
					: parseFloat(value);
		return /%\s*$/.test(value)
			? (res / 100) * (allowPercent ? 1
				: rootSize[/x|^width/.test(name) ? 'width' : 'height'])
			: res;
	}

	function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
		x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
		y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull, allowPercent) {
		w = getValue(node, w || 'width', false, allowNull, allowPercent);
		h = getValue(node, h || 'height', false, allowNull, allowPercent);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none' ? null
				: type === 'number' ? parseFloat(value)
				: type === 'array' ?
					value ? value.split(/[\s,]+/g).map(parseFloat) : []
				: type === 'color' ? getDefinition(value) || value
				: type === 'lookup' ? lookup[value]
				: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			isDefs = type === 'defs',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip && !isDefs) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importNode(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& !/^defs$/i.test(childNode.nodeName)
					&& (child = importNode(childNode, options, false))
					&& !(child instanceof SymbolDefinition))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || isDefs) {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		return PathItem.create(node.getAttribute('d'));
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			radial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
			if (gradient._radial ^ radial) {
				gradient = gradient.clone();
				gradient._radial = radial;
			}
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, radial);
		}
		var origin, destination, highlight,
			scaleToBounds = getValue(node, 'gradientUnits', true) !==
				'userSpaceOnUse';
		if (radial) {
			origin = getPoint(node, 'cx', 'cy', false, scaleToBounds,
				'50%', '50%');
			destination = origin.add(
				getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
			highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
		} else {
			origin = getPoint(node, 'x1', 'y1', false, scaleToBounds,
				'0%', '0%');
			destination = getPoint(node, 'x2', 'y2', false, scaleToBounds,
				'100%', '0%');
		}
		var color = applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
		color._scaleToBounds = scaleToBounds;
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					return importNode(child, options, isRoot);
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node);
				this.setSize(size);
				var center = getPoint(node).add(size.divide(2));
				this._matrix.append(new Matrix().translate(center));
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new SymbolDefinition(
					importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node);
			return definition
					? definition instanceof SymbolDefinition
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(
					getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			return new Shape.Rectangle(new Rectangle(
						getPoint(node),
						getSize(node)
					), getSize(node, 'rx', 'ry'));
			},

		line: function(node) {
			return new Path.Line(
					getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node).add(
					getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		},

		switch: importGroup
	};

	function applyTransform(item, value, name, node) {
		if (item.transform) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.append(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1] || 0, v[2] || 0);
					break;
				case 'translate':
					matrix.translate(v[0], v[1] || 0);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	}

	function applyOpacity(item, value, name) {
		var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
			color = item[key] && item[key]();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SvgStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			if (item[entry.set]) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color') {
					var color = item[entry.get]();
					if (color) {
						if (color._scaleToBounds) {
							var bounds = item.getBounds();
							color.transform(new Matrix()
								.translate(bounds.getPoint())
								.scale(bounds.getSize()));
						}
					}
				}
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			if (item.setVisible)
				item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			if (item.setVisible)
				item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			if (item.setOffset) {
				var percent = value.match(/(.*)%$/);
				item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
			}
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, null, null, true),
				group,
				matrix;
			if (item instanceof Group) {
				var scale = size ? size.divide(rect.getSize()) : 1,
				matrix = new Matrix().scale(scale)
						.translate(rect.getPoint().negate());
				group = item;
			} else if (item instanceof SymbolDefinition) {
				if (size)
					rect.setSize(size);
				group = item._item;
			}
			if (group)  {
				if (getAttribute(node, 'overflow', styles) !== 'visible') {
					var clip = new Shape.Rectangle(rect);
					clip.setClipMask(true);
					group.addChild(clip);
				}
				if (matrix)
					group.transform(matrix);
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value && node.style) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value ? undefined
				: value === 'none' ? null
				: value;
	}

	function applyAttributes(item, node, isRoot) {
		var parent = node.parentNode,
			styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && !/^defs$/i.test(parent.tagName)
						&& DomElement.getStyles(parent) || {}
			};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			item = value !== undefined
					&& apply(item, value, name, node, styles) || item;
		});
		return item;
	}

	function getDefinition(value) {
		var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
			name = match && match[1],
			res = name && definitions[window
					? name.replace(window.location.href.split('#')[0] + '#', '')
					: name];
		if (res && res._scaleToBounds) {
			res = res.clone();
			res._scaleToBounds = true;
		}
		return res;
	}

	function importNode(node, options, isRoot) {
		var type = node.nodeName.toLowerCase(),
			isElement = type !== '#document',
			body = document.body,
			container,
			parent,
			next;
		if (isRoot && isElement) {
			rootSize = paper.getView().getSize();
			rootSize = getSize(node, null, null, true) || rootSize;
			container = SvgElement.create('svg', {
				style: 'stroke-width: 1px; stroke-miterlimit: 10'
			});
			parent = node.parentNode;
			next = node.nextSibling;
			container.appendChild(node);
			body.appendChild(container);
		}
		var settings = paper.settings,
			applyMatrix = settings.applyMatrix,
			insertItems = settings.insertItems;
		settings.applyMatrix = false;
		settings.insertItems = false;
		var importer = importers[type],
			item = importer && importer(node, type, options, isRoot) || null;
		settings.insertItems = insertItems;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (isElement && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport,
				data = isElement && node.getAttribute('data-paper-data');
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (container) {
			body.removeChild(container);
			if (parent) {
				if (next) {
					parent.insertBefore(node, next);
				} else {
					parent.appendChild(node);
				}
			}
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	function importSVG(source, options, owner) {
		if (!source)
			return null;
		options = typeof options === 'function' ? { onLoad: options }
				: options || {};
		var scope = paper,
			item = null;

		function onLoad(svg) {
			try {
				var node = typeof svg === 'object'
					? svg
					: new self.DOMParser().parseFromString(
						svg.trim(),
						'image/svg+xml'
					);
				if (!node.nodeName) {
					node = null;
					throw new Error('Unsupported SVG source: ' + source);
				}
				paper = scope;
				item = importNode(node, options, true);
				if (!options || options.insert !== false) {
					owner._insertItem(undefined, item);
				}
				var onLoad = options.onLoad;
				if (onLoad)
					onLoad(item, svg);
			} catch (e) {
				onError(e);
			}
		}

		function onError(message, status) {
			var onError = options.onError;
			if (onError) {
				onError(message, status);
			} else {
				throw new Error(message);
			}
		}

		if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
			var node = document.getElementById(source);
			if (node) {
				onLoad(node);
			} else {
				Http.request({
					url: source,
					async: true,
					onLoad: onLoad,
					onError: onError
				});
			}
		} else if (typeof File !== 'undefined' && source instanceof File) {
			var reader = new FileReader();
			reader.onload = function() {
				onLoad(reader.result);
			};
			reader.onerror = function() {
				onError(reader.error);
			};
			return reader.readAsText(source);
		} else {
			onLoad(source);
		}

		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return importSVG(node, options, this);
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, this);
		}
	});
};

Base.exports.PaperScript = function() {
	var global = this,
		acorn = global.acorn;
	if (!acorn && typeof require !== 'undefined') {
		try { acorn = require('acorn'); } catch(e) {}
	}
	if (!acorn) {
		var exports, module;
		acorn = exports = module = {};

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports);
  if (typeof define == "function" && define.amd) return define(["exports"], mod);
  mod(root.acorn || (root.acorn = {}));
})(this, function(exports) {
  "use strict";

  exports.version = "0.5.0";

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();
	return parseTopLevel(options.program);
  };

  var defaultOptions = exports.defaultOptions = {
	ecmaVersion: 5,
	strictSemicolons: false,
	allowTrailingCommas: true,
	forbidReserved: false,
	allowReturnOutsideFunction: false,
	locations: false,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null
  };

  function setOptions(opts) {
	options = opts || {};
	for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
	  options[opt] = defaultOptions[opt];
	sourceFile = options.sourceFile || null;
  }

  var getLineInfo = exports.getLineInfo = function(input, offset) {
	for (var line = 1, cur = 0;;) {
	  lineBreak.lastIndex = cur;
	  var match = lineBreak.exec(input);
	  if (match && match.index < offset) {
		++line;
		cur = match.index + match[0].length;
	  } else break;
	}
	return {line: line, column: offset - cur};
  };

  exports.tokenize = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();

	var t = {};
	function getToken(forceRegexp) {
	  lastEnd = tokEnd;
	  readToken(forceRegexp);
	  t.start = tokStart; t.end = tokEnd;
	  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
	  t.type = tokType; t.value = tokVal;
	  return t;
	}
	getToken.jumpTo = function(pos, reAllowed) {
	  tokPos = pos;
	  if (options.locations) {
		tokCurLine = 1;
		tokLineStart = lineBreak.lastIndex = 0;
		var match;
		while ((match = lineBreak.exec(input)) && match.index < pos) {
		  ++tokCurLine;
		  tokLineStart = match.index + match[0].length;
		}
	  }
	  tokRegexpAllowed = reAllowed;
	  skipSpace();
	};
	return getToken;
  };

  var tokPos;

  var tokStart, tokEnd;

  var tokStartLoc, tokEndLoc;

  var tokType, tokVal;

  var tokRegexpAllowed;

  var tokCurLine, tokLineStart;

  var lastStart, lastEnd, lastEndLoc;

  var inFunction, labels, strict;

  function raise(pos, message) {
	var loc = getLineInfo(input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
	throw err;
  }

  var empty = [];

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
					  "continue": _continue, "debugger": _debugger, "default": _default,
					  "do": _do, "else": _else, "finally": _finally, "for": _for,
					  "function": _function, "if": _if, "return": _return, "switch": _switch,
					  "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
					  "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
					  "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
					  "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
					  "void": {keyword: "void", prefix: true, beforeExpr: true},
					  "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _multiplyModulo = {binop: 10, beforeExpr: true};

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
					  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
					  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
					  num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  function makePredicate(words) {
	words = words.split(" ");
	var f = "", cats = [];
	out: for (var i = 0; i < words.length; ++i) {
	  for (var j = 0; j < cats.length; ++j)
		if (cats[j][0].length == words[i].length) {
		  cats[j].push(words[i]);
		  continue out;
		}
	  cats.push([words[i]]);
	}
	function compareTo(arr) {
	  if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
	  f += "switch(str){";
	  for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
	  f += "return true}return false;";
	}

	if (cats.length > 3) {
	  cats.sort(function(a, b) {return b.length - a.length;});
	  f += "switch(str.length){";
	  for (var i = 0; i < cats.length; ++i) {
		var cat = cats[i];
		f += "case " + cat[0].length + ":";
		compareTo(cat);
	  }
	  f += "}";

	} else {
	  compareTo(words);
	}
	return new Function("str", f);
  }

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  var isStrictBadIdWord = makePredicate("eval arguments");

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var newline = /[\n\r\u2028\u2029]/;

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  function line_loc_t() {
	this.line = tokCurLine;
	this.column = tokPos - tokLineStart;
  }

  function initTokenState() {
	tokCurLine = 1;
	tokPos = tokLineStart = 0;
	tokRegexpAllowed = true;
	skipSpace();
  }

  function finishToken(type, val) {
	tokEnd = tokPos;
	if (options.locations) tokEndLoc = new line_loc_t;
	tokType = type;
	skipSpace();
	tokVal = val;
	tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var start = tokPos, end = input.indexOf("*/", tokPos += 2);
	if (end === -1) raise(tokPos - 2, "Unterminated comment");
	tokPos = end + 2;
	if (options.locations) {
	  lineBreak.lastIndex = start;
	  var match;
	  while ((match = lineBreak.exec(input)) && match.index < tokPos) {
		++tokCurLine;
		tokLineStart = match.index + match[0].length;
	  }
	}
	if (options.onComment)
	  options.onComment(true, input.slice(start + 2, end), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
	var start = tokPos;
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var ch = input.charCodeAt(tokPos+=2);
	while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	  ++tokPos;
	  ch = input.charCodeAt(tokPos);
	}
	if (options.onComment)
	  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipSpace() {
	while (tokPos < inputLen) {
	  var ch = input.charCodeAt(tokPos);
	  if (ch === 32) {
		++tokPos;
	  } else if (ch === 13) {
		++tokPos;
		var next = input.charCodeAt(tokPos);
		if (next === 10) {
		  ++tokPos;
		}
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch === 10 || ch === 8232 || ch === 8233) {
		++tokPos;
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch > 8 && ch < 14) {
		++tokPos;
	  } else if (ch === 47) {
		var next = input.charCodeAt(tokPos + 1);
		if (next === 42) {
		  skipBlockComment();
		} else if (next === 47) {
		  skipLineComment();
		} else break;
	  } else if (ch === 160) {
		++tokPos;
	  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		++tokPos;
	  } else {
		break;
	  }
	}
  }

  function readToken_dot() {
	var next = input.charCodeAt(tokPos + 1);
	if (next >= 48 && next <= 57) return readNumber(true);
	++tokPos;
	return finishToken(_dot);
  }

  function readToken_slash() {
	var next = input.charCodeAt(tokPos + 1);
	if (tokRegexpAllowed) {++tokPos; return readRegexp();}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_multiplyModulo, 1);
  }

  function readToken_pipe_amp(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) {
	  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
		  newline.test(input.slice(lastEnd, tokPos))) {
		tokPos += 3;
		skipLineComment();
		skipSpace();
		return readToken();
	  }
	  return finishOp(_incDec, 2);
	}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) {
	var next = input.charCodeAt(tokPos + 1);
	var size = 1;
	if (next === code) {
	  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
	  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
	  return finishOp(_bitShift, size);
	}
	if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
		input.charCodeAt(tokPos + 3) == 45) {
	  tokPos += 4;
	  skipLineComment();
	  skipSpace();
	  return readToken();
	}
	if (next === 61)
	  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
	return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
	return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
	switch(code) {
	case 46:
	  return readToken_dot();

	case 40: ++tokPos; return finishToken(_parenL);
	case 41: ++tokPos; return finishToken(_parenR);
	case 59: ++tokPos; return finishToken(_semi);
	case 44: ++tokPos; return finishToken(_comma);
	case 91: ++tokPos; return finishToken(_bracketL);
	case 93: ++tokPos; return finishToken(_bracketR);
	case 123: ++tokPos; return finishToken(_braceL);
	case 125: ++tokPos; return finishToken(_braceR);
	case 58: ++tokPos; return finishToken(_colon);
	case 63: ++tokPos; return finishToken(_question);

	case 48:
	  var next = input.charCodeAt(tokPos + 1);
	  if (next === 120 || next === 88) return readHexNumber();
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
	  return readNumber(false);

	case 34: case 39:
	  return readString(code);

	case 47:
	  return readToken_slash(code);

	case 37: case 42:
	  return readToken_mult_modulo();

	case 124: case 38:
	  return readToken_pipe_amp(code);

	case 94:
	  return readToken_caret();

	case 43: case 45:
	  return readToken_plus_min(code);

	case 60: case 62:
	  return readToken_lt_gt(code);

	case 61: case 33:
	  return readToken_eq_excl(code);

	case 126:
	  return finishOp(_prefix, 1);
	}

	return false;
  }

  function readToken(forceRegexp) {
	if (!forceRegexp) tokStart = tokPos;
	else tokPos = tokStart + 1;
	if (options.locations) tokStartLoc = new line_loc_t;
	if (forceRegexp) return readRegexp();
	if (tokPos >= inputLen) return finishToken(_eof);

	var code = input.charCodeAt(tokPos);
	if (isIdentifierStart(code) || code === 92 ) return readWord();

	var tok = getTokenFromCode(code);

	if (tok === false) {
	  var ch = String.fromCharCode(code);
	  if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
	  raise(tokPos, "Unexpected character '" + ch + "'");
	}
	return tok;
  }

  function finishOp(type, size) {
	var str = input.slice(tokPos, tokPos + size);
	tokPos += size;
	finishToken(type, str);
  }

  function readRegexp() {
	var content = "", escaped, inClass, start = tokPos;
	for (;;) {
	  if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
	  var ch = input.charAt(tokPos);
	  if (newline.test(ch)) raise(start, "Unterminated regular expression");
	  if (!escaped) {
		if (ch === "[") inClass = true;
		else if (ch === "]" && inClass) inClass = false;
		else if (ch === "/" && !inClass) break;
		escaped = ch === "\\";
	  } else escaped = false;
	  ++tokPos;
	}
	var content = input.slice(start, tokPos);
	++tokPos;
	var mods = readWord1();
	if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
	try {
	  var value = new RegExp(content, mods);
	} catch (e) {
	  if (e instanceof SyntaxError) raise(start, e.message);
	  raise(e);
	}
	return finishToken(_regexp, value);
  }

  function readInt(radix, len) {
	var start = tokPos, total = 0;
	for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	  var code = input.charCodeAt(tokPos), val;
	  if (code >= 97) val = code - 97 + 10;
	  else if (code >= 65) val = code - 65 + 10;
	  else if (code >= 48 && code <= 57) val = code - 48;
	  else val = Infinity;
	  if (val >= radix) break;
	  ++tokPos;
	  total = total * radix + val;
	}
	if (tokPos === start || len != null && tokPos - start !== len) return null;

	return total;
  }

  function readHexNumber() {
	tokPos += 2;
	var val = readInt(16);
	if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
	return finishToken(_num, val);
  }

  function readNumber(startsWithDot) {
	var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
	if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
	if (input.charCodeAt(tokPos) === 46) {
	  ++tokPos;
	  readInt(10);
	  isFloat = true;
	}
	var next = input.charCodeAt(tokPos);
	if (next === 69 || next === 101) {
	  next = input.charCodeAt(++tokPos);
	  if (next === 43 || next === 45) ++tokPos;
	  if (readInt(10) === null) raise(start, "Invalid number");
	  isFloat = true;
	}
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

	var str = input.slice(start, tokPos), val;
	if (isFloat) val = parseFloat(str);
	else if (!octal || str.length === 1) val = parseInt(str, 10);
	else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
	else val = parseInt(str, 8);
	return finishToken(_num, val);
  }

  function readString(quote) {
	tokPos++;
	var out = "";
	for (;;) {
	  if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
	  var ch = input.charCodeAt(tokPos);
	  if (ch === quote) {
		++tokPos;
		return finishToken(_string, out);
	  }
	  if (ch === 92) {
		ch = input.charCodeAt(++tokPos);
		var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
		if (octal) octal = octal[0];
		while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
		if (octal === "0") octal = null;
		++tokPos;
		if (octal) {
		  if (strict) raise(tokPos - 2, "Octal literal in strict mode");
		  out += String.fromCharCode(parseInt(octal, 8));
		  tokPos += octal.length - 1;
		} else {
		  switch (ch) {
		  case 110: out += "\n"; break;
		  case 114: out += "\r"; break;
		  case 120: out += String.fromCharCode(readHexChar(2)); break;
		  case 117: out += String.fromCharCode(readHexChar(4)); break;
		  case 85: out += String.fromCharCode(readHexChar(8)); break;
		  case 116: out += "\t"; break;
		  case 98: out += "\b"; break;
		  case 118: out += "\u000b"; break;
		  case 102: out += "\f"; break;
		  case 48: out += "\0"; break;
		  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;
		  case 10:
			if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
			break;
		  default: out += String.fromCharCode(ch); break;
		  }
		}
	  } else {
		if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
		out += String.fromCharCode(ch);
		++tokPos;
	  }
	}
  }

  function readHexChar(len) {
	var n = readInt(16, len);
	if (n === null) raise(tokStart, "Bad character escape sequence");
	return n;
  }

  var containsEsc;

  function readWord1() {
	containsEsc = false;
	var word, first = true, start = tokPos;
	for (;;) {
	  var ch = input.charCodeAt(tokPos);
	  if (isIdentifierChar(ch)) {
		if (containsEsc) word += input.charAt(tokPos);
		++tokPos;
	  } else if (ch === 92) {
		if (!containsEsc) word = input.slice(start, tokPos);
		containsEsc = true;
		if (input.charCodeAt(++tokPos) != 117)
		  raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
		++tokPos;
		var esc = readHexChar(4);
		var escStr = String.fromCharCode(esc);
		if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
		if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
		  raise(tokPos - 4, "Invalid Unicode escape");
		word += escStr;
	  } else {
		break;
	  }
	  first = false;
	}
	return containsEsc ? word : input.slice(start, tokPos);
  }

  function readWord() {
	var word = readWord1();
	var type = _name;
	if (!containsEsc && isKeyword(word))
	  type = keywordTypes[word];
	return finishToken(type, word);
  }

  function next() {
	lastStart = tokStart;
	lastEnd = tokEnd;
	lastEndLoc = tokEndLoc;
	readToken();
  }

  function setStrict(strct) {
	strict = strct;
	tokPos = tokStart;
	if (options.locations) {
	  while (tokPos < tokLineStart) {
		tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
		--tokCurLine;
	  }
	}
	skipSpace();
	readToken();
  }

  function node_t() {
	this.type = null;
	this.start = tokStart;
	this.end = null;
  }

  function node_loc_t() {
	this.start = tokStartLoc;
	this.end = null;
	if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
	var node = new node_t();
	if (options.locations)
	  node.loc = new node_loc_t();
	if (options.directSourceFile)
	  node.sourceFile = options.directSourceFile;
	if (options.ranges)
	  node.range = [tokStart, 0];
	return node;
  }

  function startNodeFrom(other) {
	var node = new node_t();
	node.start = other.start;
	if (options.locations) {
	  node.loc = new node_loc_t();
	  node.loc.start = other.loc.start;
	}
	if (options.ranges)
	  node.range = [other.range[0], 0];

	return node;
  }

  function finishNode(node, type) {
	node.type = type;
	node.end = lastEnd;
	if (options.locations)
	  node.loc.end = lastEndLoc;
	if (options.ranges)
	  node.range[1] = lastEnd;
	return node;
  }

  function isUseStrict(stmt) {
	return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	  stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  function eat(type) {
	if (tokType === type) {
	  next();
	  return true;
	}
  }

  function canInsertSemicolon() {
	return !options.strictSemicolons &&
	  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  function semicolon() {
	if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  function expect(type) {
	if (tokType === type) next();
	else unexpected();
  }

  function unexpected() {
	raise(tokStart, "Unexpected token");
  }

  function checkLVal(expr) {
	if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
	  raise(expr.start, "Assigning to rvalue");
	if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
	  raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  function parseTopLevel(program) {
	lastStart = lastEnd = tokPos;
	if (options.locations) lastEndLoc = new line_loc_t;
	inFunction = strict = null;
	labels = [];
	readToken();

	var node = program || startNode(), first = true;
	if (!program) node.body = [];
	while (tokType !== _eof) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && isUseStrict(stmt)) setStrict(true);
	  first = false;
	}
	return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  function parseStatement() {
	if (tokType === _slash || tokType === _assign && tokVal == "/=")
	  readToken(true);

	var starttype = tokType, node = startNode();

	switch (starttype) {
	case _break: case _continue:
	  next();
	  var isBreak = starttype === _break;
	  if (eat(_semi) || canInsertSemicolon()) node.label = null;
	  else if (tokType !== _name) unexpected();
	  else {
		node.label = parseIdent();
		semicolon();
	  }

	  for (var i = 0; i < labels.length; ++i) {
		var lab = labels[i];
		if (node.label == null || lab.name === node.label.name) {
		  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
		  if (node.label && isBreak) break;
		}
	  }
	  if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
	  return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	case _debugger:
	  next();
	  semicolon();
	  return finishNode(node, "DebuggerStatement");

	case _do:
	  next();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  expect(_while);
	  node.test = parseParenExpression();
	  semicolon();
	  return finishNode(node, "DoWhileStatement");

	case _for:
	  next();
	  labels.push(loopLabel);
	  expect(_parenL);
	  if (tokType === _semi) return parseFor(node, null);
	  if (tokType === _var) {
		var init = startNode();
		next();
		parseVar(init, true);
		finishNode(init, "VariableDeclaration");
		if (init.declarations.length === 1 && eat(_in))
		  return parseForIn(node, init);
		return parseFor(node, init);
	  }
	  var init = parseExpression(false, true);
	  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
	  return parseFor(node, init);

	case _function:
	  next();
	  return parseFunction(node, true);

	case _if:
	  next();
	  node.test = parseParenExpression();
	  node.consequent = parseStatement();
	  node.alternate = eat(_else) ? parseStatement() : null;
	  return finishNode(node, "IfStatement");

	case _return:
	  if (!inFunction && !options.allowReturnOutsideFunction)
		raise(tokStart, "'return' outside of function");
	  next();

	  if (eat(_semi) || canInsertSemicolon()) node.argument = null;
	  else { node.argument = parseExpression(); semicolon(); }
	  return finishNode(node, "ReturnStatement");

	case _switch:
	  next();
	  node.discriminant = parseParenExpression();
	  node.cases = [];
	  expect(_braceL);
	  labels.push(switchLabel);

	  for (var cur, sawDefault; tokType != _braceR;) {
		if (tokType === _case || tokType === _default) {
		  var isCase = tokType === _case;
		  if (cur) finishNode(cur, "SwitchCase");
		  node.cases.push(cur = startNode());
		  cur.consequent = [];
		  next();
		  if (isCase) cur.test = parseExpression();
		  else {
			if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
			cur.test = null;
		  }
		  expect(_colon);
		} else {
		  if (!cur) unexpected();
		  cur.consequent.push(parseStatement());
		}
	  }
	  if (cur) finishNode(cur, "SwitchCase");
	  next();
	  labels.pop();
	  return finishNode(node, "SwitchStatement");

	case _throw:
	  next();
	  if (newline.test(input.slice(lastEnd, tokStart)))
		raise(lastEnd, "Illegal newline after throw");
	  node.argument = parseExpression();
	  semicolon();
	  return finishNode(node, "ThrowStatement");

	case _try:
	  next();
	  node.block = parseBlock();
	  node.handler = null;
	  if (tokType === _catch) {
		var clause = startNode();
		next();
		expect(_parenL);
		clause.param = parseIdent();
		if (strict && isStrictBadIdWord(clause.param.name))
		  raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
		expect(_parenR);
		clause.guard = null;
		clause.body = parseBlock();
		node.handler = finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = eat(_finally) ? parseBlock() : null;
	  if (!node.handler && !node.finalizer)
		raise(node.start, "Missing catch or finally clause");
	  return finishNode(node, "TryStatement");

	case _var:
	  next();
	  parseVar(node);
	  semicolon();
	  return finishNode(node, "VariableDeclaration");

	case _while:
	  next();
	  node.test = parseParenExpression();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  return finishNode(node, "WhileStatement");

	case _with:
	  if (strict) raise(tokStart, "'with' in strict mode");
	  next();
	  node.object = parseParenExpression();
	  node.body = parseStatement();
	  return finishNode(node, "WithStatement");

	case _braceL:
	  return parseBlock();

	case _semi:
	  next();
	  return finishNode(node, "EmptyStatement");

	default:
	  var maybeName = tokVal, expr = parseExpression();
	  if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
		for (var i = 0; i < labels.length; ++i)
		  if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
		var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
		labels.push({name: maybeName, kind: kind});
		node.body = parseStatement();
		labels.pop();
		node.label = expr;
		return finishNode(node, "LabeledStatement");
	  } else {
		node.expression = expr;
		semicolon();
		return finishNode(node, "ExpressionStatement");
	  }
	}
  }

  function parseParenExpression() {
	expect(_parenL);
	var val = parseExpression();
	expect(_parenR);
	return val;
  }

  function parseBlock(allowStrict) {
	var node = startNode(), first = true, strict = false, oldStrict;
	node.body = [];
	expect(_braceL);
	while (!eat(_braceR)) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && allowStrict && isUseStrict(stmt)) {
		oldStrict = strict;
		setStrict(strict = true);
	  }
	  first = false;
	}
	if (strict && !oldStrict) setStrict(false);
	return finishNode(node, "BlockStatement");
  }

  function parseFor(node, init) {
	node.init = init;
	expect(_semi);
	node.test = tokType === _semi ? null : parseExpression();
	expect(_semi);
	node.update = tokType === _parenR ? null : parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForStatement");
  }

  function parseForIn(node, init) {
	node.left = init;
	node.right = parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForInStatement");
  }

  function parseVar(node, noIn) {
	node.declarations = [];
	node.kind = "var";
	for (;;) {
	  var decl = startNode();
	  decl.id = parseIdent();
	  if (strict && isStrictBadIdWord(decl.id.name))
		raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
	  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
	  node.declarations.push(finishNode(decl, "VariableDeclarator"));
	  if (!eat(_comma)) break;
	}
	return node;
  }

  function parseExpression(noComma, noIn) {
	var expr = parseMaybeAssign(noIn);
	if (!noComma && tokType === _comma) {
	  var node = startNodeFrom(expr);
	  node.expressions = [expr];
	  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
	  return finishNode(node, "SequenceExpression");
	}
	return expr;
  }

  function parseMaybeAssign(noIn) {
	var left = parseMaybeConditional(noIn);
	if (tokType.isAssign) {
	  var node = startNodeFrom(left);
	  node.operator = tokVal;
	  node.left = left;
	  next();
	  node.right = parseMaybeAssign(noIn);
	  checkLVal(left);
	  return finishNode(node, "AssignmentExpression");
	}
	return left;
  }

  function parseMaybeConditional(noIn) {
	var expr = parseExprOps(noIn);
	if (eat(_question)) {
	  var node = startNodeFrom(expr);
	  node.test = expr;
	  node.consequent = parseExpression(true);
	  expect(_colon);
	  node.alternate = parseExpression(true, noIn);
	  return finishNode(node, "ConditionalExpression");
	}
	return expr;
  }

  function parseExprOps(noIn) {
	return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  function parseExprOp(left, minPrec, noIn) {
	var prec = tokType.binop;
	if (prec != null && (!noIn || tokType !== _in)) {
	  if (prec > minPrec) {
		var node = startNodeFrom(left);
		node.left = left;
		node.operator = tokVal;
		var op = tokType;
		next();
		node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
		var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
		return parseExprOp(exprNode, minPrec, noIn);
	  }
	}
	return left;
  }

  function parseMaybeUnary() {
	if (tokType.prefix) {
	  var node = startNode(), update = tokType.isUpdate;
	  node.operator = tokVal;
	  node.prefix = true;
	  tokRegexpAllowed = true;
	  next();
	  node.argument = parseMaybeUnary();
	  if (update) checkLVal(node.argument);
	  else if (strict && node.operator === "delete" &&
			   node.argument.type === "Identifier")
		raise(node.start, "Deleting local variable in strict mode");
	  return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	}
	var expr = parseExprSubscripts();
	while (tokType.postfix && !canInsertSemicolon()) {
	  var node = startNodeFrom(expr);
	  node.operator = tokVal;
	  node.prefix = false;
	  node.argument = expr;
	  checkLVal(expr);
	  next();
	  expr = finishNode(node, "UpdateExpression");
	}
	return expr;
  }

  function parseExprSubscripts() {
	return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
	if (eat(_dot)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseIdent(true);
	  node.computed = false;
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (eat(_bracketL)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseExpression();
	  node.computed = true;
	  expect(_bracketR);
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (!noCalls && eat(_parenL)) {
	  var node = startNodeFrom(base);
	  node.callee = base;
	  node.arguments = parseExprList(_parenR, false);
	  return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
	} else return base;
  }

  function parseExprAtom() {
	switch (tokType) {
	case _this:
	  var node = startNode();
	  next();
	  return finishNode(node, "ThisExpression");
	case _name:
	  return parseIdent();
	case _num: case _string: case _regexp:
	  var node = startNode();
	  node.value = tokVal;
	  node.raw = input.slice(tokStart, tokEnd);
	  next();
	  return finishNode(node, "Literal");

	case _null: case _true: case _false:
	  var node = startNode();
	  node.value = tokType.atomValue;
	  node.raw = tokType.keyword;
	  next();
	  return finishNode(node, "Literal");

	case _parenL:
	  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
	  next();
	  var val = parseExpression();
	  val.start = tokStart1;
	  val.end = tokEnd;
	  if (options.locations) {
		val.loc.start = tokStartLoc1;
		val.loc.end = tokEndLoc;
	  }
	  if (options.ranges)
		val.range = [tokStart1, tokEnd];
	  expect(_parenR);
	  return val;

	case _bracketL:
	  var node = startNode();
	  next();
	  node.elements = parseExprList(_bracketR, true, true);
	  return finishNode(node, "ArrayExpression");

	case _braceL:
	  return parseObj();

	case _function:
	  var node = startNode();
	  next();
	  return parseFunction(node, false);

	case _new:
	  return parseNew();

	default:
	  unexpected();
	}
  }

  function parseNew() {
	var node = startNode();
	next();
	node.callee = parseSubscripts(parseExprAtom(), true);
	if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
	else node.arguments = empty;
	return finishNode(node, "NewExpression");
  }

  function parseObj() {
	var node = startNode(), first = true, sawGetSet = false;
	node.properties = [];
	next();
	while (!eat(_braceR)) {
	  if (!first) {
		expect(_comma);
		if (options.allowTrailingCommas && eat(_braceR)) break;
	  } else first = false;

	  var prop = {key: parsePropertyName()}, isGetSet = false, kind;
	  if (eat(_colon)) {
		prop.value = parseExpression(true);
		kind = prop.kind = "init";
	  } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
				 (prop.key.name === "get" || prop.key.name === "set")) {
		isGetSet = sawGetSet = true;
		kind = prop.kind = prop.key.name;
		prop.key = parsePropertyName();
		if (tokType !== _parenL) unexpected();
		prop.value = parseFunction(startNode(), false);
	  } else unexpected();

	  if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
		for (var i = 0; i < node.properties.length; ++i) {
		  var other = node.properties[i];
		  if (other.key.name === prop.key.name) {
			var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
			  kind === "init" && (other.kind === "get" || other.kind === "set");
			if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
			if (conflict) raise(prop.key.start, "Redefinition of property");
		  }
		}
	  }
	  node.properties.push(prop);
	}
	return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
	if (tokType === _num || tokType === _string) return parseExprAtom();
	return parseIdent(true);
  }

  function parseFunction(node, isStatement) {
	if (tokType === _name) node.id = parseIdent();
	else if (isStatement) unexpected();
	else node.id = null;
	node.params = [];
	var first = true;
	expect(_parenL);
	while (!eat(_parenR)) {
	  if (!first) expect(_comma); else first = false;
	  node.params.push(parseIdent());
	}

	var oldInFunc = inFunction, oldLabels = labels;
	inFunction = true; labels = [];
	node.body = parseBlock(true);
	inFunction = oldInFunc; labels = oldLabels;

	if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
	  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
		var id = i < 0 ? node.id : node.params[i];
		if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
		  raise(id.start, "Defining '" + id.name + "' in strict mode");
		if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
		  raise(id.start, "Argument name clash in strict mode");
	  }
	}

	return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  function parseExprList(close, allowTrailingComma, allowEmpty) {
	var elts = [], first = true;
	while (!eat(close)) {
	  if (!first) {
		expect(_comma);
		if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
	  } else first = false;

	  if (allowEmpty && tokType === _comma) elts.push(null);
	  else elts.push(parseExpression(true));
	}
	return elts;
  }

  function parseIdent(liberal) {
	var node = startNode();
	if (liberal && options.forbidReserved == "everywhere") liberal = false;
	if (tokType === _name) {
	  if (!liberal &&
		  (options.forbidReserved &&
		   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
		   strict && isStrictReservedWord(tokVal)) &&
		  input.slice(tokStart, tokEnd).indexOf("\\") == -1)
		raise(tokStart, "The keyword '" + tokVal + "' is reserved");
	  node.name = tokVal;
	} else if (liberal && tokType.keyword) {
	  node.name = tokType.keyword;
	} else {
	  unexpected();
	}
	tokRegexpAllowed = false;
	next();
	return finishNode(node, "Identifier");
  }

});

		if (!acorn.version)
			acorn = null;
	}

	function parse(code, options) {
		return (global.acorn || acorn).parse(code, options);
	}

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': '__equals',
		'!=': '__equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': '__self'
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{
			__self: function() {
				return this;
			}
		}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code, options) {
		if (!code)
			return '';
		options = options || {};

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function handleOverloading(node, parent) {
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (node.prefix) {
							str = '(' + str + ')';
						} else if (
							parentType === 'AssignmentExpression' ||
							parentType === 'VariableDeclarator' ||
							parentType === 'BinaryExpression'
						) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right),
								exp = left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')';
							replaceCode(node, /^\(.*\)$/.test(getCode(node))
									? '(' + exp + ')' : exp);
						}
					}
				}
				break;
			}
		}

		function handleExports(node) {
			switch (node.type) {
			case 'ExportDefaultDeclaration':
				replaceCode({
					range: [node.start, node.declaration.start]
				}, 'module.exports = ');
				break;
			case 'ExportNamedDeclaration':
				var declaration = node.declaration;
				var specifiers = node.specifiers;
				if (declaration) {
					var declarations = declaration.declarations;
					if (declarations) {
						declarations.forEach(function(dec) {
							replaceCode(dec, 'module.exports.' + getCode(dec));
						});
						replaceCode({
							range: [
								node.start,
								declaration.start + declaration.kind.length
							]
						}, '');
					}
				} else if (specifiers) {
					var exports = specifiers.map(function(specifier) {
						var name = getCode(specifier);
						return 'module.exports.' + name + ' = ' + name + '; ';
					}).join('');
					if (exports) {
						replaceCode(node, exports);
					}
				}
				break;
			}
		}

		function walkAST(node, parent, paperFeatures) {
			if (node) {
				for (var key in node) {
					if (key !== 'range' && key !== 'loc') {
						var value = node[key];
						if (Array.isArray(value)) {
							for (var i = 0, l = value.length; i < l; i++) {
								walkAST(value[i], node, paperFeatures);
							}
						} else if (value && typeof value === 'object') {
							walkAST(value, node, paperFeatures);
						}
					}
				}
				if (paperFeatures.operatorOverloading !== false) {
					handleOverloading(node, parent);
				}
				if (paperFeatures.moduleExports !== false) {
					handleExports(node);
				}
			}
		}

		function encodeVLQ(value) {
			var res = '',
				base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
			value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
			while (value || !res) {
				var next = value & (32 - 1);
				value >>= 5;
				if (value)
					next |= 32;
				res += base64[next];
			}
			return res;
		}

		var url = options.url || '',
			sourceMaps = options.sourceMaps,
			paperFeatures = options.paperFeatures || {},
			source = options.source || code,
			offset = options.offset || 0,
			agent = paper.agent,
			version = agent.versionNumber,
			offsetCode = false,
			lineBreaks = /\r\n|\n|\r/mg,
			map;
		if (sourceMaps && (agent.chrome && version >= 30
				|| agent.webkit && version >= 537.76
				|| agent.firefox && version >= 23
				|| agent.node)) {
			if (agent.node) {
				offset -= 2;
			} else if (window && url && !window.location.href.indexOf(url)) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			offsetCode = offset > 0 && !(
					agent.chrome && version >= 36 ||
					agent.safari && version >= 600 ||
					agent.firefox && version >= 40 ||
					agent.node);
			var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
			mappings.length = (code.match(lineBreaks) || []).length + 1
					+ (offsetCode ? offset : 0);
			map = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url],
				sourcesContent: [source]
			};
		}
		if (
			paperFeatures.operatorOverloading !== false ||
			paperFeatures.moduleExports !== false
		) {
			walkAST(parse(code, {
				ranges: true,
				preserveParens: true,
				sourceType: 'module'
			}), null, paperFeatures);
		}
		if (map) {
			if (offsetCode) {
				code = new Array(offset + 1).join('\n') + code;
			}
			if (/^(inline|both)$/.test(sourceMaps)) {
				code += "\n//# sourceMappingURL=data:application/json;base64,"
						+ self.btoa(unescape(encodeURIComponent(
							JSON.stringify(map))));
			}
			code += "\n//# sourceURL=" + (url || 'paperscript');
		}
		return {
			url: url,
			source: source,
			code: code,
			map: map
		};
	}

	function execute(code, scope, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/
					.test(code) && !/\bnew\s+Tool\b/.test(code)
						? new Tool() : null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func,
			compiled = typeof code === 'object' ? code : compile(code, options);
		code = compiled.code;
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, tool: tool },
				true);
		expose(scope);
		code = 'var module = { exports: {} }; ' + code;
		var exports = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push('module.exports.' + key + ' = ' + key + ';');
			}
		}, []).join('\n');
		if (exports) {
			code += '\n' + exports;
		}
		code += '\nreturn module.exports;';
		var agent = paper.agent;
		if (document && (agent.chrome
				|| agent.firefox && agent.versionNumber < 40)) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (agent.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'document.__paperscript__ = function(' + params + ') {' +
					code +
				'\n}'
			));
			head.appendChild(script);
			func = document.__paperscript__;
			delete document.__paperscript__;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var exports = func && func.apply(scope, args);
		var obj = exports || {};
		Base.each(toolHandlers, function(key) {
			var value = obj[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (obj.onResize)
				view.setOnResize(obj.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (obj.onFrame)
				view.setOnFrame(obj.onFrame);
			view.requestUpdate();
		}
		return exports;
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request({
					url: src,
					async: async,
					mimeType: 'text/plain',
					onLoad: function(code) {
						execute(code, scope, src);
					}
				});
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document && document.getElementsByTagName('script'),
				loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (window) {
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse,
		calculateBinary: __$__,
		calculateUnary: $__
	};

}.call(this);

var paper = new (PaperScope.inject(Base.exports, {
	Base: Base,
	Numerical: Numerical,
	Key: Key,
	DomEvent: DomEvent,
	DomElement: DomElement,
	document: document,
	window: window,
	Symbol: SymbolDefinition,
	PlacedSymbol: SymbolItem
}))();

if (paper.agent.node) {
	require('./node/extend.js')(paper);
}

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
}.call(this, typeof self === 'object' ? self : null);

},{"./node/extend.js":3,"./node/self.js":3,"acorn":2}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AniBase = void 0;
var paper_1 = __importDefault(require("paper"));
var AniBase = /** @class */ (function () {
    function AniBase(element) {
        this._element = element;
        this._canvas = document.createElement('canvas');
        this._element.appendChild(this._canvas);
        this._project = new paper_1.default.Project(this._canvas);
        this.InitializeCanvas();
    }
    Object.defineProperty(AniBase.prototype, "Width", {
        get: function () {
            return this._canvas.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AniBase.prototype, "Height", {
        get: function () {
            return this._canvas.height;
        },
        enumerable: false,
        configurable: true
    });
    AniBase.prototype.InitializeCanvas = function () {
        this._canvas.width = this._element.clientWidth;
        this._canvas.height = this._element.clientHeight;
        this._project.view.viewSize = new paper_1.default.Size(this.Width, this.Height);
    };
    return AniBase;
}());
exports.AniBase = AniBase;
},{"paper":4}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcentricAni = void 0;
var ani_base_1 = require("./abstractions/ani-base");
var paper_1 = __importDefault(require("paper"));
var ani_helpers_1 = require("./helpers/ani-helpers");
var ConcentricAni = /** @class */ (function (_super) {
    __extends(ConcentricAni, _super);
    function ConcentricAni(element) {
        var _this = _super.call(this, element) || this;
        _this._circles = [];
        _this.StartAni();
        return _this;
    }
    ConcentricAni.prototype.CreateElements = function () {
        var maxRadius = this.Height >= this.Width ? (this.Height - 10) / 2 : (this.Width - 10) / 2;
        var currentRadius = maxRadius;
        var strokeColor = new paper_1.default.Color('black');
        for (var i = 0; i < 4; i++) {
            var center = ani_helpers_1.AniHelpers.GetCenterFromElement(this._element);
            var point = new paper_1.default.Point(center[0], center[1]);
            var circle = new paper_1.default.Path.Circle(point, currentRadius);
            circle.strokeWidth = 1;
            circle.strokeColor = strokeColor;
            this._circles.push(circle);
            currentRadius -= maxRadius / 4;
        }
    };
    ConcentricAni.prototype.StartAni = function () {
        if (this._circles.length === 0)
            this.CreateElements();
        this.DoAnimation(0);
    };
    ConcentricAni.prototype.DoAnimation = function (index) {
        var _this = this;
        var direction = 'up';
        var interval = window.setInterval(function () {
            if (direction === 'up') {
                _this._circles[index].strokeWidth += 0.5;
                if (_this._circles[index].strokeWidth === 4) {
                    direction = 'down';
                }
            }
            else {
                _this._circles[index].strokeWidth -= 0.5;
                if (_this._circles[index].strokeWidth === 1) {
                    clearInterval(interval);
                    _this.DoAnimation(index === 3 ? 0 : ++index);
                }
            }
        }, 16);
    };
    return ConcentricAni;
}(ani_base_1.AniBase));
exports.ConcentricAni = ConcentricAni;
},{"./abstractions/ani-base":5,"./helpers/ani-helpers":7,"paper":4}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AniHelpers = void 0;
var AniHelpers = /** @class */ (function () {
    function AniHelpers() {
    }
    AniHelpers.GetCenterFromElement = function (element) {
        var result = [element.clientWidth / 2, element.clientHeight / 2];
        return result;
    };
    AniHelpers.GetPointOnCircle = function (radius, deg) {
        var radians = deg * (Math.PI / 180);
        return [radius * Math.sin(radians), radius * Math.cos(radians)];
    };
    AniHelpers.TransformCenter = function (center, point) {
        return [center[0] - point[0], center[1] - point[1]];
    };
    return AniHelpers;
}());
exports.AniHelpers = AniHelpers;
},{}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorizontalLinesAni = void 0;
var ani_base_1 = require("./abstractions/ani-base");
var paper_1 = __importDefault(require("paper"));
var ani_helpers_1 = require("./helpers/ani-helpers");
var HorizontalLinesAni = /** @class */ (function (_super) {
    __extends(HorizontalLinesAni, _super);
    function HorizontalLinesAni(element, lines) {
        if (lines === void 0) { lines = 5; }
        var _this = _super.call(this, element) || this;
        _this._lines = [];
        _this._linesCount = 0;
        _this._linesCount = lines;
        _this.StartAni();
        return _this;
    }
    HorizontalLinesAni.prototype.CreateElements = function () {
        var color = new paper_1.default.Color('black');
        var center = ani_helpers_1.AniHelpers.GetCenterFromElement(this._element);
        var heightIncrement = this.Height / (this._linesCount + 1);
        for (var i = 1; i <= this._linesCount; i++) {
            var start = new paper_1.default.Point(0, heightIncrement * i);
            var end = new paper_1.default.Point(this.Width / 2, heightIncrement * i);
            var line = new paper_1.default.Path.Line(start, end);
            line.strokeColor = color;
            line.strokeWidth = 1;
            this._lines.push(line);
        }
    };
    HorizontalLinesAni.prototype.StartAni = function () {
        this.CreateElements();
        this.DoAnimation();
    };
    HorizontalLinesAni.prototype.DoAnimation = function () {
        var _this = this;
        var center = new paper_1.default.Point(ani_helpers_1.AniHelpers.GetCenterFromElement(this._element));
        var directions = this._lines.map(function () { return 0; });
        var started = this._lines.map(function () { return false; });
        started[0] = true;
        window.setInterval(function () {
            for (var i = 0; i < _this._lines.length; i++) {
                if (!started[i])
                    return;
                if (directions[i] === 0) {
                    _this._lines[i].position.x++;
                    if (_this._lines[i].position.x > _this.Width * 0.75) {
                        directions[i] = 1;
                    }
                }
                else {
                    _this._lines[i].position.x--;
                    if (_this._lines[i].position.x <= _this.Width * 0.25) {
                        directions[i] = 0;
                    }
                }
            }
        }, 16);
        var timeout = 80;
        var _loop_1 = function (i) {
            window.setTimeout(function () {
                started[i] = true;
            }, timeout);
            timeout += 80;
        };
        for (var i = 1; i < started.length; i++) {
            _loop_1(i);
        }
    };
    return HorizontalLinesAni;
}(ani_base_1.AniBase));
exports.HorizontalLinesAni = HorizontalLinesAni;
},{"./abstractions/ani-base":5,"./helpers/ani-helpers":7,"paper":4}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpinningArcsAnni = void 0;
var ani_base_1 = require("./abstractions/ani-base");
var paper_1 = __importDefault(require("paper"));
var ani_helpers_1 = require("./helpers/ani-helpers");
var SpinningArcsAnni = /** @class */ (function (_super) {
    __extends(SpinningArcsAnni, _super);
    function SpinningArcsAnni(element, arcs) {
        if (arcs === void 0) { arcs = 5; }
        var _this = _super.call(this, element) || this;
        _this._arcs = [];
        _this._arcsCount = 0;
        _this._arcsCount = arcs;
        _this.StartAni();
        return _this;
    }
    SpinningArcsAnni.prototype.CreateElements = function () {
        var color = new paper_1.default.Color('black');
        var center = ani_helpers_1.AniHelpers.GetCenterFromElement(this._element);
        var deg = 0;
        var degreesIncrement = (360 / this._arcsCount);
        var radius = this.Width >= this.Height ? (this.Width - 1) / 2 : (this.Height - 1) / 2;
        var radiusDecrement = radius / this._arcsCount;
        for (var i = 0; i < this._arcsCount; i++) {
            var start = new paper_1.default.Point(ani_helpers_1.AniHelpers.TransformCenter(center, ani_helpers_1.AniHelpers.GetPointOnCircle(radius, deg)));
            var middle = new paper_1.default.Point(ani_helpers_1.AniHelpers.TransformCenter(center, ani_helpers_1.AniHelpers.GetPointOnCircle(radius, deg + degreesIncrement / 2)));
            var end = new paper_1.default.Point(ani_helpers_1.AniHelpers.TransformCenter(center, ani_helpers_1.AniHelpers.GetPointOnCircle(radius, deg + degreesIncrement)));
            var arc = new paper_1.default.Path.Arc(start, middle, end);
            arc.strokeWidth = 1;
            arc.strokeColor = color;
            this._arcs.push(arc);
            deg += degreesIncrement / 2;
            radius -= radiusDecrement;
        }
    };
    SpinningArcsAnni.prototype.StartAni = function () {
        this.CreateElements();
        this.DoAnimation();
    };
    SpinningArcsAnni.prototype.DoAnimation = function () {
        var _this = this;
        var center = new paper_1.default.Point(ani_helpers_1.AniHelpers.GetCenterFromElement(this._element));
        window.setInterval(function () {
            for (var i = 0; i < _this._arcs.length; i++) {
                _this._arcs[i].rotate(8, center);
            }
        }, 16);
    };
    return SpinningArcsAnni;
}(ani_base_1.AniBase));
exports.SpinningArcsAnni = SpinningArcsAnni;
},{"./abstractions/ani-base":5,"./helpers/ani-helpers":7,"paper":4}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluLnRzIiwibm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4uanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsInNyYy9hYnN0cmFjdGlvbnMvYW5pLWJhc2UudHMiLCJzcmMvY29uY2VudHJpYy1hbmkudHMiLCJzcmMvaGVscGVycy9hbmktaGVscGVycy50cyIsInNyYy9ob3Jpem9udGFsLWxpbmVzLWFuaS50cyIsInNyYy9zcGlubmluZy1hcmNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQSx1REFBcUQ7QUFDckQsbUVBQWdFO0FBQ2hFLHFEQUF1RDtBQUV2RCxJQUFNLGFBQWEsR0FBRyxJQUFJLDhCQUFhLENBQWMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7QUFFbkcsSUFBTSxZQUFZLEdBQUcsSUFBSSxnQ0FBZ0IsQ0FBYyxRQUFRLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7QUFFaEcsSUFBTSxlQUFlLEdBQUcsSUFBSSx5Q0FBa0IsQ0FBYyxRQUFRLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQzs7QUNSeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xrS0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xqaUJBLGdEQUEwQjtBQUUxQjtJQWNFLGlCQUFZLE9BQW9CO1FBQzlCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGVBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFkRCxzQkFBYywwQkFBSzthQUFuQjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDNUIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBYywyQkFBTTthQUFwQjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDN0IsQ0FBQzs7O09BQUE7SUFVTyxrQ0FBZ0IsR0FBeEI7UUFDRSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUMvQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUNqRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxlQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFLSCxjQUFDO0FBQUQsQ0EvQkEsQUErQkMsSUFBQTtBQS9CcUIsMEJBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSDdCLG9EQUFrRDtBQUNsRCxnREFBMEI7QUFDMUIscURBQW1EO0FBRW5EO0lBQW1DLGlDQUFPO0lBR3hDLHVCQUFZLE9BQW9CO1FBQWhDLFlBQ0Usa0JBQU0sT0FBTyxDQUFDLFNBRWY7UUFMZ0IsY0FBUSxHQUF3QixFQUFFLENBQUM7UUFJbEQsS0FBSSxDQUFDLFFBQVEsRUFBRSxDQUFDOztJQUNsQixDQUFDO0lBRU8sc0NBQWMsR0FBdEI7UUFDRSxJQUFNLFNBQVMsR0FBVyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFckcsSUFBSSxhQUFhLEdBQVcsU0FBUyxDQUFDO1FBQ3RDLElBQU0sV0FBVyxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFMUQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxJQUFNLE1BQU0sR0FBMkIsd0JBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdEYsSUFBTSxLQUFLLEdBQWdCLElBQUksZUFBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakUsSUFBTSxNQUFNLEdBQXNCLElBQUksZUFBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzlFLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1lBRWpDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTNCLGFBQWEsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDO0lBRUgsQ0FBQztJQUVTLGdDQUFRLEdBQWxCO1FBQ0UsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVPLG1DQUFXLEdBQW5CLFVBQW9CLEtBQWE7UUFBakMsaUJBaUJDO1FBaEJDLElBQUksU0FBUyxHQUFrQixJQUFJLENBQUM7UUFFcEMsSUFBTSxRQUFRLEdBQVcsTUFBTSxDQUFDLFdBQVcsQ0FBQztZQUMxQyxJQUFJLFNBQVMsS0FBSyxJQUFJLEVBQUU7Z0JBQ3RCLEtBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxJQUFJLEdBQUcsQ0FBQztnQkFDeEMsSUFBSSxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7b0JBQzFDLFNBQVMsR0FBRyxNQUFNLENBQUM7aUJBQ3BCO2FBQ0Y7aUJBQU07Z0JBQ0wsS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDO2dCQUN4QyxJQUFJLEtBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxLQUFLLENBQUMsRUFBRTtvQkFDMUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUN4QixLQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDN0M7YUFDRjtRQUNILENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7SUFDSCxvQkFBQztBQUFELENBbkRBLEFBbURDLENBbkRrQyxrQkFBTyxHQW1EekM7QUFuRFksc0NBQWE7Ozs7O0FDSjFCO0lBQUE7SUFlQSxDQUFDO0lBZGUsK0JBQW9CLEdBQWxDLFVBQW1DLE9BQW9CO1FBQ3JELElBQU0sTUFBTSxHQUEyQixDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDM0YsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVhLDJCQUFnQixHQUE5QixVQUErQixNQUFjLEVBQUUsR0FBVztRQUN4RCxJQUFNLE9BQU8sR0FBVyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBRTlDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFYSwwQkFBZSxHQUE3QixVQUE4QixNQUE4QixFQUFFLEtBQTZCO1FBQ3pGLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQWZBLEFBZUMsSUFBQTtBQWZZLGdDQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0F2QixvREFBa0Q7QUFDbEQsZ0RBQTBCO0FBQzFCLHFEQUFtRDtBQUVuRDtJQUF3QyxzQ0FBTztJQUc3Qyw0QkFBWSxPQUFvQixFQUFFLEtBQWlCO1FBQWpCLHNCQUFBLEVBQUEsU0FBaUI7UUFBbkQsWUFDRSxrQkFBTSxPQUFPLENBQUMsU0FHZjtRQU5nQixZQUFNLEdBQXNCLEVBQUUsQ0FBQztRQUN4QyxpQkFBVyxHQUFHLENBQUMsQ0FBQztRQUd0QixLQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixLQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7O0lBQ2xCLENBQUM7SUFFTywyQ0FBYyxHQUF0QjtRQUNFLElBQU0sS0FBSyxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEQsSUFBTSxNQUFNLEdBQTJCLHdCQUFVLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXRGLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTNELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xELElBQUksS0FBSyxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqRSxJQUFJLEdBQUcsR0FBZ0IsSUFBSSxlQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1RSxJQUFJLElBQUksR0FBRyxJQUFJLGVBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztZQUN6QixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztZQUNyQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QjtJQUVILENBQUM7SUFFUyxxQ0FBUSxHQUFsQjtRQUNFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVTLHdDQUFXLEdBQXJCO1FBQUEsaUJBcUNDO1FBcENDLElBQU0sTUFBTSxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsd0JBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUU1RixJQUFNLFVBQVUsR0FBYSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFNLE9BQUEsQ0FBQyxFQUFELENBQUMsQ0FBQyxDQUFDO1FBQ3RELElBQU0sT0FBTyxHQUFjLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQU0sT0FBQSxLQUFLLEVBQUwsQ0FBSyxDQUFDLENBQUM7UUFFeEQsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUVsQixNQUFNLENBQUMsV0FBVyxDQUFDO1lBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7b0JBQ2IsT0FBTztnQkFDVCxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ3ZCLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDO29CQUU1QixJQUFJLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksRUFBRTt3QkFDakQsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDbkI7aUJBRUY7cUJBQU07b0JBQ0wsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBRTVCLElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFO3dCQUNsRCxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUNuQjtpQkFDRjthQUNGO1FBQ0gsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsSUFBSSxPQUFPLEdBQVcsRUFBRSxDQUFDO2dDQUNoQixDQUFDO1lBQ1IsTUFBTSxDQUFDLFVBQVUsQ0FBQztnQkFDaEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUNwQixDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUE7WUFDWCxPQUFPLElBQUksRUFBRSxDQUFDOztRQUpoQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7b0JBQTlCLENBQUM7U0FLVDtJQUVILENBQUM7SUFDSCx5QkFBQztBQUFELENBckVBLEFBcUVDLENBckV1QyxrQkFBTyxHQXFFOUM7QUFyRVksZ0RBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ovQixvREFBa0Q7QUFDbEQsZ0RBQTBCO0FBQzFCLHFEQUFtRDtBQUVuRDtJQUFzQyxvQ0FBTztJQUczQywwQkFBWSxPQUFvQixFQUFFLElBQWdCO1FBQWhCLHFCQUFBLEVBQUEsUUFBZ0I7UUFBbEQsWUFDRSxrQkFBTSxPQUFPLENBQUMsU0FHZjtRQU5nQixXQUFLLEdBQXFCLEVBQUUsQ0FBQztRQUN0QyxnQkFBVSxHQUFHLENBQUMsQ0FBQztRQUdyQixLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QixLQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7O0lBQ2xCLENBQUM7SUFFTyx5Q0FBYyxHQUF0QjtRQUNFLElBQU0sS0FBSyxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEQsSUFBTSxNQUFNLEdBQTJCLHdCQUFVLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3RGLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQztRQUNwQixJQUFJLGdCQUFnQixHQUFXLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RCxJQUFJLE1BQU0sR0FBVyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFOUYsSUFBSSxlQUFlLEdBQVcsTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFdkQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDaEQsSUFBTSxLQUFLLEdBQWdCLElBQUksZUFBSyxDQUFDLEtBQUssQ0FBQyx3QkFBVSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsd0JBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pILElBQU0sTUFBTSxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsd0JBQVUsQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLHdCQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakosSUFBTSxHQUFHLEdBQWdCLElBQUksZUFBSyxDQUFDLEtBQUssQ0FBQyx3QkFBVSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsd0JBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTFJLElBQU0sR0FBRyxHQUFtQixJQUFJLGVBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDbkUsR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7WUFDcEIsR0FBRyxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7WUFFeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDckIsR0FBRyxJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztZQUM1QixNQUFNLElBQUksZUFBZSxDQUFDO1NBQzNCO0lBQ0gsQ0FBQztJQUVTLG1DQUFRLEdBQWxCO1FBQ0UsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRVMsc0NBQVcsR0FBckI7UUFBQSxpQkFPQztRQU5DLElBQU0sTUFBTSxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsd0JBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM1RixNQUFNLENBQUMsV0FBVyxDQUFDO1lBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbEQsS0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ2pDO1FBQ0gsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0E5Q0EsQUE4Q0MsQ0E5Q3FDLGtCQUFPLEdBOEM1QztBQTlDWSw0Q0FBZ0IiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgeyBDb25jZW50cmljQW5pIH0gZnJvbSBcIi4vc3JjL2NvbmNlbnRyaWMtYW5pXCI7XHJcbmltcG9ydCB7IEhvcml6b250YWxMaW5lc0FuaSB9IGZyb20gXCIuL3NyYy9ob3Jpem9udGFsLWxpbmVzLWFuaVwiO1xyXG5pbXBvcnQgeyBTcGlubmluZ0FyY3NBbm5pIH0gZnJvbSBcIi4vc3JjL3NwaW5uaW5nLWFyY3NcIjtcclxuXHJcbmNvbnN0IGNvbmNlbnRyaWNBbmkgPSBuZXcgQ29uY2VudHJpY0FuaSg8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb25jZW50cmljQ2lyY2xlc1wiKSk7XHJcblxyXG5jb25zdCBzcGlubmluZ0FyY3MgPSBuZXcgU3Bpbm5pbmdBcmNzQW5uaSg8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzcGlubmluZ0FyY3NcIikpO1xyXG5cclxuY29uc3QgaG9yaXpvbnRhbExpbmVzID0gbmV3IEhvcml6b250YWxMaW5lc0FuaSg8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJob3Jpem9udGFsTGluZXNcIikpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5hY29ybiA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gUmVzZXJ2ZWQgd29yZCBsaXN0cyBmb3IgdmFyaW91cyBkaWFsZWN0cyBvZiB0aGUgbGFuZ3VhZ2VcblxuICB2YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogXCJlbnVtXCIsXG4gICAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbiAgfTtcblxuICAvLyBBbmQgdGhlIGtleXdvcmRzXG5cbiAgdmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxuICB2YXIga2V5d29yZHMgPSB7XG4gICAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gICAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgfTtcblxuICB2YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4gIC8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbiAgLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4gIC8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4gIC8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbiAgLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG4gIC8vIEdlbmVyYXRlZCBieSBgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YzdcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNC1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmZcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYmZcXHU0ZTAwLVxcdTlmZmNcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjYVxcdWE3ZjUtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjlcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgxLVxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWFiZlxcdTFhYzBcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAvLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4gIC8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbiAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLiBUaGV5IHdlcmVcbiAgLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSwzNDksNDEsNywxLDc5LDI4LDExLDAsOSwyMSwxMDcsMjAsMjgsMjIsMTMsNTIsNzYsNDQsMzMsMjQsMjcsMzUsMzAsMCwzLDAsOSwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMywyMSwyLDMxLDQ3LDIxLDEsMiwwLDE4NSw0Niw0MiwzLDM3LDQ3LDIxLDAsNjAsNDIsMTQsMCw3MiwyNiwyMzAsNDMsMTE3LDYzLDMyLDcsMywwLDMsNywyLDEsMiwyMywxNiwwLDIsMCw5NSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMTkwLDAsODAsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsNjg5LDYzLDEyOSw3NCw2LDAsNjcsMTIsNjUsMSwyLDAsMjksNjEzNSw5LDEyMzcsNDMsOCw4OTUyLDI4Niw1MCwyLDE4LDMsOSwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsMjM1Nyw0NCwxMSw2LDE3LDAsMzcwLDQzLDEzMDEsMTk2LDYwLDY3LDgsMCwxMjA1LDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzE3LDM1LDQxNDgsMTIsMjIxLDMsNTc2MSwxNSw3NDcyLDMxMDQsNTQxLDE1MDcsNDkzOF07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksMzcwLDEsMTU0LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsMiwxMSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTYsMSwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw1LDAsODIsMTksMTMsOSwyMTQsNiwzLDgsMjgsMSw4MywxNiwxNiw5LDgyLDEyLDksOSw4NCwxNCw1LDksMjQzLDE0LDE2Niw5LDcxLDUsMiwxLDMsMywyLDAsMiwxLDEzLDksMTIwLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsODIsMCwxMiwxLDE5NjI4LDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjYyLDYsMTAsOSw0MTksMTMsMTQ5NSw2LDExMCw2LDYsOSw0NzU5LDksNzg3NzE5LDIzOV07XG5cbiAgLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuICAvLyBhc3N1bXB0aW9uIGlzIHRoYXQgbG9va2luZyB1cCBhc3RyYWwgaWRlbnRpZmllciBjaGFyYWN0ZXJzIGlzXG4gIC8vIHJhcmUuXG4gIGZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gICAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHBvcyArPSBzZXRbaV07XG4gICAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICAgIGlmIChjb2RlIDwgNTgpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gICAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2RlcylcbiAgfVxuXG4gIC8vICMjIFRva2VuIHR5cGVzXG5cbiAgLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbiAgLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4gIC8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4gIC8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuICAvLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuICAvLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuICAvLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4gIC8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4gIC8vXG4gIC8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4gIC8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbiAgLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbiAgLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4gIC8vXG4gIC8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuICAvLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuICAvLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG4gIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbiAgfVxuICB2YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuICAvLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxuICB2YXIga2V5d29yZHMkMSA9IHt9O1xuXG4gIC8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbiAgZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0eXBlcyA9IHtcbiAgICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gICAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBxdWVzdGlvbkRvdDogbmV3IFRva2VuVHlwZShcIj8uXCIpLFxuICAgIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gICAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gICAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gICAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gICAgLy9cbiAgICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgICAvL1xuICAgIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gICAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gICAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIGNvYWxlc2NlOiBiaW5vcChcIj8/XCIsIDEpLFxuXG4gICAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICAgIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gICAgX2lmOiBrdyhcImlmXCIpLFxuICAgIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICAgIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgICBfdmFyOiBrdyhcInZhclwiKSxcbiAgICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gICAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gICAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gICAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gICAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gICAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG4gIH07XG5cbiAgLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuICAvLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG4gIHZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUsIGVjbWEyMDE5U3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8ICghZWNtYTIwMTlTdHJpbmcgJiYgKGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjkpKVxuICB9XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuICB2YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxuICB2YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gcmVmLmhhc093blByb3BlcnR5O1xuICB2YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbiAgLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG4gIH1cblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICApOyB9KTtcblxuICBmdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG4gIH1cblxuICAvLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbiAgLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxuICB2YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxuICB9O1xuXG4gIC8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbiAgLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3VcbiAgLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuICAvLyBpbnRvLlxuXG4gIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgKytsaW5lO1xuICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEEgc2Vjb25kIG9wdGlvbmFsIGFyZ3VtZW50IGNhbiBiZSBnaXZlbiB0byBmdXJ0aGVyIGNvbmZpZ3VyZVxuICAvLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgICAvLyBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIG9yIDEwXG4gICAgLy8gKDIwMTkpLiBUaGlzIGluZmx1ZW5jZXMgc3VwcG9ydCBmb3Igc3RyaWN0IG1vZGUsIHRoZSBzZXQgb2ZcbiAgICAvLyByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnQgZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuIFRoZSBkZWZhdWx0XG4gICAgLy8gaXMgMTAuXG4gICAgZWNtYVZlcnNpb246IDEwLFxuICAgIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgICAvLyBDYW4gYmUgZWl0aGVyIGBcInNjcmlwdFwiYCBvciBgXCJtb2R1bGVcImAuIFRoaXMgaW5mbHVlbmNlcyBnbG9iYWxcbiAgICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgLy8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gIGNhbiBiZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWRcbiAgICAvLyB3aGVuIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkXG4gICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tYSBhcyBhbiBvZmZzZXQsIGFuZCBpZiBgbG9jYXRpb25zYCBpc1xuICAgIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gICAgLy8gYXMgc2Vjb25kIGFyZ3VtZW50LlxuICAgIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gICAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgICAvLyB0cmFpbGluZyBjb21tYXMuXG4gICAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAgIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gICAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gICAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICAgIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gICAgLy8gZXJyb3IuXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gICAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gICAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAgIC8vIG5vZGVzLlxuICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gICAgLy8gdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZVxuICAgIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAgIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAgIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gICAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gICAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gICAgLy8gYHRydWVgLlxuICAgIC8vXG4gICAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAgIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAgIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gICAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAgIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAgIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG4gIC8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KVxuICAgICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVhY2ggc2NvcGUgZ2V0cyBhIGJpdHNldCB0aGF0IG1heSBjb250YWluIHRoZXNlIGZsYWdzXG4gIHZhclxuICAgICAgU0NPUEVfVE9QID0gMSxcbiAgICAgIFNDT1BFX0ZVTkNUSU9OID0gMixcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OLFxuICAgICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjg7XG5cbiAgZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIFNDT1BFX0ZVTkNUSU9OIHwgKGFzeW5jID8gU0NPUEVfQVNZTkMgOiAwKSB8IChnZW5lcmF0b3IgPyBTQ09QRV9HRU5FUkFUT1IgOiAwKVxuICB9XG5cbiAgLy8gVXNlZCBpbiBjaGVja0xWYWwgYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbiAgdmFyXG4gICAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgICBCSU5EX1ZBUiA9IDEsIC8vIFZhci1zdHlsZSBiaW5kaW5nXG4gICAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCAvLyBTaW1wbGUgKGlkZW50aWZpZXIgcGF0dGVybikgY2F0Y2ggYmluZGluZ1xuICAgICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gICAgLy8gSXRzIHR5cGVcbiAgICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gICAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gICAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAgIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgaXQncyBhIG1vZHVsZSBjb2RlLlxuICAgIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmlmeSB0aGUgc3RhcnQgb2YgYSBwb3RlbnRpYWwgYXJyb3cgZnVuY3Rpb25cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAvLyBUaHVzLWZhciB1bmRlZmluZWQgZXhwb3J0cy5cbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAgIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuICAvLyBTd2l0Y2ggdG8gYSBnZXR0ZXIgZm9yIDcuMC4wLlxuICBQYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBjbHMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgICByZXR1cm4gY2xzXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gICAgcGFyc2VyLm5leHRUb2tlbigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbiAgfTtcblxuICBQYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXFxcXF0pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXFxcXF0pKj8pXCIpLztcbiAgcHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgc3BhY2VBZnRlciA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCksIGVuZCA9IHNwYWNlQWZ0ZXIuaW5kZXggKyBzcGFjZUFmdGVyWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJBdChlbmQpO1xuICAgICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgICAobGluZUJyZWFrLnRlc3Qoc3BhY2VBZnRlclswXSkgJiZcbiAgICAgICAgICAgISgvWyhgLlsrXFwtLyolPD49LD9eJl0vLnRlc3QobmV4dCkgfHwgbmV4dCA9PT0gXCIhXCIgJiYgdGhpcy5pbnB1dC5jaGFyQXQoZW5kICsgMSkgPT09IFwiPVwiKSlcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgLy8gU2tpcCBzZW1pY29sb24sIGlmIGFueS5cbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5pbnB1dFtzdGFydF0gPT09IFwiO1wiKVxuICAgICAgICB7IHN0YXJ0Kys7IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbiAgLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxuICBwcC5lYXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbiAgcHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xuICB9O1xuXG4gIC8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxuICBwcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICAvLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG4gIHBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmVvZiB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICBwcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4gIC8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG4gIHBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgICBpZiAoIW5vdE5leHQpXG4gICAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbiAgLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH07XG5cbiAgLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgICAtMTtcbiAgfVxuXG4gIHBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gICAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gICAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG4gIH07XG5cbiAgdmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4gIC8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuICAvLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuICAvLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4gIC8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxuICBwcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluTW9kdWxlKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9IH1cbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxuICB9O1xuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBwcCQxLmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAvLyBGb3IgYW1iaWd1b3VzIGNhc2VzLCBkZXRlcm1pbmUgaWYgYSBMZXhpY2FsRGVjbGFyYXRpb24gKG9yIG9ubHkgYVxuICAgIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgICAvLyBpcyBhbGxvd2VkLiBIb3dldmVyLCBgbGV0IFtgIGlzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIGxvb2thaGVhZCBmb3JcbiAgICAvLyBFeHByZXNzaW9uU3RhdGVtZW50LCBzbyBzcGVjaWFsLWNhc2UgaXQgZmlyc3QuXG4gICAgaWYgKG5leHRDaCA9PT0gOTEpIHsgcmV0dXJuIHRydWUgfSAvLyAnWydcbiAgICBpZiAoY29udGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHRDaCwgdHJ1ZSkpIHtcbiAgICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbiAgLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4gIC8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG4gIHBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICAgIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8ICFpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckF0KG5leHQgKyA4KSkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuICAvL1xuICAvLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuICAvLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgcHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICAgIGtpbmQgPSBcImxldFwiO1xuICAgIH1cblxuICAgIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gICAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gICAgLy8gY29tcGxleGl0eS5cblxuICAgIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5fYnJlYWs6IGNhc2UgdHlwZXMuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gICAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIC8vIEZ1bmN0aW9uIGFzIHNvbGUgYm9keSBvZiBlaXRoZXIgYW4gaWYgc3RhdGVtZW50IG9yIGEgbGFiZWxlZCBzdGF0ZW1lbnRcbiAgICAgIC8vIHdvcmtzLCBidXQgbm90IHdoZW4gaXQgaXMgcGFydCBvZiBhIGxhYmVsZWQgc3RhdGVtZW50IHRoYXQgaXMgdGhlIHNvbGVcbiAgICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KVxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fY29uc3Q6IGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9leHBvcnQ6XG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCkge1xuICAgICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgICAgaWYgKG5leHRDaCA9PT0gNDAgfHwgbmV4dENoID09PSA0NikgLy8gJygnIG9yICcuJ1xuICAgICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIHRoaXMucGFyc2VFeHByZXNzaW9uKCkpIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICAgIGlmICghdG9wTGV2ZWwpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IG1vZHVsZSdcIik7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT09IFwiYnJlYWtcIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5fd2hpbGUpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IHRoaXMuZWF0KHR5cGVzLnNlbWkpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4gIC8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuICAvLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuICAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4gIC8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbiAgLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbiAgLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbiAgcHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSkge1xuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gICAgfVxuICAgIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgICAgfVxuICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfTtcblxuICBwcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jLCBkZWNsYXJhdGlvblBvc2l0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbiAgfTtcblxuICBwcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gICAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAgIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAgIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAgIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gICAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVI7KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpOyB9XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxuICB2YXIgZW1wdHkgPSBbXTtcblxuICBwcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgICAgICB2YXIgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICAgIH1cbiAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMubGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICAgIGlmIChsYWJlbC5uYW1lID09PSBtYXliZU5hbWUpXG4gICAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgIH0gfVxuICAgIHZhciBraW5kID0gdGhpcy50eXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdGhpcy50eXBlID09PSB0eXBlcy5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2VcbiAgLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3JcbiAgLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxuICBwcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmIChleGl0U3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gZmFsc2U7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbiAgLy8gYHBhcnNlU3RhdGVtZW50YCB3aWxsIGFscmVhZHkgaGF2ZSBwYXJzZWQgdGhlIGluaXQgc3RhdGVtZW50IG9yXG4gIC8vIGV4cHJlc3Npb24uXG5cbiAgcHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gIHBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKFxuICAgICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmXG4gICAgICAoXG4gICAgICAgICFpc0ZvckluIHx8XG4gICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHxcbiAgICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnJhaXNlKFxuICAgICAgICBpbml0LnN0YXJ0LFxuICAgICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxuICBwcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbiAgLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4gIC8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG4gIHBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9O1xuXG4gICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gICAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIHJldHVybiBtZXRob2RcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH07XG5cbiAgLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLl9kZWZhdWx0KSkgeyAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgIHZhciBpc0FzeW5jO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uIHx8IChpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgRlVOQ19OVUxMQUJMRV9JRCwgZmFsc2UsIGlzQXN5bmMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jbGFzcykge1xuICAgICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgICAgdGhpcy5jaGVja0xvY2FsRXhwb3J0KHNwZWMubG9jYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgaWYgKGhhcyhleHBvcnRzLCBuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICBwcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICAgIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG4gIH07XG5cbiAgcHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG4gIHBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICAvLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gaW1wb3J0ICcuLi4nXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbiAgcHAkMS5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgICAgbm9kZSQxLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlJDIuaW1wb3J0ZWQpO1xuICAgICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlJDIubG9jYWwsIEJJTkRfTEVYSUNBTCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzXG4gIH07XG5cbiAgLy8gU2V0IGBFeHByZXNzaW9uU3RhdGVtZW50I2RpcmVjdGl2ZWAgcHJvcGVydHkgZm9yIGRpcmVjdGl2ZSBwcm9sb2d1ZXMuXG4gIHBwJDEuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gIH07XG4gIHBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgICAgdHlwZW9mIHN0YXRlbWVudC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgICApXG4gIH07XG5cbiAgdmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuICAvLyBpZiBwb3NzaWJsZS5cblxuICBwcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZyk7XG4gICAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgICAgLy8gICBBc3NpZ25tZW50UmVzdFByb3BlcnR5W1lpZWxkLCBBd2FpdF0gOlxuICAgICAgICAgIC8vICAgICBgLi4uYCBEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldFtZaWVsZCwgQXdhaXRdXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIHxEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldHwgaXMgYW4gfEFycmF5TGl0ZXJhbHwgb3IgYW4gfE9iamVjdExpdGVyYWx8LlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG4gIHBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gICAgfVxuICAgIHJldHVybiBleHByTGlzdFxuICB9O1xuXG4gIC8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxuICBwcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgICBlbHNlIHsgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgfTtcblxuICAvLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4gIC8vIHRvLlxuICAvLyBiaW5kaW5nVHlwZSBjYW4gYmUgZWl0aGVyOlxuICAvLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbiAgLy8gJ2xldCcgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSBsZXhpY2FsICgnbGV0JyBvciAnY29uc3QnKSBiaW5kaW5nXG4gIC8vICdub25lJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGJpbmRpbmcgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIGlsbGVnYWwgaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGR1cGxpY2F0ZSByZWZlcmVuY2VzXG5cbiAgcHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUgJiYgYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLnZhbHVlLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbChlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuXG4gIHZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKVxuICAgICAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7IH1cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXQga2x1ZGdlLiBDYW4gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMFxuICAgICAgICAgIH0gZWxzZSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICAgIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICAgIGlmIChvdGhlcikge1xuICAgICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgICByZWRlZmluaXRpb24gPSB0aGlzLnN0cmljdCAmJiBvdGhlci5pbml0IHx8IG90aGVyLmdldCB8fCBvdGhlci5zZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgICAgfVxuICAgICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgICAgc2V0OiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgb3RoZXJba2luZF0gPSB0cnVlO1xuICB9O1xuXG4gIC8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuICAvLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbiAgLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2ZcbiAgLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4gIC8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4gIC8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuICAvLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuICAvLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuICAvLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbiAgLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4gIC8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2VcbiAgLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbiAgcHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQobm9JbikgfVxuICAgICAgLy8gVGhlIHRva2VuaXplciB3aWxsIGFzc3VtZSBhbiBleHByZXNzaW9uIGlzIGFsbG93ZWQgYWZ0ZXJcbiAgICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICAgIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPj0gbm9kZS5sZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgfVxuICAgIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gICAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICAvLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG4gIHBwJDMucGFyc2VNYXliZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfTtcblxuICAvLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgbm9JbilcbiAgfTtcblxuICAvLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuICAvLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuICAvLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbiAgLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuICAvLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0eXBlcy5faW4pKSB7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuY29hbGVzY2U7XG4gICAgICAgIGlmIChjb2FsZXNjZSkge1xuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgcHJlY2VkZW5jZSBvZiBgdHQuY29hbGVzY2VgIGFzIGVxdWFsIHRvIHRoZSByYW5nZSBvZiBsb2dpY2FsIGV4cHJlc3Npb25zLlxuICAgICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCBgbm9kZS5yaWdodGAgc2hvdWxkbid0IGNvbnRhaW4gbG9naWNhbCBleHByZXNzaW9ucyBpbiBvcmRlciB0byBjaGVjayB0aGUgbWl4ZWQgZXJyb3IuXG4gICAgICAgICAgcHJlYyA9IHR5cGVzLmxvZ2ljYWxBTkQuYmlub3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsIHx8IGNvYWxlc2NlKTtcbiAgICAgICAgaWYgKChsb2dpY2FsICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29hbGVzY2UpIHx8IChjb2FsZXNjZSAmJiAodGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJMb2dpY2FsIGV4cHJlc3Npb25zIGFuZCBjb2FsZXNjZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgbWl4ZWQuIFdyYXAgZWl0aGVyIGJ5IHBhcmVudGhlc2VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdFxuICB9O1xuXG4gIHBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5vcGVyYXRvciA9IG9wO1xuICAgIG5vZGUucmlnaHQgPSByaWdodDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG4gIHBwJDMucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpKSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgICBzYXdVbmFyeSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuaW5jRGVjO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgICBub2RlJDEucHJlZml4ID0gZmFsc2U7XG4gICAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIFwiKipcIiwgZmFsc2UpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgfTtcblxuICAvLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxuICBwcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICAgIHsgcmV0dXJuIGV4cHIgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHQgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdywgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgdmFyIG9wdGlvbmFsU3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBvcHRpb25hbCA9IG9wdGlvbmFsU3VwcG9ydGVkICYmIHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKTtcbiAgICBpZiAoY29tcHV0ZWQgfHwgKG9wdGlvbmFsICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIik7XG4gICAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICAgIGlmIChjb21wdXRlZCkgeyB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7IH1cbiAgICAgIGlmIChvcHRpb25hbFN1cHBvcnRlZCkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXdhaXRJZGVudFBvcyA+IDApXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICAgIGlmIChvcHRpb25hbFN1cHBvcnRlZCkge1xuICAgICAgICBub2RlJDEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICAgIGlmIChvcHRpb25hbCB8fCBvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRhZyBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbnNcIik7XG4gICAgICB9XG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBiYXNlXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4gIC8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4gIC8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuICAvLyBvciBge31gLlxuXG4gIHBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gICAgdmFyIG5vZGUsIGNhbkJlQXJyb3cgPSB0aGlzLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhcnQ7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIGtleXdvcmQgb3V0c2lkZSBhIG1ldGhvZFwiKTsgfVxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyICggQXJndW1lbnRzIClcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRcblxuICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgICByZXR1cm4gbm9kZVxuXG4gICAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcblxuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMuc3RhcnROb2RlKCksIGZhbHNlKVxuXG4gICAgY2FzZSB0eXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSB0eXBlcy5iYWNrUXVvdGU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHBySW1wb3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRXhwckltcG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgICAvLyBCZWNhdXNlIGB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlgIGRvZXNuJ3QgY2hlY2sgZXNjYXBlIHNlcXVlbmNlcywgaXQgbmVlZHMgdGhlIGNoZWNrIG9mIGB0aGlzLmNvbnRhaW5zRXNjYC5cbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnRcIik7IH1cbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLmRvdDpcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGEobm9kZSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpOyAvLyBza2lwIGAoYFxuXG4gICAgLy8gUGFyc2Ugbm9kZS5zb3VyY2UuXG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcblxuICAgIC8vIFZlcmlmeSBlbmRpbmcuXG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICB2YXIgZXJyb3JQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShlcnJvclBvcywgXCJUcmFpbGluZyBjb21tYSBpcyBub3QgYWxsb3dlZCBpbiBpbXBvcnQoKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChlcnJvclBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlSW1wb3J0TWV0YSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgLmBcblxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwibWV0YVwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBpbXBvcnQgaXMgJ2ltcG9ydC5tZXRhJ1wiKTsgfVxuICAgIGlmIChjb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ2ltcG9ydC5tZXRhJyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlVHlwZSAhPT0gXCJtb2R1bGVcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnaW1wb3J0Lm1ldGEnIG91dHNpZGUgYSBtb2R1bGVcIik7IH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIGlmIChub2RlLnJhdy5jaGFyQ29kZUF0KG5vZGUucmF3Lmxlbmd0aCAtIDEpID09PSAxMTApIHsgbm9kZS5iaWdpbnQgPSBub2RlLnJhdy5zbGljZSgwLCAtMSkucmVwbGFjZSgvXy9nLCBcIlwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgdmFsLCBhbGxvd1RyYWlsaW5nQ29tbWEgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gODtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICB2YXIgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbiAgfTtcblxuICAvLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbiAgLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuICAvLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuICAvLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbiAgLy8gYXJndW1lbnQgbGlzdC5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXdcIik7IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzICduZXcudGFyZ2V0J1wiKTsgfVxuICAgICAgaWYgKGNvbnRhaW5zRXNjKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVyc1wiKTsgfVxuICAgICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGlzSW1wb3J0ID0gdGhpcy50eXBlID09PSB0eXBlcy5faW1wb3J0O1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gICAgaWYgKGlzSW1wb3J0ICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXJ0UG9zLCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KClcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICAgIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgICAgfVxuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgICBjb29rZWQ6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gICAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICAgIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmRvbGxhckJyYWNlTCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwcm9wLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG4gIHBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgICAgfVxuICAgICAgLy8gVG8gZGlzYWxsb3cgcGFyZW50aGVzaXplZCBpZGVudGlmaWVyIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKSB7XG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFBhcnNlIGFyZ3VtZW50LlxuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICAvLyBGaW5pc2hcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCkge1xuICAgICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcy5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmVxKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICAgIHJldHVybiBwcm9wLmtleVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG4gIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG4gIC8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbiAgcHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbiAgcHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxuICBwcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgICB9XG4gICAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSwgdW5kZWZpbmVkLCB1c2VTdHJpY3QgJiYgIW9sZFN0cmljdCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgfTtcblxuICBwcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICAgIH0gfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbiAgLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbiAgcHAkMy5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBuYW1lSGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuICAvLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuICAvLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4gIC8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuICAvLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG4gIHBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMy5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gICAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gICAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIG5leHQgdG9rZW4gYXMgYW4gaWRlbnRpZmllci4gSWYgYGxpYmVyYWxgIGlzIHRydWUgKHVzZWRcbiAgLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4gIC8vIGlkZW50aWZpZXJzLlxuXG4gIHBwJDMucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwsIGlzQmluZGluZykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgICAgLy8gYGNsYXNzYCBhbmQgYGZ1bmN0aW9uYCBrZXl3b3JkcyBwdXNoIG5ldyBjb250ZXh0IGludG8gdGhpcy5jb250ZXh0LlxuICAgICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCEhbGliZXJhbCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIWxpYmVyYWwpIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gbm9kZS5zdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIFBhcnNlcyB5aWVsZCBleHByZXNzaW9uIGluc2lkZSBnZW5lcmF0b3IuXG5cbiAgcHAkMy5wYXJzZVlpZWxkID0gZnVuY3Rpb24obm9Jbikge1xuICAgIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgdmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbiAgLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbiAgLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4gIC8vIG1lc3NhZ2UuXG5cbiAgcHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICAgIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICAgIHRocm93IGVyclxuICB9O1xuXG4gIHBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbiAgcHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMudmFyID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy5sZXhpY2FsID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICB9O1xuXG4gIC8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxuICBwcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xuICB9O1xuXG4gIHBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbiAgLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxuICBwcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbiAgfTtcblxuICBwcCQ1LmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxuICB9O1xuXG4gIHBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxuICBwcCQ1LmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgdmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbiAgcHAkNi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuICAvLyBUaGUgYWxnb3JpdGhtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSByZWdleHAgY2FuIGFwcGVhciBhdCBhXG5cbiAgdmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG4gIH07XG5cbiAgdmFyIHR5cGVzJDEgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG4gIH07XG5cbiAgcHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZl9zdGF0KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG4gIH07XG5cbiAgcHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFtpXTtcbiAgICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gICAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbiAgfTtcblxuICAvLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbiAgdHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gICAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgICAgeyB0aGlzLmNvbnRleHQucG9wKCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG4gIH07XG5cbiAgLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdFxuICAvLyBzcGVjaWZpY2F0aW9uLiBUaGUgbGlzdHMgYXJlIGV4dHJhY3RlZCBsaWtlIHNvOlxuICAvLyAkJCgnI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMgPiBmaWd1cmUgPiB0YWJsZSA+IHRib2R5ID4gdHIgPiB0ZDpudGgtY2hpbGQoMSkgY29kZScpLm1hcChlbCA9PiBlbC5pbm5lclRleHQpXG5cbiAgLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbiAgdmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG4gIHZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG4gIHZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIC8vICN0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXG4gIHZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbiAgLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xuICB2YXIgZWNtYTlTY3JpcHRWYWx1ZXMgPSBcIkFkbGFtIEFkbG0gQWhvbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG4gIHZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG4gIHZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbiAgdmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gICAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gICAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgICAxMTogZWNtYTExU2NyaXB0VmFsdWVzXG4gIH07XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICAgIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBub25CaW5hcnk6IHtcbiAgICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgICB9XG4gICAgfTtcbiAgICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICAgIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbiAgfVxuICBidWlsZFVuaWNvZGVEYXRhKDkpO1xuICBidWlsZFVuaWNvZGVEYXRhKDEwKTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMSk7XG5cbiAgdmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gICAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgPyAxMSA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbiAgfTtcblxuICAvLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuICAvLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gICAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGksIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiBsXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gaSArIDFcbiAgICB9XG4gICAgcmV0dXJuIGkgKyAyXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcywgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkIChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpLCBmb3JjZVUpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50KGZvcmNlVSkgPT09IGNoKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoZm9yY2VVKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNoKSB7XG4gICAgaWYgKGNoIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgfVxuICAgIGNoIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNoID4+IDEwKSArIDB4RDgwMCwgKGNoICYgMHgwM0ZGKSArIDB4REMwMClcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgZmxhZ3MgcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHBwJDgudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICAgIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBwYXR0ZXJuIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcCQ4LnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG5cbiAgICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAgIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAgIC8vIHxQYXR0ZXJuW35VLCArTl18IGFuZCB1c2UgdGhpcyByZXN1bHQgaW5zdGVhZC4gVGhyb3cgYSAqU3ludGF4RXJyb3IqXG4gICAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxuICBwcCQ4LnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5wb3MgPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICAgIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIF0gKi8pIHx8IHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURpc2p1bmN0aW9uXG4gIHBwJDgucmVnZXhwX2Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbiAgcHAkOC5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKVxuICAgICAgeyB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLVRlcm1cbiAgcHAkOC5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uIFF1YW50aWZpZXJgIGFsdGVybmF0aXZlLlxuICAgICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG4gIHBwJDgucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gXiwgJFxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBcXGIgXFxCXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDQyIC8qIEIgKi8pIHx8IHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pICYmIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbiAgcHAkOC5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyQiAvKiArICovKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gICAgKVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgICAgLy8gU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy10ZXJtXG4gICAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbiAgcHAkOC5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSAmJiBzdGF0ZS5lYXQoMHgzQSAvKiA6ICovKSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbiAgcHAkOC5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtU3ludGF4Q2hhcmFjdGVyXG4gIHBwJDgucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDI0IC8qICQgKi8gfHxcbiAgICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICAgIGNoID09PSAweDNGIC8qID8gKi8gfHxcbiAgICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgICApXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4gIC8vIEJ1dCBlYXQgZWFnZXIuXG4gIHBwJDgucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXJcbiAgcHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKFxuICAgICAgY2ggIT09IC0xICYmXG4gICAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgICAhKGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8pICYmXG4gICAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHg1QiAvKiBbICovICYmXG4gICAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICAgKSB7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBHcm91cFNwZWNpZmllciA6OlxuICAvLyAgIFtlbXB0eV1cbiAgLy8gICBgP2AgR3JvdXBOYW1lXG4gIHBwJDgucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBHcm91cE5hbWUgOjpcbiAgLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWUgYD5gXG4gIC8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxuICBwcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFIC8qID4gKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZWdFeHBJZGVudGlmaWVyTmFtZSA6OlxuICAvLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFxuICAvLyAgIFJlZ0V4cElkZW50aWZpZXJOYW1lIFJlZ0V4cElkZW50aWZpZXJQYXJ0XG4gIC8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0IDo6XG4gIC8vICAgVW5pY29kZUlEU3RhcnRcbiAgLy8gICBgJGBcbiAgLy8gICBgX2BcbiAgLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGZvcmNlVSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gICAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gICAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZm9yY2VVKSkge1xuICAgICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xuICB9XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllclBhcnQgOjpcbiAgLy8gICBVbmljb2RlSURDb250aW51ZVxuICAvLyAgIGAkYFxuICAvLyAgIGBfYFxuICAvLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxuICAvLyAgIDxaV05KPlxuICAvLyAgIDxaV0o+XG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGZvcmNlVSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gICAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gICAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZm9yY2VVKSkge1xuICAgICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqLyB8fCBjaCA9PT0gMHgyMDBDIC8qIDxaV05KPiAqLyB8fCBjaCA9PT0gMHgyMDBEIC8qIDxaV0o+ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxuICBwcCQ4LnJlZ2V4cF9lYXRBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgICBpZiAobiA+IHN0YXRlLm1heEJhY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEtHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg2QiAvKiBrICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DaGFyYWN0ZXJFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0WmVybyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA9PT0gMHg3NCAvKiB0ICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyAvKiBcXG4gKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2NiAvKiBmICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyAvKiBcXHIgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xMZXR0ZXJcbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg1QSAvKiBaICovKSB8fFxuICAgICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIHN3aXRjaFUgPSBmb3JjZVUgfHwgc3RhdGUuc3dpdGNoVTtcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pICYmIHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN3aXRjaFUgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSAmJlxuICAgICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICAgIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSWRlbnRpdHlFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDJGIC8qIC8gKi8pKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA+PSAweDMxIC8qIDEgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICAgIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgICAoY2ggPT09IDB4NTAgLyogUCAqLyB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICAgICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4NjQgLyogZCAqLyB8fFxuICAgICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgICAgY2ggPT09IDB4NzMgLyogcyAqLyB8fFxuICAgICAgY2ggPT09IDB4NTMgLyogUyAqLyB8fFxuICAgICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgICAgY2ggPT09IDB4NTcgLyogVyAqL1xuICAgIClcbiAgfVxuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gIC8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgLyogPSAqLykpIHtcbiAgICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gICAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaGFzKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbbmFtZV0udGVzdCh2YWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxuICB9O1xuICBwcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gICAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpXG4gICAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIH07XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXJzXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG4gIH1cblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkOC5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NcbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgICAgc3RhdGUuZWF0KDB4NUUgLyogXiAqLyk7XG4gICAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIC8vIFVucmVhY2hhYmxlIHNpbmNlIGl0IHRocmV3IFwidW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiIGVycm9yIGJlZm9yZS5cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gIHBwJDgucmVnZXhwX2NsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIChsZWZ0ID09PSAtMSB8fCByaWdodCA9PT0gLTEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2xhc3MgZXNjYXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDVEIC8qIF0gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQ4LnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG4gIHBwJDgucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbiAgcHAkOC5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICAgIClcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICAgIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gICAgfVxuICAgIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gICAgfVxuICAgIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2VcbiAgLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG4gIHBwJDgucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbiAgcHAkOC5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4gIC8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxuICBwcCQ4LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbiAgLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuICAvLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcC5lbmQ7XG4gICAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxuICB9O1xuXG4gIC8vICMjIFRva2VuaXplclxuXG4gIHZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbiAgcHAkOS5uZXh0ID0gZnVuY3Rpb24oaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQpIHtcbiAgICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgdGhpcy50eXBlLmtleXdvcmQpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuZXcgVG9rZW4odGhpcylcbiAgfTtcblxuICAvLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7IHBwJDlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEuZ2V0VG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgfVxuXG4gIC8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2VcbiAgLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG4gIHBwJDkuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4gIC8vIHByb3BlcnRpZXMuXG5cbiAgcHAkOS5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gICAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHsgcmV0dXJuIGN1ckNvbnRleHQub3ZlcnJpZGUodGhpcykgfVxuICAgIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gICAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfTtcblxuICBwcCQ5LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZTAwMCkgeyByZXR1cm4gY29kZSB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxuICB9O1xuXG4gIHBwJDkuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcyArPSAyKTtcbiAgICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICAgIHRoaXMucG9zID0gZW5kICsgMjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5wb3MpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgcHAkOS5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgcHAkOS5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBsb29wOiB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMzI6IGNhc2UgMTYwOiAvLyAnICdcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSkge1xuICAgICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuICAvLyBtYWludGFpbnMgYGNvbnRleHRgIGFuZCBgZXhwckFsbG93ZWRgLCBhbmQgc2tpcHMgdGhlIHNwYWNlIGFmdGVyXG4gIC8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4gIC8vIHJpZ2h0IHBvc2l0aW9uLlxuXG4gIHBwJDkuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gIH07XG5cbiAgLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbiAgLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4gIC8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4gIC8vIGludG8gaXQuXG4gIC8vXG4gIC8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbiAgLy9cbiAgcHAkOS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb3QpXG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcblxuICAgIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgICsrc2l6ZTtcbiAgICAgIHRva2VudHlwZSA9IHR5cGVzLnN0YXJzdGFyO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnfCYnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgaWYgKG5leHQyID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDMpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbHVzTWluLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0U2hpZnQsIHNpemUpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCBzaXplKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3F1ZXN0aW9uID0gZnVuY3Rpb24oKSB7IC8vICc/J1xuICAgIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTEpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA8IDQ4IHx8IG5leHQyID4gNTcpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucXVlc3Rpb25Eb3QsIDIpIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgICBpZiAoZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgICB2YXIgbmV4dDIkMSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDMpIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5jb2FsZXNjZSwgMilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucXVlc3Rpb24sIDEpXG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gICAgY2FzZSA0NjogLy8gJy4nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KClcblxuICAgIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gICAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gICAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuXG4gICAgY2FzZSA5NjogLy8gJ2AnXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gICAgY2FzZSA0ODogLy8gJzAnXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAgIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gICAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgICBjYXNlIDk0OiAvLyAnXidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICAgIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICAgIGNhc2UgNjM6IC8vICc/J1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKClcblxuICAgIGNhc2UgMTI2OiAvLyAnfidcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkgKyBcIidcIik7XG4gIH07XG5cbiAgcHAkOS5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnBvcyArPSBzaXplO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbiAgfTtcblxuICBwcCQ5LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICAgIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncywgdmFsdWU6IHZhbHVlfSlcbiAgfTtcblxuICAvLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuICAvLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuICAvLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxuICBwcCQ5LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuLCBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBhbGxvd1NlcGFyYXRvcnMgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIgJiYgbGVuID09PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBgbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsYCBpcyB0cnVlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBwcmVmaXggKDB4LDBvLDBiKVxuICAgIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAgIC8vIGlzIHplcm8gdGhlbiBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICAgIHZhciBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgPSBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gNDg7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpLCArK3RoaXMucG9zKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuXG4gICAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBvY3RhbCBudW1lcmljIGxpdGVyYWxzXCIpOyB9XG4gICAgICAgIGlmIChsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIG11c3QgYmUgZXhhY3RseSBvbmUgdW5kZXJzY29yZVwiKTsgfVxuICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBmdW5jdGlvbiBzdHJpbmdUb051bWJlcihzdHIsIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gICAgfVxuXG4gICAgLy8gYHBhcnNlRmxvYXQodmFsdWUpYCBzdG9wcyBwYXJzaW5nIGF0IHRoZSBmaXJzdCBudW1lcmljIHNlcGFyYXRvciB0aGVuIHJldHVybnMgYSB3cm9uZyB2YWx1ZS5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQmlnSW50KHN0cikge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gICAgcmV0dXJuIEJpZ0ludChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIHBwJDkucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgICB2YWwgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG4gIHBwJDkucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgdmFsJDEgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsJDEpXG4gICAgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gLy8gJystJ1xuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG5cbiAgICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG4gIH07XG5cbiAgLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG4gIHBwJDkucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkge1xuICAgIC8vIFVURi0xNiBEZWNvZGluZ1xuICAgIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbiAgfVxuXG4gIHBwJDkucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEwKSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcysrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbiAgfTtcblxuICAvLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG4gIHZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG4gIHBwJDkudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHBwJDkuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy50ZW1wbGF0ZSwgb3V0KVxuICAgICAgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG4gIHBwJDkucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiYFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5pbnZhbGlkVGVtcGxhdGUsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpKVxuXG4gICAgICAvLyBubyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gIHBwJDkucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nJDEodGhpcy5yZWFkQ29kZVBvaW50KCkpIC8vICd1J1xuICAgIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIC8vICd2JyAtPiAnXFx1MDAwYidcbiAgICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gICAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgICByZXR1cm4gXCJcIlxuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3MgLSAxO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIGNvZGVQb3MsXG4gICAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAvLyBVbmljb2RlIG5ldyBsaW5lIGNoYXJhY3RlcnMgYWZ0ZXIgXFwgZ2V0IHJlbW92ZWQgZnJvbSBvdXRwdXQgaW4gYm90aFxuICAgICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbiAgcHAkOS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gICAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICAgIHJldHVybiBuXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGB0aGlzLmNvbnRhaW5zRXNjYFxuICAvLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbiAgLy9cbiAgLy8gSW5jcmVtZW50YWxseSBhZGRzIG9ubHkgZXNjYXBlZCBjaGFycywgYWRkaW5nIG90aGVyIGNodW5rcyBhcy1pc1xuICAvLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxuICBwcCQ5LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIC8vIFwidVwiXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGVzYyk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4gIC8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG4gIHBwJDkucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxuICB9O1xuXG4gIC8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG5cbiAgdmFyIHZlcnNpb24gPSBcIjcuNC4xXCI7XG5cbiAgUGFyc2VyLmFjb3JuID0ge1xuICAgIFBhcnNlcjogUGFyc2VyLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gICAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICAgIE5vZGU6IE5vZGUsXG4gICAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gICAgdG9rVHlwZXM6IHR5cGVzLFxuICAgIGtleXdvcmRUeXBlczoga2V5d29yZHMkMSxcbiAgICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICAgIHRva0NvbnRleHRzOiB0eXBlcyQxLFxuICAgIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gICAgaXNJZGVudGlmaWVyU3RhcnQ6IGlzSWRlbnRpZmllclN0YXJ0LFxuICAgIFRva2VuOiBUb2tlbixcbiAgICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgICBsaW5lQnJlYWs6IGxpbmVCcmVhayxcbiAgICBsaW5lQnJlYWtHOiBsaW5lQnJlYWtHLFxuICAgIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG4gIH07XG5cbiAgLy8gVGhlIG1haW4gZXhwb3J0ZWQgaW50ZXJmYWNlICh1bmRlciBgc2VsZi5hY29ybmAgd2hlbiBpbiB0aGVcbiAgLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbiAgLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4gIC8vIEFQSV1bYXBpXS5cbiAgLy9cbiAgLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuICBmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuICAvLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4gIC8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxuICB9XG5cbiAgLy8gQWNvcm4gaXMgb3JnYW5pemVkIGFzIGEgdG9rZW5pemVyIGFuZCBhIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlci5cbiAgLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG4gIGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcbiAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLlRva2VuVHlwZSA9IFRva2VuVHlwZTtcbiAgZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbiAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gIGV4cG9ydHMua2V5d29yZFR5cGVzID0ga2V5d29yZHMkMTtcbiAgZXhwb3J0cy5saW5lQnJlYWsgPSBsaW5lQnJlYWs7XG4gIGV4cG9ydHMubGluZUJyZWFrRyA9IGxpbmVCcmVha0c7XG4gIGV4cG9ydHMubm9uQVNDSUl3aGl0ZXNwYWNlID0gbm9uQVNDSUl3aGl0ZXNwYWNlO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbiAgZXhwb3J0cy50b2tDb250ZXh0cyA9IHR5cGVzJDE7XG4gIGV4cG9ydHMudG9rVHlwZXMgPSB0eXBlcztcbiAgZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIiIsIi8qIVxuICogUGFwZXIuanMgdjAuMTIuMTUgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMjAsIErDvHJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vanVlcmdsZWhuaS5jb20vICYgaHR0cHM6Ly9wdWNrZXkuc3R1ZGlvL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIERhdGU6IFdlZCBNYXIgMTcgMTA6NDk6NDggMjAyMSArMDEwMFxuICpcbiAqKipcbiAqXG4gKiBTdHJhcHMuanMgLSBDbGFzcyBpbmhlcml0YW5jZSBsaWJyYXJ5IHdpdGggc3VwcG9ydCBmb3IgYmVhbi1zdHlsZSBhY2Nlc3NvcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgLSAyMDIwIErDvHJnIExlaG5pXG4gKiBodHRwOi8vanVlcmdsZWhuaS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cHM6Ly9tYXJpam5oYXZlcmJla2UubmwvYWNvcm4vXG4gKlxuICogQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCxcbiAqIGNyZWF0ZWQgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gKlxuICovXG5cbnZhciBwYXBlciA9IGZ1bmN0aW9uKHNlbGYsIHVuZGVmaW5lZCkge1xuXG5zZWxmID0gc2VsZiB8fCByZXF1aXJlKCcuL25vZGUvc2VsZi5qcycpO1xudmFyIHdpbmRvdyA9IHNlbGYud2luZG93LFxuXHRkb2N1bWVudCA9IHNlbGYuZG9jdW1lbnQ7XG5cbnZhciBCYXNlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuXHRcdGFycmF5ID0gW10sXG5cdFx0c2xpY2UgPSBhcnJheS5zbGljZSxcblx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuXHRcdGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcblx0XHRkZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG5cblx0XHRmb3JFYWNoID0gYXJyYXkuZm9yRWFjaCB8fCBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Zm9ySW4gPSBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpIHtcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKGRzdCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBzcmMpIHtcblx0XHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdFx0XHRkc3Rba2V5XSA9IHNyY1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZHN0O1xuXHRcdH0sXG5cblx0XHRlYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyLCBiaW5kKSB7XG5cdFx0XHRpZiAob2JqKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gZGVzY3JpYmUob2JqLCAnbGVuZ3RoJyk7XG5cdFx0XHRcdChkZXNjICYmIHR5cGVvZiBkZXNjLnZhbHVlID09PSAnbnVtYmVyJyA/IGZvckVhY2ggOiBmb3JJbilcblx0XHRcdFx0XHQuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmluZDtcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGluamVjdChkZXN0LCBzcmMsIGVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSkge1xuXHRcdHZhciBiZWFuc05hbWVzID0ge307XG5cblx0XHRmdW5jdGlvbiBmaWVsZChuYW1lLCB2YWwpIHtcblx0XHRcdHZhbCA9IHZhbCB8fCAodmFsID0gZGVzY3JpYmUoc3JjLCBuYW1lKSlcblx0XHRcdFx0XHQmJiAodmFsLmdldCA/IHZhbCA6IHZhbC52YWx1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnIycpXG5cdFx0XHRcdHZhbCA9IGRlc3RbdmFsLnN1YnN0cmluZygxKV0gfHwgdmFsO1xuXHRcdFx0dmFyIGlzRnVuYyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG5cdFx0XHRcdHJlcyA9IHZhbCxcblx0XHRcdFx0cHJldiA9IHByZXNlcnZlIHx8IGlzRnVuYyAmJiAhdmFsLmJhc2Vcblx0XHRcdFx0XHRcdD8gKHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSlcblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0YmVhbjtcblx0XHRcdGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBwcmV2KVxuXHRcdFx0XHRcdHZhbC5iYXNlID0gcHJldjtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpXG5cdFx0XHRcdFx0YmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cdFx0XHRcdGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0fHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKSB7XG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgoZGVzY3JpYmUoZGVzdCwgbmFtZSlcblx0XHRcdFx0XHRcdHx8IHsgY29uZmlndXJhYmxlOiB0cnVlIH0pLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdHJlcy5jb25maWd1cmFibGUgPSB0cnVlO1xuXHRcdFx0XHRcdHJlcy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZSAhPSBudWxsID8gZW51bWVyYWJsZSA6ICFiZWFuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3JjKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuXHRcdFx0XHR2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG5cdFx0XHRcdFx0c2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuXHRcdFx0XHRcdGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG5cdFx0XHRcdGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUsIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdGZ1bmN0aW9uIEJhc2UoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKHNyYylcblx0XHRcdFx0c2V0KHRoaXMsIHNyYyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmV0dXJuIGluamVjdChCYXNlLCB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbihzcmMpIHtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0dmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuXHRcdFx0XHRcdGJlYW5zID0gc3JjLmJlYW5zLFxuXHRcdFx0XHRcdHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuXHRcdFx0XHRpZiAoc3RhdGljcyAhPT0gc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdFx0aW5qZWN0KHRoaXMsIHN0YXRpY3MsIG51bGwsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYXNlID0gdGhpcyxcblx0XHRcdFx0Y3Rvcixcblx0XHRcdFx0cHJvdG87XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgb2JqLCBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRpIDwgbCAmJiAhKGN0b3IgJiYgcHJvdG8pOyBpKyspIHtcblx0XHRcdFx0b2JqID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRjdG9yID0gY3RvciB8fCBvYmouaW5pdGlhbGl6ZTtcblx0XHRcdFx0cHJvdG8gPSBwcm90byB8fCBvYmoucHJvdG90eXBlO1xuXHRcdFx0fVxuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRwcm90byA9IGN0b3IucHJvdG90eXBlID0gcHJvdG8gfHwgY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGRlZmluZShwcm90bywgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMpO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cyk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0cmV0dXJuIGN0b3I7XG5cdFx0fVxuXHR9KS5pbmplY3Qoe1xuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXG5cdFx0aW5pdGlhbGl6ZTogQmFzZSxcblxuXHRcdHNldDogQmFzZSxcblxuXHRcdGluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRcdGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IGNyZWF0ZSh0aGlzKTtcblx0XHRcdHJldHVybiByZXMuaW5qZWN0LmFwcGx5KHJlcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0ZWFjaDogZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0cmV0dXJuIGVhY2godGhpcywgaXRlciwgYmluZCk7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRlYWNoOiBlYWNoLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0XHRkZWZpbmU6IGRlZmluZSxcblx0XHRcdGRlc2NyaWJlOiBkZXNjcmliZSxcblxuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRyZXR1cm4gc2V0KG5ldyBvYmouY29uc3RydWN0b3IoKSwgb2JqKTtcblx0XHRcdH0sXG5cblx0XHRcdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHR2YXIgY3RvciA9IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0cmV0dXJuIGN0b3IgJiYgKGN0b3IgPT09IE9iamVjdCB8fCBjdG9yID09PSBCYXNlXG5cdFx0XHRcdFx0XHR8fCBjdG9yLm5hbWUgPT09ICdPYmplY3QnKTtcblx0XHRcdH0sXG5cblx0XHRcdHBpY2s6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEgIT09IHVuZGVmaW5lZCA/IGEgOiBiO1xuXHRcdFx0fSxcblxuXHRcdFx0c2xpY2U6IGZ1bmN0aW9uKGxpc3QsIGJlZ2luLCBlbmQpIHtcblx0XHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwobGlzdCwgYmVnaW4sIGVuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJylcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG5CYXNlLmluamVjdCh7XG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQgIT0gbnVsbFxuXHRcdFx0PyAgKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lXG5cdFx0XHRcdD8gXCIgJ1wiICsgdGhpcy5fbmFtZSArIFwiJ1wiXG5cdFx0XHRcdDogJyBAJyArIHRoaXMuX2lkKVxuXHRcdFx0OiAneyAnICsgQmFzZS5lYWNoKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsgKHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHRcdD8gRm9ybWF0dGVyLmluc3RhbmNlLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtdKS5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGFzcyB8fCAnJztcblx0fSxcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcblx0fSxcblxuXHRleHBvcnRKU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHByb3BzLCBleGNsdWRlKSB7XG5cdFx0aWYgKHByb3BzKVxuXHRcdFx0QmFzZS5maWx0ZXIodGhpcywgcHJvcHMsIGV4Y2x1ZGUsIHRoaXMuX3ByaW9yaXRpemUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59LCB7XG5cbmJlYW5zOiBmYWxzZSxcbnN0YXRpY3M6IHtcblx0ZXhwb3J0czoge30sXG5cblx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFx0dmFyIHJlcyA9IGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG5cdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0aWYgKG5hbWUgJiYgIUJhc2UuZXhwb3J0c1tuYW1lXSlcblx0XHRcdEJhc2UuZXhwb3J0c1tuYW1lXSA9IHJlcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuXHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKG9iajEgJiYgb2JqMS5lcXVhbHMpXG5cdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0aWYgKG9iajIgJiYgb2JqMi5lcXVhbHMpXG5cdFx0XHRyZXR1cm4gb2JqMi5lcXVhbHMob2JqMSk7XG5cdFx0aWYgKG9iajEgJiYgb2JqMlxuXHRcdFx0XHQmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmoxKSAmJiBBcnJheS5pc0FycmF5KG9iajIpKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSBvYmoxLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKG9iajFbbGVuZ3RoXSwgb2JqMltsZW5ndGhdKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmoxKSxcblx0XHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAoIShvYmoyLmhhc093blByb3BlcnR5KGtleSlcblx0XHRcdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHMob2JqMVtrZXldLCBvYmoyW2tleV0pKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG5cdFx0aWYgKHRoaXMgPT09IEJhc2UpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMucGVlayhsaXN0LCBzdGFydCk7XG5cdFx0XHRsaXN0Ll9faW5kZXgrKztcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0dmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG5cdFx0XHRyZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuXHRcdFx0YmVnaW4gPSBzdGFydCB8fCByZWFkSW5kZXggJiYgbGlzdC5fX2luZGV4IHx8IDAsXG5cdFx0XHRsZW5ndGggPSBsaXN0Lmxlbmd0aCxcblx0XHRcdG9iaiA9IGxpc3RbYmVnaW5dO1xuXHRcdGFtb3VudCA9IGFtb3VudCB8fCBsZW5ndGggLSBiZWdpbjtcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuXHRcdFx0fHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGFtb3VudCA8PSAxKSB7XG5cdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRsaXN0Ll9faW5kZXggPSBiZWdpbiArIDE7XG5cdFx0XHRyZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuXHRcdH1cblx0XHRvYmogPSBCYXNlLmNyZWF0ZShwcm90byk7XG5cdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdG9iai5fX3JlYWQgPSB0cnVlO1xuXHRcdG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgYmVnaW4gPiAwIHx8IGJlZ2luICsgYW1vdW50IDwgbGVuZ3RoXG5cdFx0XHRcdD8gQmFzZS5zbGljZShsaXN0LCBiZWdpbiwgYmVnaW4gKyBhbW91bnQpXG5cdFx0XHRcdDogbGlzdCkgfHwgb2JqO1xuXHRcdGlmIChyZWFkSW5kZXgpIHtcblx0XHRcdGxpc3QuX19pbmRleCA9IGJlZ2luICsgb2JqLl9fcmVhZDtcblx0XHRcdHZhciBmaWx0ZXJlZCA9IG9iai5fX2ZpbHRlcmVkO1xuXHRcdFx0aWYgKGZpbHRlcmVkKSB7XG5cdFx0XHRcdGxpc3QuX19maWx0ZXJlZCA9IGZpbHRlcmVkO1xuXHRcdFx0XHRvYmouX19maWx0ZXJlZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdG9iai5fX3JlYWQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0cGVlazogZnVuY3Rpb24obGlzdCwgc3RhcnQpIHtcblx0XHRyZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG5cdH0sXG5cblx0cmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0cmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcblx0fSxcblxuXHRyZWFkTGlzdDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuXHRcdHZhciByZXMgPSBbXSxcblx0XHRcdGVudHJ5LFxuXHRcdFx0YmVnaW4gPSBzdGFydCB8fCAwLFxuXHRcdFx0ZW5kID0gYW1vdW50ID8gYmVnaW4gKyBhbW91bnQgOiBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0cmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG5cdFx0XHRcdFx0PyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpXG5cdFx0XHRcdFx0OiB0aGlzLnJlYWQobGlzdCwgaSwgb3B0aW9ucywgMSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHJlYWROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG5cdFx0XHRoYXNWYWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0aWYgKGhhc1ZhbHVlKSB7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBsaXN0Ll9fZmlsdGVyZWQ7XG5cdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShsaXN0KTtcblx0XHRcdFx0ZmlsdGVyZWQgPSBsaXN0Ll9fZmlsdGVyZWQgPSBCYXNlLmNyZWF0ZShzb3VyY2UpO1xuXHRcdFx0XHRmaWx0ZXJlZC5fX3VuZmlsdGVyZWQgPSBzb3VyY2U7XG5cdFx0XHR9XG5cdFx0XHRmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVhZChoYXNWYWx1ZSA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KTtcblx0fSxcblxuXHRyZWFkU3VwcG9ydGVkOiBmdW5jdGlvbihsaXN0LCBkZXN0KSB7XG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGxpc3QpLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRyZWFkID0gZmFsc2U7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0T2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRpZiAoa2V5IGluIGRlc3QpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0LnJlYWROYW1lZChsaXN0LCBrZXkpO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRkZXN0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVhZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVhZDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKGxpc3QpIHtcblx0XHR2YXIgc291cmNlID0gbGlzdC5fX3NvdXJjZTtcblx0XHRpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBhcmcgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBsaXN0WzBdO1xuXHRcdFx0c291cmNlID0gbGlzdC5fX3NvdXJjZSA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQ/IGFyZyA6IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH0sXG5cblx0Z2V0TmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHR2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UobGlzdCk7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIG5hbWUgPyBzb3VyY2VbbmFtZV0gOiBsaXN0Ll9fZmlsdGVyZWQgfHwgc291cmNlO1xuXHRcdH1cblx0fSxcblxuXHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdH0sXG5cblx0ZmlsdGVyOiBmdW5jdGlvbihkZXN0LCBzb3VyY2UsIGV4Y2x1ZGUsIHByaW9yaXRpemUpIHtcblx0XHR2YXIgcHJvY2Vzc2VkO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlS2V5KGtleSkge1xuXHRcdFx0aWYgKCEoZXhjbHVkZSAmJiBrZXkgaW4gZXhjbHVkZSkgJiZcblx0XHRcdFx0IShwcm9jZXNzZWQgJiYga2V5IGluIHByb2Nlc3NlZCkpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGRlc3Rba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChwcmlvcml0aXplKSB7XG5cdFx0XHR2YXIga2V5cyA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGtleSwgbCA9IHByaW9yaXRpemUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICgoa2V5ID0gcHJpb3JpdGl6ZVtpXSkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0aGFuZGxlS2V5KGtleSk7XG5cdFx0XHRcdFx0a2V5c1trZXldID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJvY2Vzc2VkID0ga2V5cztcblx0XHR9XG5cblx0XHRPYmplY3Qua2V5cyhzb3VyY2UuX191bmZpbHRlcmVkIHx8IHNvdXJjZSkuZm9yRWFjaChoYW5kbGVLZXkpO1xuXHRcdHJldHVybiBkZXN0O1xuXHR9LFxuXG5cdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqLCBhc1N0cmluZykge1xuXHRcdHJldHVybiBCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iailcblx0XHRcdFx0fHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5cdH0sXG5cblx0c2VyaWFsaXplOiBmdW5jdGlvbihvYmosIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciBpc1Jvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdHJlcztcblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRvcHRpb25zLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRkZWZpbml0aW9uczoge30sXG5cdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdHZhciBpZCA9ICcjJyArIGl0ZW0uX2lkLFxuXHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXSA9IFtpZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChvYmogJiYgb2JqLl9zZXJpYWxpemUpIHtcblx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0aWYgKG5hbWUgJiYgIW9iai5fY29tcGFjdFNlcmlhbGl6ZSAmJiAoaXNSb290IHx8ICFjb21wYWN0KVxuXHRcdFx0XHRcdCYmIHJlc1swXSAhPT0gbmFtZSkge1xuXHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0cmVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSk7XG5cdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0cmVzID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRyZXNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKG9ialtrZXldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXMgPSBvYmo7XG5cdFx0fVxuXHRcdHJldHVybiBpc1Jvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdDogcmVzO1xuXHR9LFxuXG5cdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhLCBfc2V0RGljdGlvbmFyeSwgX2lzUm9vdCkge1xuXHRcdHZhciByZXMgPSBqc29uLFxuXHRcdFx0aXNGaXJzdCA9ICFfZGF0YSxcblx0XHRcdGhhc0RpY3Rpb25hcnkgPSBpc0ZpcnN0ICYmIGpzb24gJiYganNvbi5sZW5ndGhcblx0XHRcdFx0JiYganNvblswXVswXSA9PT0gJ2RpY3Rpb25hcnknO1xuXHRcdF9kYXRhID0gX2RhdGEgfHwge307XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcblx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0aXNEaWN0aW9uYXJ5ID0gdHlwZSA9PT0gJ2RpY3Rpb25hcnknO1xuXHRcdFx0aWYgKGpzb24ubGVuZ3RoID09IDEgJiYgL14jLy50ZXN0KHR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuXHRcdFx0fVxuXHRcdFx0dHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcblx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHR5cGUgPyAxIDogMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEJhc2UuZGVzZXJpYWxpemUoanNvbltpXSwgY3JlYXRlLCBfZGF0YSxcblx0XHRcdFx0XHRcdGlzRGljdGlvbmFyeSwgaGFzRGljdGlvbmFyeSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSByZXM7XG5cdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncywgaXNGaXJzdCB8fCBfaXNSb290KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXMgPSBuZXcgdHlwZShhcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGpzb24pKSB7XG5cdFx0XHRyZXMgPSB7fTtcblx0XHRcdGlmIChfc2V0RGljdGlvbmFyeSlcblx0XHRcdFx0X2RhdGEuZGljdGlvbmFyeSA9IHJlcztcblx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRyZXNba2V5XSA9IEJhc2UuZGVzZXJpYWxpemUoanNvbltrZXldLCBjcmVhdGUsIF9kYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc0RpY3Rpb25hcnkgPyByZXNbMV0gOiByZXM7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG5cdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPT0gZmFsc2Vcblx0XHRcdFx0PyBqc29uXG5cdFx0XHRcdDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbiwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIEJhc2UuZGVzZXJpYWxpemUoXG5cdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRmdW5jdGlvbihjdG9yLCBhcmdzLCBpc1Jvb3QpIHtcblx0XHRcdFx0XHR2YXIgdXNlVGFyZ2V0ID0gaXNSb290ICYmIHRhcmdldFxuXHRcdFx0XHRcdFx0XHQmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IGN0b3IsXG5cdFx0XHRcdFx0XHRvYmogPSB1c2VUYXJnZXQgPyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0OiBCYXNlLmNyZWF0ZShjdG9yLnByb3RvdHlwZSk7XG5cdFx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIG9iaiBpbnN0YW5jZW9mIEl0ZW1cblx0XHRcdFx0XHRcdFx0JiYgKHVzZVRhcmdldCB8fCAhKG9iaiBpbnN0YW5jZW9mIExheWVyKSkpIHtcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKSB7XG5cdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0aWYgKHVzZVRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmdzLmNvbmNhdChbeyBpbnNlcnQ6IHRydWUgfV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCh1c2VUYXJnZXQgPyBvYmouc2V0IDogY3RvcikuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRpZiAodXNlVGFyZ2V0KVxuXHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHR9KTtcblx0fSxcblxuXHRwdXNoOiBmdW5jdGlvbihsaXN0LCBpdGVtcykge1xuXHRcdHZhciBpdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblx0XHRpZiAoaXRlbXNMZW5ndGggPCA0MDk2KSB7XG5cdFx0XHRsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc3RhcnRMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGxpc3QubGVuZ3RoICs9IGl0ZW1zTGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtc0xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxpc3Rbc3RhcnRMZW5ndGggKyBpXSA9IGl0ZW1zW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbGlzdDtcblx0fSxcblxuXHRzcGxpY2U6IGZ1bmN0aW9uKGxpc3QsIGl0ZW1zLCBpbmRleCwgcmVtb3ZlKSB7XG5cdFx0dmFyIGFtb3VudCA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0aW5kZXggPSBhcHBlbmQgPyBsaXN0Lmxlbmd0aCA6IGluZGV4O1xuXHRcdGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKVxuXHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxuXHRcdFx0aXRlbXNbaV0uX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdEJhc2UucHVzaChsaXN0LCBpdGVtcyk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhcmdzID0gW2luZGV4LCByZW1vdmVdO1xuXHRcdFx0aWYgKGl0ZW1zKVxuXHRcdFx0XHRCYXNlLnB1c2goYXJncywgaXRlbXMpO1xuXHRcdFx0dmFyIHJlbW92ZWQgPSBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBhcmdzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGxpc3RbaV0uX2luZGV4ID0gaTtcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdH1cblx0fSxcblxuXHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcYlthLXpdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblx0fSxcblxuXHRjYW1lbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG1hdGNoLCBjaHIpIHtcblx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblx0fSxcblxuXHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcblx0fVxufX0pO1xuXG52YXIgRW1pdHRlciA9IHtcblx0b246IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9uKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRcdGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG5cdFx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHRcdFx0aGFuZGxlcnMgPSBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuXHRcdFx0aWYgKGhhbmRsZXJzLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goZnVuYyk7XG5cdFx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS5pbnN0YWxsICYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0XHRlbnRyeS5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub2ZmKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuXHRcdFx0aW5kZXg7XG5cdFx0aWYgKGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT09IC0xXG5cdFx0XHRcdFx0JiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS51bmluc3RhbGwpXG5cdFx0XHRcdFx0ZW50cnkudW5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0cmV0dXJuIHRoaXMub24odHlwZSwgZnVuY3Rpb24gaGFuZGxlcigpIHtcblx0XHRcdGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMub2ZmKHR5cGUsIGhhbmRsZXIpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGVtaXQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoIWhhbmRsZXJzKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBhcmdzID0gQmFzZS5zbGljZShhcmd1bWVudHMsIDEpLFxuXHRcdFx0c2V0VGFyZ2V0ID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmICFldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoKTtcblx0XHRpZiAoc2V0VGFyZ2V0KVxuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChoYW5kbGVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKSA9PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcClcblx0XHRcdFx0XHRldmVudC5zdG9wKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdCAgIH1cblx0XHR9XG5cdFx0aWYgKHNldFRhcmdldClcblx0XHRcdGRlbGV0ZSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHJlc3BvbmRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuXHR9LFxuXG5cdGF0dGFjaDogJyNvbicsXG5cdGRldGFjaDogJyNvZmYnLFxuXHRmaXJlOiAnI2VtaXQnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuXHRcdFx0a2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXHRcdGlmICh0eXBlcykge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0XHRpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBlbnRyeSA9IHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdFx0ZnVuYyA9IGVudHJ5ICYmIGVudHJ5W2tleV07XG5cdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRmdW5jLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGluamVjdDogZnVuY3Rpb24gaW5qZWN0KHNyYykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuXHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHR2YXIgdHlwZXMgPSB7fTtcblx0XHRcdFx0QmFzZS5lYWNoKGV2ZW50cywgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHRcdFx0XHRcdHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycsXG5cdFx0XHRcdFx0XHRuYW1lID0gaXNTdHJpbmcgPyBlbnRyeSA6IGtleSxcblx0XHRcdFx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdFx0XHR0eXBlID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR0eXBlc1t0eXBlXSA9IGlzU3RyaW5nID8ge30gOiBlbnRyeTtcblx0XHRcdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHRcdFx0XHRzcmNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzcmNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKGZ1bmMpIHtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHRcdGlmIChwcmV2KVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBwcmV2KTtcblx0XHRcdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9uKHR5cGUsIGZ1bmMpO1xuXHRcdFx0XHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNyYy5fZXZlbnRUeXBlcyA9IHR5cGVzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluamVjdC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgUGFwZXJTY29wZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGFwZXJTY29wZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGFwZXJTY29wZSgpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IG5ldyBCYXNlKHtcblx0XHRcdGFwcGx5TWF0cml4OiB0cnVlLFxuXHRcdFx0aW5zZXJ0SXRlbXM6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMuX2lkID0gUGFwZXJTY29wZS5faWQrKztcblx0XHRQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcblx0XHR2YXIgcHJvdG8gPSBQYXBlclNjb3BlLnByb3RvdHlwZTtcblx0XHRpZiAoIXRoaXMuc3VwcG9ydCkge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSkgfHwge307XG5cdFx0XHRwcm90by5zdXBwb3J0ID0ge1xuXHRcdFx0XHRuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuXHRcdFx0XHRuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcblx0XHRcdH07XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5hZ2VudCkge1xuXHRcdFx0dmFyIHVzZXIgPSBzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0b3MgPSAoLyhkYXJ3aW58d2lufG1hY3xsaW51eHxmcmVlYnNkfHN1bm9zKS8uZXhlYyh1c2VyKXx8W10pWzBdLFxuXHRcdFx0XHRwbGF0Zm9ybSA9IG9zID09PSAnZGFyd2luJyA/ICdtYWMnIDogb3MsXG5cdFx0XHRcdGFnZW50ID0gcHJvdG8uYWdlbnQgPSBwcm90by5icm93c2VyID0geyBwbGF0Zm9ybTogcGxhdGZvcm0gfTtcblx0XHRcdGlmIChwbGF0Zm9ybSlcblx0XHRcdFx0YWdlbnRbcGxhdGZvcm1dID0gdHJ1ZTtcblx0XHRcdHVzZXIucmVwbGFjZShcblx0XHRcdFx0LyhvcGVyYXxjaHJvbWV8c2FmYXJpfHdlYmtpdHxmaXJlZm94fG1zaWV8dHJpZGVudHxhdG9tfG5vZGV8anNkb20pXFwvP1xccyooWy5cXGRdKykoPzouKnZlcnNpb25cXC8oWy5cXGRdKykpPyg/Oi4qcnZcXDp2PyhbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKG1hdGNoLCBuLCB2MSwgdjIsIHJ2KSB7XG5cdFx0XHRcdFx0aWYgKCFhZ2VudC5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDpcblx0XHRcdFx0XHRcdFx0XHQvXihub2RlfHRyaWRlbnQpJC8udGVzdChuKSA/IHJ2IDogdjE7XG5cdFx0XHRcdFx0XHRhZ2VudC52ZXJzaW9uID0gdjtcblx0XHRcdFx0XHRcdGFnZW50LnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0biA9IHsgdHJpZGVudDogJ21zaWUnLCBqc2RvbTogJ25vZGUnIH1bbl0gfHwgbjtcblx0XHRcdFx0XHRcdGFnZW50Lm5hbWUgPSBuO1xuXHRcdFx0XHRcdFx0YWdlbnRbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGlmIChhZ2VudC5jaHJvbWUpXG5cdFx0XHRcdGRlbGV0ZSBhZ2VudC53ZWJraXQ7XG5cdFx0XHRpZiAoYWdlbnQuYXRvbSlcblx0XHRcdFx0ZGVsZXRlIGFnZW50LmNocm9tZTtcblx0XHR9XG5cdH0sXG5cblx0dmVyc2lvbjogXCIwLjEyLjE1XCIsXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLnByb2plY3Q7XG5cdFx0cmV0dXJuIHByb2plY3QgJiYgcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRnZXRQYXBlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhlY3V0ZTogZnVuY3Rpb24oY29kZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGV4cG9ydHMgPSBwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydHM7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNyZWF0ZUNhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHJldHVybiBDYW52YXNQcm92aWRlci5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3RzID0gdGhpcy5wcm9qZWN0cyxcblx0XHRcdHRvb2xzID0gdGhpcy50b29scztcblx0XHRmb3IgKHZhciBpID0gcHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHRwcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdG9vbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0b29sc1tpXS5yZW1vdmUoKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHRkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcblx0fSxcblxuXHRzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRcdG5hbWUgKz0gJ0F0dHJpYnV0ZSc7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWwsIGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIGVsW25hbWVdKGF0dHIpIHx8IGVsW25hbWVdKCdkYXRhLXBhcGVyLScgKyBhdHRyKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9zY29wZXM6IHt9LFxuXHRcdFx0X2lkOiAwLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zY29wZXNbaWRdIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnZ2V0JyksXG5cdFx0XHRoYXNBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnaGFzJylcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFBhcGVyU2NvcGVJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG5cdFx0dGhpcy5fc2NvcGUgPSBwYXBlcjtcblx0XHR0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuXHRcdGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSlcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9zY29wZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcylcblx0XHRcdHByZXYuZW1pdCgnZGVhY3RpdmF0ZScpO1xuXHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuXHRcdHRoaXMuZW1pdCgnYWN0aXZhdGUnLCBwcmV2KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5faW5kZXggPT0gbnVsbClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpXG5cdFx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLmdldFZpZXcoKTtcblx0fVxufSk7XG5cbnZhciBDb2xsaXNpb25EZXRlY3Rpb24gPSB7XG5cdGZpbmRJdGVtQm91bmRzQ29sbGlzaW9uczogZnVuY3Rpb24oaXRlbXMxLCBpdGVtczIsIHRvbGVyYW5jZSkge1xuXHRcdGZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuXHRcdFx0dmFyIGJvdW5kcyA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGl0ZW1zW2ldLmdldEJvdW5kcygpO1xuXHRcdFx0XHRib3VuZHNbaV0gPSBbcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b21dO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHR9XG5cblx0XHR2YXIgYm91bmRzMSA9IGdldEJvdW5kcyhpdGVtczEpLFxuXHRcdFx0Ym91bmRzMiA9ICFpdGVtczIgfHwgaXRlbXMyID09PSBpdGVtczFcblx0XHRcdFx0PyBib3VuZHMxXG5cdFx0XHRcdDogZ2V0Qm91bmRzKGl0ZW1zMik7XG5cdFx0cmV0dXJuIHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDApO1xuXHR9LFxuXG5cdGZpbmRDdXJ2ZUJvdW5kc0NvbGxpc2lvbnM6IGZ1bmN0aW9uKGN1cnZlczEsIGN1cnZlczIsIHRvbGVyYW5jZSwgYm90aEF4aXMpIHtcblx0XHRmdW5jdGlvbiBnZXRCb3VuZHMoY3VydmVzKSB7XG5cdFx0XHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0XHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdFx0XHRib3VuZHMgPSBuZXcgQXJyYXkoY3VydmVzLmxlbmd0aCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgdiA9IGN1cnZlc1tpXTtcblx0XHRcdFx0Ym91bmRzW2ldID0gW1xuXHRcdFx0XHRcdG1pbih2WzBdLCB2WzJdLCB2WzRdLCB2WzZdKSxcblx0XHRcdFx0XHRtaW4odlsxXSwgdlszXSwgdls1XSwgdls3XSksXG5cdFx0XHRcdFx0bWF4KHZbMF0sIHZbMl0sIHZbNF0sIHZbNl0pLFxuXHRcdFx0XHRcdG1heCh2WzFdLCB2WzNdLCB2WzVdLCB2WzddKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHR9XG5cblx0XHR2YXIgYm91bmRzMSA9IGdldEJvdW5kcyhjdXJ2ZXMxKSxcblx0XHRcdGJvdW5kczIgPSAhY3VydmVzMiB8fCBjdXJ2ZXMyID09PSBjdXJ2ZXMxXG5cdFx0XHRcdD8gYm91bmRzMVxuXHRcdFx0XHQ6IGdldEJvdW5kcyhjdXJ2ZXMyKTtcblx0XHRpZiAoYm90aEF4aXMpIHtcblx0XHRcdHZhciBob3IgPSB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKFxuXHRcdFx0XHRcdGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwLCBmYWxzZSwgdHJ1ZSksXG5cdFx0XHRcdHZlciA9IHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoXG5cdFx0XHRcdFx0Ym91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDAsIHRydWUsIHRydWUpLFxuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGhvci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bGlzdFtpXSA9IHsgaG9yOiBob3JbaV0sIHZlcjogdmVyW2ldIH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZmluZEJvdW5kc0NvbGxpc2lvbnMoYm91bmRzMSwgYm91bmRzMiwgdG9sZXJhbmNlIHx8IDApO1xuXHR9LFxuXG5cdGZpbmRCb3VuZHNDb2xsaXNpb25zOiBmdW5jdGlvbihib3VuZHNBLCBib3VuZHNCLCB0b2xlcmFuY2UsXG5cdFx0c3dlZXBWZXJ0aWNhbCwgb25seVN3ZWVwQXhpc0NvbGxpc2lvbnMpIHtcblx0XHR2YXIgc2VsZiA9ICFib3VuZHNCIHx8IGJvdW5kc0EgPT09IGJvdW5kc0IsXG5cdFx0XHRhbGxCb3VuZHMgPSBzZWxmID8gYm91bmRzQSA6IGJvdW5kc0EuY29uY2F0KGJvdW5kc0IpLFxuXHRcdFx0bGVuZ3RoQSA9IGJvdW5kc0EubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoQWxsID0gYWxsQm91bmRzLmxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChpbmRpY2VzLCBjb29yZCwgdmFsdWUpIHtcblx0XHRcdHZhciBsbyA9IDAsXG5cdFx0XHRcdGhpID0gaW5kaWNlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAobG8gPCBoaSkge1xuXHRcdFx0XHR2YXIgbWlkID0gKGhpICsgbG8pID4+PiAxO1xuXHRcdFx0XHRpZiAoYWxsQm91bmRzW2luZGljZXNbbWlkXV1bY29vcmRdIDwgdmFsdWUpIHtcblx0XHRcdFx0XHRsbyA9IG1pZCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGkgPSBtaWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBsbyAtIDE7XG5cdFx0fVxuXG5cdFx0dmFyIHByaTAgPSBzd2VlcFZlcnRpY2FsID8gMSA6IDAsXG5cdFx0XHRwcmkxID0gcHJpMCArIDIsXG5cdFx0XHRzZWMwID0gc3dlZXBWZXJ0aWNhbCA/IDAgOiAxLFxuXHRcdFx0c2VjMSA9IHNlYzAgKyAyO1xuXHRcdHZhciBhbGxJbmRpY2VzQnlQcmkwID0gbmV3IEFycmF5KGxlbmd0aEFsbCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhBbGw7IGkrKykge1xuXHRcdFx0YWxsSW5kaWNlc0J5UHJpMFtpXSA9IGk7XG5cdFx0fVxuXHRcdGFsbEluZGljZXNCeVByaTAuc29ydChmdW5jdGlvbihpMSwgaTIpIHtcblx0XHRcdHJldHVybiBhbGxCb3VuZHNbaTFdW3ByaTBdIC0gYWxsQm91bmRzW2kyXVtwcmkwXTtcblx0XHR9KTtcblx0XHR2YXIgYWN0aXZlSW5kaWNlc0J5UHJpMSA9IFtdLFxuXHRcdFx0YWxsQ29sbGlzaW9ucyA9IG5ldyBBcnJheShsZW5ndGhBKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aEFsbDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VySW5kZXggPSBhbGxJbmRpY2VzQnlQcmkwW2ldLFxuXHRcdFx0XHRjdXJCb3VuZHMgPSBhbGxCb3VuZHNbY3VySW5kZXhdLFxuXHRcdFx0XHRvcmlnSW5kZXggPSBzZWxmID8gY3VySW5kZXggOiBjdXJJbmRleCAtIGxlbmd0aEEsXG5cdFx0XHRcdGlzQ3VycmVudEEgPSBjdXJJbmRleCA8IGxlbmd0aEEsXG5cdFx0XHRcdGlzQ3VycmVudEIgPSBzZWxmIHx8ICFpc0N1cnJlbnRBLFxuXHRcdFx0XHRjdXJDb2xsaXNpb25zID0gaXNDdXJyZW50QSA/IFtdIDogbnVsbDtcblx0XHRcdGlmIChhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgcHJ1bmVDb3VudCA9IGJpbmFyeVNlYXJjaChhY3RpdmVJbmRpY2VzQnlQcmkxLCBwcmkxLFxuXHRcdFx0XHRcdFx0Y3VyQm91bmRzW3ByaTBdIC0gdG9sZXJhbmNlKSArIDE7XG5cdFx0XHRcdGFjdGl2ZUluZGljZXNCeVByaTEuc3BsaWNlKDAsIHBydW5lQ291bnQpO1xuXHRcdFx0XHRpZiAoc2VsZiAmJiBvbmx5U3dlZXBBeGlzQ29sbGlzaW9ucykge1xuXHRcdFx0XHRcdGN1ckNvbGxpc2lvbnMgPSBjdXJDb2xsaXNpb25zLmNvbmNhdChhY3RpdmVJbmRpY2VzQnlQcmkxKTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciBhY3RpdmVJbmRleCA9IGFjdGl2ZUluZGljZXNCeVByaTFbal07XG5cdFx0XHRcdFx0XHRhbGxDb2xsaXNpb25zW2FjdGl2ZUluZGV4XS5wdXNoKG9yaWdJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjdXJTZWMxID0gY3VyQm91bmRzW3NlYzFdLFxuXHRcdFx0XHRcdFx0Y3VyU2VjMCA9IGN1ckJvdW5kc1tzZWMwXTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciBhY3RpdmVJbmRleCA9IGFjdGl2ZUluZGljZXNCeVByaTFbal0sXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZUJvdW5kcyA9IGFsbEJvdW5kc1thY3RpdmVJbmRleF0sXG5cdFx0XHRcdFx0XHRcdGlzQWN0aXZlQSA9IGFjdGl2ZUluZGV4IDwgbGVuZ3RoQSxcblx0XHRcdFx0XHRcdFx0aXNBY3RpdmVCID0gc2VsZiB8fCBhY3RpdmVJbmRleCA+PSBsZW5ndGhBO1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdG9ubHlTd2VlcEF4aXNDb2xsaXNpb25zIHx8XG5cdFx0XHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdFx0XHRpc0N1cnJlbnRBICYmIGlzQWN0aXZlQiB8fFxuXHRcdFx0XHRcdFx0XHRcdGlzQ3VycmVudEIgJiYgaXNBY3RpdmVBXG5cdFx0XHRcdFx0XHRcdCkgJiYgKFxuXHRcdFx0XHRcdFx0XHRcdGN1clNlYzEgPj0gYWN0aXZlQm91bmRzW3NlYzBdIC0gdG9sZXJhbmNlICYmXG5cdFx0XHRcdFx0XHRcdFx0Y3VyU2VjMCA8PSBhY3RpdmVCb3VuZHNbc2VjMV0gKyB0b2xlcmFuY2Vcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpc0N1cnJlbnRBICYmIGlzQWN0aXZlQikge1xuXHRcdFx0XHRcdFx0XHRcdGN1ckNvbGxpc2lvbnMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGYgPyBhY3RpdmVJbmRleCA6IGFjdGl2ZUluZGV4IC0gbGVuZ3RoQSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGlzQ3VycmVudEIgJiYgaXNBY3RpdmVBKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWxsQ29sbGlzaW9uc1thY3RpdmVJbmRleF0ucHVzaChvcmlnSW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNDdXJyZW50QSkge1xuXHRcdFx0XHRpZiAoYm91bmRzQSA9PT0gYm91bmRzQikge1xuXHRcdFx0XHRcdGN1ckNvbGxpc2lvbnMucHVzaChjdXJJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YWxsQ29sbGlzaW9uc1tjdXJJbmRleF0gPSBjdXJDb2xsaXNpb25zO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFjdGl2ZUluZGljZXNCeVByaTEubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjdXJQcmkxID0gY3VyQm91bmRzW3ByaTFdLFxuXHRcdFx0XHRcdGluZGV4ID0gYmluYXJ5U2VhcmNoKGFjdGl2ZUluZGljZXNCeVByaTEsIHByaTEsIGN1clByaTEpO1xuXHRcdFx0XHRhY3RpdmVJbmRpY2VzQnlQcmkxLnNwbGljZShpbmRleCArIDEsIDAsIGN1ckluZGV4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFjdGl2ZUluZGljZXNCeVByaTEucHVzaChjdXJJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQ29sbGlzaW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNvbGxpc2lvbnMgPSBhbGxDb2xsaXNpb25zW2ldO1xuXHRcdFx0aWYgKGNvbGxpc2lvbnMpIHtcblx0XHRcdFx0Y29sbGlzaW9ucy5zb3J0KGZ1bmN0aW9uKGkxLCBpMikgeyByZXR1cm4gaTEgLSBpMjsgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhbGxDb2xsaXNpb25zO1xuXHR9XG59O1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblx0XHR0aGlzLnByZWNpc2lvbiA9IEJhc2UucGljayhwcmVjaXNpb24sIDUpO1xuXHRcdHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG5cdH0sXG5cblx0bnVtYmVyOiBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmVjaXNpb24gPCAxNlxuXHRcdFx0XHQ/IE1hdGgucm91bmQodmFsICogdGhpcy5tdWx0aXBsaWVyKSAvIHRoaXMubXVsdGlwbGllciA6IHZhbDtcblx0fSxcblxuXHRwYWlyOiBmdW5jdGlvbih2YWwxLCB2YWwyLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsMSkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwyKTtcblx0fSxcblxuXHRwb2ludDogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLngpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLnkpO1xuXHR9LFxuXG5cdHNpemU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC53aWR0aCkgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLm51bWJlcih2YWwuaGVpZ2h0KTtcblx0fSxcblxuXHRyZWN0YW5nbGU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnQodmFsLCBzZXBhcmF0b3IpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5zaXplKHZhbCwgc2VwYXJhdG9yKTtcblx0fVxufSk7XG5cbkZvcm1hdHRlci5pbnN0YW5jZSA9IG5ldyBGb3JtYXR0ZXIoKTtcblxudmFyIE51bWVyaWNhbCA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgYWJzY2lzc2FzID0gW1xuXHRcdFsgIDAuNTc3MzUwMjY5MTg5NjI1NzY0NTA5MTQ4OF0sXG5cdFx0WzAsMC43NzQ1OTY2NjkyNDE0ODMzNzcwMzU4NTMxXSxcblx0XHRbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcblx0XHRbMCwwLjUzODQ2OTMxMDEwNTY4MzA5MTAzNjMxNDQsMC45MDYxNzk4NDU5Mzg2NjM5OTI3OTc2MjY5XSxcblx0XHRbICAwLjIzODYxOTE4NjA4MzE5NjkwODYzMDUwMTcsMC42NjEyMDkzODY0NjYyNjQ1MTM2NjEzOTk2LDAuOTMyNDY5NTE0MjAzMTUyMDI3ODEyMzAxNl0sXG5cdFx0WzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxuXHRcdFsgIDAuMTgzNDM0NjQyNDk1NjQ5ODA0OTM5NDc2MSwwLjUyNTUzMjQwOTkxNjMyODk4NTgxNzczOTAsMC43OTY2NjY0Nzc0MTM2MjY3Mzk1OTE1NTM5LDAuOTYwMjg5ODU2NDk3NTM2MjMxNjgzNTYwOV0sXG5cdFx0WzAsMC4zMjQyNTM0MjM0MDM4MDg5MjkwMzg1MzgwLDAuNjEzMzcxNDMyNzAwNTkwMzk3MzA4NzAyMCwwLjgzNjAzMTEwNzMyNjYzNTc5NDI5OTQyOTgsMC45NjgxNjAyMzk1MDc2MjYwODk4MzU1NzYyXSxcblx0XHRbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcblx0XHRbMCwwLjI2OTU0MzE1NTk1MjM0NDk3MjMzMTUzMjAsMC41MTkwOTYxMjkyMDY4MTE4MTU5MjU3MjU3LDAuNzMwMTUyMDA1NTc0MDQ5MzI0MDkzNDE2MywwLjg4NzA2MjU5OTc2ODA5NTI5OTA3NTE1NzgsMC45NzgyMjg2NTgxNDYwNTY5OTI4MDM5MzgwXSxcblx0XHRbICAwLjEyNTIzMzQwODUxMTQ2ODkxNTQ3MjQ0MTQsMC4zNjc4MzE0OTg5OTgxODAxOTM3NTI2OTE1LDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNCwwLjc2OTkwMjY3NDE5NDMwNDY4NzAzNjg5MzgsMC45MDQxMTcyNTYzNzA0NzQ4NTY2Nzg0NjU5LDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MV0sXG5cdFx0WzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxuXHRcdFsgIDAuMTA4MDU0OTQ4NzA3MzQzNjYyMDY2MjQ0NywwLjMxOTExMjM2ODkyNzg4OTc2MDQzNTY3MTgsMC41MTUyNDg2MzYzNTgxNTQwOTE5NjUyOTA3LDAuNjg3MjkyOTA0ODExNjg1NDcwMTQ4MDE5OCwwLjgyNzIwMTMxNTA2OTc2NDk5MzE4OTc5NDcsMC45Mjg0MzQ4ODM2NjM1NzM1MTczMzYzOTExLDAuOTg2MjgzODA4Njk2ODEyMzM4ODQxNTk3M10sXG5cdFx0WzAsMC4yMDExOTQwOTM5OTc0MzQ1MjIzMDA2MjgzLDAuMzk0MTUxMzQ3MDc3NTYzMzY5ODk3MjA3NCwwLjU3MDk3MjE3MjYwODUzODg0NzUzNzIyNjcsMC43MjQ0MTc3MzEzNjAxNzAwNDc0MTYxODYxLDAuODQ4MjA2NTgzNDEwNDI3MjE2MjAwNjQ4MywwLjkzNzI3MzM5MjQwMDcwNTkwNDMwNzc1ODksMC45ODc5OTI1MTgwMjA0ODU0Mjg0ODk1NjU3XSxcblx0XHRbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxuXHRdO1xuXG5cdHZhciB3ZWlnaHRzID0gW1xuXHRcdFsxXSxcblx0XHRbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sXG5cdFx0WzAuNjUyMTQ1MTU0ODYyNTQ2MTQyNjI2OTM2MSwwLjM0Nzg1NDg0NTEzNzQ1Mzg1NzM3MzA2MzldLFxuXHRcdFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sXG5cdFx0WzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSxcblx0XHRbMC40MTc5NTkxODM2NzM0NjkzODc3NTUxMDIwLDAuMzgxODMwMDUwNTA1MTE4OTQ0OTUwMzY5OCwwLjI3OTcwNTM5MTQ4OTI3NjY2NzkwMTQ2NzgsMC4xMjk0ODQ5NjYxNjg4Njk2OTMyNzA2MTE0XSxcblx0XHRbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSxcblx0XHRbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sXG5cdFx0WzAuMjk1NTI0MjI0NzE0NzUyODcwMTczODkzMCwwLjI2OTI2NjcxOTMwOTk5NjM1NTA5MTIyNjksMC4yMTkwODYzNjI1MTU5ODIwNDM5OTU1MzQ5LDAuMTQ5NDUxMzQ5MTUwNTgwNTkzMTQ1Nzc2MywwLjA2NjY3MTM0NDMwODY4ODEzNzU5MzU2ODhdLFxuXHRcdFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sXG5cdFx0WzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSxcblx0XHRbMC4yMzI1NTE1NTMyMzA4NzM5MTAxOTQ1ODk1LDAuMjI2MjgzMTgwMjYyODk3MjM4NDEyMDkwMiwwLjIwNzgxNjA0NzUzNjg4ODUwMjMxMjUyMzIsMC4xNzgxNDU5ODA3NjE5NDU3MzgyODAwNDY3LDAuMTM4ODczNTEwMjE5Nzg3MjM4NDYzNjAxOCwwLjA5MjEyMTQ5OTgzNzcyODQ0NzkxNDQyMTgsMC4wNDA0ODQwMDQ3NjUzMTU4Nzk1MjAwMjE2XSxcblx0XHRbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSxcblx0XHRbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sXG5cdFx0WzAuMTg5NDUwNjEwNDU1MDY4NDk2Mjg1Mzk2NywwLjE4MjYwMzQxNTA0NDkyMzU4ODg2Njc2MzcsMC4xNjkxNTY1MTkzOTUwMDI1MzgxODkzMTIxLDAuMTQ5NTk1OTg4ODE2NTc2NzMyMDgxNTAxNywwLjEyNDYyODk3MTI1NTUzMzg3MjA1MjQ3NjMsMC4wOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxLDAuMDYyMjUzNTIzOTM4NjQ3ODkyODYyODQzOCwwLjAyNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDZdXG5cdF07XG5cblx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0cG93ID0gTWF0aC5wb3csXG5cdFx0bG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xuXHRcdH0sXG5cdFx0RVBTSUxPTiA9IDFlLTEyLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREaXNjcmltaW5hbnQoYSwgYiwgYykge1xuXHRcdGZ1bmN0aW9uIHNwbGl0KHYpIHtcblx0XHRcdHZhciB4ID0gdiAqIDEzNDIxNzcyOSxcblx0XHRcdFx0eSA9IHYgLSB4LFxuXHRcdFx0XHRoaSA9IHkgKyB4LFxuXHRcdFx0XHRsbyA9IHYgLSBoaTtcblx0XHRcdHJldHVybiBbaGksIGxvXTtcblx0XHR9XG5cblx0XHR2YXIgRCA9IGIgKiBiIC0gYSAqIGMsXG5cdFx0XHRFID0gYiAqIGIgKyBhICogYztcblx0XHRpZiAoYWJzKEQpICogMyA8IEUpIHtcblx0XHRcdHZhciBhZCA9IHNwbGl0KGEpLFxuXHRcdFx0XHRiZCA9IHNwbGl0KGIpLFxuXHRcdFx0XHRjZCA9IHNwbGl0KGMpLFxuXHRcdFx0XHRwID0gYiAqIGIsXG5cdFx0XHRcdGRwID0gKGJkWzBdICogYmRbMF0gLSBwICsgMiAqIGJkWzBdICogYmRbMV0pICsgYmRbMV0gKiBiZFsxXSxcblx0XHRcdFx0cSA9IGEgKiBjLFxuXHRcdFx0XHRkcSA9IChhZFswXSAqIGNkWzBdIC0gcSArIGFkWzBdICogY2RbMV0gKyBhZFsxXSAqIGNkWzBdKVxuXHRcdFx0XHRcdFx0KyBhZFsxXSAqIGNkWzFdO1xuXHRcdFx0RCA9IChwIC0gcSkgKyAoZHAgLSBkcSk7XG5cdFx0fVxuXHRcdHJldHVybiBEO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcigpIHtcblx0XHR2YXIgbm9ybSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5vcm0gJiYgKG5vcm0gPCAxZS04IHx8IG5vcm0gPiAxZTgpXG5cdFx0XHRcdD8gcG93KDIsIC1NYXRoLnJvdW5kKGxvZzIobm9ybSkpKVxuXHRcdFx0XHQ6IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdEVQU0lMT046IEVQU0lMT04sXG5cdFx0TUFDSElORV9FUFNJTE9OOiBNQUNISU5FX0VQU0lMT04sXG5cdFx0Q1VSVkVUSU1FX0VQU0lMT046IDFlLTgsXG5cdFx0R0VPTUVUUklDX0VQU0lMT046IDFlLTcsXG5cdFx0VFJJR09OT01FVFJJQ19FUFNJTE9OOiAxZS04LFxuXHRcdEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cblx0XHRpc1plcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbCA+PSAtRVBTSUxPTiAmJiB2YWwgPD0gRVBTSUxPTjtcblx0XHR9LFxuXG5cdFx0aXNNYWNoaW5lWmVybzogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRyZXR1cm4gdmFsID49IC1NQUNISU5FX0VQU0lMT04gJiYgdmFsIDw9IE1BQ0hJTkVfRVBTSUxPTjtcblx0XHR9LFxuXG5cdFx0Y2xhbXA6IGNsYW1wLFxuXG5cdFx0aW50ZWdyYXRlOiBmdW5jdGlvbihmLCBhLCBiLCBuKSB7XG5cdFx0XHR2YXIgeCA9IGFic2Npc3Nhc1tuIC0gMl0sXG5cdFx0XHRcdHcgPSB3ZWlnaHRzW24gLSAyXSxcblx0XHRcdFx0QSA9IChiIC0gYSkgKiAwLjUsXG5cdFx0XHRcdEIgPSBBICsgYSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdG0gPSAobiArIDEpID4+IDEsXG5cdFx0XHRcdHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7XG5cdFx0XHR3aGlsZSAoaSA8IG0pIHtcblx0XHRcdFx0dmFyIEF4ID0gQSAqIHhbaV07XG5cdFx0XHRcdHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBICogc3VtO1xuXHRcdH0sXG5cblx0XHRmaW5kUm9vdDogZnVuY3Rpb24oZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGZ4ID0gZih4KSxcblx0XHRcdFx0XHRkeCA9IGZ4IC8gZGYoeCksXG5cdFx0XHRcdFx0bnggPSB4IC0gZHg7XG5cdFx0XHRcdGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKSB7XG5cdFx0XHRcdFx0eCA9IG54O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmeCA+IDApIHtcblx0XHRcdFx0XHRiID0geDtcblx0XHRcdFx0XHR4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0geDtcblx0XHRcdFx0XHR4ID0gbnggPj0gYiA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNsYW1wKHgsIGEsIGIpO1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgeDEsIHgyID0gSW5maW5pdHk7XG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKGIpIDwgRVBTSUxPTilcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDtcblx0XHRcdFx0eDEgPSAtYyAvIGI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiICo9IC0wLjU7XG5cdFx0XHRcdHZhciBEID0gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpO1xuXHRcdFx0XHRpZiAoRCAmJiBhYnMoRCkgPCBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHR2YXIgZiA9IGdldE5vcm1hbGl6YXRpb25GYWN0b3IoYWJzKGEpLCBhYnMoYiksIGFicyhjKSk7XG5cdFx0XHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0XHRcdGEgKj0gZjtcblx0XHRcdFx0XHRcdGIgKj0gZjtcblx0XHRcdFx0XHRcdGMgKj0gZjtcblx0XHRcdFx0XHRcdEQgPSBnZXREaXNjcmltaW5hbnQoYSwgYiwgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChEID49IC1NQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHR2YXIgUSA9IEQgPCAwID8gMCA6IHNxcnQoRCksXG5cdFx0XHRcdFx0XHRSID0gYiArIChiIDwgMCA/IC1RIDogUSk7XG5cdFx0XHRcdFx0aWYgKFIgPT09IDApIHtcblx0XHRcdFx0XHRcdHgxID0gYyAvIGE7XG5cdFx0XHRcdFx0XHR4MiA9IC14MTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eDEgPSBSIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gYyAvIFI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHRib3VuZGxlc3MgPSBtaW4gPT0gbnVsbCxcblx0XHRcdFx0bWluQiA9IG1pbiAtIEVQU0lMT04sXG5cdFx0XHRcdG1heEIgPSBtYXggKyBFUFNJTE9OO1xuXHRcdFx0aWYgKGlzRmluaXRlKHgxKSAmJiAoYm91bmRsZXNzIHx8IHgxID4gbWluQiAmJiB4MSA8IG1heEIpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHgxIDogY2xhbXAoeDEsIG1pbiwgbWF4KTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKGJvdW5kbGVzcyB8fCB4MiA+IG1pbkIgJiYgeDIgPCBtYXhCKSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4MiA6IGNsYW1wKHgyLCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGYgPSBnZXROb3JtYWxpemF0aW9uRmFjdG9yKGFicyhhKSwgYWJzKGIpLCBhYnMoYyksIGFicyhkKSksXG5cdFx0XHRcdHgsIGIxLCBjMiwgcWQsIHE7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRhICo9IGY7XG5cdFx0XHRcdGIgKj0gZjtcblx0XHRcdFx0YyAqPSBmO1xuXHRcdFx0XHRkICo9IGY7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGV2YWx1YXRlKHgwKSB7XG5cdFx0XHRcdHggPSB4MDtcblx0XHRcdFx0dmFyIHRtcCA9IGEgKiB4O1xuXHRcdFx0XHRiMSA9IHRtcCArIGI7XG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYztcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyO1xuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdGIxID0gYztcblx0XHRcdFx0YzIgPSBkO1xuXHRcdFx0XHR4ID0gSW5maW5pdHk7XG5cdFx0XHR9IGVsc2UgaWYgKGFicyhkKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YjEgPSBiO1xuXHRcdFx0XHRjMiA9IGM7XG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXZhbHVhdGUoLShiIC8gYSkgLyAzKTtcblx0XHRcdFx0dmFyIHQgPSBxIC8gYSxcblx0XHRcdFx0XHRyID0gcG93KGFicyh0KSwgMS8zKSxcblx0XHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDEsXG5cdFx0XHRcdFx0dGQgPSAtcWQgLyBhLFxuXHRcdFx0XHRcdHJkID0gdGQgPiAwID8gMS4zMjQ3MTc5NTcyNDQ3NDYgKiBNYXRoLm1heChyLCBzcXJ0KHRkKSkgOiByLFxuXHRcdFx0XHRcdHgwID0geCAtIHMgKiByZDtcblx0XHRcdFx0aWYgKHgwICE9PSB4KSB7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0ZXZhbHVhdGUoeDApO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gKDEgKyBNQUNISU5FX0VQU0lMT04pO1xuXHRcdFx0XHRcdH0gd2hpbGUgKHMgKiB4MCA+IHMgKiB4KTtcblx0XHRcdFx0XHRpZiAoYWJzKGEpICogeCAqIHggPiBhYnMoZCAvIHgpKSB7XG5cdFx0XHRcdFx0XHRjMiA9IC1kIC8geDtcblx0XHRcdFx0XHRcdGIxID0gKGMyIC0gYykgLyB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIxLCBjMiwgcm9vdHMsIG1pbiwgbWF4KSxcblx0XHRcdFx0Ym91bmRsZXNzID0gbWluID09IG51bGw7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwXG5cdFx0XHRcdFx0fHwgY291bnQgPiAwICYmIHggIT09IHJvb3RzWzBdICYmIHggIT09IHJvb3RzWzFdKVxuXHRcdFx0XHRcdCYmIChib3VuZGxlc3MgfHwgeCA+IG1pbiAtIEVQU0lMT04gJiYgeCA8IG1heCArIEVQU0lMT04pKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHggOiBjbGFtcCh4LCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFVJRCA9IHtcblx0X2lkOiAxLFxuXHRfcG9vbHM6IHt9LFxuXG5cdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmIChuYW1lKSB7XG5cdFx0XHR2YXIgcG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuXHRcdFx0aWYgKCFwb29sKVxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7IF9pZDogMSB9O1xuXHRcdFx0cmV0dXJuIHBvb2wuX2lkKys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZCsrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkaW5nID0gdGhpcy5fX3JlYWQsXG5cdFx0XHRyZWFkID0gMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy5fc2V0KGFyZzAsIGhhc1kgPyBhcmcxIDogYXJnMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgb2JqID0gdHlwZSA9PT0gJ3N0cmluZycgPyBhcmcwLnNwbGl0KC9bXFxzLF0rLykgfHwgW10gOiBhcmcwO1xuXHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHRoaXMuX3NldCgrb2JqWzBdLCArKG9iai5sZW5ndGggPiAxID8gb2JqWzFdIDogb2JqWzBdKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCd4JyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai54IHx8IDAsIG9iai55IHx8IDApO1xuXHRcdFx0fSBlbHNlIGlmICgnd2lkdGgnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLndpZHRoIHx8IDAsIG9iai5oZWlnaHQgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKCdhbmdsZScgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoubGVuZ3RoIHx8IDAsIDApO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKG9iai5hbmdsZSB8fCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdFx0cmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gdGhpcyA9PT0gcG9pbnQgfHwgcG9pbnRcblx0XHRcdFx0JiYgKHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnlcblx0XHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHBvaW50KVxuXHRcdFx0XHRcdFx0JiYgdGhpcy54ID09PSBwb2ludFswXSAmJiB0aGlzLnkgPT09IHBvaW50WzFdKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlIHx8IDA7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRRdWFkcmFudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCA+PSAwID8gdGhpcy55ID49IDAgPyAxIDogNCA6IHRoaXMueSA+PSAwID8gMiA6IDM7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldERpcmVjdGVkQW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNyb3NzKHBvaW50KSwgdGhpcy5kb3QocG9pbnQpKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmdzKTtcblx0XHRyZXR1cm4gc3F1YXJlZCA/IGQgOiBNYXRoLnNxcnQoZCk7XG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpXG5cdFx0XHRsZW5ndGggPSAxO1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRMZW5ndGgoKSxcblx0XHRcdHNjYWxlID0gY3VycmVudCAhPT0gMCA/IGxlbmd0aCAvIGN1cnJlbnQgOiAwLFxuXHRcdFx0cG9pbnQgPSBuZXcgUG9pbnQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlKTtcblx0XHRpZiAoc2NhbGUgPj0gMClcblx0XHRcdHBvaW50Ll9hbmdsZSA9IHRoaXMuX2FuZ2xlO1xuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBjZW50ZXIpIHtcblx0XHRpZiAoYW5nbGUgPT09IDApXG5cdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHRcdGFuZ2xlID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBwb2ludCA9IGNlbnRlciA/IHRoaXMuc3VidHJhY3QoY2VudGVyKSA6IHRoaXMsXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogY29zIC0gcG9pbnQueSAqIHNpbixcblx0XHRcdHBvaW50LnggKiBzaW4gKyBwb2ludC55ICogY29zXG5cdFx0KTtcblx0XHRyZXR1cm4gY2VudGVyID8gcG9pbnQuYWRkKGNlbnRlcikgOiBwb2ludDtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHRoaXMpIDogdGhpcztcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHBvaW50LngsIHRoaXMueSArIHBvaW50LnkpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwb2ludC54LCB0aGlzLnkgLSBwb2ludC55KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAlIHBvaW50LngsIHRoaXMueSAlIHBvaW50LnkpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcyk7XG5cdH0sXG5cblx0aXNDbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHR0b2xlcmFuY2UgPSBCYXNlLnJlYWQoYXJncyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDw9IHRvbGVyYW5jZTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNDb2xpbmVhcjogJyNpc0NvbGxpbmVhcicsXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHRoaXMueCkgJiYgaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0aXNJblF1YWRyYW50OiBmdW5jdGlvbihxKSB7XG5cdFx0cmV0dXJuIHRoaXMueCAqIChxID4gMSAmJiBxIDwgNCA/IC0xIDogMSkgPj0gMFxuXHRcdFx0JiYgdGhpcy55ICogKHEgPiAyID8gLTEgOiAxKSA+PSAwO1xuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRzY2FsZSA9IHBvaW50LmlzWmVybygpID8gMCA6IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdHBvaW50LnggKiBzY2FsZSxcblx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cG9pbnQxID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmdzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cG9pbnQxID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmdzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH0sXG5cblx0XHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh4MSAqIHkyIC0geTEgKiB4Milcblx0XHRcdFx0XHQ8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpXG5cdFx0XHRcdFx0XHQqIDFlLTg7XG5cdFx0fSxcblxuXHRcdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh4MSAqIHgyICsgeTEgKiB5Milcblx0XHRcdFx0XHQ8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpXG5cdFx0XHRcdFx0XHQqIDFlLTg7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIG9wID0gTWF0aFtrZXldO1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiB0aGlzLl9nZXRTZWxlY3Rpb24oKSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZVNlbGVjdGlvbih0aGlzLl9nZXRTZWxlY3Rpb24oKSwgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXR0ZXIgPT09ICdzZXRQb3NpdGlvbicgPyA0IDogMDtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZGluZyA9IHRoaXMuX19yZWFkLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzSGVpZ2h0ID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy5fc2V0KGFyZzAsIGhhc0hlaWdodCA/IGFyZzEgOiBhcmcwKTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRyZWFkID0gaGFzSGVpZ2h0ID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9zZXQoMCwgMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG9iaiA9IHR5cGUgPT09ICdzdHJpbmcnID8gYXJnMC5zcGxpdCgvW1xccyxdKy8pIHx8IFtdIDogYXJnMDtcblx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHR0aGlzLl9zZXQoK29ialswXSwgKyhvYmoubGVuZ3RoID4gMSA/IG9ialsxXSA6IG9ialswXSkpO1xuXHRcdFx0fSBlbHNlIGlmICgnd2lkdGgnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLndpZHRoIHx8IDAsIG9iai5oZWlnaHQgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKCd4JyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai54IHx8IDAsIG9iai55IHx8IDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2V0KDAsIDApO1xuXHRcdFx0XHRyZWFkID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0OiAnI2luaXRpYWxpemUnLFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0cmV0dXJuIHNpemUgPT09IHRoaXMgfHwgc2l6ZSAmJiAodGhpcy53aWR0aCA9PT0gc2l6ZS53aWR0aFxuXHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHRcblx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShzaXplKSAmJiB0aGlzLndpZHRoID09PSBzaXplWzBdXG5cdFx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemVbMV0pIHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCArIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAtIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKiBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC8gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICUgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgJSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUoLXRoaXMud2lkdGgsIC10aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHRoaXMud2lkdGgpICYmIGlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIG9wID0gTWF0aFtrZXldO1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1JlY3RhbmdsZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHR0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy5fc2V0KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmcwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnMC54IHx8IDAsIGFyZzAueSB8fCAwLFxuXHRcdFx0XHRcdFx0YXJnMC53aWR0aCB8fCAwLCBhcmcwLmhlaWdodCB8fCAwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuZnJvbSA9PT0gdW5kZWZpbmVkICYmIGFyZzAudG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cdFx0XHRcdGlmIChCYXNlLnJlYWRTdXBwb3J0ZWQoYXJncywgdGhpcykpIHtcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocmVhZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgZnJtID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJyksXG5cdFx0XHRcdG5leHQgPSBCYXNlLnBlZWsoYXJncyksXG5cdFx0XHRcdHggPSBmcm0ueCxcblx0XHRcdFx0eSA9IGZybS55LFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0O1xuXHRcdFx0aWYgKG5leHQgJiYgbmV4dC54ICE9PSB1bmRlZmluZWQgfHwgQmFzZS5oYXNOYW1lZChhcmdzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJyk7XG5cdFx0XHRcdHdpZHRoID0gdG8ueCAtIHg7XG5cdFx0XHRcdGhlaWdodCA9IHRvLnkgLSB5O1xuXHRcdFx0XHRpZiAod2lkdGggPCAwKSB7XG5cdFx0XHRcdFx0eCA9IHRvLng7XG5cdFx0XHRcdFx0d2lkdGggPSAtd2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhlaWdodCA8IDApIHtcblx0XHRcdFx0XHR5ID0gdG8ueTtcblx0XHRcdFx0XHRoZWlnaHQgPSAtaGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmdzKTtcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHJlYWQgPSBhcmdzLl9faW5kZXg7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IGFyZ3MuX19maWx0ZXJlZDtcblx0XHRpZiAoZmlsdGVyZWQpXG5cdFx0XHR0aGlzLl9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcblx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0OiAnI2luaXRpYWxpemUnLFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdF9mdzogMSxcblx0X2ZoOiAxLFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRzeCA9IHRoaXMuX3N4LFxuXHRcdFx0c3kgPSB0aGlzLl9zeSxcblx0XHRcdHcgPSBzaXplLndpZHRoLFxuXHRcdFx0aCA9IHNpemUuaGVpZ2h0O1xuXHRcdGlmIChzeCkge1xuXHRcdFx0dGhpcy54ICs9ICh0aGlzLndpZHRoIC0gdykgKiBzeDtcblx0XHR9XG5cdFx0aWYgKHN5KSB7XG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gaCkgKiBzeTtcblx0XHR9XG5cdFx0dGhpcy53aWR0aCA9IHc7XG5cdFx0dGhpcy5oZWlnaHQgPSBoO1xuXHRcdHRoaXMuX2Z3ID0gdGhpcy5fZmggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZncpIHtcblx0XHRcdHZhciBhbW91bnQgPSBsZWZ0IC0gdGhpcy54O1xuXHRcdFx0dGhpcy53aWR0aCAtPSB0aGlzLl9zeCA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy54ID0gbGVmdDtcblx0XHR0aGlzLl9zeCA9IHRoaXMuX2Z3ID0gMDtcblx0fSxcblxuXHRnZXRUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnk7XG5cdH0sXG5cblx0c2V0VG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHRpZiAoIXRoaXMuX2ZoKSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gdG9wIC0gdGhpcy55O1xuXHRcdFx0dGhpcy5oZWlnaHQgLT0gdGhpcy5fc3kgPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG5cdFx0fVxuXHRcdHRoaXMueSA9IHRvcDtcblx0XHR0aGlzLl9zeSA9IHRoaXMuX2ZoID0gMDtcblx0fSxcblxuXHRnZXRSaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG5cdH0sXG5cblx0c2V0UmlnaHQ6IGZ1bmN0aW9uKHJpZ2h0KSB7XG5cdFx0aWYgKCF0aGlzLl9mdykge1xuXHRcdFx0dmFyIGFtb3VudCA9IHJpZ2h0IC0gdGhpcy54O1xuXHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuX3N4ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuXHRcdH1cblx0XHR0aGlzLnggPSByaWdodCAtIHRoaXMud2lkdGg7XG5cdFx0dGhpcy5fc3ggPSAxO1xuXHRcdHRoaXMuX2Z3ID0gMDtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICghdGhpcy5fZmgpIHtcblx0XHRcdHZhciBhbW91bnQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHRoaXMuX3N5ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuXHRcdH1cblx0XHR0aGlzLnkgPSBib3R0b20gLSB0aGlzLmhlaWdodDtcblx0XHR0aGlzLl9zeSA9IDE7XG5cdFx0dGhpcy5fZmggPSAwO1xuXHR9LFxuXG5cdGdldENlbnRlclg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcblx0fSxcblxuXHRzZXRDZW50ZXJYOiBmdW5jdGlvbih4KSB7XG5cdFx0aWYgKHRoaXMuX2Z3IHx8IHRoaXMuX3N4ID09PSAwLjUpIHtcblx0XHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX3N4KSB7XG5cdFx0XHRcdHRoaXMueCArPSAoeCAtIHRoaXMueCkgKiAyICogdGhpcy5fc3g7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLndpZHRoID0gKHggLSB0aGlzLngpICogMjtcblx0XHR9XG5cdFx0dGhpcy5fc3ggPSAwLjU7XG5cdFx0dGhpcy5fZncgPSAwO1xuXHR9LFxuXG5cdGdldENlbnRlclk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDI7XG5cdH0sXG5cblx0c2V0Q2VudGVyWTogZnVuY3Rpb24oeSkge1xuXHRcdGlmICh0aGlzLl9maCB8fCB0aGlzLl9zeSA9PT0gMC41KSB7XG5cdFx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5fc3kpIHtcblx0XHRcdFx0dGhpcy55ICs9ICh5IC0gdGhpcy55KSAqIDIgKiB0aGlzLl9zeTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVpZ2h0ID0gKHkgLSB0aGlzLnkpICogMjtcblx0XHR9XG5cdFx0dGhpcy5fc3kgPSAwLjU7XG5cdFx0dGhpcy5fZmggPSAwO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLmdldENlbnRlclgoKSwgdGhpcy5nZXRDZW50ZXJZKCksIHRoaXMsICdzZXRDZW50ZXInKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNldENlbnRlclgocG9pbnQueCk7XG5cdFx0dGhpcy5zZXRDZW50ZXJZKHBvaW50LnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKGFyZykge1xuXHRcdHJldHVybiBhcmcgJiYgYXJnLndpZHRoICE9PSB1bmRlZmluZWRcblx0XHRcdFx0fHwgKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cykubGVuZ3RoID09PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0ZXBzaWxvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpIHx8IDA7XG5cdFx0cmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPiB0aGlzLnggLSBlcHNpbG9uXG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55IC0gZXBzaWxvblxuXHRcdFx0XHQmJiByZWN0LnggPCB0aGlzLnggKyB0aGlzLndpZHRoICsgZXBzaWxvblxuXHRcdFx0XHQmJiByZWN0LnkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodCArIGVwc2lsb247XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdHVuaXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4MSA9IE1hdGgubWluKHRoaXMueCwgcmVjdC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0LnggKyByZWN0LndpZHRoKSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGluY2x1ZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpLFxuXHRcdFx0eDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC54KSxcblx0XHRcdHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHBvaW50LnkpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0ZXhwYW5kOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW1vdW50ID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRob3IgPSBhbW91bnQud2lkdGgsXG5cdFx0XHR2ZXIgPSBhbW91bnQuaGVpZ2h0O1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIGhvciAvIDIsIHRoaXMueSAtIHZlciAvIDIsXG5cdFx0XHRcdHRoaXMud2lkdGggKyBob3IsIHRoaXMuaGVpZ2h0ICsgdmVyKTtcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oaG9yLCB2ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQodGhpcy53aWR0aCAqIGhvciAtIHRoaXMud2lkdGgsXG5cdFx0XHRcdHRoaXMuaGVpZ2h0ICogKHZlciA9PT0gdW5kZWZpbmVkID8gaG9yIDogdmVyKSAtIHRoaXMuaGVpZ2h0KTtcblx0fVxufSwgQmFzZS5lYWNoKFtcblx0XHRbJ1RvcCcsICdMZWZ0J10sIFsnVG9wJywgJ1JpZ2h0J10sXG5cdFx0WydCb3R0b20nLCAnTGVmdCddLCBbJ0JvdHRvbScsICdSaWdodCddLFxuXHRcdFsnTGVmdCcsICdDZW50ZXInXSwgWydUb3AnLCAnQ2VudGVyJ10sXG5cdFx0WydSaWdodCcsICdDZW50ZXInXSwgWydCb3R0b20nLCAnQ2VudGVyJ11cblx0XSxcblx0ZnVuY3Rpb24ocGFydHMsIGluZGV4KSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0cy5qb2luKCcnKSxcblx0XHRcdHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl9zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0aW50ZXJuYWwgPSAnXycgKyBrZXk7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tpbnRlcm5hbF07XG5cdFx0fTtcblxuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuXHRcdFx0aWYgKCF0aGlzLl9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdH07XG5cdH0sIEJhc2UuZWFjaChbJ1BvaW50JywgJ1NpemUnLCAnQ2VudGVyJyxcblx0XHRcdCdMZWZ0JywgJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnQ2VudGVyWCcsICdDZW50ZXJZJyxcblx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddLFxuXHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIG5hbWUgPSAnc2V0JyArIGtleTtcblx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IHRydWU7XG5cdFx0XHRcdHByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgMik7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0XHRcdGlmIChvd25lci5fY2hhbmdlU2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0b3duZXIuX2NoYW5nZVNlbGVjdGlvbigyLCBzZWxlY3RlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZywgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGNvdW50ID0gYXJncy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID49IDYpIHtcblx0XHRcdHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxIHx8IGNvdW50ID09PSAyKSB7XG5cdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgTWF0cml4KSB7XG5cdFx0XHRcdHRoaXMuX3NldChhcmcuX2EsIGFyZy5fYiwgYXJnLl9jLCBhcmcuX2QsIGFyZy5fdHgsIGFyZy5fdHksXG5cdFx0XHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHR0aGlzLl9zZXQuYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdF9kb250Tm90aWZ5ID8gYXJnLmNvbmNhdChbX2RvbnROb3RpZnldKSA6IGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWNvdW50KSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghb2spIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0OiAnI2luaXRpYWxpemUnLFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoMjUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCxcblx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIG14ID09PSB0aGlzIHx8IG14ICYmIHRoaXMuX2EgPT09IG14Ll9hICYmIHRoaXMuX2IgPT09IG14Ll9iXG5cdFx0XHRcdCYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSBteC5fdHggJiYgdGhpcy5fdHkgPT09IG14Ll90eTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICdbWycgKyBbZi5udW1iZXIodGhpcy5fYSksIGYubnVtYmVyKHRoaXMuX2MpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R4KV0uam9pbignLCAnKSArICddLCBbJ1xuXHRcdFx0XHQrIFtmLm51bWJlcih0aGlzLl9iKSwgZi5udW1iZXIodGhpcy5fZCksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHkpXS5qb2luKCcsICcpICsgJ11dJztcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gdGhpcy5fZCA9IDE7XG5cdFx0dGhpcy5fYiA9IHRoaXMuX2MgPSB0aGlzLl90eCA9IHRoaXMuX3R5ID0gMDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGx5OiBmdW5jdGlvbihyZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRvd25lci50cmFuc2Zvcm0obnVsbCwgQmFzZS5waWNrKHJlY3Vyc2l2ZWx5LCB0cnVlKSwgX3NldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHNjYWxlID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYztcblx0XHR0aGlzLl9iID0gY29zICogYiArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fYyA9IC1zaW4gKiBhICsgY29zICogYztcblx0XHR0aGlzLl9kID0gLXNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYztcblx0XHR0aGlzLl90eSArPSB0eCAqIGIgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHNoZWFyID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYjtcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYyArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBiO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHNrZXcgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24obXgsIF9kb250Tm90aWZ5KSB7XG5cdFx0aWYgKG14KSB7XG5cdFx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0XHRiMiA9IG14Ll9jLFxuXHRcdFx0XHRjMiA9IG14Ll9iLFxuXHRcdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBjMTtcblx0XHRcdHRoaXMuX2MgPSBiMiAqIGExICsgZDIgKiBjMTtcblx0XHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYzIgKiBkMTtcblx0XHRcdHRoaXMuX2QgPSBiMiAqIGIxICsgZDIgKiBkMTtcblx0XHRcdHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYzE7XG5cdFx0XHR0aGlzLl90eSArPSB0eDIgKiBiMSArIHR5MiAqIGQxO1xuXHRcdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbihteCwgX2RvbnROb3RpZnkpIHtcblx0XHRpZiAobXgpIHtcblx0XHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdFx0YjIgPSBteC5fYyxcblx0XHRcdFx0YzIgPSBteC5fYixcblx0XHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYjE7XG5cdFx0XHR0aGlzLl9jID0gYTIgKiBjMSArIGIyICogZDE7XG5cdFx0XHR0aGlzLl9iID0gYzIgKiBhMSArIGQyICogYjE7XG5cdFx0XHR0aGlzLl9kID0gYzIgKiBjMSArIGQyICogZDE7XG5cdFx0XHR0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG5cdFx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGVuZGVkOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuYXBwZW5kKG14KTtcblx0fSxcblxuXHRwcmVwZW5kZWQ6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5wcmVwZW5kKG14KTtcblx0fSxcblxuXHRpbnZlcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZCxcblx0XHRcdHR4ID0gdGhpcy5fdHgsXG5cdFx0XHR0eSA9IHRoaXMuX3R5LFxuXHRcdFx0ZGV0ID0gYSAqIGQgLSBiICogYyxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG5cdFx0XHR0aGlzLl9hID0gZCAvIGRldDtcblx0XHRcdHRoaXMuX2IgPSAtYiAvIGRldDtcblx0XHRcdHRoaXMuX2MgPSAtYyAvIGRldDtcblx0XHRcdHRoaXMuX2QgPSBhIC8gZGV0O1xuXHRcdFx0dGhpcy5fdHggPSAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldDtcblx0XHRcdHRoaXMuX3R5ID0gKGIgKiB0eCAtIGEgKiB0eSkgLyBkZXQ7XG5cdFx0XHRyZXMgPSB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmludmVydCgpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiAnI2FwcGVuZCcsXG5cdHByZUNvbmNhdGVuYXRlOiAnI3ByZXBlbmQnLFxuXHRjaGFpbjogJyNhcHBlbmRlZCcsXG5cblx0X3NoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0X29yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYyAqIHRoaXMuX2I7XG5cdFx0cmV0dXJuIGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc0ludmVydGlibGUoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIGRzdCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQoXG5cdFx0XHRcdHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eCxcblx0XHRcdFx0eCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbWF4ID0gMiAqIGNvdW50OyBpIDwgbWF4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gc3JjW2ldLFxuXHRcdFx0XHR5ID0gc3JjW2kgKyAxXTtcblx0XHRcdGRzdFtpXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eDtcblx0XHRcdGRzdFtpICsgMV0gPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pIHtcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgPiBtYXhbal0pIHtcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0aW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kLFxuXHRcdFx0dHggPSB0aGlzLl90eCxcblx0XHRcdHR5ID0gdGhpcy5fdHksXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAoZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHR4KSAmJiBpc0Zpbml0ZSh0eSkpIHtcblx0XHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuXHRcdFx0aWYgKCFkZXN0KVxuXHRcdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0XHRyZXMgPSBkZXN0Ll9zZXQoXG5cdFx0XHRcdFx0KHggKiBkIC0geSAqIGMpIC8gZGV0LFxuXHRcdFx0XHRcdCh5ICogYSAtIHggKiBiKSAvIGRldCxcblx0XHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2QsXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRcdGF0YW4yID0gTWF0aC5hdGFuMixcblx0XHRcdGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0cm90YXRlLFxuXHRcdFx0c2NhbGUsXG5cdFx0XHRza2V3O1xuXHRcdGlmIChhICE9PSAwIHx8IGIgIT09IDApIHtcblx0XHRcdHZhciByID0gc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYWNvcyhhIC8gcikgKiAoYiA+IDAgPyAxIDogLTEpO1xuXHRcdFx0c2NhbGUgPSBbciwgZGV0IC8gcl07XG5cdFx0XHRza2V3ID0gW2F0YW4yKGEgKiBjICsgYiAqIGQsIHIgKiByKSwgMF07XG5cdFx0fSBlbHNlIGlmIChjICE9PSAwIHx8IGQgIT09IDApIHtcblx0XHRcdHZhciBzID0gc3FydChjICogYyArIGQgKiBkKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYXNpbihjIC8gcykgICogKGQgPiAwID8gMSA6IC0xKTtcblx0XHRcdHNjYWxlID0gW2RldCAvIHMsIHNdO1xuXHRcdFx0c2tldyA9IFswLCBhdGFuMihhICogYyArIGIgKiBkLCBzICogcyldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyb3RhdGUgPSAwO1xuXHRcdFx0c2tldyA9IHNjYWxlID0gWzAsIDBdO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHJhbnNsYXRpb246IHRoaXMuZ2V0VHJhbnNsYXRpb24oKSxcblx0XHRcdHJvdGF0aW9uOiByb3RhdGUgKiBkZWdyZWVzLFxuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlKSxcblx0XHRcdHNrZXdpbmc6IG5ldyBQb2ludChza2V3WzBdICogZGVncmVlcywgc2tld1sxXSAqIGRlZ3JlZXMpXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkuc2NhbGluZztcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkucm90YXRpb247XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5pc0lkZW50aXR5KCkpIHtcblx0XHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCxcblx0XHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdiJywgJ2MnLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRwcm9wID0gJ18nICsga2V5O1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2lnbmVkRGlzdGFuY2UocG9pbnQpKTtcblx0fSxcblxuXHRnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWduZWREaXN0YW5jZSh0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24obGluZSkge1xuXHRcdHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHAxeCwgcDF5LCB2MXgsIHYxeSwgcDJ4LCBwMnksIHYyeCwgdjJ5LCBhc1ZlY3Rvcixcblx0XHRcdFx0aXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2MXggLT0gcDF4O1xuXHRcdFx0XHR2MXkgLT0gcDF5O1xuXHRcdFx0XHR2MnggLT0gcDJ4O1xuXHRcdFx0XHR2MnkgLT0gcDJ5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNyb3NzID0gdjF4ICogdjJ5IC0gdjF5ICogdjJ4O1xuXHRcdFx0aWYgKCFOdW1lcmljYWwuaXNNYWNoaW5lWmVybyhjcm9zcykpIHtcblx0XHRcdFx0dmFyIGR4ID0gcDF4IC0gcDJ4LFxuXHRcdFx0XHRcdGR5ID0gcDF5IC0gcDJ5LFxuXHRcdFx0XHRcdHUxID0gKHYyeCAqIGR5IC0gdjJ5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0dTIgPSAodjF4ICogZHkgLSB2MXkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdFx0dU1pbiA9IC1lcHNpbG9uLFxuXHRcdFx0XHRcdHVNYXggPSAxICsgZXBzaWxvbjtcblx0XHRcdFx0aWYgKGlzSW5maW5pdGVcblx0XHRcdFx0XHRcdHx8IHVNaW4gPCB1MSAmJiB1MSA8IHVNYXggJiYgdU1pbiA8IHUyICYmIHUyIDwgdU1heCkge1xuXHRcdFx0XHRcdGlmICghaXNJbmZpbml0ZSkge1xuXHRcdFx0XHRcdFx0dTEgPSB1MSA8PSAwID8gMCA6IHUxID49IDEgPyAxIDogdTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdHAxeCArIHUxICogdjF4LFxuXHRcdFx0XHRcdFx0XHRwMXkgKyB1MSAqIHYxeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yLCBpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHZhciB2MnggPSB4IC0gcHgsXG5cdFx0XHRcdHYyeSA9IHkgLSBweSxcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDtcblx0XHRcdGlmICghaXNJbmZpbml0ZSAmJiBOdW1lcmljYWwuaXNNYWNoaW5lWmVybyhjY3cpKSB7XG5cdFx0XHRcdGNjdyA9ICh2MnggKiB2eCArIHYyeCAqIHZ4KSAvICh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0XHRcdGlmIChjY3cgPj0gMCAmJiBjY3cgPD0gMSlcblx0XHRcdFx0XHRjY3cgPSAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHQgIHJldHVybiAgdnggPT09IDAgPyAodnkgPiAwID8geCAtIHB4IDogcHggLSB4KVxuXHRcdFx0XHRcdDogdnkgPT09IDAgPyAodnggPCAwID8geSAtIHB5IDogcHkgLSB5KVxuXHRcdFx0XHRcdDogKCh4IC0gcHgpICogdnkgLSAoeSAtIHB5KSAqIHZ4KSAvIChcblx0XHRcdFx0XHRcdHZ5ID4gdnhcblx0XHRcdFx0XHRcdFx0PyB2eSAqIE1hdGguc3FydCgxICsgKHZ4ICogdngpIC8gKHZ5ICogdnkpKVxuXHRcdFx0XHRcdFx0XHQ6IHZ4ICogTWF0aC5zcXJ0KDEgKyAodnkgKiB2eSkgLyAodnggKiB2eCkpXG5cdFx0XHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKFxuXHRcdFx0XHRcdExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0Jyxcblx0X2NvbXBhY3RTZXJpYWxpemU6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUHJvamVjdChlbGVtZW50KSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzLCB0cnVlKTtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHR0aGlzLl9hY3RpdmVMYXllciA9IG51bGw7XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlID0gbmV3IFN0eWxlKG51bGwsIG51bGwsIHRoaXMpO1xuXHRcdHRoaXMuX3ZpZXcgPSBWaWV3LmNyZWF0ZSh0aGlzLFxuXHRcdFx0XHRlbGVtZW50IHx8IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcygxLCAxKSk7XG5cdFx0dGhpcy5fc2VsZWN0aW9uSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3Rpb25Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLl9jaGlsZHJlbiwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzLCBpdGVtKSB7XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0dmlldy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIXZpZXcuX3JlcXVlc3RlZCAmJiB2aWV3Ll9hdXRvVXBkYXRlKVxuXHRcdFx0XHRcdHZpZXcucmVxdWVzdFVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXM7XG5cdFx0aWYgKGNoYW5nZXMgJiYgaXRlbSkge1xuXHRcdFx0dmFyIGNoYW5nZXNCeUlkID0gdGhpcy5fY2hhbmdlc0J5SWQsXG5cdFx0XHRcdGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdGVudHJ5ID0gY2hhbmdlc0J5SWRbaWRdO1xuXHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdGVudHJ5LmZsYWdzIHw9IGZsYWdzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhbmdlcy5wdXNoKGNoYW5nZXNCeUlkW2lkXSA9IHsgaXRlbTogaXRlbSwgZmxhZ3M6IGZsYWdzIH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0Y2hpbGRyZW5baV0ucmVtb3ZlKCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5zZXQoc3R5bGUpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0Z2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLnNldHRpbmdzO1xuXHR9LFxuXG5cdGdldExheWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuXHR9LFxuXG5cdGdldEFjdGl2ZUxheWVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKHsgcHJvamVjdDogdGhpcywgaW5zZXJ0OiB0cnVlIH0pO1xuXHR9LFxuXG5cdGdldFN5bWJvbERlZmluaXRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVmaW5pdGlvbnMgPSBbXSxcblx0XHRcdGlkcyA9IHt9O1xuXHRcdHRoaXMuZ2V0SXRlbXMoe1xuXHRcdFx0Y2xhc3M6IFN5bWJvbEl0ZW0sXG5cdFx0XHRtYXRjaDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHR2YXIgZGVmaW5pdGlvbiA9IGl0ZW0uX2RlZmluaXRpb24sXG5cdFx0XHRcdFx0aWQgPSBkZWZpbml0aW9uLl9pZDtcblx0XHRcdFx0aWYgKCFpZHNbaWRdKSB7XG5cdFx0XHRcdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGRlZmluaXRpb25zO1xuXHR9LFxuXG5cdGdldFN5bWJvbHM6ICdnZXRTeW1ib2xEZWZpbml0aW9ucycsXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXMsXG5cdFx0XHRpdGVtcyA9IFtdO1xuXHRcdGZvciAodmFyIGlkIGluIHNlbGVjdGlvbkl0ZW1zKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHNlbGVjdGlvbkl0ZW1zW2lkXSxcblx0XHRcdFx0c2VsZWN0aW9uID0gaXRlbS5fc2VsZWN0aW9uO1xuXHRcdFx0aWYgKChzZWxlY3Rpb24gJiAxKSAmJiBpdGVtLmlzSW5zZXJ0ZWQoKSkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdFx0fSBlbHNlIGlmICghc2VsZWN0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXM7XG5cdFx0aWYgKGl0ZW0uX3NlbGVjdGlvbikge1xuXHRcdFx0aWYgKHNlbGVjdGlvbkl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3Rpb25Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3Rpb25JdGVtc1tpZF0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc2VsZWN0aW9uSXRlbXNbaWRdID09PSBpdGVtKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3Rpb25Db3VudC0tO1xuXHRcdFx0ZGVsZXRlIHNlbGVjdGlvbkl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zO1xuXHRcdGZvciAodmFyIGkgaW4gc2VsZWN0aW9uSXRlbXMpXG5cdFx0XHRzZWxlY3Rpb25JdGVtc1tpXS5zZXRGdWxseVNlbGVjdGVkKGZhbHNlKTtcblx0fSxcblxuXHRhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRMYXllcih1bmRlZmluZWQsIGxheWVyKTtcblx0fSxcblxuXHRpbnNlcnRMYXllcjogZnVuY3Rpb24oaW5kZXgsIGxheWVyKSB7XG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcblx0XHRcdGxheWVyLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0QmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIFtsYXllcl0sIGluZGV4LCAwKTtcblx0XHRcdGxheWVyLl9zZXRQcm9qZWN0KHRoaXMsIHRydWUpO1xuXHRcdFx0dmFyIG5hbWUgPSBsYXllci5fbmFtZTtcblx0XHRcdGlmIChuYW1lKVxuXHRcdFx0XHRsYXllci5zZXROYW1lKG5hbWUpO1xuXHRcdFx0aWYgKHRoaXMuX2NoYW5nZXMpXG5cdFx0XHRcdGxheWVyLl9jaGFuZ2VkKDUpO1xuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmVMYXllcilcblx0XHRcdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBsYXllcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbGF5ZXI7XG5cdH0sXG5cblx0X2luc2VydEl0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfY3JlYXRlZCkge1xuXHRcdGl0ZW0gPSB0aGlzLmluc2VydExheWVyKGluZGV4LCBpdGVtKVxuXHRcdFx0XHR8fCAodGhpcy5fYWN0aXZlTGF5ZXIgfHwgdGhpcy5faW5zZXJ0SXRlbSh1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRuZXcgTGF5ZXIoSXRlbS5OT19JTlNFUlQpLCB0cnVlKSlcblx0XHRcdFx0XHRcdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSk7XG5cdFx0aWYgKF9jcmVhdGVkICYmIGl0ZW0uYWN0aXZhdGUpXG5cdFx0XHRpdGVtLmFjdGl2YXRlKCk7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdHJlbW92ZU9uOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIHNldHMgPSB0aGlzLl9yZW1vdmVTZXRzO1xuXHRcdGlmIChzZXRzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNldXAnKVxuXHRcdFx0XHRzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG5cdFx0XHR2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gc2V0KSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBzZXRbaWRdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXIgPSBzZXRzW2tleV07XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldHNbdHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgcGl4ZWxSYXRpbykge1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24rKztcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGFyYW0gPSBuZXcgQmFzZSh7XG5cdFx0XHRcdG9mZnNldDogbmV3IFBvaW50KDAsIDApLFxuXHRcdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0XHR2aWV3TWF0cml4OiBtYXRyaXguaXNJZGVudGl0eSgpID8gbnVsbCA6IG1hdHJpeCxcblx0XHRcdFx0bWF0cmljZXM6IFtuZXcgTWF0cml4KCldLFxuXHRcdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHRcdH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdH1cblx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGlvbkNvdW50ID4gMCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zdHJva2VXaWR0aCA9IDE7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpIHtcblx0XHRcdFx0aXRlbXNbaWRdLl9kcmF3U2VsZWN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBpdGVtcywgdmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRzdGF0aWNzOiB7XG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc3JjKSB7XG5cdFx0XHRpZiAoc3JjLl9zZXJpYWxpemVGaWVsZHMpXG5cdFx0XHRcdHNyYy5fc2VyaWFsaXplRmllbGRzID0gQmFzZS5zZXQoe30sXG5cdFx0XHRcdFx0dGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdFx0cmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE5PX0lOU0VSVDogeyBpbnNlcnQ6IGZhbHNlIH1cblx0fSxcblxuXHRfY2xhc3M6ICdJdGVtJyxcblx0X25hbWU6IG51bGwsXG5cdF9hcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuXHRfY2FuU2NhbGVTdHJva2U6IGZhbHNlLFxuXHRfcGl2b3Q6IG51bGwsXG5cdF92aXNpYmxlOiB0cnVlLFxuXHRfYmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0X29wYWNpdHk6IDEsXG5cdF9sb2NrZWQ6IGZhbHNlLFxuXHRfZ3VpZGU6IGZhbHNlLFxuXHRfY2xpcE1hc2s6IGZhbHNlLFxuXHRfc2VsZWN0aW9uOiAwLFxuXHRfc2VsZWN0Qm91bmRzOiB0cnVlLFxuXHRfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0bmFtZTogbnVsbCxcblx0XHRhcHBseU1hdHJpeDogbnVsbCxcblx0XHRtYXRyaXg6IG5ldyBNYXRyaXgoKSxcblx0XHRwaXZvdDogbnVsbCxcblx0XHR2aXNpYmxlOiB0cnVlLFxuXHRcdGJsZW5kTW9kZTogJ25vcm1hbCcsXG5cdFx0b3BhY2l0eTogMSxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdGd1aWRlOiBmYWxzZSxcblx0XHRjbGlwTWFzazogZmFsc2UsXG5cdFx0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdGRhdGE6IHt9XG5cdH0sXG5cdF9wcmlvcml0aXplOiBbJ2FwcGx5TWF0cml4J11cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBoYW5kbGVycyA9IFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uQ2xpY2snLFxuXHRcdFx0J29uRG91YmxlQ2xpY2snLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZSddO1xuXHRyZXR1cm4gQmFzZS5lYWNoKGhhbmRsZXJzLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXMuX2V2ZW50c1tuYW1lXSA9IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9jb3VudEl0ZW1FdmVudCh0eXBlLCAxKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fY291bnRJdGVtRXZlbnQodHlwZSwgLTEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdF9ldmVudHM6IHtcblx0XHRcdFx0b25GcmFtZToge1xuXHRcdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25Mb2FkOiB7fSxcblx0XHRcdFx0b25FcnJvcjoge31cblx0XHRcdH0sXG5cdFx0XHRzdGF0aWNzOiB7XG5cdFx0XHRcdF9pdGVtSGFuZGxlcnM6IGhhbmRsZXJzXG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSwge1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBJdGVtKCkge1xuXHR9LFxuXG5cdF9pbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcywgcG9pbnQpIHtcblx0XHR2YXIgaGFzUHJvcHMgPSBwcm9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpLFxuXHRcdFx0aW50ZXJuYWwgPSBoYXNQcm9wcyAmJiBwcm9wcy5pbnRlcm5hbCA9PT0gdHJ1ZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdHByb2plY3QgPSBoYXNQcm9wcyAmJiBwcm9wcy5wcm9qZWN0IHx8IHBhcGVyLnByb2plY3QsXG5cdFx0XHRzZXR0aW5ncyA9IHBhcGVyLnNldHRpbmdzO1xuXHRcdHRoaXMuX2lkID0gaW50ZXJuYWwgPyBudWxsIDogVUlELmdldCgpO1xuXHRcdHRoaXMuX3BhcmVudCA9IHRoaXMuX2luZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdGlmIChwb2ludClcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuXHRcdG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cdFx0aWYgKGludGVybmFsIHx8IGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZVxuXHRcdFx0fHwgIXNldHRpbmdzLmluc2VydEl0ZW1zICYmICEoaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSB0cnVlKSkge1xuXHRcdFx0dGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0KGhhc1Byb3BzICYmIHByb3BzLnBhcmVudCB8fCBwcm9qZWN0KVxuXHRcdFx0XHRcdC5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMsIHRydWUpO1xuXHRcdH1cblx0XHRpZiAoaGFzUHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUKSB7XG5cdFx0XHR0aGlzLnNldChwcm9wcywge1xuXHRcdFx0XHRpbnRlcm5hbDogdHJ1ZSwgaW5zZXJ0OiB0cnVlLCBwcm9qZWN0OiB0cnVlLCBwYXJlbnQ6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzUHJvcHM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBwcm9wcyA9IHt9LFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZmllbGRzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoYXRba2V5XTtcblx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwga2V5ID09PSAnbGVhZGluZydcblx0XHRcdFx0XHRcdD8gZmllbGRzLmZvbnRTaXplICogMS4yIDogZmllbGRzW2tleV0pKSB7XG5cdFx0XHRcdFx0cHJvcHNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLFxuXHRcdFx0XHRcdFx0XHRrZXkgIT09ICdkYXRhJywgZGljdGlvbmFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpYWxpemUodGhpcy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0c2VyaWFsaXplKHRoaXMuX3N0eWxlLl9kZWZhdWx0cyk7XG5cdFx0cmV0dXJuIFsgdGhpcy5fY2xhc3MsIHByb3BzIF07XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0dmFyIHN5bWJvbCA9IHRoaXMuX3N5bWJvbCxcblx0XHRcdGNhY2hlUGFyZW50ID0gdGhpcy5fcGFyZW50IHx8IHN5bWJvbCxcblx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlZCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMTYpIHtcblx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGNhY2hlUGFyZW50XG5cdFx0XHRcdCYmIChmbGFncyAmIDcyKSkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDIpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChwcm9qZWN0KVxuXHRcdFx0cHJvamVjdC5fY2hhbmdlZChmbGFncywgdGhpcyk7XG5cdFx0aWYgKHN5bWJvbClcblx0XHRcdHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0fSxcblxuXHRzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0aWYgKG5hbWUgPT09ICgrbmFtZSkgKyAnJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnTmFtZXMgY29uc2lzdGluZyBvbmx5IG9mIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRpZiAobmFtZSAmJiBvd25lcikge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gb3duZXIuX25hbWVkQ2hpbGRyZW47XG5cdFx0XHQobmFtZWRDaGlsZHJlbltuYW1lXSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0gfHwgW10pLnB1c2godGhpcyk7XG5cdFx0XHRpZiAoIShuYW1lIGluIGNoaWxkcmVuKSlcblx0XHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgyNTYpO1xuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3R5bGU7XG5cdH0sXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdGtleSA9ICdfJyArIG5hbWUsXG5cdFx0XHRmbGFncyA9IHtcblx0XHRcdFx0bG9ja2VkOiAyNTYsXG5cdFx0XHRcdHZpc2libGU6IDI2NVxuXHRcdFx0fTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2tleV07XG5cdFx0fTtcblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXNba2V5XSkge1xuXHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZChmbGFnc1tuYW1lXSB8fCAyNTcpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG57fSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuXHR9LFxuXG5cdHNldFNlbGVjdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cdFx0aWYgKHNlbGVjdGlvbiAhPT0gdGhpcy5fc2VsZWN0aW9uKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRpZiAocHJvamVjdCkge1xuXHRcdFx0XHRwcm9qZWN0Ll91cGRhdGVTZWxlY3Rpb24odGhpcyk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoMjU3KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZVNlbGVjdGlvbjogZnVuY3Rpb24oZmxhZywgc2VsZWN0ZWQpIHtcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuXHRcdHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGVkID8gc2VsZWN0aW9uIHwgZmxhZyA6IHNlbGVjdGlvbiAmIH5mbGFnKTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhISh0aGlzLl9zZWxlY3Rpb24gJiAxKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlU2VsZWN0aW9uKDEsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0c2VsZWN0ZWQgPSAhISh0aGlzLl9zZWxlY3Rpb24gJiAxKTtcblx0XHRpZiAoY2hpbGRyZW4gJiYgc2VsZWN0ZWQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoIWNoaWxkcmVuW2ldLmlzRnVsbHlTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlU2VsZWN0aW9uKDEsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRpc0NsaXBNYXNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xpcE1hc2s7XG5cdH0sXG5cblx0c2V0Q2xpcE1hc2s6IGZ1bmN0aW9uKGNsaXBNYXNrKSB7XG5cdFx0aWYgKHRoaXMuX2NsaXBNYXNrICE9IChjbGlwTWFzayA9ICEhY2xpcE1hc2spKSB7XG5cdFx0XHR0aGlzLl9jbGlwTWFzayA9IGNsaXBNYXNrO1xuXHRcdFx0aWYgKGNsaXBNYXNrKSB7XG5cdFx0XHRcdHRoaXMuc2V0RmlsbENvbG9yKG51bGwpO1xuXHRcdFx0XHR0aGlzLnNldFN0cm9rZUNvbG9yKG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNTcpO1xuXHRcdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdFx0dGhpcy5fcGFyZW50Ll9jaGFuZ2VkKDIwNDgpO1xuXHRcdH1cblx0fSxcblxuXHRnZXREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2RhdGEpXG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH0sXG5cblx0c2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHR9LFxuXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gfHxcblx0XHRcdCh0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRnJvbUJvdW5kcygpKTtcblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0X2dldFBvc2l0aW9uRnJvbUJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bpdm90XG5cdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzLl9waXZvdClcblx0XHRcdFx0OiAoYm91bmRzIHx8IHRoaXMuZ2V0Qm91bmRzKCkpLmdldENlbnRlcih0cnVlKTtcblx0fSxcblxuXHRnZXRQaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0cmV0dXJuIHBpdm90XG5cdFx0XHRcdD8gbmV3IExpbmtlZFBvaW50KHBpdm90LngsIHBpdm90LnksIHRoaXMsICdzZXRQaXZvdCcpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRzZXRQaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGl2b3QgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSwgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdH1cbn0sIEJhc2UuZWFjaCh7XG5cdFx0Z2V0U3Ryb2tlQm91bmRzOiB7IHN0cm9rZTogdHJ1ZSB9LFxuXHRcdGdldEhhbmRsZUJvdW5kczogeyBoYW5kbGU6IHRydWUgfSxcblx0XHRnZXRJbnRlcm5hbEJvdW5kczogeyBpbnRlcm5hbDogdHJ1ZSB9XG5cdH0sXG5cdGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuXHRcdHRoaXNba2V5XSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKG1hdHJpeCwgb3B0aW9ucyk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgaGFzTWF0cml4ID0gb3B0aW9ucyB8fCBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXgsXG5cdFx0XHRvcHRzID0gQmFzZS5zZXQoe30sIGhhc01hdHJpeCA/IG9wdGlvbnMgOiBtYXRyaXgsXG5cdFx0XHRcdFx0dGhpcy5fYm91bmRzT3B0aW9ucyk7XG5cdFx0aWYgKCFvcHRzLnN0cm9rZSB8fCB0aGlzLmdldFN0cm9rZVNjYWxpbmcoKSlcblx0XHRcdG9wdHMuY2FjaGVJdGVtID0gdGhpcztcblx0XHR2YXIgcmVjdCA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhoYXNNYXRyaXggJiYgbWF0cml4LCBvcHRzKS5yZWN0O1xuXHRcdHJldHVybiAhYXJndW1lbnRzLmxlbmd0aFxuXHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LFxuXHRcdFx0XHRcdHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0X21hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdGlmIChyZWN0LndpZHRoICE9IGJvdW5kcy53aWR0aCB8fCByZWN0LmhlaWdodCAhPSBib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRpZiAoIV9tYXRyaXguaXNJbnZlcnRpYmxlKCkpIHtcblx0XHRcdFx0X21hdHJpeC5zZXQoX21hdHJpeC5fYmFja3VwXG5cdFx0XHRcdFx0XHR8fCBuZXcgTWF0cml4KCkudHJhbnNsYXRlKF9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdFx0bWF0cml4LnNjYWxlKFxuXHRcdFx0XHRcdGJvdW5kcy53aWR0aCAhPT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAwLFxuXHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQgIT09IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAwKTtcblx0XHR9XG5cdFx0Y2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuXHRcdHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLCBvcHRpb25zLmNhY2hlSXRlbSk7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCBvcHRpb25zKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzQ2FjaGVLZXk6IGZ1bmN0aW9uKG9wdGlvbnMsIGludGVybmFsKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdG9wdGlvbnMuc3Ryb2tlID8gMSA6IDAsXG5cdFx0XHRvcHRpb25zLmhhbmRsZSA/IDEgOiAwLFxuXHRcdFx0aW50ZXJuYWwgPyAxIDogMFxuXHRcdF0uam9pbignJyk7XG5cdH0sXG5cblx0X2dldENhY2hlZEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zLCBub0ludGVybmFsKSB7XG5cdFx0bWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHZhciBpbnRlcm5hbCA9IG9wdGlvbnMuaW50ZXJuYWwgJiYgIW5vSW50ZXJuYWwsXG5cdFx0XHRjYWNoZUl0ZW0gPSBvcHRpb25zLmNhY2hlSXRlbSxcblx0XHRcdF9tYXRyaXggPSBpbnRlcm5hbCA/IG51bGwgOiB0aGlzLl9tYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdGNhY2hlS2V5ID0gY2FjaGVJdGVtICYmICghbWF0cml4IHx8IG1hdHJpeC5lcXVhbHMoX21hdHJpeCkpXG5cdFx0XHRcdCYmIHRoaXMuX2dldEJvdW5kc0NhY2hlS2V5KG9wdGlvbnMsIGludGVybmFsKSxcblx0XHRcdGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLl9wYXJlbnQgfHwgdGhpcy5fc3ltYm9sLCBjYWNoZUl0ZW0pO1xuXHRcdGlmIChjYWNoZUtleSAmJiBib3VuZHMgJiYgY2FjaGVLZXkgaW4gYm91bmRzKSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlY3Q6IGNhY2hlZC5yZWN0LmNsb25lKCksXG5cdFx0XHRcdG5vbnNjYWxpbmc6IGNhY2hlZC5ub25zY2FsaW5nXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR2YXIgcmVzID0gdGhpcy5fZ2V0Qm91bmRzKG1hdHJpeCB8fCBfbWF0cml4LCBvcHRpb25zKSxcblx0XHRcdHJlY3QgPSByZXMucmVjdCB8fCByZXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bm9uc2NhbGluZyA9IHJlcy5ub25zY2FsaW5nIHx8IHN0eWxlLmhhc1N0cm9rZSgpXG5cdFx0XHRcdCYmICFzdHlsZS5nZXRTdHJva2VTY2FsaW5nKCk7XG5cdFx0aWYgKGNhY2hlS2V5KSB7XG5cdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHZhciBjYWNoZWQgPSBib3VuZHNbY2FjaGVLZXldID0ge1xuXHRcdFx0XHRyZWN0OiByZWN0LmNsb25lKCksXG5cdFx0XHRcdG5vbnNjYWxpbmc6IG5vbnNjYWxpbmcsXG5cdFx0XHRcdGludGVybmFsOiBpbnRlcm5hbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlY3Q6IHJlY3QsXG5cdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nXG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0U3Ryb2tlTWF0cml4OiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkgPyBudWxsXG5cdFx0XHRcdDogb3B0aW9ucyAmJiBvcHRpb25zLmludGVybmFsID8gdGhpc1xuXHRcdFx0XHRcdDogdGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCAmJiB0aGlzLl9zeW1ib2wuX2l0ZW0sXG5cdFx0XHRteCA9IHBhcmVudCA/IHBhcmVudC5nZXRWaWV3TWF0cml4KCkuaW52ZXJ0KCkgOiBtYXRyaXg7XG5cdFx0cmV0dXJuIG14ICYmIG14Ll9zaGlmdGxlc3MoKTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X3VwZGF0ZUJvdW5kc0NhY2hlOiBmdW5jdGlvbihwYXJlbnQsIGl0ZW0pIHtcblx0XHRcdGlmIChwYXJlbnQgJiYgaXRlbSkge1xuXHRcdFx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdFx0XHRyZWYgPSBwYXJlbnQuX2JvdW5kc0NhY2hlID0gcGFyZW50Ll9ib3VuZHNDYWNoZSB8fCB7XG5cdFx0XHRcdFx0XHRpZHM6IHt9LFxuXHRcdFx0XHRcdFx0bGlzdDogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIXJlZi5pZHNbaWRdKSB7XG5cdFx0XHRcdFx0cmVmLmxpc3QucHVzaChpdGVtKTtcblx0XHRcdFx0XHRyZWYuaWRzW2lkXSA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NsZWFyQm91bmRzQ2FjaGU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBjYWNoZSA9IGl0ZW0uX2JvdW5kc0NhY2hlO1xuXHRcdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRcdGl0ZW0uX2JvdW5kcyA9IGl0ZW0uX3Bvc2l0aW9uID0gaXRlbS5fYm91bmRzQ2FjaGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY2FjaGUubGlzdCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR2YXIgb3RoZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChvdGhlciAhPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0b3RoZXIuX2JvdW5kcyA9IG90aGVyLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChvdGhlci5fYm91bmRzQ2FjaGUpXG5cdFx0XHRcdFx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUob3RoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihpdGVtcywgbWF0cml4LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgeDEgPSBJbmZpbml0eSxcblx0XHRcdFx0eDIgPSAteDEsXG5cdFx0XHRcdHkxID0geDEsXG5cdFx0XHRcdHkyID0geDIsXG5cdFx0XHRcdG5vbnNjYWxpbmcgPSBmYWxzZTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aWYgKGl0ZW0uX3Zpc2libGUgJiYgIWl0ZW0uaXNFbXB0eSh0cnVlKSkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBpdGVtLl9nZXRDYWNoZWRCb3VuZHMoXG5cdFx0XHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmFwcGVuZGVkKGl0ZW0uX21hdHJpeCksIG9wdGlvbnMsIHRydWUpLFxuXHRcdFx0XHRcdFx0cmVjdCA9IGJvdW5kcy5yZWN0O1xuXHRcdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdFx0eTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcblx0XHRcdFx0XHR4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcblx0XHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHRcdFx0aWYgKGJvdW5kcy5ub25zY2FsaW5nKVxuXHRcdFx0XHRcdFx0bm9uc2NhbGluZyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlY3Q6IGlzRmluaXRlKHgxKVxuXHRcdFx0XHRcdD8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cdFx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCksXG5cdFx0XHRcdG5vbnNjYWxpbmc6IG5vbnNjYWxpbmdcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeFxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHRoaXMuX2RlY29tcG9zZWQgfHwgKHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCkpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZSgpO1xuXHRcdHJldHVybiBkZWNvbXBvc2VkID8gZGVjb21wb3NlZC5yb3RhdGlvbiA6IDA7XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQpIHtcblx0XHRcdFx0ZGVjb21wb3NlZC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKSxcblx0XHRcdHMgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZztcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHMgPyBzLnggOiAxLCBzID8gcy55IDogMSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuXHRcdFx0c2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY3VycmVudCAmJiBzY2FsaW5nICYmICFjdXJyZW50LmVxdWFscyhzY2FsaW5nKSkge1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpLFxuXHRcdFx0XHRkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCxcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0aWYgKGlzWmVybyhjdXJyZW50LngpIHx8IGlzWmVybyhjdXJyZW50LnkpKSB7XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUoZGVjb21wb3NlZC50cmFuc2xhdGlvbik7XG5cdFx0XHRcdGlmIChyb3RhdGlvbikge1xuXHRcdFx0XHRcdG1hdHJpeC5yb3RhdGUocm90YXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdHJpeC5zY2FsZShzY2FsaW5nLngsIHNjYWxpbmcueSk7XG5cdFx0XHRcdHRoaXMuX21hdHJpeC5zZXQobWF0cml4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpO1xuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChyb3RhdGlvbilcblx0XHRcdFx0XHRtYXRyaXgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdFx0bWF0cml4LnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHRcdFx0aWYgKHJvdGF0aW9uKVxuXHRcdFx0XHRcdG1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uKTtcblx0XHRcdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdFx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlY29tcG9zZWQpIHtcblx0XHRcdFx0ZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcblx0XHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fSxcblxuXHRzZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cdFx0bWF0cml4LnNldC5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Z2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbihfZG9udENsb25lKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeDtcblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0dmFyIHBhcmVudHMgPSBbXTtcblx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKCFwYXJlbnQuX2dsb2JhbE1hdHJpeCkge1xuXHRcdFx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJlbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0cGFyZW50c1tpXS5fZ2xvYmFsTWF0cml4ID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50cy5wdXNoKHBhcmVudCk7XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIW1hdHJpeCkge1xuXHRcdFx0bWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0bWF0cml4LnByZXBlbmQocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0fVxuXHRcdHJldHVybiBfZG9udENsb25lID8gbWF0cml4IDogbWF0cml4LmNsb25lKCk7XG5cdH0sXG5cblx0Z2V0Vmlld01hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlcGVuZCh0aGlzLmdldFZpZXcoKS5fbWF0cml4KTtcblx0fSxcblxuXHRnZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4O1xuXHR9LFxuXG5cdHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbihhcHBseSkge1xuXHRcdGlmICh0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmICEhYXBwbHkpXG5cdFx0XHR0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0fSxcblxuXHRnZXRUcmFuc2Zvcm1Db250ZW50OiAnI2dldEFwcGx5TWF0cml4Jyxcblx0c2V0VHJhbnNmb3JtQ29udGVudDogJyNzZXRBcHBseU1hdHJpeCcsXG59LCB7XG5cdGdldFByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0O1xuXHR9LFxuXG5cdF9zZXRQcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0LCBpbnN0YWxsRXZlbnRzKSB7XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QgIT09IHByb2plY3QpIHtcblx0XHRcdGlmICh0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0XHRpbnN0YWxsRXZlbnRzID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKGluc3RhbGxFdmVudHMpXG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKHRydWUpO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0Ll92aWV3O1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0X2dldE93bmVyOiAnI2dldFBhcmVudCcsXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRyZXR1cm4gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0aW5zZXJ0ID0gQmFzZS5waWNrKG9wdGlvbnMgPyBvcHRpb25zLmluc2VydCA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gdHJ1ZSksXG5cdFx0XHRkZWVwID0gQmFzZS5waWNrKG9wdGlvbnMgPyBvcHRpb25zLmRlZXAgOiB1bmRlZmluZWQsIHRydWUpO1xuXHRcdGlmIChjaGlsZHJlbilcblx0XHRcdGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0aWYgKCFjaGlsZHJlbiB8fCBkZWVwKVxuXHRcdFx0Y29weS5jb3B5Q29udGVudCh0aGlzKTtcblx0XHRpZiAoIWNoaWxkcmVuKVxuXHRcdFx0Y29weS5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRpZiAoaW5zZXJ0KVxuXHRcdFx0Y29weS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHR2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKG5hbWUgJiYgcGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRvcmlnID0gbmFtZSxcblx0XHRcdFx0aSA9IDE7XG5cdFx0XHR3aGlsZSAoY2hpbGRyZW5bbmFtZV0pXG5cdFx0XHRcdG5hbWUgPSBvcmlnICsgJyAnICsgKGkrKyk7XG5cdFx0XHRpZiAobmFtZSAhPT0gb3JpZylcblx0XHRcdFx0Y29weS5zZXROYW1lKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29weTtcblx0fSxcblxuXHRjb3B5Q29udGVudDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gc291cmNlLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5hZGRDaGlsZChjaGlsZHJlbltpXS5jbG9uZShmYWxzZSksIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRjb3B5QXR0cmlidXRlczogZnVuY3Rpb24oc291cmNlLCBleGNsdWRlTWF0cml4KSB7XG5cdFx0dGhpcy5zZXRTdHlsZShzb3VyY2UuX3N0eWxlKTtcblx0XHR2YXIga2V5cyA9IFsnX2xvY2tlZCcsICdfdmlzaWJsZScsICdfYmxlbmRNb2RlJywgJ19vcGFjaXR5Jyxcblx0XHRcdFx0J19jbGlwTWFzaycsICdfZ3VpZGUnXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRcdFx0dGhpc1trZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHRcdGlmICghZXhjbHVkZU1hdHJpeClcblx0XHRcdHRoaXMuX21hdHJpeC5zZXQoc291cmNlLl9tYXRyaXgsIHRydWUpO1xuXHRcdHRoaXMuc2V0QXBwbHlNYXRyaXgoc291cmNlLl9hcHBseU1hdHJpeCk7XG5cdFx0dGhpcy5zZXRQaXZvdChzb3VyY2UuX3Bpdm90KTtcblx0XHR0aGlzLnNldFNlbGVjdGlvbihzb3VyY2UuX3NlbGVjdGlvbik7XG5cdFx0dmFyIGRhdGEgPSBzb3VyY2UuX2RhdGEsXG5cdFx0XHRuYW1lID0gc291cmNlLl9uYW1lO1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhID8gQmFzZS5jbG9uZShkYXRhKSA6IG51bGw7XG5cdFx0aWYgKG5hbWUpXG5cdFx0XHR0aGlzLnNldE5hbWUobmFtZSk7XG5cdH0sXG5cblx0cmFzdGVyaXplOiBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHJlc29sdXRpb24sXG5cdFx0XHRpbnNlcnQsXG5cdFx0XHRyYXN0ZXI7XG5cdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcwKSkge1xuXHRcdFx0cmVzb2x1dGlvbiA9IGFyZzAucmVzb2x1dGlvbjtcblx0XHRcdGluc2VydCA9IGFyZzAuaW5zZXJ0O1xuXHRcdFx0cmFzdGVyID0gYXJnMC5yYXN0ZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc29sdXRpb24gPSBhcmcwO1xuXHRcdFx0aW5zZXJ0ID0gYXJnMTtcblx0XHR9XG5cdFx0aWYgKHJhc3Rlcikge1xuXHRcdFx0cmFzdGVyLm1hdHJpeC5yZXNldCh0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcygpLFxuXHRcdFx0c2NhbGUgPSAocmVzb2x1dGlvbiB8fCB0aGlzLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkpIC8gNzIsXG5cdFx0XHR0b3BMZWZ0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpLFxuXHRcdFx0Ym90dG9tUmlnaHQgPSBib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKS5jZWlsKCksXG5cdFx0XHRib3VuZHNTaXplID0gbmV3IFNpemUoYm90dG9tUmlnaHQuc3VidHJhY3QodG9wTGVmdCkpLFxuXHRcdFx0cmFzdGVyU2l6ZSA9IGJvdW5kc1NpemUubXVsdGlwbHkoc2NhbGUpO1xuXHRcdHJhc3Rlci5zZXRTaXplKHJhc3RlclNpemUsIHRydWUpO1xuXG5cdFx0aWYgKCFyYXN0ZXJTaXplLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgY3R4ID0gcmFzdGVyLmdldENvbnRleHQodHJ1ZSksXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdFx0dGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdFx0cmFzdGVyLnRyYW5zZm9ybShcblx0XHRcdG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQudHJhbnNsYXRlKHRvcExlZnQuYWRkKGJvdW5kc1NpemUuZGl2aWRlKDIpKSlcblx0XHRcdFx0LnNjYWxlKDEgLyBzY2FsZSlcblx0XHQpO1xuXHRcdGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpIHtcblx0XHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRyZXR1cm4gKFxuXHRcdFx0bWF0cml4LmlzSW52ZXJ0aWJsZSgpICYmXG5cdFx0XHQhIXRoaXMuX2NvbnRhaW5zKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKVxuXHRcdCk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRyZWN0YW5nbGU6IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSxcblx0XHRcdG1hdHJpeDogdGhpcy5fbWF0cml4LFxuXHRcdFx0aW5zZXJ0OiBmYWxzZSxcblx0XHR9KTtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbihpdGVtLCBfbWF0cml4KSB7XG5cdFx0aWYgKCEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksIG51bGwsXG5cdFx0XHRcdF9tYXRyaXgsIHRydWUpLmxlbmd0aCA+IDA7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGhpdFRlc3QoKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIHRoaXMuX2hpdFRlc3QoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3MpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhpdFRlc3RBbGwoKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoYXJncyksXG5cdFx0XHRhbGwgPSBbXTtcblx0XHR0aGlzLl9oaXRUZXN0KHBvaW50LCBuZXcgQmFzZSh7IGFsbDogYWxsIH0sIG9wdGlvbnMpKTtcblx0XHRyZXR1cm4gYWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBfZXhjbHVkZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHR2YXIgcmVzID0gY2hpbGQgIT09IF9leGNsdWRlICYmIGNoaWxkLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zLFxuXHRcdFx0XHRcdFx0dmlld01hdHJpeCk7XG5cdFx0XHRcdGlmIChyZXMgJiYgIW9wdGlvbnMuYWxsKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGhpdFRlc3Q6IGhpdFRlc3QsXG5cdFx0aGl0VGVzdEFsbDogaGl0VGVzdEFsbCxcblx0XHRfaGl0VGVzdDogaGl0VGVzdENoaWxkcmVuXG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0aGl0VGVzdDogaGl0VGVzdCxcblx0XHRoaXRUZXN0QWxsOiBoaXRUZXN0QWxsLFxuXHRcdF9oaXRUZXN0Q2hpbGRyZW46IGhpdFRlc3RDaGlsZHJlbixcblx0fTtcbn0sIHtcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMsIHBhcmVudFZpZXdNYXRyaXgpIHtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJlbnRWaWV3TWF0cml4XG5cdFx0XHRcdFx0PyBwYXJlbnRWaWV3TWF0cml4LmFwcGVuZGVkKG1hdHJpeClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlcGVuZCh0aGlzLmdldFZpZXcoKS5fbWF0cml4KSxcblx0XHRcdHRvbGVyYW5jZSA9IE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAxZS0xMiksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFBhdGguX2dldFN0cm9rZVBhZGRpbmcodG9sZXJhbmNlLFxuXHRcdFx0XHRcdFx0bWF0cml4Ll9zaGlmdGxlc3MoKS5pbnZlcnQoKSkpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblx0XHRpZiAoIXBvaW50IHx8ICF0aGlzLl9jaGlsZHJlbiAmJlxuXHRcdFx0IXRoaXMuZ2V0Qm91bmRzKHsgaW50ZXJuYWw6IHRydWUsIHN0cm9rZTogdHJ1ZSwgaGFuZGxlOiB0cnVlIH0pXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgY2hlY2tTZWxmID0gIShvcHRpb25zLmd1aWRlcyAmJiAhdGhpcy5fZ3VpZGVcblx0XHRcdFx0fHwgb3B0aW9ucy5zZWxlY3RlZCAmJiAhdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0fHwgb3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdHx8IG9wdGlvbnMuY2xhc3MgJiYgISh0aGlzIGluc3RhbmNlb2Ygb3B0aW9ucy5jbGFzcykpLFxuXHRcdFx0bWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRib3VuZHMsXG5cdFx0XHRyZXM7XG5cblx0XHRmdW5jdGlvbiBmaWx0ZXIoaGl0KSB7XG5cdFx0XHRpZiAoaGl0ICYmIG1hdGNoICYmICFtYXRjaChoaXQpKVxuXHRcdFx0XHRoaXQgPSBudWxsO1xuXHRcdFx0aWYgKGhpdCAmJiBvcHRpb25zLmFsbClcblx0XHRcdFx0b3B0aW9ucy5hbGwucHVzaChoaXQpO1xuXHRcdFx0cmV0dXJuIGhpdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1BvaW50KHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IHBhcnQgPyBib3VuZHNbJ2dldCcgKyBwYXJ0XSgpIDogdGhhdC5nZXRQb3NpdGlvbigpO1xuXHRcdFx0aWYgKHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUodG9sZXJhbmNlUGFkZGluZykubGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCwge1xuXHRcdFx0XHRcdG5hbWU6IHBhcnQgPyBCYXNlLmh5cGhlbmF0ZShwYXJ0KSA6IHR5cGUsXG5cdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGVja1Bvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbixcblx0XHRcdGNoZWNrQ2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRjaGVja0JvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xuXHRcdGlmIChjaGVja1NlbGYgJiYgdGhpcy5fcGFyZW50XG5cdFx0XHRcdCYmIChjaGVja1Bvc2l0aW9uIHx8IGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSkge1xuXHRcdFx0aWYgKGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSB7XG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKTtcblx0XHRcdH1cblx0XHRcdHJlcyA9IGNoZWNrUG9zaXRpb24gJiYgY2hlY2tQb2ludCgncG9zaXRpb24nKSB8fFxuXHRcdFx0XHRcdGNoZWNrQ2VudGVyICYmIGNoZWNrUG9pbnQoJ2NlbnRlcicsICdDZW50ZXInKTtcblx0XHRcdGlmICghcmVzICYmIGNoZWNrQm91bmRzKSB7XG5cdFx0XHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlcidcblx0XHRcdFx0XTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4ICYmICFyZXM7IGkrKykge1xuXHRcdFx0XHRcdHJlcyA9IGNoZWNrUG9pbnQoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcyA9IGZpbHRlcihyZXMpO1xuXHRcdH1cblxuXHRcdGlmICghcmVzKSB7XG5cdFx0XHRyZXMgPSB0aGlzLl9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpXG5cdFx0XHRcdHx8IGNoZWNrU2VsZlxuXHRcdFx0XHRcdCYmIGZpbHRlcih0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0XHRcdHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbFxuXHRcdFx0XHRcdFx0XHQ6IHZpZXdNYXRyaXguX3NoaWZ0bGVzcygpLmludmVydCgpKSlcblx0XHRcdFx0fHwgbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpIHtcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSh0aGlzKTtcblx0XHR9IGVsc2UgaWYgKG5hbWUgPT09ICdtYXRjaCcpIHtcblx0XHRcdHJldHVybiBjb21wYXJlKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdFx0PyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKClcblx0XHRcdFx0XHQ6IG5hbWUgPT09ICd0eXBlJ1xuXHRcdFx0XHRcdFx0PyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogdGhpc1tuYW1lXTtcblx0XHRcdGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGNvbXBhcmU7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fY2xhc3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuICEhY29tcGFyZSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUpIHtcblx0XHRcdFx0aWYgKGNvbXBhcmUudGVzdCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wYXJlLnRlc3QodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpWzBdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9nZXRJdGVtczogZnVuY3Rpb24gX2dldEl0ZW1zKGl0ZW0sIG9wdGlvbnMsIG1hdHJpeCwgcGFyYW0sIGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSkge1xuXHRcdFx0XHR2YXIgb2JqID0gdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmcgPSBvYmogJiYgb2JqLm92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdGluc2lkZSA9IG9iaiAmJiBvYmouaW5zaWRlLFxuXHRcdFx0XHRcdGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcblx0XHRcdFx0XHRyZWN0ID0gYm91bmRzICYmIFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdKTtcblx0XHRcdFx0cGFyYW0gPSB7XG5cdFx0XHRcdFx0aXRlbXM6IFtdLFxuXHRcdFx0XHRcdHJlY3Vyc2l2ZTogb2JqICYmIG9iai5yZWN1cnNpdmUgIT09IGZhbHNlLFxuXHRcdFx0XHRcdGluc2lkZTogISFpbnNpZGUsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmc6ICEhb3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0cmVjdDogcmVjdCxcblx0XHRcdFx0XHRwYXRoOiBvdmVybGFwcGluZyAmJiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0XHRcdFx0cmVjdGFuZ2xlOiByZWN0LFxuXHRcdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvYmopIHtcblx0XHRcdFx0XHRvcHRpb25zID0gQmFzZS5maWx0ZXIoe30sIG9wdGlvbnMsIHtcblx0XHRcdFx0XHRcdHJlY3Vyc2l2ZTogdHJ1ZSwgaW5zaWRlOiB0cnVlLCBvdmVybGFwcGluZzogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbixcblx0XHRcdFx0aXRlbXMgPSBwYXJhbS5pdGVtcyxcblx0XHRcdFx0cmVjdCA9IHBhcmFtLnJlY3Q7XG5cdFx0XHRtYXRyaXggPSByZWN0ICYmIChtYXRyaXggfHwgbmV3IE1hdHJpeCgpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRcdGNoaWxkTWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChjaGlsZC5fbWF0cml4KSxcblx0XHRcdFx0XHRhZGQgPSB0cnVlO1xuXHRcdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmICghcmVjdC5pbnRlcnNlY3RzKGJvdW5kcykpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAoIShyZWN0LmNvbnRhaW5zKGJvdW5kcylcblx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ub3ZlcmxhcHBpbmcgJiYgKGJvdW5kcy5jb250YWlucyhyZWN0KVxuXHRcdFx0XHRcdFx0XHRcdHx8IHBhcmFtLnBhdGguaW50ZXJzZWN0cyhjaGlsZCwgY2hpbGRNYXRyaXgpKSkpXG5cdFx0XHRcdFx0XHRhZGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWRkICYmIGNoaWxkLm1hdGNoZXMob3B0aW9ucykpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRpZiAoZmlyc3RPbmx5KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhcmFtLnJlY3Vyc2l2ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRfZ2V0SXRlbXMoY2hpbGQsIG9wdGlvbnMsIGNoaWxkTWF0cml4LCBwYXJhbSwgZmlyc3RPbmx5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpcyA/IHRoaXMuYWRkQ2hpbGQocmVzKSA6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG5cdFx0dmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0pIDogbnVsbDtcblx0XHRyZXR1cm4gcmVzICYmIHJlc1swXTtcblx0fSxcblxuXHRhZGRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQmFzZS5zbGljZShpdGVtcyk7XG5cdFx0XHR2YXIgaW5zZXJ0ZWQgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldLFxuXHRcdFx0XHRcdGlkID0gaXRlbSAmJiBpdGVtLl9pZDtcblx0XHRcdFx0aWYgKCFpdGVtIHx8IGluc2VydGVkW2lkXSkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdGluc2VydGVkW2lkXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEJhc2Uuc3BsaWNlKGNoaWxkcmVuLCBpdGVtcywgaW5kZXgsIDApO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRub3RpZnlTZWxmID0gcHJvamVjdC5fY2hhbmdlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV0sXG5cdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX25hbWU7XG5cdFx0XHRcdGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cdFx0XHRcdGl0ZW0uX3NldFByb2plY3QocHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChuYW1lKVxuXHRcdFx0XHRcdGl0ZW0uc2V0TmFtZShuYW1lKTtcblx0XHRcdFx0aWYgKG5vdGlmeVNlbGYpXG5cdFx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtcyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfaW5zZXJ0SXRlbTogJyNpbnNlcnRDaGlsZCcsXG5cblx0X2luc2VydEF0OiBmdW5jdGlvbihpdGVtLCBvZmZzZXQpIHtcblx0XHR2YXIgb3duZXIgPSBpdGVtICYmIGl0ZW0uX2dldE93bmVyKCksXG5cdFx0XHRyZXMgPSBpdGVtICE9PSB0aGlzICYmIG93bmVyID8gdGhpcyA6IG51bGw7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0cmVzLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0b3duZXIuX2luc2VydEl0ZW0oaXRlbS5faW5kZXggKyBvZmZzZXQsIHJlcyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0aW5zZXJ0QWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMCk7XG5cdH0sXG5cblx0c2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRyZXR1cm4gb3duZXIgPyBvd25lci5faW5zZXJ0SXRlbSgwLCB0aGlzKSA6IG51bGw7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciA/IG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcykgOiBudWxsO1xuXHR9LFxuXG5cdGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG5cblx0YXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG5cdH0sXG5cblx0bW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcblxuXHRtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuXG5cdGFkZFRvOiBmdW5jdGlvbihvd25lcikge1xuXHRcdHJldHVybiBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24ob3duZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZShmYWxzZSkuYWRkVG8ob3duZXIpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuWzBdLnJlZHVjZShvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpIHtcblx0XHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3JlbW92ZU5hbWVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gb3duZXIuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRcdG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0XHRuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcblx0XHRcdFx0aW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKVxuXHRcdFx0XHRcdGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0bmFtZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24obm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKSxcblx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAodGhpcy5fc3R5bGUpXG5cdFx0XHR0aGlzLl9zdHlsZS5fZGlzcG9zZSgpO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdFx0cHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdFx0QmFzZS5zcGxpY2Uob3duZXIuX2NoaWxkcmVuLCBudWxsLCBpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KVxuXHRcdFx0XHRvd25lci5fY2hhbmdlZCgxMSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24ocmVjdXJzaXZlbHkpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHR2YXIgbnVtQ2hpbGRyZW4gPSBjaGlsZHJlbiA/IGNoaWxkcmVuLmxlbmd0aCA6IDA7XG5cdFx0aWYgKHJlY3Vyc2l2ZWx5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoaWxkcmVuOyBpKyspIHtcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0VtcHR5KHJlY3Vyc2l2ZWx5KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhbnVtQ2hpbGRyZW47XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09PSBpdGVtKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNTaWJsaW5nOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbS5fcGFyZW50O1xuXHR9LFxuXG5cdGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQuX3BhcmVudFxuXHRcdFx0XHQmJiAvXihHcm91cHxMYXllcnxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKVxuXHRcdFx0XHQmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxufSwgQmFzZS5lYWNoKFsncm90YXRlJywgJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciByb3RhdGUgPSBrZXkgPT09ICdyb3RhdGUnO1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHZhbHVlID0gKHJvdGF0ZSA/IEJhc2UgOiBQb2ludCkucmVhZChhcmdzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW2tleV0odmFsdWUsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH07XG59LCB7XG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHR0cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXggJiYgIW1hdHJpeC5pc0lkZW50aXR5KCksXG5cdFx0XHRhcHBseU1hdHJpeCA9IChcblx0XHRcdFx0X3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4IHx8XG5cdFx0XHRcdHRoaXMuX2FwcGx5TWF0cml4ICYmIChcblx0XHRcdFx0XHR0cmFuc2Zvcm1NYXRyaXggfHwgIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8XG5cdFx0XHRcdFx0X2FwcGx5UmVjdXJzaXZlbHkgJiYgdGhpcy5fY2hpbGRyZW5cblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHRpZiAoIXRyYW5zZm9ybU1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAodHJhbnNmb3JtTWF0cml4KSB7XG5cdFx0XHRpZiAoIW1hdHJpeC5pc0ludmVydGlibGUoKSAmJiBfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0XHRfbWF0cml4Ll9iYWNrdXAgPSBfbWF0cml4LmdldFZhbHVlcygpO1xuXHRcdFx0X21hdHJpeC5wcmVwZW5kKG1hdHJpeCwgdHJ1ZSk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuXHRcdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuXHRcdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdFx0ZmlsbENvbG9yLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcblx0XHR9XG5cblx0XHRpZiAoYXBwbHlNYXRyaXggJiYgKGFwcGx5TWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtQ29udGVudChcblx0XHRcdFx0X21hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdGlmIChwaXZvdClcblx0XHRcdFx0X21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QsIHBpdm90LCB0cnVlKTtcblx0XHRcdF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0XHRpZiAoX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4KVxuXHRcdFx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdGlmICh0cmFuc2Zvcm1NYXRyaXggfHwgYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdH1cblx0XHR2YXIgZGVjb21wID0gdHJhbnNmb3JtTWF0cml4ICYmIGJvdW5kcyAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0aWYgKGRlY29tcCAmJiBkZWNvbXAuc2tld2luZy5pc1plcm8oKSAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGNhY2hlLm5vbnNjYWxpbmcpIHtcblx0XHRcdFx0XHRkZWxldGUgYm91bmRzW2tleV07XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXBwbHlNYXRyaXggfHwgIWNhY2hlLmludGVybmFsKSB7XG5cdFx0XHRcdFx0dmFyIHJlY3QgPSBjYWNoZS5yZWN0O1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW3RoaXMuX2dldEJvdW5kc0NhY2hlS2V5KFxuXHRcdFx0XHR0aGlzLl9ib3VuZHNPcHRpb25zIHx8IHt9KV07XG5cdFx0XHRpZiAoY2FjaGVkKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gcm9tQm91bmRzKGNhY2hlZC5yZWN0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybU1hdHJpeCAmJiBwb3NpdGlvbiAmJiB0aGlzLl9waXZvdCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvc2l0aW9uLCBwb3NpdGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgsIGFwcGx5UmVjdXJzaXZlbHksIHNldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl9pbnZlcnNlVHJhbnNmb3JtKFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9HbG9iYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cGFyZW50VG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9QYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Zml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcblx0XHRyZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0aXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcblx0XHRcdHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG5cdFx0XHRzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKVxuXHRcdFx0XHRcdD8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0OiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcblx0XHRcdG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksXG5cdFx0XHRcdFx0bmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuXHRcdG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcblx0XHR0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuXHR9XG59KSwge1xuXG5cdF9zZXRTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbENvbG9yKCkudG9DYW52YXNTdHlsZShjdHgsIG1hdHJpeCk7XG5cdFx0fVxuXHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCwgbWF0cml4KTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdFx0dmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRcdHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0cm9rZUpvaW4pXG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG5cdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcblx0XHRcdGlmIChtaXRlckxpbWl0KVxuXHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG5cdFx0XHRcdHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdHlsZS5oYXNTaGFkb3coKSkge1xuXHRcdFx0dmFyIHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdG14ID0gdmlld01hdHJpeC5fc2hpZnRsZXNzKCkucHJlcGVuZChcblx0XHRcdFx0XHRuZXcgTWF0cml4KCkuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbykpLFxuXHRcdFx0XHRibHVyID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChzdHlsZS5nZXRTaGFkb3dCbHVyKCksIDApKSxcblx0XHRcdFx0b2Zmc2V0ID0gbXgudHJhbnNmb3JtKHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCkpO1xuXHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRjdHguc2hhZG93Qmx1ciA9IGJsdXIuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuXHRcdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fb3BhY2l0eSA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0Z2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uYXBwZW5kZWQobWF0cml4KTtcblx0XHRpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdHJldHVybjtcblxuXHRcdHZpZXdNYXRyaXggPSB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5hcHBlbmRlZChnbG9iYWxNYXRyaXgpXG5cdFx0XHRcdDogZ2xvYmFsTWF0cml4O1xuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IGdsb2JhbE1hdHJpeDtcblx0XHR9XG5cblx0XHR2YXIgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlLFxuXHRcdFx0b3BhY2l0eSA9IE51bWVyaWNhbC5jbGFtcCh0aGlzLl9vcGFjaXR5LCAwLCAxKSxcblx0XHRcdG5vcm1hbEJsZW5kID0gYmxlbmRNb2RlID09PSAnbm9ybWFsJyxcblx0XHRcdG5hdGl2ZUJsZW5kID0gQmxlbmRNb2RlLm5hdGl2ZU1vZGVzW2JsZW5kTW9kZV0sXG5cdFx0XHRkaXJlY3QgPSBub3JtYWxCbGVuZCAmJiBvcGFjaXR5ID09PSAxXG5cdFx0XHRcdFx0fHwgcGFyYW0uZG9udFN0YXJ0XG5cdFx0XHRcdFx0fHwgcGFyYW0uY2xpcFxuXHRcdFx0XHRcdHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSlcblx0XHRcdFx0XHRcdCYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdG1haW5DdHgsIGl0ZW1PZmZzZXQsIHByZXZPZmZzZXQ7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyh2aWV3TWF0cml4KTtcblx0XHRcdGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcblx0XHRcdG1haW5DdHggPSBjdHg7XG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKVxuXHRcdFx0XHRcdC5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSlcblx0XHRcdFx0Y3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXhcblx0XHRcdFx0PyBwYXJlbnRTdHJva2VNYXRyaXguYXBwZW5kZWQobWF0cml4KVxuXHRcdFx0XHQ6IHRoaXMuX2NhblNjYWxlU3Ryb2tlICYmICF0aGlzLmdldFN0cm9rZVNjYWxpbmcodHJ1ZSlcblx0XHRcdFx0XHQmJiB2aWV3TWF0cml4LFxuXHRcdFx0Y2xpcCA9ICFkaXJlY3QgJiYgcGFyYW0uY2xpcEl0ZW0sXG5cdFx0XHR0cmFuc2Zvcm0gPSAhc3Ryb2tlTWF0cml4IHx8IGNsaXA7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblx0XHRcdGlmIChuYXRpdmVCbGVuZClcblx0XHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcblx0XHR9XG5cdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0KGRpcmVjdCA/IG1hdHJpeCA6IHZpZXdNYXRyaXgpLmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0fVxuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRwYXJhbS5jbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKSB7XG5cdFx0XHRjdHguY2xpcCh0aGlzLmdldEZpbGxSdWxlKCkpO1xuXHRcdH1cblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3Rpb25JdGVtcywgdXBkYXRlVmVyc2lvbikge1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRpdGVtU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAxLFxuXHRcdFx0Ym91bmRzU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAyXG5cdFx0XHRcdFx0fHwgaXRlbVNlbGVjdGVkICYmIHRoaXMuX3NlbGVjdEJvdW5kcyxcblx0XHRcdHBvc2l0aW9uU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiA0O1xuXHRcdGlmICghdGhpcy5fZHJhd1NlbGVjdGVkKVxuXHRcdFx0aXRlbVNlbGVjdGVkID0gZmFsc2U7XG5cdFx0aWYgKChpdGVtU2VsZWN0ZWQgfHwgYm91bmRzU2VsZWN0ZWQgfHwgcG9zaXRpb25TZWxlY3RlZClcblx0XHRcdFx0JiYgdGhpcy5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR2YXIgbGF5ZXIsXG5cdFx0XHRcdGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpIHx8IChsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSlcblx0XHRcdFx0XHQmJiBsYXllci5nZXRTZWxlY3RlZENvbG9yKHRydWUpLFxuXHRcdFx0XHRteCA9IG1hdHJpeC5hcHBlbmRlZCh0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSksXG5cdFx0XHRcdGhhbGYgPSBzaXplIC8gMjtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKGl0ZW1TZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGlvbkl0ZW1zKTtcblx0XHRcdGlmIChwb3NpdGlvblNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRcdHBhcmVudCA9IHRoaXMuX3BhcmVudCxcblx0XHRcdFx0XHRwb2ludCA9IHBhcmVudCA/IHBhcmVudC5sb2NhbFRvR2xvYmFsKHBvcykgOiBwb3MsXG5cdFx0XHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyh4LCB5LCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0dmFyIGRlbHRhcyA9IFtbMCwgLTFdLCBbMSwgMF0sIFswLCAxXSwgWy0xLCAwXV0sXG5cdFx0XHRcdFx0c3RhcnQgPSBoYWxmLFxuXHRcdFx0XHRcdGVuZCA9IHNpemUgKyAxO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciBkZWx0YSA9IGRlbHRhc1tpXSxcblx0XHRcdFx0XHRcdGR4ID0gZGVsdGFbMF0sXG5cdFx0XHRcdFx0XHRkeSA9IGRlbHRhWzFdO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeCArIGR4ICogc3RhcnQsIHkgKyBkeSAqIHN0YXJ0KTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyBkeCAqIGVuZCwgeSArIGR5ICogZW5kKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChib3VuZHNTZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRcdGN0eFshaSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsXG5cdFx0XHRcdFx0XHRcdHNpemUsIHNpemUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNoID0ge307XG5cdFx0aGFzaFtrZXldID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pLCB7XG5cdHR3ZWVuOiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHRvO1xuXHRcdFx0dG8gPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IG51bGw7XG5cdFx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IHRvO1xuXHRcdFx0XHR0byA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBlYXNpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZWFzaW5nLFxuXHRcdFx0c3RhcnQgPSBvcHRpb25zICYmIG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMgIT0gbnVsbCAmJiAoXG5cdFx0XHRcdHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyA/IG9wdGlvbnMgOiBvcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpLFxuXHRcdFx0dHdlZW4gPSBuZXcgVHdlZW4odGhpcywgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KTtcblx0XHRmdW5jdGlvbiBvbkZyYW1lKGV2ZW50KSB7XG5cdFx0XHR0d2Vlbi5faGFuZGxlRnJhbWUoZXZlbnQudGltZSAqIDEwMDApO1xuXHRcdFx0aWYgKCF0d2Vlbi5ydW5uaW5nKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdmcmFtZScsIG9uRnJhbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZHVyYXRpb24pIHtcblx0XHRcdHRoaXMub24oJ2ZyYW1lJywgb25GcmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fSxcblxuXHR0d2VlblRvOiBmdW5jdGlvbih0bywgb3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnR3ZWVuKG51bGwsIHRvLCBvcHRpb25zKTtcblx0fSxcblxuXHR0d2VlbkZyb206IGZ1bmN0aW9uKGZyb20sIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy50d2Vlbihmcm9tLCBudWxsLCBvcHRpb25zKTtcblx0fVxufSk7XG5cbnZhciBHcm91cCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JvdXAnLFxuXHRfc2VsZWN0Qm91bmRzOiBmYWxzZSxcblx0X3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiAyMDUwKSB7XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0X2dldENsaXBJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblx0XHRpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xpcEl0ZW0gPSBudWxsO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24gX2dldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHRcdHJldHVybiBjbGlwSXRlbVxuXHRcdFx0PyBjbGlwSXRlbS5fZ2V0Q2FjaGVkQm91bmRzKGNsaXBJdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksXG5cdFx0XHRcdEJhc2Uuc2V0KHt9LCBvcHRpb25zLCB7IHN0cm9rZTogZmFsc2UgfSkpXG5cdFx0XHQ6IF9nZXRCb3VuZHMuYmFzZS5jYWxsKHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2hpdFRlc3RDaGlsZHJlbjogZnVuY3Rpb24gX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuXHRcdHZhciBjbGlwSXRlbSA9IHRoaXMuX2dldENsaXBJdGVtKCk7XG5cdFx0cmV0dXJuICghY2xpcEl0ZW0gfHwgY2xpcEl0ZW0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHQmJiBfaGl0VGVzdENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0XHRjbGlwSXRlbSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCk7XG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBjbGlwSXRlbTogY2xpcEl0ZW0sIGNsaXA6IGZhbHNlIH0pO1xuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGl0ZW0gIT09IGNsaXBJdGVtKVxuXHRcdFx0XHRpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKCkge1xuXHRcdEdyb3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2dldE93bmVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuX2luZGV4ICE9IG51bGwgJiYgdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKCkge1xuXHR9XG59KTtcblxudmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaGFwZScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHR5cGU6IG51bGwsXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRyYWRpdXM6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcywgcG9pbnQpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzLCBwb2ludCk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSBpdGVtLl90eXBlXG5cdFx0XHQmJiB0aGlzLl9zaXplLmVxdWFscyhpdGVtLl9zaXplKVxuXHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fcmFkaXVzLCBpdGVtLl9yYWRpdXMpO1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldFR5cGUoc291cmNlLl90eXBlKTtcblx0XHR0aGlzLnNldFNpemUoc291cmNlLl9zaXplKTtcblx0XHR0aGlzLnNldFJhZGl1cyhzb3VyY2UuX3JhZGl1cyk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChTaXplLm1pbih0aGlzLl9yYWRpdXMsIHNpemUuZGl2aWRlKDIpLmFicygpKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5fc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zaXplLl9zZXQod2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG5cdFx0XHRcdD8gcmFkXG5cdFx0XHRcdDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbihyYWRpdXMpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBzaXplID0gcmFkaXVzICogMjtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMuX3NpemUuX3NldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cyk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplLl9zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRpZiAocGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXgpXG5cdFx0XHRwYXRoLnNldEFwcGx5TWF0cml4KHRydWUpO1xuXHRcdGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpXG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdHRvU2hhcGU6ICcjY2xvbmUnLFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b1BhdGgoZmFsc2UpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuXHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSB8fCBkb250UGFpbnQpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRpc0NpcmNsZSA9IHR5cGUgPT09ICdjaXJjbGUnO1xuXHRcdFx0aWYgKCFwYXJhbS5kb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIGlzQ2lyY2xlKSB7XG5cdFx0XHRcdGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcnggPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRzaXplID0gdGhpcy5fc2l6ZSxcblx0XHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIHR5cGUgPT09ICdyZWN0YW5nbGUnICYmIHJ4ID09PSAwICYmIHJ5ID09PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LnJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciB4ID0gd2lkdGggLyAyLFxuXHRcdFx0XHRcdFx0eSA9IGhlaWdodCAvIDIsXG5cdFx0XHRcdFx0XHRrYXBwYSA9IDEgLSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0XHRcdFx0XHRjeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjeSA9IHJ5ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjID0gW1xuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIC15LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgeSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIHJ5XG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdGlmIChzdHJva2VNYXRyaXgpXG5cdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgudHJhbnNmb3JtKGMsIGMsIDMyKTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGNbMF0sIGNbMV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1s4XSwgY1s5XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxMF0sIGNbMTFdLCBjWzEyXSwgY1sxM10sIGNbMTRdLCBjWzE1XSk7XG5cdFx0XHRcdFx0aWYgKHkgIT09IHJ5KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzE2XSwgY1sxN10pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMThdLCBjWzE5XSwgY1syMF0sIGNbMjFdLCBjWzIyXSwgY1syM10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1syNF0sIGNbMjVdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzI2XSwgY1syN10sIGNbMjhdLCBjWzI5XSwgY1szMF0sIGNbMzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdH1cblx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdHN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKClcblx0XHRcdFx0XHQmJiBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRyZWN0ID0gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCk7XG5cdFx0cmV0dXJuIHN0cm9rZVdpZHRoXG5cdFx0XHRcdD8gcmVjdC5leHBhbmQoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VXaWR0aCxcblx0XHRcdFx0XHR0aGlzLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSkpXG5cdFx0XHRcdDogcmVjdDtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIHEgPSAxOyBxIDw9IDQ7IHErKykge1xuXHRcdFx0XHR2YXIgZGlyID0gbmV3IFBvaW50KHEgPiAxICYmIHEgPCA0ID8gLTEgOiAxLCBxID4gMiA/IC0xIDogMSksXG5cdFx0XHRcdFx0Y29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcblx0XHRcdFx0XHRjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuXHRcdFx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKFxuXHRcdFx0XHRcdFx0XHRleHBhbmQgPyBjb3JuZXIuYWRkKGRpci5tdWx0aXBseShleHBhbmQpKSA6IGNvcm5lcixcblx0XHRcdFx0XHRcdFx0Y2VudGVyKTtcblx0XHRcdFx0aWYgKHJlY3QuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB7IHBvaW50OiBjZW50ZXIsIHF1YWRyYW50OiBxIH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQsIHJhZGl1cywgcGFkZGluZywgcXVhZHJhbnQpIHtcblx0XHR2YXIgdmVjdG9yID0gcG9pbnQuZGl2aWRlKHJhZGl1cyk7XG5cdFx0cmV0dXJuICghcXVhZHJhbnQgfHwgdmVjdG9yLmlzSW5RdWFkcmFudChxdWFkcmFudCkpICYmXG5cdFx0XHRcdHZlY3Rvci5zdWJ0cmFjdCh2ZWN0b3Iubm9ybWFsaXplKCkpLm11bHRpcGx5KHJhZGl1cylcblx0XHRcdFx0XHQuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfY29udGFpbnM6IGZ1bmN0aW9uIF9jb250YWlucyhwb2ludCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY2VudGVyXG5cdFx0XHRcdFx0XHQ/IHBvaW50LnN1YnRyYWN0KGNlbnRlci5wb2ludCkuZGl2aWRlKHRoaXMuX3JhZGl1cylcblx0XHRcdFx0XHRcdFx0LmdldExlbmd0aCgpIDw9IDFcblx0XHRcdFx0XHRcdDogX2NvbnRhaW5zLmJhc2UuY2FsbCh0aGlzLCBwb2ludCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQuZGl2aWRlKHRoaXMuc2l6ZSkuZ2V0TGVuZ3RoKCkgPD0gMC41O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIF9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0c3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2UsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKTtcblx0XHRcdGlmIChoaXRTdHJva2UgfHwgaGl0RmlsbCkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogMCxcblx0XHRcdFx0XHRzdHJva2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZy5hZGQoXG5cdFx0XHRcdFx0XHRQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0IXN0eWxlLmdldFN0cm9rZVNjYWxpbmcoKSAmJiBzdHJva2VNYXRyaXgpKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHBhZGRpbmcgPSBzdHJva2VQYWRkaW5nLm11bHRpcGx5KDIpLFxuXHRcdFx0XHRcdFx0Y2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBwYWRkaW5nKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHRoaXQgPSBpc09uRWxsaXBzZVN0cm9rZShwb2ludC5zdWJ0cmFjdChjZW50ZXIucG9pbnQpLFxuXHRcdFx0XHRcdFx0XHRcdHJhZGl1cywgc3Ryb2tlUGFkZGluZywgY2VudGVyLnF1YWRyYW50KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0aW5uZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nLm5lZ2F0ZSgpKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpdCA9IGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LCByYWRpdXMsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0ID8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IF9oaXRUZXN0U2VsZi5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5zdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNyZWF0ZVNoYXBlKHR5cGUsIHBvaW50LCBzaXplLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgaXRlbSA9IEJhc2UuY3JlYXRlKFNoYXBlLnByb3RvdHlwZSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdGl0ZW0uX2luaXRpYWxpemUoQmFzZS5nZXROYW1lZChhcmdzKSwgcG9pbnQpO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5taW4oU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0ZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmdzKSxcblx0XHRcdFx0cmFkaXVzID0gZWxsaXBzZS5yYWRpdXM7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2VsbGlwc2UnLCBlbGxpcHNlLmNlbnRlciwgcmFkaXVzLm11bHRpcGx5KDIpLFxuXHRcdFx0XHRcdHJhZGl1cywgYXJncyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IGZhbHNlLCBoYW5kbGU6IGZhbHNlIH0sXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjcm9zc09yaWdpbjogbnVsbCxcblx0XHRzb3VyY2U6IG51bGxcblx0fSxcblx0X3ByaW9yaXRpemU6IFsnY3Jvc3NPcmlnaW4nXSxcblx0X3Ntb290aGluZzogJ2xvdycsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3Rlcihzb3VyY2UsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKHNvdXJjZSxcblx0XHRcdFx0cG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpKSB7XG5cdFx0XHR2YXIgaW1hZ2UsXG5cdFx0XHRcdHR5cGUgPSB0eXBlb2Ygc291cmNlLFxuXHRcdFx0XHRvYmplY3QgPSB0eXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdD8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKVxuXHRcdFx0XHRcdDogdHlwZSAgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0XHQ/IHNvdXJjZVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0aWYgKG9iamVjdCAmJiBvYmplY3QgIT09IEl0ZW0uTk9fSU5TRVJUKSB7XG5cdFx0XHRcdGlmIChvYmplY3QuZ2V0Q29udGV4dCB8fCBvYmplY3QubmF0dXJhbEhlaWdodCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aW1hZ2UgPSBvYmplY3Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0XHRpZiAoIXNpemUuaXNaZXJvKCkpIHtcblx0XHRcdFx0XHRcdGltYWdlID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBpbWFnZSA9IHNvdXJjZS5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSBzb3VyY2UuX2NhbnZhcztcblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdHRoaXMuX3NldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc291cmNlLl9zaXplKTtcblx0XHRcdGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdHRoaXMuX3NldEltYWdlKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IHNvdXJjZS5fY3Jvc3NPcmlnaW47XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplID8gc2l6ZS53aWR0aCA6IDAsIHNpemUgPyBzaXplLmhlaWdodCA6IDAsXG5cdFx0XHRcdHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oX3NpemUsIF9jbGVhcikge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuXHRcdFx0aWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9ICFfY2xlYXIgJiYgdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0XHRcdHRoaXMuX3NldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLFxuXHRcdFx0XHRcdFx0XHRzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoX2NsZWFyKSB7XG5cdFx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0Z2V0TG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gIXNpemUgfHwgc2l6ZS53aWR0aCA9PT0gMCAmJiBzaXplLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0b3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG5cdFx0XHR2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuXHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdDcyIC8gdS5nZXRMZW5ndGgoKSxcblx0XHRcdDcyIC8gdi5nZXRMZW5ndGgoKVxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0UHBpOiAnI2dldFJlc29sdXRpb24nLFxuXG5cdGdldEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH0sXG5cblx0c2V0SW1hZ2U6IGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gZW1pdChldmVudCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKSxcblx0XHRcdFx0dHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGUgfHwgJ2xvYWQnO1xuXHRcdFx0aWYgKHZpZXcgJiYgdGhhdC5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRwYXBlciA9IHZpZXcuX3Njb3BlO1xuXHRcdFx0XHR0aGF0LmVtaXQodHlwZSwgbmV3IEV2ZW50KGV2ZW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHNldFRpbWVvdXQoZW1pdCwgMCk7XG5cdFx0fSBlbHNlIGlmIChpbWFnZSkge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7XG5cdFx0XHRcdGxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0dGhhdC5fc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHRcdGVtaXQoZXZlbnQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZW1pdFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gISEoaW1hZ2UgJiYgaW1hZ2Uuc3JjICYmIGltYWdlLmNvbXBsZXRlKTtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aCA6IDAsXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQgOiAwKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDEwMzMpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihfY2hhbmdlKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoX2NoYW5nZSkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMDI1KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG5cdFx0cmV0dXJuIGltYWdlICYmIGltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIGltYWdlID0gbmV3IHNlbGYuSW1hZ2UoKSxcblx0XHRcdGNyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW47XG5cdFx0aWYgKGNyb3NzT3JpZ2luKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAoc3JjKVxuXHRcdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRyZXR1cm4gaW1hZ2UgJiYgaW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRpZiAoaW1hZ2UpXG5cdFx0XHRpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldFNtb290aGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Ntb290aGluZztcblx0fSxcblxuXHRzZXRTbW9vdGhpbmc6IGZ1bmN0aW9uKHNtb290aGluZykge1xuXHRcdHRoaXMuX3Ntb290aGluZyA9IHR5cGVvZiBzbW9vdGhpbmcgPT09ICdzdHJpbmcnXG5cdFx0XHQ/IHNtb290aGluZ1xuXHRcdFx0OiBzbW9vdGhpbmcgPyAnbG93JyA6ICdvZmYnO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjU3KTtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzIHx8IHRoaXMuX2xvYWRlZCAmJiB0aGlzLl9pbWFnZTtcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0U3ViQ2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHJlY3QuZ2V0U2l6ZSgpKTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBjdHguY2FudmFzO1xuXHR9LFxuXG5cdGdldFN1YlJhc3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0cmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLl9zZXRJbWFnZSh0aGlzLmdldFN1YkNhbnZhcyhyZWN0KSk7XG5cdFx0cmFzdGVyLnRyYW5zbGF0ZShyZWN0LmdldENlbnRlcigpLnN1YnRyYWN0KHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZSgyKSkpO1xuXHRcdHJhc3Rlci5fbWF0cml4LnByZXBlbmQodGhpcy5fbWF0cml4KTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHR0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxuXHRcdFx0c3JjID0gaW1hZ2UgJiYgaW1hZ2Uuc3JjO1xuXHRcdGlmICgvXmRhdGE6Ly50ZXN0KHNyYykpXG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXHRcdHJldHVybiBjYW52YXMgPyBjYW52YXMudG9EYXRhVVJMLmFwcGx5KGNhbnZhcywgYXJndW1lbnRzKSA6IG51bGw7XG5cdH0sXG5cblx0ZHJhd0ltYWdlOiBmdW5jdGlvbihpbWFnZSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbihvYmplY3QpIHtcblx0XHR2YXIgYm91bmRzLCBwYXRoO1xuXHRcdGlmICghb2JqZWN0KSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcblx0XHRcdHBhdGggPSBvYmplY3Q7XG5cdFx0XHRib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKCd3aWR0aCcgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoJ3gnIGluIG9iamVjdCkge1xuXHRcdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghYm91bmRzKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHNhbXBsZVNpemUgPSAzMixcblx0XHRcdHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcblx0XHRcdGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuXHRcdHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0bmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChwYXRoKVxuXHRcdFx0cGF0aC5kcmF3KGN0eCwgbmV3IEJhc2UoeyBjbGlwOiB0cnVlLCBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCksXG5cdFx0XHRzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRpZiAoZWxlbWVudClcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuXHRcdFx0XHRNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcblx0XHRcdGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuXHRcdFx0dG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0dmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcblx0XHRcdHRvdGFsICs9IGFscGhhO1xuXHRcdFx0YWxwaGEgLz0gMjU1O1xuXHRcdFx0Y2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKVxuXHRcdFx0Y2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cdFx0cmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sXG5cdFx0XHRcdGRhdGFbM10gLyAyNTUpO1xuXHR9LFxuXG5cdHNldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmdzKSxcblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG5cdFx0XHRhbHBoYSA9IGNvbG9yLl9hbHBoYSxcblx0XHRcdGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcblx0XHRcdGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG5cdFx0XHRkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0ZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG5cdFx0ZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG5cdFx0ZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG5cdFx0ZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcblx0XHRjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHR9LFxuXG5cdGNyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuY3JlYXRlSW1hZ2VEYXRhKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRnZXRJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocmVjdC5pc0VtcHR5KCkpXG5cdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdH0sXG5cblx0c2V0SW1hZ2VEYXRhOiBmdW5jdGlvbihkYXRhICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkucHV0SW1hZ2VEYXRhKGRhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuXHRcdFx0XHRvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcblx0XHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCAmJiBlbGVtZW50LndpZHRoID4gMCAmJiBlbGVtZW50LmhlaWdodCA+IDApIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IE51bWVyaWNhbC5jbGFtcCh0aGlzLl9vcGFjaXR5LCAwLCAxKTtcblxuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXG5cdFx0XHR2YXIgc21vb3RoaW5nID0gdGhpcy5fc21vb3RoaW5nLFxuXHRcdFx0XHRkaXNhYmxlZCA9IHNtb290aGluZyA9PT0gJ29mZic7XG5cdFx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKFxuXHRcdFx0XHRjdHgsXG5cdFx0XHRcdGRpc2FibGVkID8gJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCcgOiAnaW1hZ2VTbW9vdGhpbmdRdWFsaXR5Jyxcblx0XHRcdFx0ZGlzYWJsZWQgPyBmYWxzZSA6IHNtb290aGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFN5bWJvbEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbEl0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IHRydWUgfSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbEl0ZW0oYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihhcmcwIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbiA/XG5cdFx0XHRcdFx0YXJnMCA6IG5ldyBTeW1ib2xEZWZpbml0aW9uKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlZmluaXRpb24gPT09IGl0ZW0uX2RlZmluaXRpb247XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0RGVmaW5pdGlvbihzb3VyY2UuX2RlZmluaXRpb24pO1xuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogJyNnZXREZWZpbml0aW9uJyxcblx0c2V0U3ltYm9sOiAnI3NldERlZmluaXRpb24nLFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uLl9pdGVtLmlzRW1wdHkoKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW07XG5cdFx0cmV0dXJuIGl0ZW0uX2dldENhY2hlZEJvdW5kcyhpdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcblx0XHR2YXIgb3B0cyA9IG9wdGlvbnMuZXh0ZW5kKHsgYWxsOiBmYWxzZSB9KTtcblx0XHR2YXIgcmVzID0gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5faGl0VGVzdChwb2ludCwgb3B0cywgdmlld01hdHJpeCk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5fZGVmaW5pdGlvbi5faXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHR9XG5cbn0pO1xuXG52YXIgU3ltYm9sRGVmaW5pdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU3ltYm9sRGVmaW5pdGlvbicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sRGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0SXRlbShpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5faXRlbV0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpXG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdGlmIChmbGFncyAmIDEpXG5cdFx0XHR0aGlzLnByb2plY3QuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3N5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2l0ZW0pXG5cdFx0XHR0aGlzLl9pdGVtLl9zeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3N5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiAnI2dldEl0ZW0nLFxuXHRzZXREZWZpbml0aW9uOiAnI3NldEl0ZW0nLFxuXG5cdHBsYWNlOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sSXRlbSh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbih0aGlzLl9pdGVtLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRyZXR1cm4gc3ltYm9sID09PSB0aGlzXG5cdFx0XHRcdHx8IHN5bWJvbCAmJiB0aGlzLl9pdGVtLmVxdWFscyhzeW1ib2wuX2l0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpXG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihhcmdzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3MgJiYgQmFzZS5yZWFkKGFyZ3MpO1xuXHRcdFx0cmV0dXJuIG5ldyBCYXNlKHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0cG9zaXRpb246IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cdF9zZWxlY3Rpb246IDAsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0LCBzZWxlY3Rpb247XG5cdFx0aWYgKGNvdW50ID4gMCkge1xuXHRcdFx0aWYgKGFyZzAgPT0gbnVsbCB8fCB0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAxICYmIGFyZzAgJiYgJ3BvaW50JyBpbiBhcmcwKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBhcmcwLnBvaW50O1xuXHRcdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBhcmcwLnNlbGVjdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0XHRcdGhhbmRsZU91dCA9IGFyZzI7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gYXJnMztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBbIGFyZzAsIGFyZzEgXTtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcyICE9PSB1bmRlZmluZWQgPyBbIGFyZzIsIGFyZzMgXSA6IG51bGw7XG5cdFx0XHRcdGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0bmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcblx0XHRpZiAoc2VsZWN0aW9uKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRvYmogPSBzZWxlY3Rpb24gfHwgdGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0XHQ/IFtwb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dF1cblx0XHRcdFx0XHQ6IHBvaW50O1xuXHRcdGlmIChzZWxlY3Rpb24pXG5cdFx0XHRvYmoucHVzaChzZWxlY3Rpb24pO1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRpZiAoIXBhdGgpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIGN1cnZlcyA9IHBhdGguX2N1cnZlcyxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXgsXG5cdFx0XHRjdXJ2ZTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluKVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGluZGV4ID4gMCA/IGN1cnZlc1tpbmRleCAtIDFdIDogcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0XHQ/IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0gOiBudWxsKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHRcdGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0KVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGN1cnZlc1tpbmRleF0pKVxuXHRcdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRwYXRoLl9jaGFuZ2VkKDQxKTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdGlzU21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlSW4gPSB0aGlzLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZU91dCA9IHRoaXMuX2hhbmRsZU91dDtcblx0XHRyZXR1cm4gIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xsaW5lYXIoaGFuZGxlT3V0KTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG5cdFx0dGhpcy5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuXHR9LFxuXG5cdHNldFNlbGVjdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cdFx0dmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcblx0XHRcdHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCAwO1xuXHRcdGlmIChwYXRoICYmIHNlbGVjdGlvbiAhPT0gb2xkU2VsZWN0aW9uKSB7XG5cdFx0XHRwYXRoLl91cGRhdGVTZWxlY3Rpb24odGhpcywgb2xkU2VsZWN0aW9uLCBzZWxlY3Rpb24pO1xuXHRcdFx0cGF0aC5fY2hhbmdlZCgyNTcpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlU2VsZWN0aW9uOiBmdW5jdGlvbihmbGFnLCBzZWxlY3RlZCkge1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG5cdFx0dGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0ZWQgPyBzZWxlY3Rpb24gfCBmbGFnIDogc2VsZWN0aW9uICYgfmZsYWcpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhISh0aGlzLl9zZWxlY3Rpb24gJiA3KTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9jaGFuZ2VTZWxlY3Rpb24oNywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKG9wdGlvbnMsIF9maXJzdCwgX2xhc3QpIHtcblx0XHR2YXIgb3B0cyA9IG9wdGlvbnMgfHwge30sXG5cdFx0XHR0eXBlID0gb3B0cy50eXBlLFxuXHRcdFx0ZmFjdG9yID0gb3B0cy5mYWN0b3IsXG5cdFx0XHRwcmV2ID0gdGhpcy5nZXRQcmV2aW91cygpLFxuXHRcdFx0bmV4dCA9IHRoaXMuZ2V0TmV4dCgpLFxuXHRcdFx0cDAgPSAocHJldiB8fCB0aGlzKS5fcG9pbnQsXG5cdFx0XHRwMSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0cDIgPSAobmV4dCB8fCB0aGlzKS5fcG9pbnQsXG5cdFx0XHRkMSA9IHAwLmdldERpc3RhbmNlKHAxKSxcblx0XHRcdGQyID0gcDEuZ2V0RGlzdGFuY2UocDIpO1xuXHRcdGlmICghdHlwZSB8fCB0eXBlID09PSAnY2F0bXVsbC1yb20nKSB7XG5cdFx0XHR2YXIgYSA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC41IDogZmFjdG9yLFxuXHRcdFx0XHRkMV9hID0gTWF0aC5wb3coZDEsIGEpLFxuXHRcdFx0XHRkMV8yYSA9IGQxX2EgKiBkMV9hLFxuXHRcdFx0XHRkMl9hID0gTWF0aC5wb3coZDIsIGEpLFxuXHRcdFx0XHRkMl8yYSA9IGQyX2EgKiBkMl9hO1xuXHRcdFx0aWYgKCFfZmlyc3QgJiYgcHJldikge1xuXHRcdFx0XHR2YXIgQSA9IDIgKiBkMl8yYSArIDMgKiBkMl9hICogZDFfYSArIGQxXzJhLFxuXHRcdFx0XHRcdE4gPSAzICogZDJfYSAqIChkMl9hICsgZDFfYSk7XG5cdFx0XHRcdHRoaXMuc2V0SGFuZGxlSW4oTiAhPT0gMFxuXHRcdFx0XHRcdD8gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0KGQyXzJhICogcDAuX3ggKyBBICogcDEuX3ggLSBkMV8yYSAqIHAyLl94KSAvIE4gLSBwMS5feCxcblx0XHRcdFx0XHRcdChkMl8yYSAqIHAwLl95ICsgQSAqIHAxLl95IC0gZDFfMmEgKiBwMi5feSkgLyBOIC0gcDEuX3kpXG5cdFx0XHRcdFx0OiBuZXcgUG9pbnQoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIV9sYXN0ICYmIG5leHQpIHtcblx0XHRcdFx0dmFyIEEgPSAyICogZDFfMmEgKyAzICogZDFfYSAqIGQyX2EgKyBkMl8yYSxcblx0XHRcdFx0XHROID0gMyAqIGQxX2EgKiAoZDFfYSArIGQyX2EpO1xuXHRcdFx0XHR0aGlzLnNldEhhbmRsZU91dChOICE9PSAwXG5cdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHQoZDFfMmEgKiBwMi5feCArIEEgKiBwMS5feCAtIGQyXzJhICogcDAuX3gpIC8gTiAtIHAxLl94LFxuXHRcdFx0XHRcdFx0KGQxXzJhICogcDIuX3kgKyBBICogcDEuX3kgLSBkMl8yYSAqIHAwLl95KSAvIE4gLSBwMS5feSlcblx0XHRcdFx0XHQ6IG5ldyBQb2ludCgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdnZW9tZXRyaWMnKSB7XG5cdFx0XHRpZiAocHJldiAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciB2ZWN0b3IgPSBwMC5zdWJ0cmFjdChwMiksXG5cdFx0XHRcdFx0dCA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC40IDogZmFjdG9yLFxuXHRcdFx0XHRcdGsgPSB0ICogZDEgLyAoZDEgKyBkMik7XG5cdFx0XHRcdGlmICghX2ZpcnN0KVxuXHRcdFx0XHRcdHRoaXMuc2V0SGFuZGxlSW4odmVjdG9yLm11bHRpcGx5KGspKTtcblx0XHRcdFx0aWYgKCFfbGFzdClcblx0XHRcdFx0XHR0aGlzLnNldEhhbmRsZU91dCh2ZWN0b3IubXVsdGlwbHkoayAtIHQpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTbW9vdGhpbmcgbWV0aG9kIFxcJycgKyB0eXBlICsgJ1xcJyBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5faW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEgfHwgZmFsc2U7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQsXG5cdFx0XHR0bXAgPSBoYW5kbGVJbi5jbG9uZSgpO1xuXHRcdGhhbmRsZUluLnNldChoYW5kbGVPdXQpO1xuXHRcdGhhbmRsZU91dC5zZXQodG1wKTtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVPdXQsIHRoaXMuX2hhbmRsZUluKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoID8gISF0aGlzLl9wYXRoLnJlbW92ZVNlZ21lbnQodGhpcy5faW5kZXgpIDogZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0cmV0dXJuIHNlZ21lbnQgPT09IHRoaXMgfHwgc2VnbWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gc2VnbWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fcG9pbnQuZXF1YWxzKHNlZ21lbnQuX3BvaW50KVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVJbi5lcXVhbHMoc2VnbWVudC5faGFuZGxlSW4pXG5cdFx0XHRcdCYmIHRoaXMuX2hhbmRsZU91dC5lcXVhbHMoc2VnbWVudC5faGFuZGxlT3V0KVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gWyAncG9pbnQ6ICcgKyB0aGlzLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVJbjogJyArIHRoaXMuX2hhbmRsZUluKTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZU91dDogJyArIHRoaXMuX2hhbmRsZU91dCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCB0cnVlKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcblx0XHR2YXIgdSA9IDEgLSBmYWN0b3IsXG5cdFx0XHR2ID0gZmFjdG9yLFxuXHRcdFx0cG9pbnQxID0gZnJvbS5fcG9pbnQsXG5cdFx0XHRwb2ludDIgPSB0by5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbjEgPSBmcm9tLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZUluMiA9IHRvLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZU91dDIgPSB0by5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlT3V0MSA9IGZyb20uX2hhbmRsZU91dDtcblx0XHR0aGlzLl9wb2ludC5fc2V0KFxuXHRcdFx0XHR1ICogcG9pbnQxLl94ICsgdiAqIHBvaW50Mi5feCxcblx0XHRcdFx0dSAqIHBvaW50MS5feSArIHYgKiBwb2ludDIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2hhbmRsZUluLl9zZXQoXG5cdFx0XHRcdHUgKiBoYW5kbGVJbjEuX3ggKyB2ICogaGFuZGxlSW4yLl94LFxuXHRcdFx0XHR1ICogaGFuZGxlSW4xLl95ICsgdiAqIGhhbmRsZUluMi5feSwgdHJ1ZSk7XG5cdFx0dGhpcy5faGFuZGxlT3V0Ll9zZXQoXG5cdFx0XHRcdHUgKiBoYW5kbGVPdXQxLl94ICsgdiAqIGhhbmRsZU91dDIuX3gsXG5cdFx0XHRcdHUgKiBoYW5kbGVPdXQxLl95ICsgdiAqIGhhbmRsZU91dDIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcblx0XHRcdGhhbmRsZUluID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZUluIDogbnVsbCxcblx0XHRcdGhhbmRsZU91dCA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcblx0XHRcdHggPSBwb2ludC5feCxcblx0XHRcdHkgPSBwb2ludC5feSxcblx0XHRcdGkgPSAyO1xuXHRcdGNvb3Jkc1swXSA9IHg7XG5cdFx0Y29vcmRzWzFdID0geTtcblx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll95ICsgeTtcblx0XHR9XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgaSAvIDIpO1xuXHRcdFx0eCA9IGNvb3Jkc1swXTtcblx0XHRcdHkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoY2hhbmdlKSB7XG5cdFx0XHRcdHBvaW50Ll94ID0geDtcblx0XHRcdFx0cG9pbnQuX3kgPSB5O1xuXHRcdFx0XHRpID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LFxuXHRcdFx0c2VsZWN0ZWQ7XG5cdFx0aWYgKCFwb2ludCkge1xuXHRcdFx0eCA9IHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoKHggPSBwb2ludFswXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0eSA9IHBvaW50WzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHQgPSBwb2ludDtcblx0XHRcdGlmICgoeCA9IHB0LngpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHggPSBwdC54O1xuXHRcdFx0fVxuXHRcdFx0eSA9IHB0Lnk7XG5cdFx0XHRzZWxlY3RlZCA9IHB0LnNlbGVjdGVkO1xuXHRcdH1cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdG93bmVyW2tleV0gPSB0aGlzO1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHRoaXMuX3gpICYmIGlzWmVybyh0aGlzLl95KTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIHRoaXMuX2dldFNlbGVjdGlvbigpKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlU2VsZWN0aW9uKHRoaXMuX2dldFNlbGVjdGlvbigpLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X2dldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0cmV0dXJuIHRoaXMgPT09IG93bmVyLl9wb2ludCA/IDFcblx0XHRcdDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZUluID8gMlxuXHRcdFx0OiB0aGlzID09PSBvd25lci5faGFuZGxlT3V0ID8gNFxuXHRcdFx0OiAwO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0c2VnMSwgc2VnMixcblx0XHRcdHBvaW50MSwgcG9pbnQyLFxuXHRcdFx0aGFuZGxlMSwgaGFuZGxlMjtcblx0XHRpZiAoY291bnQgPT09IDMpIHtcblx0XHRcdHRoaXMuX3BhdGggPSBhcmcwO1xuXHRcdFx0c2VnMSA9IGFyZzE7XG5cdFx0XHRzZWcyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKCFjb3VudCkge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHRzZWcyID0gbmV3IFNlZ21lbnQoKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoJ3NlZ21lbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuXHRcdFx0fSBlbHNlIGlmICgncG9pbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHBvaW50MSA9IGFyZzAucG9pbnQxO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMC5oYW5kbGUxO1xuXHRcdFx0XHRoYW5kbGUyID0gYXJnMC5oYW5kbGUyO1xuXHRcdFx0XHRwb2ludDIgPSBhcmcwLnBvaW50Mjtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHRwb2ludDEgPSBbYXJnMFswXSwgYXJnMFsxXV07XG5cdFx0XHRcdHBvaW50MiA9IFthcmcwWzZdLCBhcmcwWzddXTtcblx0XHRcdFx0aGFuZGxlMSA9IFthcmcwWzJdIC0gYXJnMFswXSwgYXJnMFszXSAtIGFyZzBbMV1dO1xuXHRcdFx0XHRoYW5kbGUyID0gW2FyZzBbNF0gLSBhcmcwWzZdLCBhcmcwWzVdIC0gYXJnMFs3XV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KGFyZzApO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcblx0XHRcdHBvaW50MSA9IGFyZzA7XG5cdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdGhhbmRsZTIgPSBhcmcyO1xuXHRcdFx0cG9pbnQyID0gYXJnMztcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRwb2ludDEgPSBbYXJnMCwgYXJnMV07XG5cdFx0XHRwb2ludDIgPSBbYXJnNiwgYXJnN107XG5cdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG5cdFx0fVxuXHRcdHRoaXMuX3NlZ21lbnQxID0gc2VnMSB8fCBuZXcgU2VnbWVudChwb2ludDEsIG51bGwsIGhhbmRsZTEpO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnMiB8fCBuZXcgU2VnbWVudChwb2ludDIsIGhhbmRsZTIsIG51bGwpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0PyBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRIYW5kbGUxKCksIHRoaXMuZ2V0SGFuZGxlMigpLFxuXHRcdFx0XHRcdHRoaXMuZ2V0UG9pbnQyKCldXG5cdFx0XHRcdDogW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0UG9pbnQyKCldLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRjbGFzc2lmeTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmNsYXNzaWZ5KHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG5cdFx0XHRpZiAocmVtb3ZlZClcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoaGFuZGxlT3V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Z2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDE7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG5cdH0sXG5cblx0aXNGaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5fc2VnbWVudDEuX2luZGV4ID09PSBwYXRoLl9jdXJ2ZXMubGVuZ3RoIC0gMVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH1cbn0sIHtcblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpXG5cdFx0XHR0aGlzLl9sZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRnZXRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IExpbmUodGhpcy5fc2VnbWVudDEuX3BvaW50LCB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG5cdH0sXG5cblx0Z2V0UGFydExlbmd0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcblx0fSxcblxuXHRkaXZpZGVBdDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUobG9jYXRpb24gJiYgbG9jYXRpb24uY3VydmUgPT09IHRoaXNcblx0XHRcdFx0PyBsb2NhdGlvbi50aW1lIDogdGhpcy5nZXRUaW1lQXQobG9jYXRpb24pKTtcblx0fSxcblxuXHRkaXZpZGVBdFRpbWU6IGZ1bmN0aW9uKHRpbWUsIF9zZXRIYW5kbGVzKSB7XG5cdFx0dmFyIHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAodGltZSA+PSB0TWluICYmIHRpbWUgPD0gdE1heCkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHRpbWUpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV0sXG5cdFx0XHRcdHNldEhhbmRsZXMgPSBfc2V0SGFuZGxlcyB8fCB0aGlzLmhhc0hhbmRsZXMoKSxcblx0XHRcdFx0c2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0XHRzZWcyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdFx0aWYgKHNldEhhbmRsZXMpIHtcblx0XHRcdFx0c2VnMS5faGFuZGxlT3V0Ll9zZXQobGVmdFsyXSAtIGxlZnRbMF0sIGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0c2VnMi5faGFuZGxlSW4uX3NldChyaWdodFs0XSAtIHJpZ2h0WzZdLHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSBsZWZ0WzZdLCB5ID0gbGVmdFs3XSxcblx0XHRcdFx0c2VnbWVudCA9IG5ldyBTZWdtZW50KG5ldyBQb2ludCh4LCB5KSxcblx0XHRcdFx0XHRcdHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0cGF0aC5pbnNlcnQoc2VnMS5faW5kZXggKyAxLCBzZWdtZW50KTtcblx0XHRcdFx0cmVzID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZ21lbnQ7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdFx0cmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIHNlZzIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0QXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoID8gcGF0aC5zcGxpdEF0KGxvY2F0aW9uKSA6IG51bGw7XG5cdH0sXG5cblx0c3BsaXRBdFRpbWU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zcGxpdEF0KHRoaXMuZ2V0TG9jYXRpb25BdFRpbWUodGltZSkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24ob2Zmc2V0LCBpc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXRcblx0XHRcdFx0OiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zcGxpdEF0VGltZShvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGlzVGltZSA/IG9mZnNldFxuXHRcdFx0XHQ6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuXHR9LFxuXG5cdHJldmVyc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2VkKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2VkKCkpO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldFZhbHVlczogZnVuY3Rpb24oc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgsIHN0cmFpZ2h0KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHgxID0gcDEueCwgeTEgPSBwMS55LFxuXHRcdFx0eDIgPSBwMi54LCB5MiA9IHAyLnksXG5cdFx0XHR2YWx1ZXMgPSBzdHJhaWdodFxuXHRcdFx0XHQ/IFsgeDEsIHkxLCB4MSwgeTEsIHgyLCB5MiwgeDIsIHkyIF1cblx0XHRcdFx0OiBbXG5cdFx0XHRcdFx0eDEsIHkxLFxuXHRcdFx0XHRcdHgxICsgaDEuX3gsIHkxICsgaDEuX3ksXG5cdFx0XHRcdFx0eDIgKyBoMi5feCwgeTIgKyBoMi5feSxcblx0XHRcdFx0XHR4MiwgeTJcblx0XHRcdFx0XTtcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyh2YWx1ZXMsIHZhbHVlcywgNCk7XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRzdWJkaXZpZGU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHg0ID0gdSAqIHgwICsgdCAqIHgxLCB5NCA9IHUgKiB5MCArIHQgKiB5MSxcblx0XHRcdHg1ID0gdSAqIHgxICsgdCAqIHgyLCB5NSA9IHUgKiB5MSArIHQgKiB5Mixcblx0XHRcdHg2ID0gdSAqIHgyICsgdCAqIHgzLCB5NiA9IHUgKiB5MiArIHQgKiB5Myxcblx0XHRcdHg3ID0gdSAqIHg0ICsgdCAqIHg1LCB5NyA9IHUgKiB5NCArIHQgKiB5NSxcblx0XHRcdHg4ID0gdSAqIHg1ICsgdCAqIHg2LCB5OCA9IHUgKiB5NSArIHQgKiB5Nixcblx0XHRcdHg5ID0gdSAqIHg3ICsgdCAqIHg4LCB5OSA9IHUgKiB5NyArIHQgKiB5ODtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3gwLCB5MCwgeDQsIHk0LCB4NywgeTcsIHg5LCB5OV0sXG5cdFx0XHRbeDksIHk5LCB4OCwgeTgsIHg2LCB5NiwgeDMsIHkzXVxuXHRcdF07XG5cdH0sXG5cblx0Z2V0TW9ub0N1cnZlczogZnVuY3Rpb24odiwgZGlyKSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0aW8gPSBkaXIgPyAwIDogMSxcblx0XHRcdG8wID0gdltpbyArIDBdLFxuXHRcdFx0bzEgPSB2W2lvICsgMl0sXG5cdFx0XHRvMiA9IHZbaW8gKyA0XSxcblx0XHRcdG8zID0gdltpbyArIDZdO1xuXHRcdGlmICgobzAgPj0gbzEpID09PSAobzEgPj0gbzIpICYmIChvMSA+PSBvMikgPT09IChvMiA+PSBvMylcblx0XHRcdFx0fHwgQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0Y3VydmVzLnB1c2godik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhID0gMyAqIChvMSAtIG8yKSAtIG8wICsgbzMsXG5cdFx0XHRcdGIgPSAyICogKG8wICsgbzIpIC0gNCAqIG8xLFxuXHRcdFx0XHRjID0gbzEgLSBvMCxcblx0XHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0biA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgdE1pbiwgdE1heCk7XG5cdFx0XHRpZiAoIW4pIHtcblx0XHRcdFx0Y3VydmVzLnB1c2godik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyb290cy5zb3J0KCk7XG5cdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcblx0XHRcdFx0aWYgKG4gPiAxKSB7XG5cdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG5cdFx0XHRcdFx0Y3VydmVzLnB1c2gocGFydHNbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzFdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHYwID0gdltjb29yZF0sXG5cdFx0XHR2MSA9IHZbY29vcmQgKyAyXSxcblx0XHRcdHYyID0gdltjb29yZCArIDRdLFxuXHRcdFx0djMgPSB2W2Nvb3JkICsgNl0sXG5cdFx0XHRyZXMgPSAwO1xuXHRcdGlmICggICEodjAgPCB2YWwgJiYgdjMgPCB2YWwgJiYgdjEgPCB2YWwgJiYgdjIgPCB2YWwgfHxcblx0XHRcdFx0djAgPiB2YWwgJiYgdjMgPiB2YWwgJiYgdjEgPiB2YWwgJiYgdjIgPiB2YWwpKSB7XG5cdFx0XHR2YXIgYyA9IDMgKiAodjEgLSB2MCksXG5cdFx0XHRcdGIgPSAzICogKHYyIC0gdjEpIC0gYyxcblx0XHRcdFx0YSA9IHYzIC0gdjAgLSBjIC0gYjtcblx0XHRcdHJlcyA9IE51bWVyaWNhbC5zb2x2ZUN1YmljKGEsIGIsIGMsIHYwIC0gdmFsLCByb290cywgbWluLCBtYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGdldFRpbWVPZjogZnVuY3Rpb24odiwgcG9pbnQpIHtcblx0XHR2YXIgcDAgPSBuZXcgUG9pbnQodlswXSwgdlsxXSksXG5cdFx0XHRwMyA9IG5ldyBQb2ludCh2WzZdLCB2WzddKSxcblx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdGdlb21FcHNpbG9uID0gMWUtNyxcblx0XHRcdHQgPSBwb2ludC5pc0Nsb3NlKHAwLCBlcHNpbG9uKSA/IDBcblx0XHRcdCAgOiBwb2ludC5pc0Nsb3NlKHAzLCBlcHNpbG9uKSA/IDFcblx0XHRcdCAgOiBudWxsO1xuXHRcdGlmICh0ID09PSBudWxsKSB7XG5cdFx0XHR2YXIgY29vcmRzID0gW3BvaW50LngsIHBvaW50LnldLFxuXHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyh2LCBjLCBjb29yZHNbY10sIHJvb3RzLCAwLCAxKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHUgPSByb290c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuaXNDbG9zZShDdXJ2ZS5nZXRQb2ludCh2LCB1KSwgZ2VvbUVwc2lsb24pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzQ2xvc2UocDAsIGdlb21FcHNpbG9uKSA/IDBcblx0XHRcdCA6IHBvaW50LmlzQ2xvc2UocDMsIGdlb21FcHNpbG9uKSA/IDFcblx0XHRcdCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFRpbWU6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0aWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdHZ4ID0geDMgLSB4MCwgdnkgPSB5MyAtIHkwLFxuXHRcdFx0XHRkZXQgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcblx0XHRcdGlmIChkZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0dmFyIHUgPSAoKHBvaW50LnggLSB4MCkgKiB2eCArIChwb2ludC55IC0geTApICogdnkpIC8gZGV0O1xuXHRcdFx0cmV0dXJuIHUgPCAxZS0xMiA/IDBcblx0XHRcdFx0IDogdSA+IDAuOTk5OTk5OTk5OTk5ID8gMVxuXHRcdFx0XHQgOiBDdXJ2ZS5nZXRUaW1lT2Yodixcblx0XHRcdFx0XHRuZXcgUG9pbnQoeDAgKyB1ICogdngsIHkwICsgdSAqIHZ5KSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvdW50ID0gMTAwLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluVCA9IDA7XG5cblx0XHRmdW5jdGlvbiByZWZpbmUodCkge1xuXHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcblx0XHRcdFx0dmFyIGRpc3QgPSBwb2ludC5nZXREaXN0YW5jZShDdXJ2ZS5nZXRQb2ludCh2LCB0KSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChkaXN0IDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdG1pblQgPSB0O1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcblx0XHRcdHJlZmluZShpIC8gY291bnQpO1xuXG5cdFx0dmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cdFx0d2hpbGUgKHN0ZXAgPiAxZS04KSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblQ7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHR2YXIgZmxpcCA9IGZyb20gPiB0bztcblx0XHRpZiAoZmxpcCkge1xuXHRcdFx0dmFyIHRtcCA9IGZyb207XG5cdFx0XHRmcm9tID0gdG87XG5cdFx0XHR0byA9IHRtcDtcblx0XHR9XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuXHRcdHJldHVybiBmbGlwXG5cdFx0XHRcdD8gW3ZbNl0sIHZbN10sIHZbNF0sIHZbNV0sIHZbMl0sIHZbM10sIHZbMF0sIHZbMV1dXG5cdFx0XHRcdDogdjtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIGZsYXRuZXNzKSB7XG5cdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0eDEgPSB2WzJdLCB5MSA9IHZbM10sXG5cdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0dXggPSAzICogeDEgLSAyICogeDAgLSB4Myxcblx0XHRcdHV5ID0gMyAqIHkxIC0gMiAqIHkwIC0geTMsXG5cdFx0XHR2eCA9IDMgKiB4MiAtIDIgKiB4MyAtIHgwLFxuXHRcdFx0dnkgPSAzICogeTIgLSAyICogeTMgLSB5MDtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8PSAxNiAqIGZsYXRuZXNzICogZmxhdG5lc3M7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XTtcblx0XHRyZXR1cm4gMyAqICgoeTMgLSB5MCkgKiAoeDEgKyB4MikgLSAoeDMgLSB4MCkgKiAoeTEgKyB5Milcblx0XHRcdFx0KyB5MSAqICh4MCAtIHgyKSAtIHgxICogKHkwIC0geTIpXG5cdFx0XHRcdCsgeTMgKiAoeDIgKyB4MCAvIDMpIC0geDMgKiAoeTIgKyB5MCAvIDMpKSAvIDIwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IFswLCAwXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKylcblx0XHRcdEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSxcblx0XHRcdFx0XHRpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0X2FkZEJvdW5kczogZnVuY3Rpb24odjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcblx0XHRmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcblx0XHRcdHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuXHRcdFx0XHRyaWdodCA9IHZhbHVlICsgcGFkZGluZztcblx0XHRcdGlmIChsZWZ0IDwgbWluW2Nvb3JkXSlcblx0XHRcdFx0bWluW2Nvb3JkXSA9IGxlZnQ7XG5cdFx0XHRpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuXHRcdFx0XHRtYXhbY29vcmRdID0gcmlnaHQ7XG5cdFx0fVxuXG5cdFx0cGFkZGluZyAvPSAyO1xuXHRcdHZhciBtaW5QYWQgPSBtaW5bY29vcmRdICsgcGFkZGluZyxcblx0XHRcdG1heFBhZCA9IG1heFtjb29yZF0gLSBwYWRkaW5nO1xuXHRcdGlmICggICAgdjAgPCBtaW5QYWQgfHwgdjEgPCBtaW5QYWQgfHwgdjIgPCBtaW5QYWQgfHwgdjMgPCBtaW5QYWQgfHxcblx0XHRcdFx0djAgPiBtYXhQYWQgfHwgdjEgPiBtYXhQYWQgfHwgdjIgPiBtYXhQYWQgfHwgdjMgPiBtYXhQYWQpIHtcblx0XHRcdGlmICh2MSA8IHYwICE9IHYxIDwgdjMgJiYgdjIgPCB2MCAhPSB2MiA8IHYzKSB7XG5cdFx0XHRcdGFkZCh2MCwgMCk7XG5cdFx0XHRcdGFkZCh2MywgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuXHRcdFx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0XHRcdGMgPSB2MSAtIHYwLFxuXHRcdFx0XHRcdGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcblx0XHRcdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0XHRcdGFkZCh2MywgMCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdFx0XHR1ID0gMSAtIHQ7XG5cdFx0XHRcdFx0aWYgKHRNaW4gPD0gdCAmJiB0IDw9IHRNYXgpXG5cdFx0XHRcdFx0XHRhZGQodSAqIHUgKiB1ICogdjBcblx0XHRcdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHRcdFx0KyAzICogdSAqIHQgKiB0ICogdjJcblx0XHRcdFx0XHRcdFx0KyB0ICogdCAqIHQgKiB2Myxcblx0XHRcdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn19LCBCYXNlLmVhY2goXG5cdFsnZ2V0Qm91bmRzJywgJ2dldFN0cm9rZUJvdW5kcycsICdnZXRIYW5kbGVCb3VuZHMnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV07XG5cdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFxuXHRcdFx0XHRcdFx0W3RoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHMuY2xvbmUoKTtcblx0XHR9O1xuXHR9LFxue1xuXG59KSwgQmFzZS5lYWNoKHtcblx0aXNTdHJhaWdodDogZnVuY3Rpb24ocDEsIGgxLCBoMiwgcDIpIHtcblx0XHRpZiAoaDEuaXNaZXJvKCkgJiYgaDIuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdiA9IHAyLnN1YnRyYWN0KHAxKTtcblx0XHRcdGlmICh2LmlzWmVybygpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodi5pc0NvbGxpbmVhcihoMSkgJiYgdi5pc0NvbGxpbmVhcihoMikpIHtcblx0XHRcdFx0dmFyIGwgPSBuZXcgTGluZShwMSwgcDIpLFxuXHRcdFx0XHRcdGVwc2lsb24gPSAxZS03O1xuXHRcdFx0XHRpZiAobC5nZXREaXN0YW5jZShwMS5hZGQoaDEpKSA8IGVwc2lsb24gJiZcblx0XHRcdFx0XHRsLmdldERpc3RhbmNlKHAyLmFkZChoMikpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRcdHZhciBkaXYgPSB2LmRvdCh2KSxcblx0XHRcdFx0XHRcdHMxID0gdi5kb3QoaDEpIC8gZGl2LFxuXHRcdFx0XHRcdFx0czIgPSB2LmRvdChoMikgLyBkaXY7XG5cdFx0XHRcdFx0cmV0dXJuIHMxID49IDAgJiYgczEgPD0gMSAmJiBzMiA8PSAwICYmIHMyID49IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24ocDEsIGgxLCBoMiwgcDIpIHtcblx0XHR2YXIgdGhpcmQgPSBwMi5zdWJ0cmFjdChwMSkuZGl2aWRlKDMpO1xuXHRcdHJldHVybiBoMS5lcXVhbHModGhpcmQpICYmIGgyLm5lZ2F0ZSgpLmVxdWFscyh0aGlyZCk7XG5cdH1cbn0sIGZ1bmN0aW9uKHRlc3QsIG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGVwc2lsb24pIHtcblx0XHR2YXIgc2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0c2VnMiA9IHRoaXMuX3NlZ21lbnQyO1xuXHRcdHJldHVybiB0ZXN0KHNlZzEuX3BvaW50LCBzZWcxLl9oYW5kbGVPdXQsIHNlZzIuX2hhbmRsZUluLCBzZWcyLl9wb2ludCxcblx0XHRcdFx0ZXBzaWxvbik7XG5cdH07XG5cblx0dGhpcy5zdGF0aWNzW25hbWVdID0gZnVuY3Rpb24odiwgZXBzaWxvbikge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddO1xuXHRcdHJldHVybiB0ZXN0KFxuXHRcdFx0XHRuZXcgUG9pbnQoeDAsIHkwKSxcblx0XHRcdFx0bmV3IFBvaW50KHZbMl0gLSB4MCwgdlszXSAtIHkwKSxcblx0XHRcdFx0bmV3IFBvaW50KHZbNF0gLSB4Mywgdls1XSAtIHkzKSxcblx0XHRcdFx0bmV3IFBvaW50KHgzLCB5MyksIGVwc2lsb24pO1xuXHR9O1xufSwge1xuXHRzdGF0aWNzOiB7fSxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0fHwgIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKTtcblx0fSxcblxuXHRoYXNMZW5ndGg6IGZ1bmN0aW9uKGVwc2lsb24pIHtcblx0XHRyZXR1cm4gKCF0aGlzLmdldFBvaW50MSgpLmVxdWFscyh0aGlzLmdldFBvaW50MigpKSB8fCB0aGlzLmhhc0hhbmRsZXMoKSlcblx0XHRcdFx0JiYgdGhpcy5nZXRMZW5ndGgoKSA+IChlcHNpbG9uIHx8IDApO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBjdXJ2ZSAmJiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZS5pc1N0cmFpZ2h0KClcblx0XHRcdFx0JiYgdGhpcy5nZXRMaW5lKCkuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TGluZSgpKTtcblx0fSxcblxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS55KVxuXHRcdFx0XHQ8IDFlLTg7XG5cdH0sXG5cblx0aXNWZXJ0aWNhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0VGltZSgwLjUpLngpXG5cdFx0XHRcdDwgMWUtODtcblx0fVxufSksIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgX2lzVGltZSkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKFxuXHRcdFx0XHRfaXNUaW1lID8gb2Zmc2V0IDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdFRpbWU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDFcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGltZUF0OiBmdW5jdGlvbihvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFRpbWVBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogJyNnZXRUaW1lQXQnLFxuXG5cdGdldFRpbWVzV2l0aFRhbmdlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGFuZ2VudC5pc1plcm8oKVxuXHRcdFx0XHQ/IFtdXG5cdFx0XHRcdDogQ3VydmUuZ2V0VGltZXNXaXRoVGFuZ2VudCh0aGlzLmdldFZhbHVlcygpLCB0YW5nZW50KTtcblx0fSxcblxuXHRnZXRPZmZzZXRBdFRpbWU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJ0TGVuZ3RoKDAsIHQpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRoaXMuZ2V0VGltZU9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGltZU9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VGltZU9mKHRoaXMuZ2V0VmFsdWVzKCksIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6ICcjZ2V0VGltZU9mJyxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHR0ID0gQ3VydmUuZ2V0TmVhcmVzdFRpbWUodmFsdWVzLCBwb2ludCksXG5cdFx0XHRwdCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQsIHB0LCBudWxsLCBwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuXHR9XG5cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtZXRob2RzID0gWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRXZWlnaHRlZFRhbmdlbnQnLFxuXHRcdCdnZXRXZWlnaHRlZE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChtZXRob2RzLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24obG9jYXRpb24sIF9pc1RpbWUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh2YWx1ZXMsIF9pc1RpbWUgPyBsb2NhdGlvblxuXHRcdFx0XHRcdFx0OiBDdXJ2ZS5nZXRUaW1lQXQodmFsdWVzLCBsb2NhdGlvbikpO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1tuYW1lICsgJ0F0VGltZSddID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5nZXRWYWx1ZXMoKSwgdGltZSk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdHN0YXRpY3M6IHtcblx0XHRcdFx0X2V2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqICh4MSAtIHgyKSArIDMgKiAoeDMgLSB4MCksXG5cdFx0XHRieCA9IDYgKiAoeDAgKyB4MikgLSAxMiAqIHgxLFxuXHRcdFx0Y3ggPSAzICogKHgxIC0geDApLFxuXG5cdFx0XHRheSA9IDkgKiAoeTEgLSB5MikgKyAzICogKHkzIC0geTApLFxuXHRcdFx0YnkgPSA2ICogKHkwICsgeTIpIC0gMTIgKiB5MSxcblx0XHRcdGN5ID0gMyAqICh5MSAtIHkwKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmFsdWF0ZSh2LCB0LCB0eXBlLCBub3JtYWxpemVkKSB7XG5cdFx0aWYgKHQgPT0gbnVsbCB8fCB0IDwgMCB8fCB0ID4gMSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0aWYgKGlzWmVybyh4MSAtIHgwKSAmJiBpc1plcm8oeTEgLSB5MCkpIHtcblx0XHRcdHgxID0geDA7XG5cdFx0XHR5MSA9IHkwO1xuXHRcdH1cblx0XHRpZiAoaXNaZXJvKHgyIC0geDMpICYmIGlzWmVybyh5MiAtIHkzKSkge1xuXHRcdFx0eDIgPSB4Mztcblx0XHRcdHkyID0geTM7XG5cdFx0fVxuXHRcdHZhciBjeCA9IDMgKiAoeDEgLSB4MCksXG5cdFx0XHRieCA9IDMgKiAoeDIgLSB4MSkgLSBjeCxcblx0XHRcdGF4ID0geDMgLSB4MCAtIGN4IC0gYngsXG5cdFx0XHRjeSA9IDMgKiAoeTEgLSB5MCksXG5cdFx0XHRieSA9IDMgKiAoeTIgLSB5MSkgLSBjeSxcblx0XHRcdGF5ID0geTMgLSB5MCAtIGN5IC0gYnksXG5cdFx0XHR4LCB5O1xuXHRcdGlmICh0eXBlID09PSAwKSB7XG5cdFx0XHR4ID0gdCA9PT0gMCA/IHgwIDogdCA9PT0gMSA/IHgzXG5cdFx0XHRcdFx0OiAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgeDA7XG5cdFx0XHR5ID0gdCA9PT0gMCA/IHkwIDogdCA9PT0gMSA/IHkzXG5cdFx0XHRcdFx0OiAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgeTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdFx0aWYgKHQgPCB0TWluKSB7XG5cdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0fSBlbHNlIGlmICh0ID4gdE1heCkge1xuXHRcdFx0XHR4ID0gMyAqICh4MyAtIHgyKTtcblx0XHRcdFx0eSA9IDMgKiAoeTMgLSB5Mik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuXHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG5cdFx0XHRcdFx0eCA9IHgyIC0geDE7XG5cdFx0XHRcdFx0eSA9IHkyIC0geTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGxlbikge1xuXHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHR2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuXHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRkID0gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHR4ID0gZCAhPT0gMCA/ICh4ICogeTIgLSB5ICogeDIpIC8gZCA6IDA7XG5cdFx0XHRcdHkgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cblx0XHRjbGFzc2lmeTogZnVuY3Rpb24odikge1xuXG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGExID0geDAgKiAoeTMgLSB5MikgKyB5MCAqICh4MiAtIHgzKSArIHgzICogeTIgLSB5MyAqIHgyLFxuXHRcdFx0XHRhMiA9IHgxICogKHkwIC0geTMpICsgeTEgKiAoeDMgLSB4MCkgKyB4MCAqIHkzIC0geTAgKiB4Myxcblx0XHRcdFx0YTMgPSB4MiAqICh5MSAtIHkwKSArIHkyICogKHgwIC0geDEpICsgeDEgKiB5MCAtIHkxICogeDAsXG5cdFx0XHRcdGQzID0gMyAqIGEzLFxuXHRcdFx0XHRkMiA9IGQzIC0gYTIsXG5cdFx0XHRcdGQxID0gZDIgLSBhMiArIGExLFxuXHRcdFx0XHRsID0gTWF0aC5zcXJ0KGQxICogZDEgKyBkMiAqIGQyICsgZDMgKiBkMyksXG5cdFx0XHRcdHMgPSBsICE9PSAwID8gMSAvIGwgOiAwLFxuXHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvLFxuXHRcdFx0XHRzZXJwZW50aW5lID0gJ3NlcnBlbnRpbmUnO1xuXHRcdFx0ZDEgKj0gcztcblx0XHRcdGQyICo9IHM7XG5cdFx0XHRkMyAqPSBzO1xuXG5cdFx0XHRmdW5jdGlvbiB0eXBlKHR5cGUsIHQxLCB0Mikge1xuXHRcdFx0XHR2YXIgaGFzUm9vdHMgPSB0MSAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHQxT2sgPSBoYXNSb290cyAmJiB0MSA+IDAgJiYgdDEgPCAxLFxuXHRcdFx0XHRcdHQyT2sgPSBoYXNSb290cyAmJiB0MiA+IDAgJiYgdDIgPCAxO1xuXHRcdFx0XHRpZiAoaGFzUm9vdHMgJiYgKCEodDFPayB8fCB0Mk9rKVxuXHRcdFx0XHRcdFx0fHwgdHlwZSA9PT0gJ2xvb3AnICYmICEodDFPayAmJiB0Mk9rKSkpIHtcblx0XHRcdFx0XHR0eXBlID0gJ2FyY2gnO1xuXHRcdFx0XHRcdHQxT2sgPSB0Mk9rID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdHJvb3RzOiB0MU9rIHx8IHQyT2tcblx0XHRcdFx0XHRcdFx0PyB0MU9rICYmIHQyT2tcblx0XHRcdFx0XHRcdFx0XHQ/IHQxIDwgdDIgPyBbdDEsIHQyXSA6IFt0MiwgdDFdXG5cdFx0XHRcdFx0XHRcdFx0OiBbdDFPayA/IHQxIDogdDJdXG5cdFx0XHRcdFx0XHRcdDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNaZXJvKGQxKSkge1xuXHRcdFx0XHRyZXR1cm4gaXNaZXJvKGQyKVxuXHRcdFx0XHRcdFx0PyB0eXBlKGlzWmVybyhkMykgPyAnbGluZScgOiAncXVhZHJhdGljJylcblx0XHRcdFx0XHRcdDogdHlwZShzZXJwZW50aW5lLCBkMyAvICgzICogZDIpKTtcblx0XHRcdH1cblx0XHRcdHZhciBkID0gMyAqIGQyICogZDIgLSA0ICogZDEgKiBkMztcblx0XHRcdGlmIChpc1plcm8oZCkpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGUoJ2N1c3AnLCBkMiAvICgyICogZDEpKTtcblx0XHRcdH1cblx0XHRcdHZhciBmMSA9IGQgPiAwID8gTWF0aC5zcXJ0KGQgLyAzKSA6IE1hdGguc3FydCgtZCksXG5cdFx0XHRcdGYyID0gMiAqIGQxO1xuXHRcdFx0cmV0dXJuIHR5cGUoZCA+IDAgPyBzZXJwZW50aW5lIDogJ2xvb3AnLFxuXHRcdFx0XHRcdChkMiArIGYxKSAvIGYyLFxuXHRcdFx0XHRcdChkMiAtIGYxKSAvIGYyKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbih2LCBhLCBiLCBkcykge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHRcdHZhciBjID0gdjtcblx0XHRcdFx0aWYgKGIgPCAxKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBiKVswXTtcblx0XHRcdFx0XHRhIC89IGI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEgPiAwKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBhKVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZHggPSBjWzZdIC0gY1swXSxcblx0XHRcdFx0XHRkeSA9IGNbN10gLSBjWzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzIHx8IGdldExlbmd0aEludGVncmFuZCh2KSwgYSwgYixcblx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGltZUF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDA7XG5cdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gc3RhcnQ7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHYsIGEsIGIsIGRzKSxcblx0XHRcdFx0ZGlmZiA9IGFicyhvZmZzZXQpIC0gcmFuZ2VMZW5ndGg7XG5cdFx0XHRpZiAoYWJzKGRpZmYpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuXHRcdFx0fSBlbHNlIGlmIChkaWZmID4gZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMzIsXG5cdFx0XHRcdFx0MWUtMTIpO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDAsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q3VydmF0dXJlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMywgZmFsc2UpLng7XG5cdFx0fSxcblxuXHRcdGdldFBlYWtzOiBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGF4ID0gICAgIC14MCArIDMgKiB4MSAtIDMgKiB4MiArIHgzLFxuXHRcdFx0XHRieCA9ICAzICogeDAgLSA2ICogeDEgKyAzICogeDIsXG5cdFx0XHRcdGN4ID0gLTMgKiB4MCArIDMgKiB4MSxcblx0XHRcdFx0YXkgPSAgICAgLXkwICsgMyAqIHkxIC0gMyAqIHkyICsgeTMsXG5cdFx0XHRcdGJ5ID0gIDMgKiB5MCAtIDYgKiB5MSArIDMgKiB5Mixcblx0XHRcdFx0Y3kgPSAtMyAqIHkwICsgMyAqIHkxLFxuXHRcdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0TnVtZXJpY2FsLnNvbHZlQ3ViaWMoXG5cdFx0XHRcdFx0OSAqIChheCAqIGF4ICsgYXkgKiBheSksXG5cdFx0XHRcdFx0OSAqIChheCAqIGJ4ICsgYnkgKiBheSksXG5cdFx0XHRcdFx0MiAqIChieCAqIGJ4ICsgYnkgKiBieSkgKyAzICogKGN4ICogYXggKyBjeSAqIGF5KSxcblx0XHRcdFx0XHQoY3ggKiBieCArIGJ5ICogY3kpLFxuXHRcdFx0XHRcdHJvb3RzLCB0TWluLCB0TWF4KTtcblx0XHRcdHJldHVybiByb290cy5zb3J0KCk7XG5cdFx0fVxuXHR9fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgdDEsIGMyLCB0Miwgb3ZlcmxhcCkge1xuXHRcdHZhciBleGNsdWRlU3RhcnQgPSAhb3ZlcmxhcCAmJiBjMS5nZXRQcmV2aW91cygpID09PSBjMixcblx0XHRcdGV4Y2x1ZGVFbmQgPSAhb3ZlcmxhcCAmJiBjMSAhPT0gYzIgJiYgYzEuZ2V0TmV4dCgpID09PSBjMixcblx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0MSAhPT0gbnVsbCAmJiB0MSA+PSAoZXhjbHVkZVN0YXJ0ID8gdE1pbiA6IDApICYmXG5cdFx0XHR0MSA8PSAoZXhjbHVkZUVuZCA/IHRNYXggOiAxKSkge1xuXHRcdFx0aWYgKHQyICE9PSBudWxsICYmIHQyID49IChleGNsdWRlRW5kID8gdE1pbiA6IDApICYmXG5cdFx0XHRcdHQyIDw9IChleGNsdWRlU3RhcnQgPyB0TWF4IDogMSkpIHtcblx0XHRcdFx0dmFyIGxvYzEgPSBuZXcgQ3VydmVMb2NhdGlvbihjMSwgdDEsIG51bGwsIG92ZXJsYXApLFxuXHRcdFx0XHRcdGxvYzIgPSBuZXcgQ3VydmVMb2NhdGlvbihjMiwgdDIsIG51bGwsIG92ZXJsYXApO1xuXHRcdFx0XHRsb2MxLl9pbnRlcnNlY3Rpb24gPSBsb2MyO1xuXHRcdFx0XHRsb2MyLl9pbnRlcnNlY3Rpb24gPSBsb2MxO1xuXHRcdFx0XHRpZiAoIWluY2x1ZGUgfHwgaW5jbHVkZShsb2MxKSkge1xuXHRcdFx0XHRcdEN1cnZlTG9jYXRpb24uaW5zZXJ0KGxvY2F0aW9ucywgbG9jMSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgpIHtcblx0XHRpZiAoKytjYWxscyA+PSA0MDk2IHx8ICsrcmVjdXJzaW9uID49IDQwKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciBmYXRMaW5lRXBzaWxvbiA9IDFlLTksXG5cdFx0XHRxMHggPSB2MlswXSwgcTB5ID0gdjJbMV0sIHEzeCA9IHYyWzZdLCBxM3kgPSB2Mls3XSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSksXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0aHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRib3R0b20gPSBodWxsWzFdLFxuXHRcdFx0dE1pbkNsaXAsXG5cdFx0XHR0TWF4Q2xpcDtcblx0XHRpZiAoZDEgPT09IDAgJiYgZDIgPT09IDBcblx0XHRcdFx0JiYgZHAwID09PSAwICYmIGRwMSA9PT0gMCAmJiBkcDIgPT09IDAgJiYgZHAzID09PSAwXG5cdFx0XHR8fCAodE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCkpID09IG51bGxcblx0XHRcdHx8ICh0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcC5yZXZlcnNlKCksIGJvdHRvbS5yZXZlcnNlKCksXG5cdFx0XHRcdGRNaW4sIGRNYXgpKSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciB0TWluTmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWluQ2xpcCxcblx0XHRcdHRNYXhOZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNYXhDbGlwO1xuXHRcdGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgZmF0TGluZUVwc2lsb24pIHtcblx0XHRcdHZhciB0ID0gKHRNaW5OZXcgKyB0TWF4TmV3KSAvIDIsXG5cdFx0XHRcdHUgPSAodU1pbiArIHVNYXgpIC8gMjtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRmbGlwID8gYzIgOiBjMSwgZmxpcCA/IHUgOiB0LFxuXHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdCA6IHUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG5cdFx0XHR2YXIgdURpZmYgPSB1TWF4IC0gdU1pbjtcblx0XHRcdGlmICh0TWF4Q2xpcCAtIHRNaW5DbGlwID4gMC44KSB7XG5cdFx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVEaWZmKSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCAwLjUpLFxuXHRcdFx0XHRcdFx0dCA9ICh0TWluTmV3ICsgdE1heE5ldykgLyAyO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHR2MiwgcGFydHNbMF0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdE1pbk5ldywgdCk7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHYyLCBwYXJ0c1sxXSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0LCB0TWF4TmV3KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjIsIDAuNSksXG5cdFx0XHRcdFx0XHR1ID0gKHVNaW4gKyB1TWF4KSAvIDI7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHBhcnRzWzBdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHUsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodURpZmYgPT09IDAgfHwgdURpZmYgPj0gZmF0TGluZUVwc2lsb24pIHtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djIsIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHR2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLCBmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB0TWluTmV3LCB0TWF4TmV3LCB1TWluLCB1TWF4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FsbHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb252ZXhIdWxsKGRxMCwgZHExLCBkcTIsIGRxMykge1xuXHRcdHZhciBwMCA9IFsgMCwgZHEwIF0sXG5cdFx0XHRwMSA9IFsgMSAvIDMsIGRxMSBdLFxuXHRcdFx0cDIgPSBbIDIgLyAzLCBkcTIgXSxcblx0XHRcdHAzID0gWyAxLCBkcTMgXSxcblx0XHRcdGRpc3QxID0gZHExIC0gKDIgKiBkcTAgKyBkcTMpIC8gMyxcblx0XHRcdGRpc3QyID0gZHEyIC0gKGRxMCArIDIgKiBkcTMpIC8gMyxcblx0XHRcdGh1bGw7XG5cdFx0aWYgKGRpc3QxICogZGlzdDIgPCAwKSB7XG5cdFx0XHRodWxsID0gW1twMCwgcDEsIHAzXSwgW3AwLCBwMiwgcDNdXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3RSYXRpbyA9IGRpc3QxIC8gZGlzdDI7XG5cdFx0XHRodWxsID0gW1xuXHRcdFx0XHRkaXN0UmF0aW8gPj0gMiA/IFtwMCwgcDEsIHAzXVxuXHRcdFx0XHQ6IGRpc3RSYXRpbyA8PSAwLjUgPyBbcDAsIHAyLCBwM11cblx0XHRcdFx0OiBbcDAsIHAxLCBwMiwgcDNdLFxuXHRcdFx0XHRbcDAsIHAzXVxuXHRcdFx0XTtcblx0XHR9XG5cdFx0cmV0dXJuIChkaXN0MSB8fCBkaXN0MikgPCAwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdGlmIChodWxsVG9wWzBdWzFdIDwgZE1pbikge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsVG9wLCB0cnVlLCBkTWluKTtcblx0XHR9IGVsc2UgaWYgKGh1bGxCb3R0b21bMF1bMV0gPiBkTWF4KSB7XG5cdFx0XHRyZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxCb3R0b20sIGZhbHNlLCBkTWF4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGh1bGxUb3BbMF1bMF07XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGxQYXJ0KHBhcnQsIHRvcCwgdGhyZXNob2xkKSB7XG5cdFx0dmFyIHB4ID0gcGFydFswXVswXSxcblx0XHRcdHB5ID0gcGFydFswXVsxXTtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHBhcnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcXggPSBwYXJ0W2ldWzBdLFxuXHRcdFx0XHRxeSA9IHBhcnRbaV1bMV07XG5cdFx0XHRpZiAodG9wID8gcXkgPj0gdGhyZXNob2xkIDogcXkgPD0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdHJldHVybiBxeSA9PT0gdGhyZXNob2xkID8gcXhcblx0XHRcdFx0XHRcdDogcHggKyAodGhyZXNob2xkIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0fVxuXHRcdFx0cHggPSBxeDtcblx0XHRcdHB5ID0gcXk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2LCBweCwgcHksIHZ4LCB2eSkge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdGlmIChpc1plcm8odngpICYmIGlzWmVybyh2eSkpIHtcblx0XHRcdHZhciB0ID0gQ3VydmUuZ2V0VGltZU9mKHYsIG5ldyBQb2ludChweCwgcHkpKTtcblx0XHRcdHJldHVybiB0ID09PSBudWxsID8gW10gOiBbdF07XG5cdFx0fVxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoLXZ5LCB2eCksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRydiA9IFtdLFxuXHRcdFx0cm9vdHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuXHRcdFx0dmFyIHggPSB2W2ldIC0gcHgsXG5cdFx0XHRcdHkgPSB2W2kgKyAxXSAtIHB5O1xuXHRcdFx0cnYucHVzaChcblx0XHRcdFx0eCAqIGNvcyAtIHkgKiBzaW4sXG5cdFx0XHRcdHggKiBzaW4gKyB5ICogY29zKTtcblx0XHR9XG5cdFx0Q3VydmUuc29sdmVDdWJpYyhydiwgMSwgMCwgcm9vdHMsIDAsIDEpO1xuXHRcdHJldHVybiByb290cztcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdGZsaXApIHtcblx0XHR2YXIgeDEgPSB2MlswXSwgeTEgPSB2MlsxXSxcblx0XHRcdHgyID0gdjJbNl0sIHkyID0gdjJbN10sXG5cdFx0XHRyb290cyA9IGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB0MSA9IHJvb3RzW2ldLFxuXHRcdFx0XHRwMSA9IEN1cnZlLmdldFBvaW50KHYxLCB0MSksXG5cdFx0XHRcdHQyID0gQ3VydmUuZ2V0VGltZU9mKHYyLCBwMSk7XG5cdFx0XHRpZiAodDIgIT09IG51bGwpIHtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0ZmxpcCA/IGMyIDogYzEsIGZsaXAgPyB0MiA6IHQxLFxuXHRcdFx0XHRcdFx0ZmxpcCA/IGMxIDogYzIsIGZsaXAgPyB0MSA6IHQyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHR2YXIgcHQgPSBMaW5lLmludGVyc2VjdChcblx0XHRcdFx0djFbMF0sIHYxWzFdLCB2MVs2XSwgdjFbN10sXG5cdFx0XHRcdHYyWzBdLCB2MlsxXSwgdjJbNl0sIHYyWzddKTtcblx0XHRpZiAocHQpIHtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjMSwgQ3VydmUuZ2V0VGltZU9mKHYxLCBwdCksXG5cdFx0XHRcdFx0YzIsIEN1cnZlLmdldFRpbWVPZih2MiwgcHQpKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRtaW4gPSBNYXRoLm1pbixcblx0XHRcdG1heCA9IE1hdGgubWF4O1xuXG5cdFx0aWYgKG1heCh2MVswXSwgdjFbMl0sIHYxWzRdLCB2MVs2XSkgKyBlcHNpbG9uID5cblx0XHRcdG1pbih2MlswXSwgdjJbMl0sIHYyWzRdLCB2Mls2XSkgJiZcblx0XHRcdG1pbih2MVswXSwgdjFbMl0sIHYxWzRdLCB2MVs2XSkgLSBlcHNpbG9uIDxcblx0XHRcdG1heCh2MlswXSwgdjJbMl0sIHYyWzRdLCB2Mls2XSkgJiZcblx0XHRcdG1heCh2MVsxXSwgdjFbM10sIHYxWzVdLCB2MVs3XSkgKyBlcHNpbG9uID5cblx0XHRcdG1pbih2MlsxXSwgdjJbM10sIHYyWzVdLCB2Mls3XSkgJiZcblx0XHRcdG1pbih2MVsxXSwgdjFbM10sIHYxWzVdLCB2MVs3XSkgLSBlcHNpbG9uIDxcblx0XHRcdG1heCh2MlsxXSwgdjJbM10sIHYyWzVdLCB2Mls3XSkpIHtcblx0XHRcdHZhciBvdmVybGFwcyA9IGdldE92ZXJsYXBzKHYxLCB2Mik7XG5cdFx0XHRpZiAob3ZlcmxhcHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldO1xuXHRcdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdFx0YzEsIG92ZXJsYXBbMF0sXG5cdFx0XHRcdFx0XHRcdGMyLCBvdmVybGFwWzFdLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0XHRcdHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuXHRcdFx0XHRcdHN0cmFpZ2h0ID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0Mixcblx0XHRcdFx0XHRmbGlwID0gc3RyYWlnaHQxICYmICFzdHJhaWdodDIsXG5cdFx0XHRcdFx0YmVmb3JlID0gbG9jYXRpb25zLmxlbmd0aDtcblx0XHRcdFx0KHN0cmFpZ2h0XG5cdFx0XHRcdFx0PyBhZGRMaW5lSW50ZXJzZWN0aW9uXG5cdFx0XHRcdFx0OiBzdHJhaWdodDEgfHwgc3RyYWlnaHQyXG5cdFx0XHRcdFx0XHQ/IGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnNcblx0XHRcdFx0XHRcdDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcblx0XHRcdFx0XHRcdFx0ZmxpcCA/IHYyIDogdjEsIGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0XHRcdFx0XHRmbGlwID8gYzIgOiBjMSwgZmxpcCA/IGMxIDogYzIsXG5cdFx0XHRcdFx0XHRcdGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdFx0XHRcdFx0MCwgMCwgMCwgMSwgMCwgMSk7XG5cdFx0XHRcdGlmICghc3RyYWlnaHQgfHwgbG9jYXRpb25zLmxlbmd0aCA9PT0gYmVmb3JlKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciB0MSA9IGkgPj4gMSxcblx0XHRcdFx0XHRcdFx0dDIgPSBpICYgMSxcblx0XHRcdFx0XHRcdFx0aTEgPSB0MSAqIDYsXG5cdFx0XHRcdFx0XHRcdGkyID0gdDIgKiA2LFxuXHRcdFx0XHRcdFx0XHRwMSA9IG5ldyBQb2ludCh2MVtpMV0sIHYxW2kxICsgMV0pLFxuXHRcdFx0XHRcdFx0XHRwMiA9IG5ldyBQb2ludCh2MltpMl0sIHYyW2kyICsgMV0pO1xuXHRcdFx0XHRcdFx0aWYgKHAxLmlzQ2xvc2UocDIsIGVwc2lsb24pKSB7XG5cdFx0XHRcdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdFx0XHRcdGMxLCB0MSxcblx0XHRcdFx0XHRcdFx0XHRcdGMyLCB0Mik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIGluZm8gPSBDdXJ2ZS5jbGFzc2lmeSh2MSk7XG5cdFx0aWYgKGluZm8udHlwZSA9PT0gJ2xvb3AnKSB7XG5cdFx0XHR2YXIgcm9vdHMgPSBpbmZvLnJvb3RzO1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdGMxLCByb290c1swXSxcblx0XHRcdFx0XHRjMSwgcm9vdHNbMV0pO1xuXHRcdH1cblx0ICByZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9ucyhjdXJ2ZXMxLCBjdXJ2ZXMyLCBpbmNsdWRlLCBtYXRyaXgxLCBtYXRyaXgyLFxuXHRcdFx0X3JldHVybkZpcnN0KSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS03LFxuXHRcdFx0c2VsZiA9ICFjdXJ2ZXMyO1xuXHRcdGlmIChzZWxmKVxuXHRcdFx0Y3VydmVzMiA9IGN1cnZlczE7XG5cdFx0dmFyIGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBjdXJ2ZXMyLmxlbmd0aCxcblx0XHRcdHZhbHVlczEgPSBuZXcgQXJyYXkobGVuZ3RoMSksXG5cdFx0XHR2YWx1ZXMyID0gc2VsZiA/IHZhbHVlczEgOiBuZXcgQXJyYXkobGVuZ3RoMiksXG5cdFx0XHRsb2NhdGlvbnMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YWx1ZXMxW2ldID0gY3VydmVzMVtpXS5nZXRWYWx1ZXMobWF0cml4MSk7XG5cdFx0fVxuXHRcdGlmICghc2VsZikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcblx0XHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgYm91bmRzQ29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zKFxuXHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyLCBlcHNpbG9uKTtcblx0XHRmb3IgKHZhciBpbmRleDEgPSAwOyBpbmRleDEgPCBsZW5ndGgxOyBpbmRleDErKykge1xuXHRcdFx0dmFyIGN1cnZlMSA9IGN1cnZlczFbaW5kZXgxXSxcblx0XHRcdFx0djEgPSB2YWx1ZXMxW2luZGV4MV07XG5cdFx0XHRpZiAoc2VsZikge1xuXHRcdFx0XHRnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY29sbGlzaW9uczEgPSBib3VuZHNDb2xsaXNpb25zW2luZGV4MV07XG5cdFx0XHRpZiAoY29sbGlzaW9uczEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjb2xsaXNpb25zMS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmIChfcmV0dXJuRmlyc3QgJiYgbG9jYXRpb25zLmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHRcdFx0dmFyIGluZGV4MiA9IGNvbGxpc2lvbnMxW2pdO1xuXHRcdFx0XHRcdGlmICghc2VsZiB8fCBpbmRleDIgPiBpbmRleDEpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJ2ZTIgPSBjdXJ2ZXMyW2luZGV4Ml0sXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVzMltpbmRleDJdO1xuXHRcdFx0XHRcdFx0Z2V0Q3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHRcdHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRPdmVybGFwcyh2MSwgdjIpIHtcblxuXHRcdGZ1bmN0aW9uIGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYpIHtcblx0XHRcdHZhciB4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdHJldHVybiB4ICogeCArIHkgKiB5O1xuXHRcdH1cblxuXHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdGdldERpc3RhbmNlID0gTGluZS5nZXREaXN0YW5jZSxcblx0XHRcdHRpbWVFcHNpbG9uID0gMWUtOCxcblx0XHRcdGdlb21FcHNpbG9uID0gMWUtNyxcblx0XHRcdHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0c3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG5cdFx0XHRzdHJhaWdodEJvdGggPSBzdHJhaWdodDEgJiYgc3RyYWlnaHQyLFxuXHRcdFx0ZmxpcCA9IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYxKSA8IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYyKSxcblx0XHRcdGwxID0gZmxpcCA/IHYyIDogdjEsXG5cdFx0XHRsMiA9IGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0cHggPSBsMVswXSwgcHkgPSBsMVsxXSxcblx0XHRcdHZ4ID0gbDFbNl0gLSBweCwgdnkgPSBsMVs3XSAtIHB5O1xuXHRcdGlmIChnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbMF0sIGwyWzFdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNl0sIGwyWzddLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG5cdFx0XHRpZiAoIXN0cmFpZ2h0Qm90aCAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbMl0sIGwxWzNdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRcdGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMVs0XSwgbDFbNV0sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzJdLCBsMlszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNF0sIGwyWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG5cdFx0XHRcdHN0cmFpZ2h0MSA9IHN0cmFpZ2h0MiA9IHN0cmFpZ2h0Qm90aCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdHJhaWdodEJvdGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRpZiAoc3RyYWlnaHQxIF4gc3RyYWlnaHQyKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgdiA9IFt2MSwgdjJdLFxuXHRcdFx0cGFpcnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgcGFpcnMubGVuZ3RoIDwgMjsgaSsrKSB7XG5cdFx0XHR2YXIgaTEgPSBpICYgMSxcblx0XHRcdFx0aTIgPSBpMSBeIDEsXG5cdFx0XHRcdHQxID0gaSA+PiAxLFxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFRpbWVPZih2W2kxXSwgbmV3IFBvaW50KFxuXHRcdFx0XHRcdHZbaTJdW3QxID8gNiA6IDBdLFxuXHRcdFx0XHRcdHZbaTJdW3QxID8gNyA6IDFdKSk7XG5cdFx0XHRpZiAodDIgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcGFpciA9IGkxID8gW3QxLCB0Ml0gOiBbdDIsIHQxXTtcblx0XHRcdFx0aWYgKCFwYWlycy5sZW5ndGggfHxcblx0XHRcdFx0XHRhYnMocGFpclswXSAtIHBhaXJzWzBdWzBdKSA+IHRpbWVFcHNpbG9uICYmXG5cdFx0XHRcdFx0YWJzKHBhaXJbMV0gLSBwYWlyc1swXVsxXSkgPiB0aW1lRXBzaWxvbikge1xuXHRcdFx0XHRcdHBhaXJzLnB1c2gocGFpcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpID4gMiAmJiAhcGFpcnMubGVuZ3RoKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHBhaXJzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoIXN0cmFpZ2h0Qm90aCkge1xuXHRcdFx0dmFyIG8xID0gQ3VydmUuZ2V0UGFydCh2MSwgcGFpcnNbMF1bMF0sIHBhaXJzWzFdWzBdKSxcblx0XHRcdFx0bzIgPSBDdXJ2ZS5nZXRQYXJ0KHYyLCBwYWlyc1swXVsxXSwgcGFpcnNbMV1bMV0pO1xuXHRcdFx0aWYgKGFicyhvMlsyXSAtIG8xWzJdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMlszXSAtIG8xWzNdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMls0XSAtIG8xWzRdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMls1XSAtIG8xWzVdKSA+IGdlb21FcHNpbG9uKVxuXHRcdFx0XHRwYWlycyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBwYWlycztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRpbWVzV2l0aFRhbmdlbnQodiwgdGFuZ2VudCkge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdG5vcm1hbGl6ZWQgPSB0YW5nZW50Lm5vcm1hbGl6ZSgpLFxuXHRcdFx0dHggPSBub3JtYWxpemVkLngsXG5cdFx0XHR0eSA9IG5vcm1hbGl6ZWQueSxcblx0XHRcdGF4ID0gMyAqIHgzIC0gOSAqIHgyICsgOSAqIHgxIC0gMyAqIHgwLFxuXHRcdFx0YXkgPSAzICogeTMgLSA5ICogeTIgKyA5ICogeTEgLSAzICogeTAsXG5cdFx0XHRieCA9IDYgKiB4MiAtIDEyICogeDEgKyA2ICogeDAsXG5cdFx0XHRieSA9IDYgKiB5MiAtIDEyICogeTEgKyA2ICogeTAsXG5cdFx0XHRjeCA9IDMgKiB4MSAtIDMgKiB4MCxcblx0XHRcdGN5ID0gMyAqIHkxIC0gMyAqIHkwLFxuXHRcdFx0ZGVuID0gMiAqIGF4ICogdHkgLSAyICogYXkgKiB0eCxcblx0XHRcdHRpbWVzID0gW107XG5cdFx0aWYgKE1hdGguYWJzKGRlbikgPCBOdW1lcmljYWwuQ1VSVkVUSU1FX0VQU0lMT04pIHtcblx0XHRcdHZhciBudW0gPSBheCAqIGN5IC0gYXkgKiBjeCxcblx0XHRcdFx0ZGVuID0gYXggKiBieSAtIGF5ICogYng7XG5cdFx0XHRpZiAoZGVuICE9IDApIHtcblx0XHRcdFx0dmFyIHQgPSAtbnVtIC8gZGVuO1xuXHRcdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkgdGltZXMucHVzaCh0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRlbHRhID0gKGJ4ICogYnggLSA0ICogYXggKiBjeCkgKiB0eSAqIHR5ICtcblx0XHRcdFx0KC0yICogYnggKiBieSArIDQgKiBheSAqIGN4ICsgNCAqIGF4ICogY3kpICogdHggKiB0eSArXG5cdFx0XHRcdChieSAqIGJ5IC0gNCAqIGF5ICogY3kpICogdHggKiB0eCxcblx0XHRcdFx0ayA9IGJ4ICogdHkgLSBieSAqIHR4O1xuXHRcdFx0aWYgKGRlbHRhID49IDAgJiYgZGVuICE9IDApIHtcblx0XHRcdFx0dmFyIGQgPSBNYXRoLnNxcnQoZGVsdGEpLFxuXHRcdFx0XHRcdHQwID0gLShrICsgZCkgLyBkZW4sXG5cdFx0XHRcdFx0dDEgPSAoLWsgKyBkKSAvIGRlbjtcblx0XHRcdFx0aWYgKHQwID49IDAgJiYgdDAgPD0gMSkgdGltZXMucHVzaCh0MCk7XG5cdFx0XHRcdGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHRpbWVzLnB1c2godDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGltZXM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0XHR2YXIgdjEgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0XHR2MiA9IGN1cnZlICYmIGN1cnZlICE9PSB0aGlzICYmIGN1cnZlLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIHYyID8gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgdGhpcywgY3VydmUsIFtdKVxuXHRcdFx0XHRcdCAgOiBnZXRTZWxmSW50ZXJzZWN0aW9uKHYxLCB0aGlzLCBbXSk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGdldE92ZXJsYXBzOiBnZXRPdmVybGFwcyxcblx0XHRcdGdldEludGVyc2VjdGlvbnM6IGdldEludGVyc2VjdGlvbnMsXG5cdFx0XHRnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zOiBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zLFxuXHRcdFx0Z2V0VGltZXNXaXRoVGFuZ2VudDogZ2V0VGltZXNXaXRoVGFuZ2VudFxuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGltZSwgcG9pbnQsIF9vdmVybGFwLCBfZGlzdGFuY2UpIHtcblx0XHRpZiAodGltZSA+PSAwLjk5OTk5OTk5KSB7XG5cdFx0XHR2YXIgbmV4dCA9IGN1cnZlLmdldE5leHQoKTtcblx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRjdXJ2ZSA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldEN1cnZlKGN1cnZlKTtcblx0XHR0aGlzLl90aW1lID0gdGltZTtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50IHx8IGN1cnZlLmdldFBvaW50QXRUaW1lKHRpbWUpO1xuXHRcdHRoaXMuX292ZXJsYXAgPSBfb3ZlcmxhcDtcblx0XHR0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcblx0XHR0aGlzLl9pbnRlcnNlY3Rpb24gPSB0aGlzLl9uZXh0ID0gdGhpcy5fcHJldmlvdXMgPSBudWxsO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dGhpcy5fcGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5fdmVyc2lvbiA9IHBhdGggPyBwYXRoLl92ZXJzaW9uIDogMDtcblx0fSxcblxuXHRfc2V0Q3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChjdXJ2ZS5fcGF0aCk7XG5cdFx0dGhpcy5fY3VydmUgPSBjdXJ2ZTtcblx0XHR0aGlzLl9zZWdtZW50ID0gbnVsbDtcblx0XHR0aGlzLl9zZWdtZW50MSA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IGN1cnZlLl9zZWdtZW50Mjtcblx0fSxcblxuXHRfc2V0U2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKTtcblx0XHRpZiAoY3VydmUpIHtcblx0XHRcdHRoaXMuX3NldEN1cnZlKGN1cnZlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2V0UGF0aChzZWdtZW50Ll9wYXRoKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gc2VnbWVudDtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0dGhpcy5fdGltZSA9IHNlZ21lbnQgPT09IHRoaXMuX3NlZ21lbnQxID8gMCA6IDE7XG5cdFx0dGhpcy5fcG9pbnQgPSBzZWdtZW50Ll9wb2ludC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudDtcblx0XHRpZiAoIXNlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0dGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuXHRcdFx0aWYgKHRpbWUgPT09IDApIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHRcdH0gZWxzZSBpZiAodGltZSA9PT0gMSkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lICE9IG51bGwpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgdGltZSlcblx0XHRcdFx0XHQ8IGN1cnZlLmdldFBhcnRMZW5ndGgodGltZSwgMSlcblx0XHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gc2VnbWVudDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKHBhdGggJiYgcGF0aC5fdmVyc2lvbiAhPT0gdGhpcy5fdmVyc2lvbikge1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX29mZnNldCA9IHRoaXMuX2N1cnZlT2Zmc2V0ID0gdGhpcy5fY3VydmUgPSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyeVNlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0dmFyIGN1cnZlID0gc2VnbWVudCAmJiBzZWdtZW50LmdldEN1cnZlKCk7XG5cdFx0XHRpZiAoY3VydmUgJiYgKHRoYXQuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhhdC5fcG9pbnQpKSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoYXQuX3NldEN1cnZlKGN1cnZlKTtcblx0XHRcdFx0cmV0dXJuIGN1cnZlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9jdXJ2ZVxuXHRcdFx0fHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50KVxuXHRcdFx0fHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50MSlcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKSk7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRJbmRleCgpO1xuXHR9LFxuXG5cdGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiB0aW1lID09IG51bGxcblx0XHRcdD8gdGhpcy5fdGltZSA9IGN1cnZlLmdldFRpbWVPZih0aGlzLl9wb2ludClcblx0XHRcdDogdGltZTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXI6ICcjZ2V0VGltZScsXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cdFx0aWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0dmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKSxcblx0XHRcdFx0aW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cdFx0XHRpZiAocGF0aCAmJiBpbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZXMgPSBwYXRoLmdldEN1cnZlcygpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdFx0b2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldCArPSB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldDtcblx0XHRpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0dGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5fY3VydmVPZmZzZXQgPSBvZmZzZXQgPSB0aW1lICE9IG51bGwgJiYgY3VydmVcblx0XHRcdFx0XHQmJiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cmVzID0gY3VydmUgJiYgY3VydmUuZGl2aWRlQXRUaW1lKHRoaXMuZ2V0VGltZSgpKTtcblx0XHRpZiAocmVzKSB7XG5cdFx0XHR0aGlzLl9zZXRTZWdtZW50KHJlcy5fc2VnbWVudDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRyZXMgPSBjdXJ2ZSAmJiBjdXJ2ZS5zcGxpdEF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0dGhpcy5fc2V0U2VnbWVudChwYXRoLmdldExhc3RTZWdtZW50KCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gIHJlcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGxvYywgX2lnbm9yZU90aGVyKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMgPT09IGxvYztcblx0XHRpZiAoIXJlcyAmJiBsb2MgaW5zdGFuY2VvZiBDdXJ2ZUxvY2F0aW9uKSB7XG5cdFx0XHR2YXIgYzEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGMyID0gbG9jLmdldEN1cnZlKCksXG5cdFx0XHRcdHAxID0gYzEuX3BhdGgsXG5cdFx0XHRcdHAyID0gYzIuX3BhdGg7XG5cdFx0XHRpZiAocDEgPT09IHAyKSB7XG5cdFx0XHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtNyxcblx0XHRcdFx0XHRkaWZmID0gYWJzKHRoaXMuZ2V0T2Zmc2V0KCkgLSBsb2MuZ2V0T2Zmc2V0KCkpLFxuXHRcdFx0XHRcdGkxID0gIV9pZ25vcmVPdGhlciAmJiB0aGlzLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdFx0aTIgPSAhX2lnbm9yZU90aGVyICYmIGxvYy5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRyZXMgPSAoZGlmZiA8IGVwc2lsb25cblx0XHRcdFx0XHRcdHx8IHAxICYmIGFicyhwMS5nZXRMZW5ndGgoKSAtIGRpZmYpIDwgZXBzaWxvbilcblx0XHRcdFx0XHQmJiAoIWkxICYmICFpMiB8fCBpMSAmJiBpMiAmJiBpMS5lcXVhbHMoaTIsIHRydWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0cGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG5cdFx0dmFyIHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRpZiAodGltZSAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgndGltZTogJyArIGYubnVtYmVyKHRpbWUpKTtcblx0XHRpZiAodGhpcy5fZGlzdGFuY2UgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2Rpc3RhbmNlOiAnICsgZi5udW1iZXIodGhpcy5fZGlzdGFuY2UpKTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdGlzVG91Y2hpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblx0XHRpZiAoaW50ZXIgJiYgdGhpcy5nZXRUYW5nZW50KCkuaXNDb2xsaW5lYXIoaW50ZXIuZ2V0VGFuZ2VudCgpKSkge1xuXHRcdFx0dmFyIGN1cnZlMSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0Y3VydmUyID0gaW50ZXIuZ2V0Q3VydmUoKTtcblx0XHRcdHJldHVybiAhKGN1cnZlMS5pc1N0cmFpZ2h0KCkgJiYgY3VydmUyLmlzU3RyYWlnaHQoKVxuXHRcdFx0XHRcdCYmIGN1cnZlMS5nZXRMaW5lKCkuaW50ZXJzZWN0KGN1cnZlMi5nZXRMaW5lKCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQ3Jvc3Npbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblx0XHRpZiAoIWludGVyKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciB0MSA9IHRoaXMuZ2V0VGltZSgpLFxuXHRcdFx0dDIgPSBpbnRlci5nZXRUaW1lKCksXG5cdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHQxSW5zaWRlID0gdDEgPj0gdE1pbiAmJiB0MSA8PSB0TWF4LFxuXHRcdFx0dDJJbnNpZGUgPSB0MiA+PSB0TWluICYmIHQyIDw9IHRNYXg7XG5cdFx0aWYgKHQxSW5zaWRlICYmIHQySW5zaWRlKVxuXHRcdFx0cmV0dXJuICF0aGlzLmlzVG91Y2hpbmcoKTtcblx0XHR2YXIgYzIgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRjMSA9IGMyICYmIHQxIDwgdE1pbiA/IGMyLmdldFByZXZpb3VzKCkgOiBjMixcblx0XHRcdGM0ID0gaW50ZXIuZ2V0Q3VydmUoKSxcblx0XHRcdGMzID0gYzQgJiYgdDIgPCB0TWluID8gYzQuZ2V0UHJldmlvdXMoKSA6IGM0O1xuXHRcdGlmICh0MSA+IHRNYXgpXG5cdFx0XHRjMiA9IGMyLmdldE5leHQoKTtcblx0XHRpZiAodDIgPiB0TWF4KVxuXHRcdFx0YzQgPSBjNC5nZXROZXh0KCk7XG5cdFx0aWYgKCFjMSB8fCAhYzIgfHwgIWMzIHx8ICFjNClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBvZmZzZXRzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRPZmZzZXRzKGN1cnZlLCBlbmQpIHtcblx0XHRcdHZhciB2ID0gY3VydmUuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdHJvb3RzID0gQ3VydmUuY2xhc3NpZnkodikucm9vdHMgfHwgQ3VydmUuZ2V0UGVha3ModiksXG5cdFx0XHRcdGNvdW50ID0gcm9vdHMubGVuZ3RoLFxuXHRcdFx0XHRvZmZzZXQgPSBDdXJ2ZS5nZXRMZW5ndGgodixcblx0XHRcdFx0XHRlbmQgJiYgY291bnQgPyByb290c1tjb3VudCAtIDFdIDogMCxcblx0XHRcdFx0XHQhZW5kICYmIGNvdW50ID8gcm9vdHNbMF0gOiAxKTtcblx0XHRcdG9mZnNldHMucHVzaChjb3VudCA/IG9mZnNldCA6IG9mZnNldCAvIDMyKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0luUmFuZ2UoYW5nbGUsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gbWluIDwgbWF4XG5cdFx0XHRcdFx0PyBhbmdsZSA+IG1pbiAmJiBhbmdsZSA8IG1heFxuXHRcdFx0XHRcdDogYW5nbGUgPiBtaW4gfHwgYW5nbGUgPCBtYXg7XG5cdFx0fVxuXG5cdFx0aWYgKCF0MUluc2lkZSkge1xuXHRcdFx0YWRkT2Zmc2V0cyhjMSwgdHJ1ZSk7XG5cdFx0XHRhZGRPZmZzZXRzKGMyLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGlmICghdDJJbnNpZGUpIHtcblx0XHRcdGFkZE9mZnNldHMoYzMsIHRydWUpO1xuXHRcdFx0YWRkT2Zmc2V0cyhjNCwgZmFsc2UpO1xuXHRcdH1cblx0XHR2YXIgcHQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRvZmZzZXQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzKSxcblx0XHRcdHYyID0gdDFJbnNpZGUgPyBjMi5nZXRUYW5nZW50QXRUaW1lKHQxKVxuXHRcdFx0XHRcdDogYzIuZ2V0UG9pbnRBdChvZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdHYxID0gdDFJbnNpZGUgPyB2Mi5uZWdhdGUoKVxuXHRcdFx0XHRcdDogYzEuZ2V0UG9pbnRBdCgtb2Zmc2V0KS5zdWJ0cmFjdChwdCksXG5cdFx0XHR2NCA9IHQySW5zaWRlID8gYzQuZ2V0VGFuZ2VudEF0VGltZSh0Milcblx0XHRcdFx0XHQ6IGM0LmdldFBvaW50QXQob2Zmc2V0KS5zdWJ0cmFjdChwdCksXG5cdFx0XHR2MyA9IHQySW5zaWRlID8gdjQubmVnYXRlKClcblx0XHRcdFx0XHQ6IGMzLmdldFBvaW50QXQoLW9mZnNldCkuc3VidHJhY3QocHQpLFxuXHRcdFx0YTEgPSB2MS5nZXRBbmdsZSgpLFxuXHRcdFx0YTIgPSB2Mi5nZXRBbmdsZSgpLFxuXHRcdFx0YTMgPSB2My5nZXRBbmdsZSgpLFxuXHRcdFx0YTQgPSB2NC5nZXRBbmdsZSgpO1xuXHRcdHJldHVybiAhISh0MUluc2lkZVxuXHRcdFx0XHQ/IChpc0luUmFuZ2UoYTEsIGEzLCBhNCkgXiBpc0luUmFuZ2UoYTIsIGEzLCBhNCkpICYmXG5cdFx0XHRcdCAgKGlzSW5SYW5nZShhMSwgYTQsIGEzKSBeIGlzSW5SYW5nZShhMiwgYTQsIGEzKSlcblx0XHRcdFx0OiAoaXNJblJhbmdlKGEzLCBhMSwgYTIpIF4gaXNJblJhbmdlKGE0LCBhMSwgYTIpKSAmJlxuXHRcdFx0XHQgIChpc0luUmFuZ2UoYTMsIGEyLCBhMSkgXiBpc0luUmFuZ2UoYTQsIGEyLCBhMSkpKTtcblx0fSxcblxuXHRoYXNPdmVybGFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9vdmVybGFwO1xuXHR9XG59LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgZ2V0ID0gbmFtZSArICdBdCc7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHR0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG5cdFx0cmV0dXJuIHRpbWUgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZVtnZXRdKHRpbWUsIHRydWUpO1xuXHR9O1xufSwge1xuXHRwcmVzZXJ2ZTogdHJ1ZVxufSksXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gaW5zZXJ0KGxvY2F0aW9ucywgbG9jLCBtZXJnZSkge1xuXHRcdHZhciBsZW5ndGggPSBsb2NhdGlvbnMubGVuZ3RoLFxuXHRcdFx0bCA9IDAsXG5cdFx0XHRyID0gbGVuZ3RoIC0gMTtcblxuXHRcdGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgZGlyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBkaXI7IGkgPj0gLTEgJiYgaSA8PSBsZW5ndGg7IGkgKz0gZGlyKSB7XG5cdFx0XHRcdHZhciBsb2MyID0gbG9jYXRpb25zWygoaSAlIGxlbmd0aCkgKyBsZW5ndGgpICUgbGVuZ3RoXTtcblx0XHRcdFx0aWYgKCFsb2MuZ2V0UG9pbnQoKS5pc0Nsb3NlKGxvYzIuZ2V0UG9pbnQoKSxcblx0XHRcdFx0XHRcdDFlLTcpKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRpZiAobG9jLmVxdWFscyhsb2MyKSlcblx0XHRcdFx0XHRyZXR1cm4gbG9jMjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHdoaWxlIChsIDw9IHIpIHtcblx0XHRcdHZhciBtID0gKGwgKyByKSA+Pj4gMSxcblx0XHRcdFx0bG9jMiA9IGxvY2F0aW9uc1ttXSxcblx0XHRcdFx0Zm91bmQ7XG5cdFx0XHRpZiAobWVyZ2UgJiYgKGZvdW5kID0gbG9jLmVxdWFscyhsb2MyKSA/IGxvYzJcblx0XHRcdFx0XHQ6IChzZWFyY2gobSwgLTEpIHx8IHNlYXJjaChtLCAxKSkpKSB7XG5cdFx0XHRcdGlmIChsb2MuX292ZXJsYXApIHtcblx0XHRcdFx0XHRmb3VuZC5fb3ZlcmxhcCA9IGZvdW5kLl9pbnRlcnNlY3Rpb24uX292ZXJsYXAgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmb3VuZDtcblx0XHRcdH1cblx0XHR2YXIgcGF0aDEgPSBsb2MuZ2V0UGF0aCgpLFxuXHRcdFx0cGF0aDIgPSBsb2MyLmdldFBhdGgoKSxcblx0XHRcdGRpZmYgPSBwYXRoMSAhPT0gcGF0aDJcblx0XHRcdFx0PyBwYXRoMS5faWQgLSBwYXRoMi5faWRcblx0XHRcdFx0OiAobG9jLmdldEluZGV4KCkgKyBsb2MuZ2V0VGltZSgpKVxuXHRcdFx0XHQtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFRpbWUoKSk7XG5cdFx0XHRpZiAoZGlmZiA8IDApIHtcblx0XHRcdFx0ciA9IG0gLSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IG0gKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2NhdGlvbnMuc3BsaWNlKGwsIDAsIGxvYyk7XG5cdFx0cmV0dXJuIGxvYztcblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRpbnNlcnQ6IGluc2VydCxcblxuXHRcdGV4cGFuZDogZnVuY3Rpb24obG9jYXRpb25zKSB7XG5cdFx0XHR2YXIgZXhwYW5kZWQgPSBsb2NhdGlvbnMuc2xpY2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aW5zZXJ0KGV4cGFuZGVkLCBsb2NhdGlvbnNbaV0uX2ludGVyc2VjdGlvbiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fX07XG59KTtcblxudmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlbScsXG5cdF9zZWxlY3RCb3VuZHM6IGZhbHNlLFxuXHRfY2FuU2NhbGVTdHJva2U6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKGFyZykge1xuXHRcdFx0dmFyIGRhdGEsXG5cdFx0XHRcdHNlZ21lbnRzLFxuXHRcdFx0XHRjb21wb3VuZDtcblx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IGFyZy5zZWdtZW50cztcblx0XHRcdFx0ZGF0YSA9IGFyZy5wYXRoRGF0YTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHNlZ21lbnRzID0gYXJnO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkYXRhID0gYXJnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNlZ21lbnRzKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuXHRcdFx0XHRjb21wb3VuZCA9IGZpcnN0ICYmIEFycmF5LmlzQXJyYXkoZmlyc3RbMF0pO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhKSB7XG5cdFx0XHRcdGNvbXBvdW5kID0gKGRhdGEubWF0Y2goL20vZ2kpIHx8IFtdKS5sZW5ndGggPiAxXG5cdFx0XHRcdFx0XHR8fCAvelxccypcXFMrL2kudGVzdChkYXRhKTtcblx0XHRcdH1cblx0XHRcdHZhciBjdG9yID0gY29tcG91bmQgPyBDb21wb3VuZFBhdGggOiBQYXRoO1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKGFyZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXJlYSgpID49IDA7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0fSxcblxuXHRzZXRQYXRoRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXG5cdFx0dmFyIHBhcnRzID0gZGF0YSAmJiBkYXRhLm1hdGNoKC9bbWxodmNzcXRhel1bXm1saHZjc3F0YXpdKi9pZyksXG5cdFx0XHRjb29yZHMsXG5cdFx0XHRyZWxhdGl2ZSA9IGZhbHNlLFxuXHRcdFx0cHJldmlvdXMsXG5cdFx0XHRjb250cm9sLFxuXHRcdFx0Y3VycmVudCA9IG5ldyBQb2ludCgpLFxuXHRcdFx0c3RhcnQgPSBuZXcgUG9pbnQoKTtcblxuXHRcdGZ1bmN0aW9uIGdldENvb3JkKGluZGV4LCBjb29yZCkge1xuXHRcdFx0dmFyIHZhbCA9ICtjb29yZHNbaW5kZXhdO1xuXHRcdFx0aWYgKHJlbGF0aXZlKVxuXHRcdFx0XHR2YWwgKz0gY3VycmVudFtjb29yZF07XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBvaW50KGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCwgJ3gnKSxcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXggKyAxLCAneScpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xlYXIoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMgJiYgcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHBhcnRzW2ldLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydFswXSxcblx0XHRcdFx0bG93ZXIgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjb29yZHMgPSBwYXJ0Lm1hdGNoKC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKTtcblx0XHRcdHZhciBsZW5ndGggPSBjb29yZHMgJiYgY29vcmRzLmxlbmd0aDtcblx0XHRcdHJlbGF0aXZlID0gY29tbWFuZCA9PT0gbG93ZXI7XG5cdFx0XHRpZiAocHJldmlvdXMgPT09ICd6JyAmJiAhL1ttel0vLnRlc3QobG93ZXIpKVxuXHRcdFx0XHR0aGlzLm1vdmVUbyhjdXJyZW50KTtcblx0XHRcdHN3aXRjaCAobG93ZXIpIHtcblx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHZhciBtb3ZlID0gbG93ZXIgPT09ICdtJztcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXNbbW92ZSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdFx0aWYgKG1vdmUpIHtcblx0XHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0XHRcdG1vdmUgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0dmFyIGNvb3JkID0gbG93ZXIgPT09ICdoJyA/ICd4JyA6ICd5Jztcblx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnQuY2xvbmUoKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGN1cnJlbnRbY29vcmRdID0gZ2V0Q29vcmQoaiwgY29vcmQpO1xuXHRcdFx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA2KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiArIDIpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdC9bY3NdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA0KSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSAoL1txdF0vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqKSk7XG5cdFx0XHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA3KSB7XG5cdFx0XHRcdFx0dGhpcy5hcmNUbyhjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDUpLFxuXHRcdFx0XHRcdFx0XHRuZXcgU2l6ZSgrY29vcmRzW2pdLCArY29vcmRzW2ogKyAxXSksXG5cdFx0XHRcdFx0XHRcdCtjb29yZHNbaiArIDJdLCArY29vcmRzW2ogKyA0XSwgK2Nvb3Jkc1tqICsgM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdHRoaXMuY2xvc2VQYXRoKDFlLTEyKTtcblx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgd2luZGluZyA9IHBvaW50LmlzSW5zaWRlKFxuXHRcdFx0XHR0aGlzLmdldEJvdW5kcyh7IGludGVybmFsOiB0cnVlLCBoYW5kbGU6IHRydWUgfSkpXG5cdFx0XHRcdFx0PyB0aGlzLl9nZXRXaW5kaW5nKHBvaW50KVxuXHRcdFx0XHRcdDoge307XG5cdFx0cmV0dXJuIHdpbmRpbmcub25QYXRoIHx8ICEhKHRoaXMuZ2V0RmlsbFJ1bGUoKSA9PT0gJ2V2ZW5vZGQnXG5cdFx0XHRcdD8gd2luZGluZy53aW5kaW5nTCAmIDEgfHwgd2luZGluZy53aW5kaW5nUiAmIDFcblx0XHRcdFx0OiB3aW5kaW5nLndpbmRpbmcpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIGluY2x1ZGUsIF9tYXRyaXgsIF9yZXR1cm5GaXJzdCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyA9PT0gcGF0aCB8fCAhcGF0aCxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdG1hdHJpeDIgPSBzZWxmID8gbWF0cml4MVxuXHRcdFx0XHQ6IChfbWF0cml4IHx8IHBhdGguX21hdHJpeCkuX29yTnVsbElmSWRlbnRpdHkoKTtcblx0XHRyZXR1cm4gc2VsZiB8fCB0aGlzLmdldEJvdW5kcyhtYXRyaXgxKS5pbnRlcnNlY3RzKFxuXHRcdFx0XHRwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSwgMWUtMTIpXG5cdFx0XHRcdD8gQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdHRoaXMuZ2V0Q3VydmVzKCksICFzZWxmICYmIHBhdGguZ2V0Q3VydmVzKCksIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRtYXRyaXgxLCBtYXRyaXgyLCBfcmV0dXJuRmlyc3QpXG5cdFx0XHRcdDogW107XG5cdH0sXG5cblx0Z2V0Q3Jvc3NpbmdzOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9ucyhwYXRoLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0cmV0dXJuIGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHR9KTtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5Mb2MgPSBudWxsO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdG1pbkRpc3QgPSBsb2MuX2Rpc3RhbmNlO1xuXHRcdFx0XHRtaW5Mb2MgPSBsb2M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Mb2M7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldFBvaW50KCkgOiBsb2M7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcblx0XHR2YXIgaXNQYXRoID0gIXRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bmFtZSA9IGlzUGF0aCA/ICdfc2VnbWVudHMnIDogJ19jaGlsZHJlbicsXG5cdFx0XHRpdGVtc0Zyb20gPSBmcm9tW25hbWVdLFxuXHRcdFx0aXRlbXNUbyA9IHRvW25hbWVdLFxuXHRcdFx0aXRlbXMgPSB0aGlzW25hbWVdO1xuXHRcdGlmICghaXRlbXNGcm9tIHx8ICFpdGVtc1RvIHx8IGl0ZW1zRnJvbS5sZW5ndGggIT09IGl0ZW1zVG8ubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmFuZHMgaW4gaW50ZXJwb2xhdGUoKSBjYWxsOiAnICtcblx0XHRcdFx0XHRmcm9tICsgJywgJyArIHRvKTtcblx0XHR9XG5cdFx0dmFyIGN1cnJlbnQgPSBpdGVtcy5sZW5ndGgsXG5cdFx0XHRsZW5ndGggPSBpdGVtc1RvLmxlbmd0aDtcblx0XHRpZiAoY3VycmVudCA8IGxlbmd0aCkge1xuXHRcdFx0dmFyIGN0b3IgPSBpc1BhdGggPyBTZWdtZW50IDogUGF0aDtcblx0XHRcdGZvciAodmFyIGkgPSBjdXJyZW50OyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGQobmV3IGN0b3IoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjdXJyZW50ID4gbGVuZ3RoKSB7XG5cdFx0XHR0aGlzW2lzUGF0aCA/ICdyZW1vdmVTZWdtZW50cycgOiAncmVtb3ZlQ2hpbGRyZW4nXShsZW5ndGgsIGN1cnJlbnQpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpdGVtc1tpXS5pbnRlcnBvbGF0ZShpdGVtc0Zyb21baV0sIGl0ZW1zVG9baV0sIGZhY3Rvcik7XG5cdFx0fVxuXHRcdGlmIChpc1BhdGgpIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZyb20uX2Nsb3NlZCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRjb21wYXJlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dmFyIG9rID0gZmFsc2U7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBwYXRoczEgPSB0aGlzLl9jaGlsZHJlbiB8fCBbdGhpc10sXG5cdFx0XHRcdHBhdGhzMiA9IHBhdGguX2NoaWxkcmVuID8gcGF0aC5fY2hpbGRyZW4uc2xpY2UoKSA6IFtwYXRoXSxcblx0XHRcdFx0bGVuZ3RoMSA9IHBhdGhzMS5sZW5ndGgsXG5cdFx0XHRcdGxlbmd0aDIgPSBwYXRoczIubGVuZ3RoLFxuXHRcdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdG9rID0gdHJ1ZTtcblx0XHRcdHZhciBib3VuZHNPdmVybGFwcyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kSXRlbUJvdW5kc0NvbGxpc2lvbnMocGF0aHMxLCBwYXRoczIsIE51bWVyaWNhbC5HRU9NRVRSSUNfRVBTSUxPTik7XG5cdFx0XHRmb3IgKHZhciBpMSA9IGxlbmd0aDEgLSAxOyBpMSA+PSAwICYmIG9rOyBpMS0tKSB7XG5cdFx0XHRcdHZhciBwYXRoMSA9IHBhdGhzMVtpMV07XG5cdFx0XHRcdG9rID0gZmFsc2U7XG5cdFx0XHRcdHZhciBwYXRoQm91bmRzT3ZlcmxhcHMgPSBib3VuZHNPdmVybGFwc1tpMV07XG5cdFx0XHRcdGlmIChwYXRoQm91bmRzT3ZlcmxhcHMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpMiA9IHBhdGhCb3VuZHNPdmVybGFwcy5sZW5ndGggLSAxOyBpMiA+PSAwICYmICFvazsgaTItLSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdGgxLmNvbXBhcmUocGF0aHMyW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIW1hdGNoZWRbcGF0aEJvdW5kc092ZXJsYXBzW2kyXV0pIHtcblx0XHRcdFx0XHRcdFx0XHRtYXRjaGVkW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG9rID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9rID0gb2sgJiYgY291bnQgPT09IGxlbmd0aDI7XG5cdFx0fVxuXHRcdHJldHVybiBvaztcblx0fSxcblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR0aGlzLl92ZXJzaW9uID0gMDtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJnc1xuXHRcdFx0OiBhcmcgJiYgKGFyZy5zaXplID09PSB1bmRlZmluZWQgJiYgKGFyZy54ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHR8fCBhcmcucG9pbnQgIT09IHVuZGVmaW5lZCkpXG5cdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcblx0XHRcdGlmICghc2VnbWVudHMgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0XHRhcmcgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pbml0aWFsaXplKCFzZWdtZW50cyAmJiBhcmcpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkID09PSBpdGVtLl9jbG9zZWRcblx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fc2VnbWVudHMsIGl0ZW0uX3NlZ21lbnRzKTtcblx0fSxcblxuXHRjb3B5Q29udGVudDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzb3VyY2UuX3NlZ21lbnRzKTtcblx0XHR0aGlzLl9jbG9zZWQgPSBzb3VyY2UuX2Nsb3NlZDtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcblx0XHRfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2FyZWEgPSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uKys7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0ICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tpXS5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiA2NCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKSxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aDtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPSAwO1xuXHRcdHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAobGVuZ3RoKSB7XG5cdFx0XHR2YXIgbGFzdCA9IHNlZ21lbnRzW2xlbmd0aCAtIDFdO1xuXHRcdFx0aWYgKHR5cGVvZiBsYXN0ID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9zZWQobGFzdCk7XG5cdFx0XHRcdGxlbmd0aC0tO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMsIDAsIHt9LCBsZW5ndGgpKTtcblx0XHR9XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCg0MSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzKTtcblx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goJ00nICsgZi5wYWlyKGN1clgsIGN1clkpKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluWCA9IGNvb3Jkc1syXTtcblx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHRpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWVxuXHRcdFx0XHRcdFx0JiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcblx0XHRcdFx0XHRpZiAoIXNraXBMaW5lKSB7XG5cdFx0XHRcdFx0XHR2YXIgZHggPSBjdXJYIC0gcHJldlgsXG5cdFx0XHRcdFx0XHRcdGR5ID0gY3VyWSAtIHByZXZZO1xuXHRcdFx0XHRcdFx0cGFydHMucHVzaChcblx0XHRcdFx0XHRcdFx0ICBkeCA9PT0gMCA/ICd2JyArIGYubnVtYmVyKGR5KVxuXHRcdFx0XHRcdFx0XHQ6IGR5ID09PSAwID8gJ2gnICsgZi5udW1iZXIoZHgpXG5cdFx0XHRcdFx0XHRcdDogJ2wnICsgZi5wYWlyKGR4LCBkeSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdjJyArIGYucGFpcihvdXRYIC0gcHJldlgsIG91dFkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0ICsgJyAnICsgZi5wYWlyKCBpblggLSBwcmV2WCwgIGluWSAtIHByZXZZKVxuXHRcdFx0XHRcdFx0XHQgKyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKCFsZW5ndGgpXG5cdFx0XHRyZXR1cm4gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzWzBdLCB0cnVlKTtcblx0XHRcdHBhcnRzLnB1c2goJ3onKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FkZDogZnVuY3Rpb24oc2VncywgaW5kZXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGFtb3VudCA9IHNlZ3MubGVuZ3RoLFxuXHRcdFx0YXBwZW5kID0gaW5kZXggPT0gbnVsbCxcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gc2VnbWVudHMubGVuZ3RoIDogaW5kZXg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3BhdGgpXG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdzW2ldID0gc2VnbWVudC5jbG9uZSgpO1xuXHRcdFx0c2VnbWVudC5fcGF0aCA9IHRoaXM7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb24pXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCAwLCBzZWdtZW50Ll9zZWxlY3Rpb24pO1xuXHRcdH1cblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRCYXNlLnB1c2goc2VnbWVudHMsIHNlZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWdtZW50cy5zcGxpY2UuYXBwbHkoc2VnbWVudHMsIFtpbmRleCwgMF0uY29uY2F0KHNlZ3MpKTtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIHRvdGFsID0gdGhpcy5fY291bnRDdXJ2ZXMoKSxcblx0XHRcdFx0c3RhcnQgPSBpbmRleCA+IDAgJiYgaW5kZXggKyBhbW91bnQgLSAxID09PSB0b3RhbCA/IGluZGV4IC0gMVxuXHRcdFx0XHRcdDogaW5kZXgsXG5cdFx0XHRcdGluc2VydCA9IHN0YXJ0LFxuXHRcdFx0XHRlbmQgPSBNYXRoLm1pbihzdGFydCArIGFtb3VudCwgdG90YWwpO1xuXHRcdFx0aWYgKHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW3N0YXJ0LCAwXS5jb25jYXQoc2Vncy5fY3VydmVzKSk7XG5cdFx0XHRcdGluc2VydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IGluc2VydDsgaSA8IGVuZDsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoc3RhcnQsIGVuZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoNDEpO1xuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdF9hZGp1c3RDdXJ2ZXM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGN1cnZlO1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGN1cnZlLl9wYXRoID0gdGhpcztcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RoaXMuX2Nsb3NlZCAmJiAhc3RhcnQgPyBzZWdtZW50cy5sZW5ndGggLSAxXG5cdFx0XHRcdDogc3RhcnQgLSAxXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbc3RhcnRdIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW2VuZF0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2VuZF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfY291bnRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuICF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbihzZWdtZW50MSApIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRyZXR1cm4gYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJncykpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmdzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRyZXR1cm4gYXJncy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJncywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJncywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50OiBmdW5jdGlvbihpbmRleCApIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChzZWdtZW50cykpO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbihpbmRleCwgc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMpLCBpbmRleCk7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihzdGFydCwgZW5kLCBfaW5jbHVkZUN1cnZlcykge1xuXHRcdHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0XHRlbmQgPSBCYXNlLnBpY2soZW5kLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCksXG5cdFx0XHRhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcblx0XHRpZiAoIWFtb3VudClcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb24pXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb24sIDApO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBzZWdtZW50Ll9wYXRoID0gbnVsbDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBzdGFydCA+IDAgJiYgZW5kID09PSBjb3VudCArICh0aGlzLl9jbG9zZWQgPyAxIDogMClcblx0XHRcdFx0XHQ/IHN0YXJ0IC0gMVxuXHRcdFx0XHRcdDogc3RhcnQsXG5cdFx0XHRcdGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cdFx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0XHRjdXJ2ZXNbaV0uX3BhdGggPSBudWxsO1xuXHRcdFx0aWYgKF9pbmNsdWRlQ3VydmVzKVxuXHRcdFx0XHRyZW1vdmVkLl9jdXJ2ZXMgPSBjdXJ2ZXMuc2xpY2UoMSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoaW5kZXgsIGluZGV4KTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCg0MSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlU2VnbWVudHMnLFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoc2VnbWVudHNbaV0uaGFzSGFuZGxlcygpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5jbGVhckhhbmRsZXMoKTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGxlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZWEgPSB0aGlzLl9hcmVhO1xuXHRcdGlmIChhcmVhID09IG51bGwpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cdFx0XHRhcmVhID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBsYXN0ID0gaSArIDEgPT09IGw7XG5cdFx0XHRcdGFyZWEgKz0gQ3VydmUuZ2V0QXJlYShDdXJ2ZS5nZXRWYWx1ZXMoXG5cdFx0XHRcdFx0XHRzZWdtZW50c1tpXSwgc2VnbWVudHNbbGFzdCA/IDAgOiBpICsgMV0sXG5cdFx0XHRcdFx0XHRudWxsLCBsYXN0ICYmICFjbG9zZWQpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FyZWEgPSBhcmVhO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJlYTtcblx0fSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXMuaXNTZWxlY3RlZCgpICYmIGxlbmd0aCA+IDAgJiYgdGhpcy5fc2VnbWVudFNlbGVjdGlvblxuXHRcdFx0XHQ9PT0gbGVuZ3RoICogNztcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuXHRcdGlmICghKHNlbGVjdGlvbiAmIDEpKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHMoZmFsc2UpO1xuXHRcdHNldFNlbGVjdGlvbi5iYXNlLmNhbGwodGhpcywgc2VsZWN0aW9uKTtcblx0fSxcblxuXHRfc2VsZWN0U2VnbWVudHM6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRzZWxlY3Rpb24gPSBzZWxlY3RlZCA/IDcgOiAwO1xuXHRcdHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gKiBsZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oc2VnbWVudCwgb2xkU2VsZWN0aW9uLCBuZXdTZWxlY3Rpb24pIHtcblx0XHRzZWdtZW50Ll9zZWxlY3Rpb24gPSBuZXdTZWxlY3Rpb247XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlZ21lbnRTZWxlY3Rpb24gKz0gbmV3U2VsZWN0aW9uIC0gb2xkU2VsZWN0aW9uO1xuXHRcdGlmIChzZWxlY3Rpb24gPiAwKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRkaXZpZGVBdDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KGxvY2F0aW9uKSxcblx0XHRcdGN1cnZlO1xuXHRcdHJldHVybiBsb2MgJiYgKGN1cnZlID0gbG9jLmdldEN1cnZlKCkuZGl2aWRlQXQobG9jLmdldEN1cnZlT2Zmc2V0KCkpKVxuXHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0c3BsaXRBdDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KGxvY2F0aW9uKSxcblx0XHRcdGluZGV4ID0gbG9jICYmIGxvYy5pbmRleCxcblx0XHRcdHRpbWUgPSBsb2MgJiYgbG9jLnRpbWUsXG5cdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAodGltZSA+IHRNYXgpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHR0aW1lID0gMDtcblx0XHR9XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0aWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBjdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGltZSA+PSB0TWluKSB7XG5cdFx0XHRcdGN1cnZlc1tpbmRleCsrXS5kaXZpZGVBdFRpbWUodGltZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGg7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcblx0XHRcdFx0cGF0aCA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0XHRwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0cGF0aC5fYWRkKHNlZ3MsIDApO1xuXHRcdFx0dGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihpbmRleCwgdGltZSkge1xuXHRcdHZhciBjdXJ2ZSxcblx0XHRcdGxvY2F0aW9uID0gdGltZSA9PT0gdW5kZWZpbmVkID8gaW5kZXhcblx0XHRcdFx0OiAoY3VydmUgPSB0aGlzLmdldEN1cnZlcygpW2luZGV4XSlcblx0XHRcdFx0XHQmJiBjdXJ2ZS5nZXRMb2NhdGlvbkF0VGltZSh0aW1lKTtcblx0XHRyZXR1cm4gbG9jYXRpb24gIT0gbnVsbCA/IHRoaXMuc3BsaXRBdChsb2NhdGlvbikgOiBudWxsO1xuXHR9LFxuXG5cdGpvaW46IGZ1bmN0aW9uKHBhdGgsIHRvbGVyYW5jZSkge1xuXHRcdHZhciBlcHNpbG9uID0gdG9sZXJhbmNlIHx8IDA7XG5cdFx0aWYgKHBhdGggJiYgcGF0aCAhPT0gdGhpcykge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRcdGxhc3QxID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpLFxuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdGlmICghbGFzdDIpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5pc0Nsb3NlKGxhc3QyLl9wb2ludCwgZXBzaWxvbikpXG5cdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0dmFyIGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmlzQ2xvc2UoZmlyc3QyLl9wb2ludCwgZXBzaWxvbikpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuaXNDbG9zZShmaXJzdDIuX3BvaW50LCBlcHNpbG9uKSlcblx0XHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5pc0Nsb3NlKGxhc3QyLl9wb2ludCwgZXBzaWxvbikpIHtcblx0XHRcdFx0XHRmaXJzdDEuc2V0SGFuZGxlSW4obGFzdDIuX2hhbmRsZUluKTtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5pc0Nsb3NlKGxhc3QuX3BvaW50LCBlcHNpbG9uKSkge1xuXHRcdFx0Zmlyc3Quc2V0SGFuZGxlSW4obGFzdC5faGFuZGxlSW4pO1xuXHRcdFx0bGFzdC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdHNpbXBsaWZ5ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbXBsaWZ5LFxuXHRcdFx0dG9sZXJhbmNlID0gc2ltcGxpZnkgPyAxZS03IDogMDtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoIWN1cnZlLmhhc0hhbmRsZXMoKSAmJiAoIWN1cnZlLmhhc0xlbmd0aCh0b2xlcmFuY2UpXG5cdFx0XHRcdFx0fHwgc2ltcGxpZnkgJiYgY3VydmUuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TmV4dCgpKSkpXG5cdFx0XHRcdGN1cnZlLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50cy5yZXZlcnNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZUluID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0c2VnbWVudC5faGFuZGxlT3V0ID0gaGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnZlcyA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbihmbGF0bmVzcykge1xuXHRcdHZhciBmbGF0dGVuZXIgPSBuZXcgUGF0aEZsYXR0ZW5lcih0aGlzLCBmbGF0bmVzcyB8fCAwLjI1LCAyNTYsIHRydWUpLFxuXHRcdFx0cGFydHMgPSBmbGF0dGVuZXIucGFydHMsXG5cdFx0XHRsZW5ndGggPSBwYXJ0cy5sZW5ndGgsXG5cdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocGFydHNbaV0uY3VydmUuc2xpY2UoMCwgMikpKTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwYXJ0c1tsZW5ndGggLSAxXS5jdXJ2ZS5zbGljZSg2KSkpO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0fSxcblxuXHRzaW1wbGlmeTogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IFBhdGhGaXR0ZXIodGhpcykuZml0KHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdGlmIChzZWdtZW50cylcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdHJldHVybiAhIXNlZ21lbnRzO1xuXHR9LFxuXG5cdHNtb290aDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdHMgPSBvcHRpb25zIHx8IHt9LFxuXHRcdFx0dHlwZSA9IG9wdHMudHlwZSB8fCAnYXN5bW1ldHJpYycsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SW5kZXgodmFsdWUsIF9kZWZhdWx0KSB7XG5cdFx0XHR2YXIgaW5kZXggPSB2YWx1ZSAmJiB2YWx1ZS5pbmRleDtcblx0XHRcdGlmIChpbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gdmFsdWUucGF0aDtcblx0XHRcdFx0aWYgKHBhdGggJiYgcGF0aCAhPT0gdGhhdClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IodmFsdWUuX2NsYXNzICsgJyAnICsgaW5kZXggKyAnIG9mICcgKyBwYXRoXG5cdFx0XHRcdFx0XHRcdCsgJyBpcyBub3QgcGFydCBvZiAnICsgdGhhdCk7XG5cdFx0XHRcdGlmIChfZGVmYXVsdCAmJiB2YWx1ZSBpbnN0YW5jZW9mIEN1cnZlKVxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbmRleCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IF9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1hdGgubWluKGluZGV4IDwgMCAmJiBjbG9zZWRcblx0XHRcdFx0XHQ/IGluZGV4ICUgbGVuZ3RoXG5cdFx0XHRcdFx0OiBpbmRleCA8IDAgPyBpbmRleCArIGxlbmd0aCA6IGluZGV4LCBsZW5ndGggLSAxKTtcblx0XHR9XG5cblx0XHR2YXIgbG9vcCA9IGNsb3NlZCAmJiBvcHRzLmZyb20gPT09IHVuZGVmaW5lZCAmJiBvcHRzLnRvID09PSB1bmRlZmluZWQsXG5cdFx0XHRmcm9tID0gZ2V0SW5kZXgob3B0cy5mcm9tLCAwKSxcblx0XHRcdHRvID0gZ2V0SW5kZXgob3B0cy50bywgbGVuZ3RoIC0gMSk7XG5cblx0XHRpZiAoZnJvbSA+IHRvKSB7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZyb20gLT0gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRtcCA9IGZyb207XG5cdFx0XHRcdGZyb20gPSB0bztcblx0XHRcdFx0dG8gPSB0bXA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICgvXig/OmFzeW1tZXRyaWN8Y29udGludW91cykkLy50ZXN0KHR5cGUpKSB7XG5cdFx0XHR2YXIgYXN5bW1ldHJpYyA9IHR5cGUgPT09ICdhc3ltbWV0cmljJyxcblx0XHRcdFx0bWluID0gTWF0aC5taW4sXG5cdFx0XHRcdGFtb3VudCA9IHRvIC0gZnJvbSArIDEsXG5cdFx0XHRcdG4gPSBhbW91bnQgLSAxLFxuXHRcdFx0XHRwYWRkaW5nID0gbG9vcCA/IG1pbihhbW91bnQsIDQpIDogMSxcblx0XHRcdFx0cGFkZGluZ0xlZnQgPSBwYWRkaW5nLFxuXHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBwYWRkaW5nLFxuXHRcdFx0XHRrbm90cyA9IFtdO1xuXHRcdFx0aWYgKCFjbG9zZWQpIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQgPSBtaW4oMSwgZnJvbSk7XG5cdFx0XHRcdHBhZGRpbmdSaWdodCA9IG1pbigxLCBsZW5ndGggLSB0byAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0biArPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcblx0XHRcdGlmIChuIDw9IDEpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gZnJvbSAtIHBhZGRpbmdMZWZ0OyBpIDw9IG47IGkrKywgaisrKSB7XG5cdFx0XHRcdGtub3RzW2ldID0gc2VnbWVudHNbKGogPCAwID8gaiArIGxlbmd0aCA6IGopICUgbGVuZ3RoXS5fcG9pbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3gsXG5cdFx0XHRcdHkgPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feSxcblx0XHRcdFx0ZiA9IDIsXG5cdFx0XHRcdG5fMSA9IG4gLSAxLFxuXHRcdFx0XHRyeCA9IFt4XSxcblx0XHRcdFx0cnkgPSBbeV0sXG5cdFx0XHRcdHJmID0gW2ZdLFxuXHRcdFx0XHRweCA9IFtdLFxuXHRcdFx0XHRweSA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGludGVybmFsID0gaSA8IG5fMSxcblx0XHRcdFx0XHRhID0gaW50ZXJuYWwgPyAxIDogYXN5bW1ldHJpYyA/IDEgOiAyLFxuXHRcdFx0XHRcdGIgPSBpbnRlcm5hbCA/IDQgOiBhc3ltbWV0cmljID8gMiA6IDcsXG5cdFx0XHRcdFx0dSA9IGludGVybmFsID8gNCA6IGFzeW1tZXRyaWMgPyAzIDogOCxcblx0XHRcdFx0XHR2ID0gaW50ZXJuYWwgPyAyIDogYXN5bW1ldHJpYyA/IDAgOiAxLFxuXHRcdFx0XHRcdG0gPSBhIC8gZjtcblx0XHRcdFx0ZiA9IHJmW2ldID0gYiAtIG07XG5cdFx0XHRcdHggPSByeFtpXSA9IHUgKiBrbm90c1tpXS5feCArIHYgKiBrbm90c1tpICsgMV0uX3ggLSBtICogeDtcblx0XHRcdFx0eSA9IHJ5W2ldID0gdSAqIGtub3RzW2ldLl95ICsgdiAqIGtub3RzW2kgKyAxXS5feSAtIG0gKiB5O1xuXHRcdFx0fVxuXG5cdFx0XHRweFtuXzFdID0gcnhbbl8xXSAvIHJmW25fMV07XG5cdFx0XHRweVtuXzFdID0gcnlbbl8xXSAvIHJmW25fMV07XG5cdFx0XHRmb3IgKHZhciBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHB4W2ldID0gKHJ4W2ldIC0gcHhbaSArIDFdKSAvIHJmW2ldO1xuXHRcdFx0XHRweVtpXSA9IChyeVtpXSAtIHB5W2kgKyAxXSkgLyByZltpXTtcblx0XHRcdH1cblx0XHRcdHB4W25dID0gKDMgKiBrbm90c1tuXS5feCAtIHB4W25fMV0pIC8gMjtcblx0XHRcdHB5W25dID0gKDMgKiBrbm90c1tuXS5feSAtIHB5W25fMV0pIC8gMjtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IHBhZGRpbmdMZWZ0LCBtYXggPSBuIC0gcGFkZGluZ1JpZ2h0LCBqID0gZnJvbTtcblx0XHRcdFx0XHRpIDw9IG1heDsgaSsrLCBqKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tqIDwgMCA/IGogKyBsZW5ndGggOiBqXSxcblx0XHRcdFx0XHRwdCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0XHRcdGh4ID0gcHhbaV0gLSBwdC5feCxcblx0XHRcdFx0XHRoeSA9IHB5W2ldIC0gcHQuX3k7XG5cdFx0XHRcdGlmIChsb29wIHx8IGkgPCBtYXgpXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVPdXQoaHgsIGh5KTtcblx0XHRcdFx0aWYgKGxvb3AgfHwgaSA+IHBhZGRpbmdMZWZ0KVxuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oLWh4LCAtaHkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG5cdFx0XHRcdHNlZ21lbnRzW2kgPCAwID8gaSArIGxlbmd0aCA6IGldLnNtb290aChvcHRzLFxuXHRcdFx0XHRcdFx0IWxvb3AgJiYgaSA9PT0gZnJvbSwgIWxvb3AgJiYgaSA9PT0gdG8pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHR0b1NoYXBlOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRpZiAoIXRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHJhZGl1cyxcblx0XHRcdHRvcENlbnRlcjtcblxuXHRcdGZ1bmN0aW9uIGlzQ29sbGluZWFyKGksIGopIHtcblx0XHRcdHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzIgPSBzZWcxLmdldE5leHQoKSxcblx0XHRcdFx0c2VnMyA9IHNlZ21lbnRzW2pdLFxuXHRcdFx0XHRzZWc0ID0gc2VnMy5nZXROZXh0KCk7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMy5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzQ29sbGluZWFyKFxuXHRcdFx0XHRcdFx0c2VnNC5fcG9pbnQuc3VidHJhY3Qoc2VnMy5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuXHRcdFx0dmFyIHNlZzIgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMSA9IHNlZzIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdFx0c2VnMyA9IHNlZzIuZ2V0TmV4dCgpO1xuXHRcdFx0cmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc09ydGhvZ29uYWwoXG5cdFx0XHRcdFx0XHRzZWczLl9wb2ludC5zdWJ0cmFjdChzZWcyLl9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQXJjKGkpIHtcblx0XHRcdHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzIgPSBzZWcxLmdldE5leHQoKSxcblx0XHRcdFx0aGFuZGxlMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0aGFuZGxlMiA9IHNlZzIuX2hhbmRsZUluLFxuXHRcdFx0XHRrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblx0XHRcdGlmIChoYW5kbGUxLmlzT3J0aG9nb25hbChoYW5kbGUyKSkge1xuXHRcdFx0XHR2YXIgcHQxID0gc2VnMS5fcG9pbnQsXG5cdFx0XHRcdFx0cHQyID0gc2VnMi5fcG9pbnQsXG5cdFx0XHRcdFx0Y29ybmVyID0gbmV3IExpbmUocHQxLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRcdG5ldyBMaW5lKHB0MiwgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQxKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHRcdCYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQyKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0hhbmRsZXMoKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNDb2xsaW5lYXIoMCwgMikgJiYgaXNDb2xsaW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29sbGluZWFyKDEsIDUpICYmIGlzQ29sbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gbmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdHNoYXBlLmNvcHlBdHRyaWJ1dGVzKHRoaXMsIHRydWUpO1xuXHRcdFx0c2hhcGUuX21hdHJpeC5wcmVwZW5kKHRoaXMuX21hdHJpeCk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpXG5cdFx0XHRcdHNoYXBlLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHR0b1BhdGg6ICcjY2xvbmUnLFxuXG5cdGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocGF0aCkge1xuXHRcdGlmICghcGF0aCB8fCBwYXRoIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIGNvbXBhcmUuYmFzZS5jYWxsKHRoaXMsIHBhdGgpO1xuXHRcdHZhciBjdXJ2ZXMxID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGN1cnZlczIgPSBwYXRoLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoMiA9IGN1cnZlczIubGVuZ3RoO1xuXHRcdGlmICghbGVuZ3RoMSB8fCAhbGVuZ3RoMikge1xuXHRcdFx0cmV0dXJuIGxlbmd0aDEgPT0gbGVuZ3RoMjtcblx0XHR9XG5cdFx0dmFyIHYxID0gY3VydmVzMVswXS5nZXRWYWx1ZXMoKSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdHBvczEgPSAwLCBwb3MyLFxuXHRcdFx0ZW5kMSA9IDAsIGVuZDI7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcblx0XHRcdHZhciB2MiA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKCk7XG5cdFx0XHR2YWx1ZXMyLnB1c2godjIpO1xuXHRcdFx0dmFyIG92ZXJsYXBzID0gQ3VydmUuZ2V0T3ZlcmxhcHModjEsIHYyKTtcblx0XHRcdGlmIChvdmVybGFwcykge1xuXHRcdFx0XHRwb3MyID0gIWkgJiYgb3ZlcmxhcHNbMF1bMF0gPiAwID8gbGVuZ3RoMiAtIDEgOiBpO1xuXHRcdFx0XHRlbmQyID0gb3ZlcmxhcHNbMF1bMV07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRlcHNpbG9uID0gMWUtOCxcblx0XHRcdHYyID0gdmFsdWVzMltwb3MyXSxcblx0XHRcdHN0YXJ0Mjtcblx0XHR3aGlsZSAodjEgJiYgdjIpIHtcblx0XHRcdHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cdFx0XHRpZiAob3ZlcmxhcHMpIHtcblx0XHRcdFx0dmFyIHQxID0gb3ZlcmxhcHNbMF1bMF07XG5cdFx0XHRcdGlmIChhYnModDEgLSBlbmQxKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHRlbmQxID0gb3ZlcmxhcHNbMV1bMF07XG5cdFx0XHRcdFx0aWYgKGVuZDEgPT09IDEpIHtcblx0XHRcdFx0XHRcdHYxID0gKytwb3MxIDwgbGVuZ3RoMSA/IGN1cnZlczFbcG9zMV0uZ2V0VmFsdWVzKCkgOiBudWxsO1xuXHRcdFx0XHRcdFx0ZW5kMSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0MiA9IG92ZXJsYXBzWzBdWzFdO1xuXHRcdFx0XHRcdGlmIChhYnModDIgLSBlbmQyKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHRcdGlmICghc3RhcnQyKVxuXHRcdFx0XHRcdFx0XHRzdGFydDIgPSBbcG9zMiwgdDJdO1xuXHRcdFx0XHRcdFx0ZW5kMiA9IG92ZXJsYXBzWzFdWzFdO1xuXHRcdFx0XHRcdFx0aWYgKGVuZDIgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCsrcG9zMiA+PSBsZW5ndGgyKVxuXHRcdFx0XHRcdFx0XHRcdHBvczIgPSAwO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlczJbcG9zMl0gfHwgY3VydmVzMltwb3MyXS5nZXRWYWx1ZXMoKTtcblx0XHRcdFx0XHRcdFx0ZW5kMiA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXYxKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzdGFydDJbMF0gPT09IHBvczIgJiYgc3RhcnQyWzFdID09PSBlbmQyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCxcblx0XHRcdGFyZWEsIGxvYywgcmVzLFxuXHRcdFx0aGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhpdEN1cnZlcyA9IG9wdGlvbnMuY3VydmVzLFxuXHRcdFx0c3Ryb2tlUmFkaXVzID0gaGl0U3Ryb2tlXG5cdFx0XHRcdFx0PyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuXHRcdFx0XHRcdDogaGl0RmlsbCAmJiBvcHRpb25zLnRvbGVyYW5jZSA+IDAgfHwgaGl0Q3VydmVzXG5cdFx0XHRcdFx0XHQ/IDAgOiBudWxsO1xuXHRcdGlmIChzdHJva2VSYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG5cdFx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG5cdFx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuXHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRzdHJva2VQYWRkaW5nID0gc3Ryb2tlUGFkZGluZy5hZGQoXG5cdFx0XHRcdFx0UGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsIHN0cm9rZU1hdHJpeCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0am9pbiA9IGNhcCA9ICdyb3VuZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDbG9zZUVub3VnaChwdCwgcGFkZGluZykge1xuXHRcdFx0cmV0dXJuIHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuXHRcdFx0aWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2VnLl9wb2ludDtcblx0XHRcdFx0aWYgKHB0ICE9PSBhbmNob3IpXG5cdFx0XHRcdFx0cHQgPSBwdC5hZGQoYW5jaG9yKTtcblx0XHRcdFx0aWYgKGlzQ2xvc2VFbm91Z2gocHQsIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQobmFtZSwgdGhhdCwge1xuXHRcdFx0XHRcdFx0c2VnbWVudDogc2VnLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludHMoc2VnLCBlbmRzKSB7XG5cdFx0XHRyZXR1cm4gKGVuZHMgfHwgb3B0aW9ucy5zZWdtZW50cylcblx0XHRcdFx0JiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpXG5cdFx0XHRcdHx8ICghZW5kcyAmJiBvcHRpb25zLmhhbmRsZXMpICYmIChcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVPdXQsICdoYW5kbGUtb3V0JykpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuXHRcdFx0YXJlYS5hZGQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSB7XG5cdFx0XHR2YXIgaXNKb2luID0gY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMFxuXHRcdFx0XHRcdCYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxO1xuXHRcdFx0aWYgKChpc0pvaW4gPyBqb2luIDogY2FwKSA9PT0gJ3JvdW5kJykge1xuXHRcdFx0XHRyZXR1cm4gaXNDbG9zZUVub3VnaChzZWdtZW50Ll9wb2ludCwgc3Ryb2tlUGFkZGluZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcmVhID0gbmV3IFBhdGgoeyBpbnRlcm5hbDogdHJ1ZSwgY2xvc2VkOiB0cnVlIH0pO1xuXHRcdFx0XHRpZiAoaXNKb2luKSB7XG5cdFx0XHRcdFx0aWYgKCFzZWdtZW50LmlzU21vb3RoKCkpIHtcblx0XHRcdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCBzdHJva2VSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdCAgIG1pdGVyTGltaXQsIG51bGwsIHN0cm9rZU1hdHJpeCwgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2FwID09PSAnc3F1YXJlJykge1xuXHRcdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHN0cm9rZVJhZGl1cywgbnVsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LCBhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYXJlYS5pc0VtcHR5KCkpIHtcblx0XHRcdFx0XHR2YXIgbG9jO1xuXHRcdFx0XHRcdHJldHVybiBhcmVhLmNvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHRcdFx0fHwgKGxvYyA9IGFyZWEuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KSlcblx0XHRcdFx0XHRcdFx0JiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5lbmRzICYmICFvcHRpb25zLnNlZ21lbnRzICYmICFjbG9zZWQpIHtcblx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbMF0sIHRydWUpXG5cdFx0XHRcdFx0fHwgY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0sIHRydWUpKVxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5zZWdtZW50cyB8fCBvcHRpb25zLmhhbmRsZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKylcblx0XHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0aWYgKHN0cm9rZVJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0bG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYykge1xuXHRcdFx0XHR2YXIgdGltZSA9IGxvYy5nZXRUaW1lKCk7XG5cdFx0XHRcdGlmICh0aW1lID09PSAwIHx8IHRpbWUgPT09IDEgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja1NlZ21lbnRTdHJva2UobG9jLmdldFNlZ21lbnQoKSkpXG5cdFx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbG9jICYmIGpvaW4gPT09ICdtaXRlcicgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmdldERpc3RhbmNlKHNlZ21lbnQuX3BvaW50KVxuXHRcdFx0XHRcdFx0XHQ8PSBtaXRlckxpbWl0ICogc3Ryb2tlUmFkaXVzXG5cdFx0XHRcdFx0XHRcdCYmIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSkge1xuXHRcdFx0XHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhbG9jICYmIGhpdEZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdHx8IGxvYyAmJiAhaGl0U3Ryb2tlICYmICFoaXRDdXJ2ZXNcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKVxuXHRcdFx0XHRcdDogbG9jXG5cdFx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnY3VydmUnLCB0aGlzLCB7XG5cdFx0XHRcdFx0XHRcdGxvY2F0aW9uOiBsb2MsXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBsb2MuZ2V0UG9pbnQoKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0fVxuXG59LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gbG9jICYmIGxvY1tuYW1lXSgpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcblx0XHRcdGlmIChsb2MpXG5cdFx0XHRcdHJldHVybiBsb2M7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0aWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBsZW5ndGgsXG5cdFx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRcdGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0aWYgKGxlbmd0aCA+IG9mZnNldCkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnZlcy5sZW5ndGggPiAwICYmIG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdLCAxKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG9mZnNldCAmJiBvZmZzZXQuZ2V0UGF0aCAmJiBvZmZzZXQuZ2V0UGF0aCgpID09PSB0aGlzKSB7XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRzV2l0aFRhbmdlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0YW5nZW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0YW5nZW50LmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldHMgPSBbXTtcblx0XHR2YXIgY3VydmVTdGFydCA9IDA7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHR2YXIgY3VydmVUaW1lcyA9IGN1cnZlLmdldFRpbWVzV2l0aFRhbmdlbnQodGFuZ2VudCk7XG5cdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IGN1cnZlVGltZXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBjdXJ2ZVN0YXJ0ICsgY3VydmUuZ2V0T2Zmc2V0QXRUaW1lKGN1cnZlVGltZXNbal0pO1xuXHRcdFx0XHRpZiAob2Zmc2V0cy5pbmRleE9mKG9mZnNldCkgPCAwKSB7XG5cdFx0XHRcdFx0b2Zmc2V0cy5wdXNoKG9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN1cnZlU3RhcnQgKz0gY3VydmUubGVuZ3RoO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0cztcblx0fVxufSksXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0aWYgKHNpemUgPD0gMCkgcmV0dXJuO1xuXG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMixcblx0XHRcdG1pbmlTaXplID0gc2l6ZSAtIDIsXG5cdFx0XHRtaW5pSGFsZiA9IGhhbGYgLSAxLFxuXHRcdFx0Y29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cFgsIHBZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuXHRcdFx0dmFyIGhYID0gY29vcmRzW2luZGV4XSxcblx0XHRcdFx0aFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblx0XHRcdGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocFgsIHBZKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhoWCwgaFkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VsZWN0aW9uID0gc2VnbWVudC5fc2VsZWN0aW9uO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXHRcdFx0cFggPSBjb29yZHNbMF07XG5cdFx0XHRwWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChzZWxlY3Rpb24gJiAyKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDIpO1xuXHRcdFx0aWYgKHNlbGVjdGlvbiAmIDQpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKG1pbmlTaXplID4gMCAmJiAhKHNlbGVjdGlvbiAmIDEpKSB7XG5cdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QocFggLSBtaW5pSGFsZiwgcFkgLSBtaW5pSGFsZiwgbWluaVNpemUsIG1pbmlTaXplKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3U2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdFx0Y3VyWCA9IGNvb3Jkc1swXTtcblx0XHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50O1xuXHRcdFx0XHRjdXJYID0gcG9pbnQuX3g7XG5cdFx0XHRcdGN1clkgPSBwb2ludC5feTtcblx0XHRcdH1cblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdGluWCA9IGNvb3Jkc1syXTtcblx0XHRcdFx0XHRpblkgPSBjb29yZHNbM107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0XHRcdGluWCA9IGN1clggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdFx0aW5ZID0gY3VyWSArIGhhbmRsZS5feTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWVxuXHRcdFx0XHRcdFx0JiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKG91dFgsIG91dFksIGluWCwgaW5ZLCBjdXJYLCBjdXJZKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRvdXRYID0gY29vcmRzWzRdO1xuXHRcdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdFx0b3V0WCA9IHByZXZYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRvdXRZID0gcHJldlkgKyBoYW5kbGUuX3k7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAocGF0aC5fY2xvc2VkICYmIGxlbmd0aCA+IDApXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1swXSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHRcdHZhciBkb250U3RhcnQgPSBwYXJhbS5kb250U3RhcnQsXG5cdFx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRcdGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0XHRkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0ZGFzaExlbmd0aCA9ICFwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2ggJiYgaGFzU3Ryb2tlXG5cdFx0XHRcdFx0XHQmJiBkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aDtcblxuXHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0aWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlICYmICFkYXNoTGVuZ3RoIHx8IGRvbnRQYWludCkge1xuXHRcdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcblx0XHRcdFx0cmV0dXJuIGRhc2hBcnJheVsoKGkgJSBkYXNoTGVuZ3RoKSArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuXHRcdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFzU3Ryb2tlKSB7XG5cdFx0XHRcdFx0aWYgKGRhc2hMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHR2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcywgMC4yNSwgMzIsIGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeCksXG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IGZsYXR0ZW5lci5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0ZmxhdHRlbmVyLmRyYXdQYXJ0KGN0eCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG5cdFx0XHRcdFx0XHRcdGZyb20gPSB0byArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIG1hdHJpeCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRkcmF3SGFuZGxlcyhjdHgsIHRoaXMuX3NlZ21lbnRzLCBtYXRyaXgsIHBhcGVyLnNldHRpbmdzLmhhbmRsZVNpemUpO1xuXHRcdH1cblx0fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0aGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0aGFuZGxlLmFkZCh0by5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdHRvXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHR0aHJvdWdoID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHR0ID0gQmFzZS5waWNrKEJhc2UucmVhZChhcmdzKSwgMC41KSxcblx0XHRcdFx0dDEgPSAxIC0gdCxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0aGFuZGxlID0gdGhyb3VnaC5zdWJ0cmFjdChjdXJyZW50Lm11bHRpcGx5KHQxICogdDEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdCh0by5tdWx0aXBseSh0ICogdCkpLmRpdmlkZSgyICogdCAqIHQxKTtcblx0XHRcdGlmIChoYW5kbGUuaXNOYU4oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdDYW5ub3QgcHV0IGEgY3VydmUgdGhyb3VnaCBwb2ludHMgd2l0aCBwYXJhbWV0ZXIgPSAnICsgdCk7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlLCB0byk7XG5cdFx0fSxcblxuXHRcdGFyY1RvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dGhyb3VnaCxcblx0XHRcdFx0cGVlayA9IEJhc2UucGVlayhhcmdzKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKHBlZWssIHRydWUpLFxuXHRcdFx0XHRjZW50ZXIsIGV4dGVudCwgdmVjdG9yLCBtYXRyaXg7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHR0aHJvdWdoID0gbWlkZGxlLmFkZChtaWRkbGUuc3VidHJhY3QoZnJvbSkucm90YXRlKFxuXHRcdFx0XHRcdFx0Y2xvY2t3aXNlID8gLTkwIDogOTApKTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5yZW1haW4oYXJncykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKTtcblx0XHRcdH0gZWxzZSBpZiAoIWZyb20uZXF1YWxzKHRvKSkge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRcdGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0XHRcdGlmIChpc1plcm8ocmFkaXVzLndpZHRoKSB8fCBpc1plcm8ocmFkaXVzLmhlaWdodCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gQmFzZS5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRcdGxhcmdlID0gISFCYXNlLnJlYWQoYXJncyksXG5cdFx0XHRcdFx0bWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRwdCA9IGZyb20uc3VidHJhY3QobWlkZGxlKS5yb3RhdGUoLXJvdGF0aW9uKSxcblx0XHRcdFx0XHR4ID0gcHQueCxcblx0XHRcdFx0XHR5ID0gcHQueSxcblx0XHRcdFx0XHRyeCA9IGFicyhyYWRpdXMud2lkdGgpLFxuXHRcdFx0XHRcdHJ5ID0gYWJzKHJhZGl1cy5oZWlnaHQpLFxuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4LFxuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5LFxuXHRcdFx0XHRcdHhTcSA9IHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9IHkgKiB5O1xuXHRcdFx0XHR2YXIgZmFjdG9yID0gc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgMWUtMTIpXG5cdFx0XHRcdFx0ZmFjdG9yID0gMDtcblx0XHRcdFx0aWYgKGZhY3RvciA8IDApXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdGNlbnRlciA9IG5ldyBQb2ludChyeCAqIHkgLyByeSwgLXJ5ICogeCAvIHJ4KVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KChsYXJnZSA9PT0gY2xvY2t3aXNlID8gLTEgOiAxKSAqIHNxcnQoZmFjdG9yKSlcblx0XHRcdFx0XHRcdC5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikucm90YXRlKHJvdGF0aW9uKVxuXHRcdFx0XHRcdFx0LnNjYWxlKHJ4LCByeSk7XG5cdFx0XHRcdHZlY3RvciA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShmcm9tKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG5cdFx0XHRcdGlmICghY2xvY2t3aXNlICYmIGV4dGVudCA+IDApXG5cdFx0XHRcdFx0ZXh0ZW50IC09IDM2MDtcblx0XHRcdFx0ZWxzZSBpZiAoY2xvY2t3aXNlICYmIGV4dGVudCA8IDApXG5cdFx0XHRcdFx0ZXh0ZW50ICs9IDM2MDtcblx0XHRcdH1cblx0XHRcdGlmICh0aHJvdWdoKSB7XG5cdFx0XHRcdHZhciBsMSA9IG5ldyBMaW5lKGZyb20uYWRkKHRocm91Z2gpLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dGhyb3VnaC5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsMiA9IG5ldyBMaW5lKHRocm91Z2guYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRvLnN1YnRyYWN0KHRocm91Z2gpLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byksXG5cdFx0XHRcdFx0dGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG5cdFx0XHRcdGNlbnRlciA9IGwxLmludGVyc2VjdChsMiwgdHJ1ZSk7XG5cdFx0XHRcdGlmICghY2VudGVyKSB7XG5cdFx0XHRcdFx0aWYgKCF0aHJvdWdoU2lkZSlcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZSh0by5zdWJ0cmFjdChjZW50ZXIpKTtcblx0XHRcdFx0dmFyIGNlbnRlclNpZGUgPSBsaW5lLmdldFNpZGUoY2VudGVyLCB0cnVlKTtcblx0XHRcdFx0aWYgKGNlbnRlclNpZGUgPT09IDApIHtcblx0XHRcdFx0XHRleHRlbnQgPSB0aHJvdWdoU2lkZSAqIGFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXh0ZW50KSB7XG5cdFx0XHRcdHZhciBlcHNpbG9uID0gMWUtNyxcblx0XHRcdFx0XHRleHQgPSBhYnMoZXh0ZW50KSxcblx0XHRcdFx0XHRjb3VudCA9IGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKChleHQgLSBlcHNpbG9uKSAvIDkwKSxcblx0XHRcdFx0XHRpbmMgPSBleHRlbnQgLyBjb3VudCxcblx0XHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0XHR6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcHQgPSB0byxcblx0XHRcdFx0XHRcdG91dCA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdFx0b3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0XHRvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSlcblx0XHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0XHRfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSlcblx0XHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bGluZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGN1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmdzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLFxuXHRcdFx0XHRcdGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGhhbmRsZSA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3MpKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmdzKSwgdHJ1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3MpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdHRoaXMuam9pbih0aGlzLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgbWV0aG9kID0gb3B0aW9ucy5oYW5kbGVcblx0XHRcdFx0PyAnZ2V0SGFuZGxlQm91bmRzJ1xuXHRcdFx0XHQ6IG9wdGlvbnMuc3Ryb2tlXG5cdFx0XHRcdD8gJ2dldFN0cm9rZUJvdW5kcydcblx0XHRcdFx0OiAnZ2V0Qm91bmRzJztcblx0XHRyZXR1cm4gUGF0aFttZXRob2RdKHRoaXMuX3NlZ21lbnRzLCB0aGlzLl9jbG9zZWQsIHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSksXG5cdFx0XHRtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IG5ldyBBcnJheSgyKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdEN1cnZlLl9hZGRCb3VuZHMoXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpXSxcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSxcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpXSxcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0eWxlID0gcGF0aC5nZXRTdHlsZSgpLFxuXHRcdFx0c3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCksXG5cdFx0XHRzdHJva2VNYXRyaXggPSBzdHJva2UgJiYgcGF0aC5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gc3Ryb2tlICYmIFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdHN0cm9rZU1hdHJpeCksXG5cdFx0XHRib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcpO1xuXHRcdGlmICghc3Ryb2tlKVxuXHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3Ryb2tlV2lkdGggLyAyLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKSxcblx0XHRcdGpvaW5Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBTaXplKHN0cm9rZVBhZGRpbmcpKTtcblxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKFxuXHRcdFx0XHRcdGpvaW5Cb3VuZHMuc2V0Q2VudGVyKHNlZ21lbnQuX3BvaW50LnRyYW5zZm9ybShtYXRyaXgpKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkSm9pbihzZWdtZW50LCBqb2luKSB7XG5cdFx0XHRpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCBzZWdtZW50LmlzU21vb3RoKCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLCBtaXRlckxpbWl0LFxuXHRcdFx0XHRcdFx0bWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgc3Ryb2tlUmFkaXVzLCBtYXRyaXgsXG5cdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKTtcblx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0YWRkSm9pbihzZWdtZW50c1swXSwgam9pbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRDYXAoc2VnbWVudHNbMF0sIGNhcCk7XG5cdFx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0U3Ryb2tlUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBob3IgPSBuZXcgUG9pbnQocmFkaXVzLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHZlciA9IG5ldyBQb2ludCgwLCByYWRpdXMpLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSBNYXRoLmF0YW4yKGIgKiB0YW4sIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4yKGIsIHRhbiAqIGEpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyArIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgbWF0cml4LFxuXHRcdFx0c3Ryb2tlTWF0cml4LCBhZGRQb2ludCwgaXNBcmVhKSB7XG5cdFx0dmFyIGN1cnZlMiA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdGN1cnZlMSA9IGN1cnZlMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0cG9pbnQgPSBjdXJ2ZTIuZ2V0UG9pbnQxKCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0VGltZSgxKS5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHRcdC50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXRUaW1lKDApLm11bHRpcGx5KHJhZGl1cylcblx0XHRcdFx0LnRyYW5zZm9ybShzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRhbmdsZSA9IG5vcm1hbDEuZ2V0RGlyZWN0ZWRBbmdsZShub3JtYWwyKTtcblx0XHRpZiAoYW5nbGUgPCAwIHx8IGFuZ2xlID49IDE4MCkge1xuXHRcdFx0bm9ybWFsMSA9IG5vcm1hbDEubmVnYXRlKCk7XG5cdFx0XHRub3JtYWwyID0gbm9ybWFsMi5uZWdhdGUoKTtcblx0XHR9XG5cdFx0aWYgKGlzQXJlYSlcblx0XHRcdGFkZFBvaW50KHBvaW50KTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMSkpO1xuXHRcdGlmIChqb2luID09PSAnbWl0ZXInKSB7XG5cdFx0XHR2YXIgY29ybmVyID0gbmV3IExpbmUocG9pbnQuYWRkKG5vcm1hbDEpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlXG5cdFx0XHRcdCkuaW50ZXJzZWN0KG5ldyBMaW5lKHBvaW50LmFkZChub3JtYWwyKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuXHRcdFx0XHQpLCB0cnVlKTtcblx0XHRcdGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0ICogcmFkaXVzKSB7XG5cdFx0XHRcdGFkZFBvaW50KGNvcm5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwyKSk7XG5cdH0sXG5cblx0X2FkZFNxdWFyZUNhcDogZnVuY3Rpb24oc2VnbWVudCwgY2FwLCByYWRpdXMsIG1hdHJpeCwgc3Ryb2tlTWF0cml4LFxuXHRcdFx0YWRkUG9pbnQsIGlzQXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpXG5cdFx0XHRcdFx0Lm11bHRpcGx5KGxvYy5nZXRUaW1lKCkgPT09IDAgPyByYWRpdXMgOiAtcmFkaXVzKVxuXHRcdFx0XHRcdC50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KTtcblx0XHRpZiAoY2FwID09PSAnc3F1YXJlJykge1xuXHRcdFx0aWYgKGlzQXJlYSkge1xuXHRcdFx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0XHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZSgtOTApKTtcblx0XHR9XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0eWxlID0gcGF0aC5nZXRTdHlsZSgpLFxuXHRcdFx0c3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRzdHJva2VQYWRkaW5nLFxuXHRcdFx0am9pblBhZGRpbmc7XG5cdFx0aWYgKHN0cm9rZSkge1xuXHRcdFx0dmFyIHN0cm9rZU1hdHJpeCA9IHBhdGguX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpLFxuXHRcdFx0XHRzdHJva2VSYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VKb2luKCkgPT09ICdtaXRlcicpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlQ2FwKCkgPT09ICdzcXVhcmUnKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gTWF0aC5tYXgoam9pblJhZGl1cywgc3Ryb2tlUmFkaXVzICogTWF0aC5TUVJUMik7XG5cdFx0XHRzdHJva2VQYWRkaW5nID0gUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHRqb2luUGFkZGluZyA9IFBhdGguX2dldFN0cm9rZVBhZGRpbmcoam9pblJhZGl1cywgc3Ryb2tlTWF0cml4KTtcblx0XHR9XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSAhaiA/IGpvaW5QYWRkaW5nIDogc3Ryb2tlUGFkZGluZyxcblx0XHRcdFx0XHRwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nWzBdIDogMCxcblx0XHRcdFx0XHRwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nWzFdIDogMCxcblx0XHRcdFx0XHR4ID0gY29vcmRzW2pdLFxuXHRcdFx0XHRcdHkgPSBjb29yZHNbaiArIDFdLFxuXHRcdFx0XHRcdHhuID0geCAtIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHh4ID0geCArIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHluID0geSAtIHBhZGRpbmdZLFxuXHRcdFx0XHRcdHl4ID0geSArIHBhZGRpbmdZO1xuXHRcdFx0XHRpZiAoeG4gPCB4MSkgeDEgPSB4bjtcblx0XHRcdFx0aWYgKHh4ID4geDIpIHgyID0geHg7XG5cdFx0XHRcdGlmICh5biA8IHkxKSB5MSA9IHluO1xuXHRcdFx0XHRpZiAoeXggPiB5MikgeTIgPSB5eDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fVxufX0pO1xuXG5QYXRoLmluamVjdCh7IHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0ZWxsaXBzZVNlZ21lbnRzID0gW1xuXHRcdFx0bmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhIF0sIFswLCAta2FwcGFdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDAgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGEgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMCBdLCBbLWthcHBhLCAwXSlcblx0XHRdO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRwYXRoLl9hZGQoc2VnbWVudHMpO1xuXHRcdHBhdGguX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMsIHsgaW5zZXJ0OiB0cnVlIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxsaXBzZShjZW50ZXIsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBzZWdtZW50cyA9IG5ldyBBcnJheSg0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBlbGxpcHNlU2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KFxuXHRcdFx0XHRzZWdtZW50Ll9wb2ludC5tdWx0aXBseShyYWRpdXMpLmFkZChjZW50ZXIpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVJbi5tdWx0aXBseShyYWRpdXMpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJncywgJ2Zyb20nKSksXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmdzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJncyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShlbGxpcHNlLmNlbnRlciwgZWxsaXBzZS5yYWRpdXMsIGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3Rocm91Z2gnKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuXHRcdFx0XHRzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdzaWRlcycpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSBzaWRlcyAlIDMgPT09IDAsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdFx0fSxcblxuXHRcdFN0YXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyksXG5cdFx0XHRcdHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzMScpLFxuXHRcdFx0XHRyYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1czInKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHBvaW50cyxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIC0xKSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkocG9pbnRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMpIHtcblx0XHR2YXIgbGlzdCA9IGl0ZW1zLFxuXHRcdFx0Zmlyc3QgPSBsaXN0WzBdO1xuXHRcdGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3RbMF0gPT09ICdudW1iZXInKVxuXHRcdFx0bGlzdCA9IFtsaXN0XTtcblx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHRcdGlmIChsaXN0ID09PSBpdGVtcyAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBQYXRoKSlcblx0XHRcdFx0bGlzdCA9IEJhc2Uuc2xpY2UobGlzdCk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuXHRcdFx0XHRsaXN0W2ldID0gbmV3IFBhdGgoeyBzZWdtZW50czogaXRlbSwgaW5zZXJ0OiBmYWxzZSB9KTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHRsaXN0LnNwbGljZS5hcHBseShsaXN0LCBbaSwgMV0uY29uY2F0KGl0ZW0ucmVtb3ZlQ2hpbGRyZW4oKSkpO1xuXHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBsaXN0KTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShvcHRpb25zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcGF0aCA9IGNoaWxkcmVuW2ldLnJlZHVjZShvcHRpb25zKTtcblx0XHRcdGlmIChwYXRoLmlzRW1wdHkoKSlcblx0XHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdHZhciBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKCFjaGlsZHJlbltpXS5fY2xvc2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHNldENsb3NlZDogZnVuY3Rpb24oY2xvc2VkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuW2ldLnNldENsb3NlZChjbG9zZWQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0Y3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdEJhc2UucHVzaChjdXJ2ZXMsIGNoaWxkcmVuW2ldLmdldEN1cnZlcygpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRhcmVhID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGFyZWEgKz0gY2hpbGRyZW5baV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRsZW5ndGggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGVuZ3RoICs9IGNoaWxkcmVuW2ldLmdldExlbmd0aCgpO1xuXHRcdHJldHVybiBsZW5ndGg7XG5cdH0sXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuXHRcdFx0XHRcdD8gX21hdHJpeC5hcHBlbmRlZChteCkgOiBfbWF0cml4LCBfcHJlY2lzaW9uKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocy5qb2luKCcnKTtcblx0fSxcblxuXHRfaGl0VGVzdENoaWxkcmVuOiBmdW5jdGlvbiBfaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG5cdFx0cmV0dXJuIF9oaXRUZXN0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIHBvaW50LFxuXHRcdFx0XHRvcHRpb25zLmNsYXNzID09PSBQYXRoIHx8IG9wdGlvbnMudHlwZSA9PT0gJ3BhdGgnID8gb3B0aW9uc1xuXHRcdFx0XHRcdDogQmFzZS5zZXQoe30sIG9wdGlvbnMsIHsgZmlsbDogZmFsc2UgfSksXG5cdFx0XHRcdHZpZXdNYXRyaXgpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHJldHVybjtcblxuXHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHNlbGVjdGlvbkl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRpZiAoIXNlbGVjdGlvbkl0ZW1zW2NoaWxkLl9pZF0pIHtcblx0XHRcdFx0Y2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuXHRcdFx0XHRcdFx0OiBtYXRyaXguYXBwZW5kZWQobXgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmICFjaGlsZHJlbi5sZW5ndGgpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcblx0XHRyZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsnbGluZVRvJywgJ2N1YmljQ3VydmVUbycsICdxdWFkcmF0aWNDdXJ2ZVRvJywgJ2N1cnZlVG8nLFxuXHRcdFx0J2FyY1RvJywgJ2xpbmVCeScsICdjdWJpY0N1cnZlQnknLCAncXVhZHJhdGljQ3VydmVCeScsICdjdXJ2ZUJ5Jyxcblx0XHRcdCdhcmNCeSddLFxuXHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdHBhdGhba2V5XS5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMpLFxuXHRcdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudFxuXHRcdFx0XHRcdFx0XHQ6IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0aWYgKHBhdGggIT09IGN1cnJlbnQpXG5cdFx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdFx0cGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdH0sXG5cblx0XHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG5cdFx0XHRcdFx0bGFzdCA9IGN1cnJlbnQgJiYgY3VycmVudC5nZXRMYXN0U2VnbWVudCgpLFxuXHRcdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcblx0XHRcdH0sXG5cblx0XHRcdGNsb3NlUGF0aDogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0XHRcdGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLmNsb3NlUGF0aCh0b2xlcmFuY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sIEJhc2UuZWFjaChbJ3JldmVyc2UnLCAnZmxhdHRlbicsICdzaW1wbGlmeScsICdzbW9vdGgnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHRoaXNba2V5XSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRyZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHJlcyA9IGNoaWxkcmVuW2ldW2tleV0ocGFyYW0pIHx8IHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcbn0sIHt9KSk7XG5cblBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtaW4gPSBNYXRoLm1pbixcblx0XHRtYXggPSBNYXRoLm1heCxcblx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRvcGVyYXRvcnMgPSB7XG5cdFx0XHR1bml0ZTogICAgIHsgJzEnOiB0cnVlLCAnMic6IHRydWUgfSxcblx0XHRcdGludGVyc2VjdDogeyAnMic6IHRydWUgfSxcblx0XHRcdHN1YnRyYWN0OiAgeyAnMSc6IHRydWUgfSxcblx0XHRcdGV4Y2x1ZGU6ICAgeyAnMSc6IHRydWUsICctMSc6IHRydWUgfVxuXHRcdH07XG5cblx0ZnVuY3Rpb24gZ2V0UGF0aHMocGF0aCkge1xuXHRcdHJldHVybiBwYXRoLl9jaGlsZHJlbiB8fCBbcGF0aF07XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoLCByZXNvbHZlKSB7XG5cdFx0dmFyIHJlcyA9IHBhdGhcblx0XHRcdC5jbG9uZShmYWxzZSlcblx0XHRcdC5yZWR1Y2UoeyBzaW1wbGlmeTogdHJ1ZSB9KVxuXHRcdFx0LnRyYW5zZm9ybShudWxsLCB0cnVlLCB0cnVlKTtcblx0XHRpZiAocmVzb2x2ZSkge1xuXHRcdFx0dmFyIHBhdGhzID0gZ2V0UGF0aHMocmVzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdGlmICghcGF0aC5fY2xvc2VkICYmICFwYXRoLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHBhdGguY2xvc2VQYXRoKDFlLTEyKTtcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXHRcdFx0XHRcdHBhdGguZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcyA9IHJlc1xuXHRcdFx0XHQucmVzb2x2ZUNyb3NzaW5ncygpXG5cdFx0XHRcdC5yZW9yaWVudChyZXMuZ2V0RmlsbFJ1bGUoKSA9PT0gJ25vbnplcm8nLCB0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlc3VsdChwYXRocywgc2ltcGxpZnksIHBhdGgxLCBwYXRoMiwgb3B0aW9ucykge1xuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29tcG91bmRQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyZXN1bHQuYWRkQ2hpbGRyZW4ocGF0aHMsIHRydWUpO1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZWR1Y2UoeyBzaW1wbGlmeTogc2ltcGxpZnkgfSk7XG5cdFx0aWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLmluc2VydCA9PSBmYWxzZSkpIHtcblx0XHRcdHJlc3VsdC5pbnNlcnRBYm92ZShwYXRoMiAmJiBwYXRoMS5pc1NpYmxpbmcocGF0aDIpXG5cdFx0XHRcdFx0JiYgcGF0aDEuZ2V0SW5kZXgoKSA8IHBhdGgyLmdldEluZGV4KCkgPyBwYXRoMiA6IHBhdGgxKTtcblx0XHR9XG5cdFx0cmVzdWx0LmNvcHlBdHRyaWJ1dGVzKHBhdGgxLCB0cnVlKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZmlsdGVySW50ZXJzZWN0aW9uKGludGVyKSB7XG5cdFx0cmV0dXJuIGludGVyLmhhc092ZXJsYXAoKSB8fCBpbnRlci5pc0Nyb3NzaW5nKCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFjZUJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSkgJiZcblx0XHRcdFx0L14oc3VidHJhY3R8aW50ZXJzZWN0KSQvLnRlc3Qob3BlcmF0aW9uKSlcblx0XHRcdHJldHVybiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pO1xuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgdHJ1ZSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIsIHRydWUpLFxuXHRcdFx0b3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0aW9uXTtcblx0XHRvcGVyYXRvcltvcGVyYXRpb25dID0gdHJ1ZTtcblx0XHRpZiAoX3BhdGgyICYmIChvcGVyYXRvci5zdWJ0cmFjdCB8fCBvcGVyYXRvci5leGNsdWRlKVxuXHRcdFx0XHReIChfcGF0aDIuaXNDbG9ja3dpc2UoKSBeIF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0dmFyIGNyb3NzaW5ncyA9IGRpdmlkZUxvY2F0aW9ucyhDdXJ2ZUxvY2F0aW9uLmV4cGFuZChcblx0XHRcdFx0X3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmaWx0ZXJJbnRlcnNlY3Rpb24pKSksXG5cdFx0XHRwYXRoczEgPSBnZXRQYXRocyhfcGF0aDEpLFxuXHRcdFx0cGF0aHMyID0gX3BhdGgyICYmIGdldFBhdGhzKF9wYXRoMiksXG5cdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0Y3VydmVzID0gW10sXG5cdFx0XHRwYXRocztcblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3RQYXRocyhwYXRocykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGggPSBwYXRoc1tpXTtcblx0XHRcdFx0QmFzZS5wdXNoKHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdEJhc2UucHVzaChjdXJ2ZXMsIHBhdGguZ2V0Q3VydmVzKCkpO1xuXHRcdFx0XHRwYXRoLl9vdmVybGFwc09ubHkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEN1cnZlcyhpbmRpY2VzKSB7XG5cdFx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbmRpY2VzICYmIGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxpc3QucHVzaChjdXJ2ZXNbaW5kaWNlc1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXG5cdFx0aWYgKGNyb3NzaW5ncy5sZW5ndGgpIHtcblx0XHRcdGNvbGxlY3RQYXRocyhwYXRoczEpO1xuXHRcdFx0aWYgKHBhdGhzMilcblx0XHRcdFx0Y29sbGVjdFBhdGhzKHBhdGhzMik7XG5cblx0XHRcdHZhciBjdXJ2ZXNWYWx1ZXMgPSBuZXcgQXJyYXkoY3VydmVzLmxlbmd0aCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y3VydmVzVmFsdWVzW2ldID0gY3VydmVzW2ldLmdldFZhbHVlcygpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnZlQ29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zKFxuXHRcdFx0XHRcdGN1cnZlc1ZhbHVlcywgY3VydmVzVmFsdWVzLCAwLCB0cnVlKTtcblx0XHRcdHZhciBjdXJ2ZUNvbGxpc2lvbnNNYXAgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcblx0XHRcdFx0XHRpZCA9IGN1cnZlLl9wYXRoLl9pZCxcblx0XHRcdFx0XHRtYXAgPSBjdXJ2ZUNvbGxpc2lvbnNNYXBbaWRdID0gY3VydmVDb2xsaXNpb25zTWFwW2lkXSB8fCB7fTtcblx0XHRcdFx0bWFwW2N1cnZlLmdldEluZGV4KCldID0ge1xuXHRcdFx0XHRcdGhvcjogZ2V0Q3VydmVzKGN1cnZlQ29sbGlzaW9uc1tpXS5ob3IpLFxuXHRcdFx0XHRcdHZlcjogZ2V0Q3VydmVzKGN1cnZlQ29sbGlzaW9uc1tpXS52ZXIpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3Jvc3NpbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRwcm9wYWdhdGVXaW5kaW5nKGNyb3NzaW5nc1tpXS5fc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsXG5cdFx0XHRcdFx0XHRjdXJ2ZUNvbGxpc2lvbnNNYXAsIG9wZXJhdG9yKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdFx0aW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdGlmICghc2VnbWVudC5fd2luZGluZykge1xuXHRcdFx0XHRcdHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsXG5cdFx0XHRcdFx0XHRcdGN1cnZlQ29sbGlzaW9uc01hcCwgb3BlcmF0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghKGludGVyICYmIGludGVyLl9vdmVybGFwKSlcblx0XHRcdFx0XHRzZWdtZW50Ll9wYXRoLl9vdmVybGFwc09ubHkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHBhdGhzID0gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRocyA9IHJlb3JpZW50UGF0aHMoXG5cdFx0XHRcdFx0cGF0aHMyID8gcGF0aHMxLmNvbmNhdChwYXRoczIpIDogcGF0aHMxLnNsaWNlKCksXG5cdFx0XHRcdFx0ZnVuY3Rpb24odykge1xuXHRcdFx0XHRcdFx0cmV0dXJuICEhb3BlcmF0b3Jbd107XG5cdFx0XHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVSZXN1bHQocGF0aHMsIHRydWUsIHBhdGgxLCBwYXRoMiwgb3B0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuXHRcdFx0X3BhdGgyID0gcHJlcGFyZVBhdGgocGF0aDIpLFxuXHRcdFx0Y3Jvc3NpbmdzID0gX3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmaWx0ZXJJbnRlcnNlY3Rpb24pLFxuXHRcdFx0c3VidHJhY3QgPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcsXG5cdFx0XHRkaXZpZGUgPSBvcGVyYXRpb24gPT09ICdkaXZpZGUnLFxuXHRcdFx0YWRkZWQgPSB7fSxcblx0XHRcdHBhdGhzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRQYXRoKHBhdGgpIHtcblx0XHRcdGlmICghYWRkZWRbcGF0aC5faWRdICYmIChkaXZpZGUgfHxcblx0XHRcdFx0XHRfcGF0aDIuY29udGFpbnMocGF0aC5nZXRQb2ludEF0KHBhdGguZ2V0TGVuZ3RoKCkgLyAyKSlcblx0XHRcdFx0XHRcdF4gc3VidHJhY3QpKSB7XG5cdFx0XHRcdHBhdGhzLnVuc2hpZnQocGF0aCk7XG5cdFx0XHRcdHJldHVybiBhZGRlZFtwYXRoLl9pZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBjcm9zc2luZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gY3Jvc3NpbmdzW2ldLnNwbGl0KCk7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRpZiAoYWRkUGF0aChwYXRoKSlcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXHRcdFx0XHRfcGF0aDEuZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZFBhdGgoX3BhdGgxKTtcblx0XHRyZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCBmYWxzZSwgcGF0aDEsIHBhdGgyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpbmtJbnRlcnNlY3Rpb25zKGZyb20sIHRvKSB7XG5cdFx0dmFyIHByZXYgPSBmcm9tO1xuXHRcdHdoaWxlIChwcmV2KSB7XG5cdFx0XHRpZiAocHJldiA9PT0gdG8pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXYgPSBwcmV2Ll9wcmV2aW91cztcblx0XHR9XG5cdFx0d2hpbGUgKGZyb20uX25leHQgJiYgZnJvbS5fbmV4dCAhPT0gdG8pXG5cdFx0XHRmcm9tID0gZnJvbS5fbmV4dDtcblx0XHRpZiAoIWZyb20uX25leHQpIHtcblx0XHRcdHdoaWxlICh0by5fcHJldmlvdXMpXG5cdFx0XHRcdHRvID0gdG8uX3ByZXZpb3VzO1xuXHRcdFx0ZnJvbS5fbmV4dCA9IHRvO1xuXHRcdFx0dG8uX3ByZXZpb3VzID0gZnJvbTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhckN1cnZlSGFuZGxlcyhjdXJ2ZXMpIHtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0Y3VydmVzW2ldLmNsZWFySGFuZGxlcygpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVvcmllbnRQYXRocyhwYXRocywgaXNJbnNpZGUsIGNsb2Nrd2lzZSkge1xuXHRcdHZhciBsZW5ndGggPSBwYXRocyAmJiBwYXRocy5sZW5ndGg7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxvb2t1cCA9IEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgsIGkpIHtcblx0XHRcdFx0XHR0aGlzW3BhdGguX2lkXSA9IHtcblx0XHRcdFx0XHRcdGNvbnRhaW5lcjogbnVsbCxcblx0XHRcdFx0XHRcdHdpbmRpbmc6IHBhdGguaXNDbG9ja3dpc2UoKSA/IDEgOiAtMSxcblx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSwge30pLFxuXHRcdFx0XHRzb3J0ZWQgPSBwYXRocy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGIuZ2V0QXJlYSgpKSAtIGFicyhhLmdldEFyZWEoKSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRmaXJzdCA9IHNvcnRlZFswXTtcblx0XHRcdHZhciBjb2xsaXNpb25zID0gQ29sbGlzaW9uRGV0ZWN0aW9uLmZpbmRJdGVtQm91bmRzQ29sbGlzaW9ucyhzb3J0ZWQsXG5cdFx0XHRcdFx0bnVsbCwgTnVtZXJpY2FsLkdFT01FVFJJQ19FUFNJTE9OKTtcblx0XHRcdGlmIChjbG9ja3dpc2UgPT0gbnVsbClcblx0XHRcdFx0Y2xvY2t3aXNlID0gZmlyc3QuaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gc29ydGVkW2ldLFxuXHRcdFx0XHRcdGVudHJ5MSA9IGxvb2t1cFtwYXRoMS5faWRdLFxuXHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSAwLFxuXHRcdFx0XHRcdGluZGljZXMgPSBjb2xsaXNpb25zW2ldO1xuXHRcdFx0XHRpZiAoaW5kaWNlcykge1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IG51bGw7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IGluZGljZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdGlmIChpbmRpY2VzW2pdIDwgaSkge1xuXHRcdFx0XHRcdFx0XHRwb2ludCA9IHBvaW50IHx8IHBhdGgxLmdldEludGVyaW9yUG9pbnQoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHBhdGgyID0gc29ydGVkW2luZGljZXNbal1dO1xuXHRcdFx0XHRcdFx0XHRpZiAocGF0aDIuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVudHJ5MiA9IGxvb2t1cFtwYXRoMi5faWRdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSBlbnRyeTIud2luZGluZztcblx0XHRcdFx0XHRcdFx0XHRlbnRyeTEud2luZGluZyArPSBjb250YWluZXJXaW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRcdGVudHJ5MS5jb250YWluZXIgPSBlbnRyeTIuZXhjbHVkZVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBlbnRyeTIuY29udGFpbmVyIDogcGF0aDI7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzSW5zaWRlKGVudHJ5MS53aW5kaW5nKSA9PT0gaXNJbnNpZGUoY29udGFpbmVyV2luZGluZykpIHtcblx0XHRcdFx0XHRlbnRyeTEuZXhjbHVkZSA9IHRydWU7XG5cdFx0XHRcdFx0cGF0aHNbZW50cnkxLmluZGV4XSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IGVudHJ5MS5jb250YWluZXI7XG5cdFx0XHRcdFx0cGF0aDEuc2V0Q2xvY2t3aXNlKFxuXHRcdFx0XHRcdFx0XHRjb250YWluZXIgPyAhY29udGFpbmVyLmlzQ2xvY2t3aXNlKCkgOiBjbG9ja3dpc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdGZ1bmN0aW9uIGRpdmlkZUxvY2F0aW9ucyhsb2NhdGlvbnMsIGluY2x1ZGUsIGNsZWFyTGF0ZXIpIHtcblx0XHR2YXIgcmVzdWx0cyA9IGluY2x1ZGUgJiYgW10sXG5cdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdGNsZWFySGFuZGxlcyA9IGZhbHNlLFxuXHRcdFx0Y2xlYXJDdXJ2ZXMgPSBjbGVhckxhdGVyIHx8IFtdLFxuXHRcdFx0Y2xlYXJMb29rdXAgPSBjbGVhckxhdGVyICYmIHt9LFxuXHRcdFx0cmVub3JtYWxpemVMb2NzLFxuXHRcdFx0cHJldkN1cnZlLFxuXHRcdFx0cHJldlRpbWU7XG5cblx0XHRmdW5jdGlvbiBnZXRJZChjdXJ2ZSkge1xuXHRcdFx0cmV0dXJuIGN1cnZlLl9wYXRoLl9pZCArICcuJyArIGN1cnZlLl9zZWdtZW50MS5faW5kZXg7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IChjbGVhckxhdGVyICYmIGNsZWFyTGF0ZXIubGVuZ3RoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjbGVhckxhdGVyW2ldO1xuXHRcdFx0aWYgKGN1cnZlLl9wYXRoKVxuXHRcdFx0XHRjbGVhckxvb2t1cFtnZXRJZChjdXJ2ZSldID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuXHRcdFx0XHR0aW1lID0gbG9jLl90aW1lLFxuXHRcdFx0XHRvcmlnVGltZSA9IHRpbWUsXG5cdFx0XHRcdGV4Y2x1ZGUgPSBpbmNsdWRlICYmICFpbmNsdWRlKGxvYyksXG5cdFx0XHRcdGN1cnZlID0gbG9jLl9jdXJ2ZSxcblx0XHRcdFx0c2VnbWVudDtcblx0XHRcdGlmIChjdXJ2ZSkge1xuXHRcdFx0XHRpZiAoY3VydmUgIT09IHByZXZDdXJ2ZSkge1xuXHRcdFx0XHRcdGNsZWFySGFuZGxlcyA9ICFjdXJ2ZS5oYXNIYW5kbGVzKClcblx0XHRcdFx0XHRcdFx0fHwgY2xlYXJMb29rdXAgJiYgY2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXTtcblx0XHRcdFx0XHRyZW5vcm1hbGl6ZUxvY3MgPSBbXTtcblx0XHRcdFx0XHRwcmV2VGltZSA9IG51bGw7XG5cdFx0XHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldlRpbWUgPj0gdE1pbikge1xuXHRcdFx0XHRcdHRpbWUgLz0gcHJldlRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChleGNsdWRlKSB7XG5cdFx0XHRcdGlmIChyZW5vcm1hbGl6ZUxvY3MpXG5cdFx0XHRcdFx0cmVub3JtYWxpemVMb2NzLnB1c2gobG9jKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKGluY2x1ZGUpIHtcblx0XHRcdFx0cmVzdWx0cy51bnNoaWZ0KGxvYyk7XG5cdFx0XHR9XG5cdFx0XHRwcmV2VGltZSA9IG9yaWdUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPCB0TWluKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPiB0TWF4KSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbmV3Q3VydmUgPSBjdXJ2ZS5kaXZpZGVBdFRpbWUodGltZSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChjbGVhckhhbmRsZXMpXG5cdFx0XHRcdFx0Y2xlYXJDdXJ2ZXMucHVzaChjdXJ2ZSwgbmV3Q3VydmUpO1xuXHRcdFx0XHRzZWdtZW50ID0gbmV3Q3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gcmVub3JtYWxpemVMb2NzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0dmFyIGwgPSByZW5vcm1hbGl6ZUxvY3Nbal07XG5cdFx0XHRcdFx0bC5fdGltZSA9IChsLl90aW1lIC0gdGltZSkgLyAoMSAtIHRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsb2MuX3NldFNlZ21lbnQoc2VnbWVudCk7XG5cdFx0XHR2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdGRlc3QgPSBsb2MuX2ludGVyc2VjdGlvbjtcblx0XHRcdGlmIChpbnRlcikge1xuXHRcdFx0XHRsaW5rSW50ZXJzZWN0aW9ucyhpbnRlciwgZGVzdCk7XG5cdFx0XHRcdHZhciBvdGhlciA9IGludGVyO1xuXHRcdFx0XHR3aGlsZSAob3RoZXIpIHtcblx0XHRcdFx0XHRsaW5rSW50ZXJzZWN0aW9ucyhvdGhlci5faW50ZXJzZWN0aW9uLCBpbnRlcik7XG5cdFx0XHRcdFx0b3RoZXIgPSBvdGhlci5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudC5faW50ZXJzZWN0aW9uID0gZGVzdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjbGVhckxhdGVyKVxuXHRcdFx0Y2xlYXJDdXJ2ZUhhbmRsZXMoY2xlYXJDdXJ2ZXMpO1xuXHRcdHJldHVybiByZXN1bHRzIHx8IGxvY2F0aW9ucztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgZGlyLCBjbG9zZWQsIGRvbnRGbGlwKSB7XG5cdFx0dmFyIGN1cnZlc0xpc3QgPSBBcnJheS5pc0FycmF5KGN1cnZlcylcblx0XHRcdD8gY3VydmVzXG5cdFx0XHQ6IGN1cnZlc1tkaXIgPyAnaG9yJyA6ICd2ZXInXTtcblx0XHR2YXIgaWEgPSBkaXIgPyAxIDogMCxcblx0XHRcdGlvID0gaWEgXiAxLFxuXHRcdFx0cHYgPSBbcG9pbnQueCwgcG9pbnQueV0sXG5cdFx0XHRwYSA9IHB2W2lhXSxcblx0XHRcdHBvID0gcHZbaW9dLFxuXHRcdFx0d2luZGluZ0Vwc2lsb24gPSAxZS05LFxuXHRcdFx0cXVhbGl0eUVwc2lsb24gPSAxZS02LFxuXHRcdFx0cGFMID0gcGEgLSB3aW5kaW5nRXBzaWxvbixcblx0XHRcdHBhUiA9IHBhICsgd2luZGluZ0Vwc2lsb24sXG5cdFx0XHR3aW5kaW5nTCA9IDAsXG5cdFx0XHR3aW5kaW5nUiA9IDAsXG5cdFx0XHRwYXRoV2luZGluZ0wgPSAwLFxuXHRcdFx0cGF0aFdpbmRpbmdSID0gMCxcblx0XHRcdG9uUGF0aCA9IGZhbHNlLFxuXHRcdFx0b25BbnlQYXRoID0gZmFsc2UsXG5cdFx0XHRxdWFsaXR5ID0gMSxcblx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHR2UHJldixcblx0XHRcdHZDbG9zZTtcblxuXHRcdGZ1bmN0aW9uIGFkZFdpbmRpbmcodikge1xuXHRcdFx0dmFyIG8wID0gdltpbyArIDBdLFxuXHRcdFx0XHRvMyA9IHZbaW8gKyA2XTtcblx0XHRcdGlmIChwbyA8IG1pbihvMCwgbzMpIHx8IHBvID4gbWF4KG8wLCBvMykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEwID0gdltpYSArIDBdLFxuXHRcdFx0XHRhMSA9IHZbaWEgKyAyXSxcblx0XHRcdFx0YTIgPSB2W2lhICsgNF0sXG5cdFx0XHRcdGEzID0gdltpYSArIDZdO1xuXHRcdFx0aWYgKG8wID09PSBvMykge1xuXHRcdFx0XHRpZiAoYTAgPCBwYVIgJiYgYTMgPiBwYUwgfHwgYTMgPCBwYVIgJiYgYTAgPiBwYUwpIHtcblx0XHRcdFx0XHRvblBhdGggPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gICBwbyA9PT0gbzAgPyAwXG5cdFx0XHRcdFx0OiBwbyA9PT0gbzMgPyAxXG5cdFx0XHRcdFx0OiBwYUwgPiBtYXgoYTAsIGExLCBhMiwgYTMpIHx8IHBhUiA8IG1pbihhMCwgYTEsIGEyLCBhMylcblx0XHRcdFx0XHQ/IDFcblx0XHRcdFx0XHQ6IEN1cnZlLnNvbHZlQ3ViaWModiwgaW8sIHBvLCByb290cywgMCwgMSkgPiAwXG5cdFx0XHRcdFx0XHQ/IHJvb3RzWzBdXG5cdFx0XHRcdFx0XHQ6IDEsXG5cdFx0XHRcdGEgPSAgIHQgPT09IDAgPyBhMFxuXHRcdFx0XHRcdDogdCA9PT0gMSA/IGEzXG5cdFx0XHRcdFx0OiBDdXJ2ZS5nZXRQb2ludCh2LCB0KVtkaXIgPyAneScgOiAneCddLFxuXHRcdFx0XHR3aW5kaW5nID0gbzAgPiBvMyA/IDEgOiAtMSxcblx0XHRcdFx0d2luZGluZ1ByZXYgPSB2UHJldltpb10gPiB2UHJldltpbyArIDZdID8gMSA6IC0xLFxuXHRcdFx0XHRhM1ByZXYgPSB2UHJldltpYSArIDZdO1xuXHRcdFx0aWYgKHBvICE9PSBvMCkge1xuXHRcdFx0XHRpZiAoYSA8IHBhTCkge1xuXHRcdFx0XHRcdHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGEgPiBwYVIpIHtcblx0XHRcdFx0XHRwYXRoV2luZGluZ1IgKz0gd2luZGluZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvblBhdGggPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhID4gcGEgLSBxdWFsaXR5RXBzaWxvbiAmJiBhIDwgcGEgKyBxdWFsaXR5RXBzaWxvbilcblx0XHRcdFx0XHRxdWFsaXR5IC89IDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAod2luZGluZyAhPT0gd2luZGluZ1ByZXYpIHtcblx0XHRcdFx0XHRpZiAoYTAgPCBwYUwpIHtcblx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYTAgPiBwYVIpIHtcblx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhMCAhPSBhM1ByZXYpIHtcblx0XHRcdFx0XHRpZiAoYTNQcmV2IDwgcGFSICYmIGEgPiBwYVIpIHtcblx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0b25QYXRoID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGEzUHJldiA+IHBhTCAmJiBhIDwgcGFMKSB7XG5cdFx0XHRcdFx0XHRwYXRoV2luZGluZ0wgKz0gd2luZGluZztcblx0XHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHF1YWxpdHkgLz0gNDtcblx0XHRcdH1cblx0XHRcdHZQcmV2ID0gdjtcblx0XHRcdHJldHVybiAhZG9udEZsaXAgJiYgYSA+IHBhTCAmJiBhIDwgcGFSXG5cdFx0XHRcdFx0JiYgQ3VydmUuZ2V0VGFuZ2VudCh2LCB0KVtkaXIgPyAneCcgOiAneSddID09PSAwXG5cdFx0XHRcdFx0JiYgZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCAhZGlyLCBjbG9zZWQsIHRydWUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcblx0XHRcdHZhciBvMCA9IHZbaW8gKyAwXSxcblx0XHRcdFx0bzEgPSB2W2lvICsgMl0sXG5cdFx0XHRcdG8yID0gdltpbyArIDRdLFxuXHRcdFx0XHRvMyA9IHZbaW8gKyA2XTtcblx0XHRcdGlmIChwbyA8PSBtYXgobzAsIG8xLCBvMiwgbzMpICYmIHBvID49IG1pbihvMCwgbzEsIG8yLCBvMykpIHtcblx0XHRcdFx0dmFyIGEwID0gdltpYSArIDBdLFxuXHRcdFx0XHRcdGExID0gdltpYSArIDJdLFxuXHRcdFx0XHRcdGEyID0gdltpYSArIDRdLFxuXHRcdFx0XHRcdGEzID0gdltpYSArIDZdLFxuXHRcdFx0XHRcdG1vbm9DdXJ2ZXMgPSBwYUwgPiBtYXgoYTAsIGExLCBhMiwgYTMpIHx8XG5cdFx0XHRcdFx0XHRcdFx0IHBhUiA8IG1pbihhMCwgYTEsIGEyLCBhMylcblx0XHRcdFx0XHRcdFx0PyBbdl0gOiBDdXJ2ZS5nZXRNb25vQ3VydmVzKHYsIGRpciksXG5cdFx0XHRcdFx0cmVzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1vbm9DdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHJlcyA9IGFkZFdpbmRpbmcobW9ub0N1cnZlc1tpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXNMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzTGlzdFtpXSxcblx0XHRcdFx0cGF0aCA9IGN1cnZlLl9wYXRoLFxuXHRcdFx0XHR2ID0gY3VydmUuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdHJlcztcblx0XHRcdGlmICghaSB8fCBjdXJ2ZXNMaXN0W2kgLSAxXS5fcGF0aCAhPT0gcGF0aCkge1xuXHRcdFx0XHR2UHJldiA9IG51bGw7XG5cdFx0XHRcdGlmICghcGF0aC5fY2xvc2VkKSB7XG5cdFx0XHRcdFx0dkNsb3NlID0gQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdFx0XHRwYXRoLmdldExhc3RDdXJ2ZSgpLmdldFNlZ21lbnQyKCksXG5cdFx0XHRcdFx0XHRcdGN1cnZlLmdldFNlZ21lbnQxKCksXG5cdFx0XHRcdFx0XHRcdG51bGwsICFjbG9zZWQpO1xuXHRcdFx0XHRcdGlmICh2Q2xvc2VbaW9dICE9PSB2Q2xvc2VbaW8gKyA2XSkge1xuXHRcdFx0XHRcdFx0dlByZXYgPSB2Q2xvc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF2UHJldikge1xuXHRcdFx0XHRcdHZQcmV2ID0gdjtcblx0XHRcdFx0XHR2YXIgcHJldiA9IHBhdGguZ2V0TGFzdEN1cnZlKCk7XG5cdFx0XHRcdFx0d2hpbGUgKHByZXYgJiYgcHJldiAhPT0gY3VydmUpIHtcblx0XHRcdFx0XHRcdHZhciB2MiA9IHByZXYuZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdFx0XHRpZiAodjJbaW9dICE9PSB2MltpbyArIDZdKSB7XG5cdFx0XHRcdFx0XHRcdHZQcmV2ID0gdjI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHJldiA9IHByZXYuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlcyA9IGhhbmRsZUN1cnZlKHYpKVxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXG5cdFx0XHRpZiAoaSArIDEgPT09IGwgfHwgY3VydmVzTGlzdFtpICsgMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0aWYgKHZDbG9zZSAmJiAocmVzID0gaGFuZGxlQ3VydmUodkNsb3NlKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0aWYgKG9uUGF0aCAmJiAhcGF0aFdpbmRpbmdMICYmICFwYXRoV2luZGluZ1IpIHtcblx0XHRcdFx0XHRwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSBwYXRoLmlzQ2xvY2t3aXNlKGNsb3NlZCkgXiBkaXJcblx0XHRcdFx0XHRcdFx0PyAxIDogLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2luZGluZ0wgKz0gcGF0aFdpbmRpbmdMO1xuXHRcdFx0XHR3aW5kaW5nUiArPSBwYXRoV2luZGluZ1I7XG5cdFx0XHRcdHBhdGhXaW5kaW5nTCA9IHBhdGhXaW5kaW5nUiA9IDA7XG5cdFx0XHRcdGlmIChvblBhdGgpIHtcblx0XHRcdFx0XHRvbkFueVBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdG9uUGF0aCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZDbG9zZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdpbmRpbmdMID0gYWJzKHdpbmRpbmdMKTtcblx0XHR3aW5kaW5nUiA9IGFicyh3aW5kaW5nUik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpbmRpbmc6IG1heCh3aW5kaW5nTCwgd2luZGluZ1IpLFxuXHRcdFx0d2luZGluZ0w6IHdpbmRpbmdMLFxuXHRcdFx0d2luZGluZ1I6IHdpbmRpbmdSLFxuXHRcdFx0cXVhbGl0eTogcXVhbGl0eSxcblx0XHRcdG9uUGF0aDogb25BbnlQYXRoXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgcGF0aDEsIHBhdGgyLCBjdXJ2ZUNvbGxpc2lvbnNNYXAsXG5cdFx0XHRvcGVyYXRvcikge1xuXHRcdHZhciBjaGFpbiA9IFtdLFxuXHRcdFx0c3RhcnQgPSBzZWdtZW50LFxuXHRcdFx0dG90YWxMZW5ndGggPSAwLFxuXHRcdFx0d2luZGluZztcblx0XHRkbyB7XG5cdFx0XHR2YXIgY3VydmUgPSBzZWdtZW50LmdldEN1cnZlKCk7XG5cdFx0XHRpZiAoY3VydmUpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgY3VydmU6IGN1cnZlLCBsZW5ndGg6IGxlbmd0aCB9KTtcblx0XHRcdFx0dG90YWxMZW5ndGggKz0gbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdH0gd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuX2ludGVyc2VjdGlvbiAmJiBzZWdtZW50ICE9PSBzdGFydCk7XG5cdFx0dmFyIG9mZnNldHMgPSBbMC41LCAwLjI1LCAwLjc1XSxcblx0XHRcdHdpbmRpbmcgPSB7IHdpbmRpbmc6IDAsIHF1YWxpdHk6IC0xIH0sXG5cdFx0XHR0TWluID0gMWUtMyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoICYmIHdpbmRpbmcucXVhbGl0eSA8IDAuNTsgaSsrKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdG90YWxMZW5ndGggKiBvZmZzZXRzW2ldO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIGwgPSBjaGFpbi5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gY2hhaW5bal0sXG5cdFx0XHRcdFx0Y3VydmVMZW5ndGggPSBlbnRyeS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggPD0gY3VydmVMZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgY3VydmUgPSBlbnRyeS5jdXJ2ZSxcblx0XHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aCxcblx0XHRcdFx0XHRcdHBhcmVudCA9IHBhdGguX3BhcmVudCxcblx0XHRcdFx0XHRcdG9wZXJhbmQgPSBwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiBwYXRoLFxuXHRcdFx0XHRcdFx0dCA9IE51bWVyaWNhbC5jbGFtcChjdXJ2ZS5nZXRUaW1lQXQobGVuZ3RoKSwgdE1pbiwgdE1heCksXG5cdFx0XHRcdFx0XHRwdCA9IGN1cnZlLmdldFBvaW50QXRUaW1lKHQpLFxuXHRcdFx0XHRcdFx0ZGlyID0gYWJzKGN1cnZlLmdldFRhbmdlbnRBdFRpbWUodCkueSkgPCBNYXRoLlNRUlQxXzI7XG5cdFx0XHRcdFx0dmFyIHdpbmQgPSBudWxsO1xuXHRcdFx0XHRcdGlmIChvcGVyYXRvci5zdWJ0cmFjdCAmJiBwYXRoMikge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyUGF0aCA9IG9wZXJhbmQgPT09IHBhdGgxID8gcGF0aDIgOiBwYXRoMSxcblx0XHRcdFx0XHRcdFx0cGF0aFdpbmRpbmcgPSBvdGhlclBhdGguX2dldFdpbmRpbmcocHQsIGRpciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAob3BlcmFuZCA9PT0gcGF0aDEgJiYgcGF0aFdpbmRpbmcud2luZGluZyB8fFxuXHRcdFx0XHRcdFx0XHRvcGVyYW5kID09PSBwYXRoMiAmJiAhcGF0aFdpbmRpbmcud2luZGluZykge1xuXHRcdFx0XHRcdFx0XHRpZiAocGF0aFdpbmRpbmcucXVhbGl0eSA8IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kID0geyB3aW5kaW5nOiAwLCBxdWFsaXR5OiAxIH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2luZCA9ICB3aW5kIHx8IGdldFdpbmRpbmcoXG5cdFx0XHRcdFx0XHRcdHB0LCBjdXJ2ZUNvbGxpc2lvbnNNYXBbcGF0aC5faWRdW2N1cnZlLmdldEluZGV4KCldLFxuXHRcdFx0XHRcdFx0XHRkaXIsIHRydWUpO1xuXHRcdFx0XHRcdGlmICh3aW5kLnF1YWxpdHkgPiB3aW5kaW5nLnF1YWxpdHkpXG5cdFx0XHRcdFx0XHR3aW5kaW5nID0gd2luZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZW5ndGggLT0gY3VydmVMZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0Y2hhaW5bal0uc2VnbWVudC5fd2luZGluZyA9IHdpbmRpbmc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IpIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHN0YXJ0cztcblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWQoc2VnKSB7XG5cdFx0XHR2YXIgd2luZGluZztcblx0XHRcdHJldHVybiAhIShzZWcgJiYgIXNlZy5fdmlzaXRlZCAmJiAoIW9wZXJhdG9yXG5cdFx0XHRcdFx0fHwgb3BlcmF0b3JbKHdpbmRpbmcgPSBzZWcuX3dpbmRpbmcgfHwge30pLndpbmRpbmddXG5cdFx0XHRcdFx0XHQmJiAhKG9wZXJhdG9yLnVuaXRlICYmIHdpbmRpbmcud2luZGluZyA9PT0gMlxuXHRcdFx0XHRcdFx0XHQmJiB3aW5kaW5nLndpbmRpbmdMICYmIHdpbmRpbmcud2luZGluZ1IpKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTdGFydChzZWcpIHtcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHNlZyA9PT0gc3RhcnRzW2ldKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB2aXNpdFBhdGgocGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRzZWdtZW50c1tpXS5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3Jvc3NpbmdTZWdtZW50cyhzZWdtZW50LCBjb2xsZWN0U3RhcnRzKSB7XG5cdFx0XHR2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0ID0gaW50ZXIsXG5cdFx0XHRcdGNyb3NzaW5ncyA9IFtdO1xuXHRcdFx0aWYgKGNvbGxlY3RTdGFydHMpXG5cdFx0XHRcdHN0YXJ0cyA9IFtzZWdtZW50XTtcblxuXHRcdFx0ZnVuY3Rpb24gY29sbGVjdChpbnRlciwgZW5kKSB7XG5cdFx0XHRcdHdoaWxlIChpbnRlciAmJiBpbnRlciAhPT0gZW5kKSB7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gaW50ZXIuX3NlZ21lbnQsXG5cdFx0XHRcdFx0XHRwYXRoID0gb3RoZXIgJiYgb3RoZXIuX3BhdGg7XG5cdFx0XHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0XHRcdHZhciBuZXh0ID0gb3RoZXIuZ2V0TmV4dCgpIHx8IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRcdFx0XHRcdG5leHRJbnRlciA9IG5leHQuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0XHRcdGlmIChvdGhlciAhPT0gc2VnbWVudCAmJiAoaXNTdGFydChvdGhlcilcblx0XHRcdFx0XHRcdFx0fHwgaXNTdGFydChuZXh0KVxuXHRcdFx0XHRcdFx0XHR8fCBuZXh0ICYmIChpc1ZhbGlkKG90aGVyKSAmJiAoaXNWYWxpZChuZXh0KVxuXHRcdFx0XHRcdFx0XHRcdHx8IG5leHRJbnRlciAmJiBpc1ZhbGlkKG5leHRJbnRlci5fc2VnbWVudCkpKSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjcm9zc2luZ3MucHVzaChvdGhlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY29sbGVjdFN0YXJ0cylcblx0XHRcdFx0XHRcdFx0c3RhcnRzLnB1c2gob3RoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnRlciA9IGludGVyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbnRlcikge1xuXHRcdFx0XHRjb2xsZWN0KGludGVyKTtcblx0XHRcdFx0d2hpbGUgKGludGVyICYmIGludGVyLl9wcmV2aW91cylcblx0XHRcdFx0XHRpbnRlciA9IGludGVyLl9wcmV2aW91cztcblx0XHRcdFx0Y29sbGVjdChpbnRlciwgc3RhcnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNyb3NzaW5ncztcblx0XHR9XG5cblx0XHRzZWdtZW50cy5zb3J0KGZ1bmN0aW9uKHNlZzEsIHNlZzIpIHtcblx0XHRcdHZhciBpbnRlcjEgPSBzZWcxLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdGludGVyMiA9IHNlZzIuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0b3ZlcjEgPSAhIShpbnRlcjEgJiYgaW50ZXIxLl9vdmVybGFwKSxcblx0XHRcdFx0b3ZlcjIgPSAhIShpbnRlcjIgJiYgaW50ZXIyLl9vdmVybGFwKSxcblx0XHRcdFx0cGF0aDEgPSBzZWcxLl9wYXRoLFxuXHRcdFx0XHRwYXRoMiA9IHNlZzIuX3BhdGg7XG5cdFx0XHRyZXR1cm4gb3ZlcjEgXiBvdmVyMlxuXHRcdFx0XHRcdD8gb3ZlcjEgPyAxIDogLTFcblx0XHRcdFx0XHQ6ICFpbnRlcjEgXiAhaW50ZXIyXG5cdFx0XHRcdFx0XHQ/IGludGVyMSA/IDEgOiAtMVxuXHRcdFx0XHRcdFx0OiBwYXRoMSAhPT0gcGF0aDJcblx0XHRcdFx0XHRcdFx0PyBwYXRoMS5faWQgLSBwYXRoMi5faWRcblx0XHRcdFx0XHRcdFx0OiBzZWcxLl9pbmRleCAtIHNlZzIuX2luZGV4O1xuXHRcdH0pO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWcgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0dmFsaWQgPSBpc1ZhbGlkKHNlZyksXG5cdFx0XHRcdHBhdGggPSBudWxsLFxuXHRcdFx0XHRmaW5pc2hlZCA9IGZhbHNlLFxuXHRcdFx0XHRjbG9zZWQgPSB0cnVlLFxuXHRcdFx0XHRicmFuY2hlcyA9IFtdLFxuXHRcdFx0XHRicmFuY2gsXG5cdFx0XHRcdHZpc2l0ZWQsXG5cdFx0XHRcdGhhbmRsZUluO1xuXHRcdFx0aWYgKHZhbGlkICYmIHNlZy5fcGF0aC5fb3ZlcmxhcHNPbmx5KSB7XG5cdFx0XHRcdHZhciBwYXRoMSA9IHNlZy5fcGF0aCxcblx0XHRcdFx0XHRwYXRoMiA9IHNlZy5faW50ZXJzZWN0aW9uLl9zZWdtZW50Ll9wYXRoO1xuXHRcdFx0XHRpZiAocGF0aDEuY29tcGFyZShwYXRoMikpIHtcblx0XHRcdFx0XHRpZiAocGF0aDEuZ2V0QXJlYSgpKVxuXHRcdFx0XHRcdFx0cGF0aHMucHVzaChwYXRoMS5jbG9uZShmYWxzZSkpO1xuXHRcdFx0XHRcdHZpc2l0UGF0aChwYXRoMSk7XG5cdFx0XHRcdFx0dmlzaXRQYXRoKHBhdGgyKTtcblx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAodmFsaWQpIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gIXBhdGgsXG5cdFx0XHRcdFx0Y3Jvc3NpbmdzID0gZ2V0Q3Jvc3NpbmdTZWdtZW50cyhzZWcsIGZpcnN0KSxcblx0XHRcdFx0XHRvdGhlciA9IGNyb3NzaW5ncy5zaGlmdCgpLFxuXHRcdFx0XHRcdGZpbmlzaGVkID0gIWZpcnN0ICYmIChpc1N0YXJ0KHNlZykgfHwgaXNTdGFydChvdGhlcikpLFxuXHRcdFx0XHRcdGNyb3NzID0gIWZpbmlzaGVkICYmIG90aGVyO1xuXHRcdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0XHRwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRcdGJyYW5jaCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZpbmlzaGVkKSB7XG5cdFx0XHRcdFx0aWYgKHNlZy5pc0ZpcnN0KCkgfHwgc2VnLmlzTGFzdCgpKVxuXHRcdFx0XHRcdFx0Y2xvc2VkID0gc2VnLl9wYXRoLl9jbG9zZWQ7XG5cdFx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3Jvc3MgJiYgYnJhbmNoKSB7XG5cdFx0XHRcdFx0YnJhbmNoZXMucHVzaChicmFuY2gpO1xuXHRcdFx0XHRcdGJyYW5jaCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFicmFuY2gpIHtcblx0XHRcdFx0XHRpZiAoY3Jvc3MpXG5cdFx0XHRcdFx0XHRjcm9zc2luZ3MucHVzaChzZWcpO1xuXHRcdFx0XHRcdGJyYW5jaCA9IHtcblx0XHRcdFx0XHRcdHN0YXJ0OiBwYXRoLl9zZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRjcm9zc2luZ3M6IGNyb3NzaW5ncyxcblx0XHRcdFx0XHRcdHZpc2l0ZWQ6IHZpc2l0ZWQgPSBbXSxcblx0XHRcdFx0XHRcdGhhbmRsZUluOiBoYW5kbGVJblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNyb3NzKVxuXHRcdFx0XHRcdHNlZyA9IG90aGVyO1xuXHRcdFx0XHRpZiAoIWlzVmFsaWQoc2VnKSkge1xuXHRcdFx0XHRcdHBhdGgucmVtb3ZlU2VnbWVudHMoYnJhbmNoLnN0YXJ0KTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgayA9IHZpc2l0ZWQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2pdLl92aXNpdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZpc2l0ZWQubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRzZWcgPSBicmFuY2ggJiYgYnJhbmNoLmNyb3NzaW5ncy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0aWYgKCFzZWcgfHwgIXNlZy5fcGF0aCkge1xuXHRcdFx0XHRcdFx0XHRzZWcgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRicmFuY2ggPSBicmFuY2hlcy5wb3AoKTtcblx0XHRcdFx0XHRcdFx0aWYgKGJyYW5jaCkge1xuXHRcdFx0XHRcdFx0XHRcdHZpc2l0ZWQgPSBicmFuY2gudmlzaXRlZDtcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVJbiA9IGJyYW5jaC5oYW5kbGVJbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gd2hpbGUgKGJyYW5jaCAmJiAhaXNWYWxpZChzZWcpKTtcblx0XHRcdFx0XHRpZiAoIXNlZylcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBuZXh0ID0gc2VnLmdldE5leHQoKTtcblx0XHRcdFx0cGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgaGFuZGxlSW4sXG5cdFx0XHRcdFx0XHRuZXh0ICYmIHNlZy5faGFuZGxlT3V0KSk7XG5cdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdHZpc2l0ZWQucHVzaChzZWcpO1xuXHRcdFx0XHRzZWcgPSBuZXh0IHx8IHNlZy5fcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdFx0aGFuZGxlSW4gPSBuZXh0ICYmIG5leHQuX2hhbmRsZUluO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpbmlzaGVkKSB7XG5cdFx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKGhhbmRsZUluKTtcblx0XHRcdFx0XHRwYXRoLnNldENsb3NlZChjbG9zZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXRoLmdldEFyZWEoKSAhPT0gMCkge1xuXHRcdFx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZ2V0V2luZGluZzogZnVuY3Rpb24ocG9pbnQsIGRpciwgY2xvc2VkKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5nZXRDdXJ2ZXMoKSwgZGlyLCBjbG9zZWQpO1xuXHRcdH0sXG5cblx0XHR1bml0ZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAndW5pdGUnLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdpbnRlcnNlY3QnLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ3N1YnRyYWN0Jywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ2V4Y2x1ZGUnLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSlcblx0XHRcdFx0XHQ/IHNwbGl0Qm9vbGVhbih0aGlzLCBwYXRoLCAnZGl2aWRlJylcblx0XHRcdFx0XHQ6IGNyZWF0ZVJlc3VsdChbXG5cdFx0XHRcdFx0XHR0aGlzLnN1YnRyYWN0KHBhdGgsIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnNlY3QocGF0aCwgb3B0aW9ucylcblx0XHRcdFx0XHRdLCB0cnVlLCB0aGlzLCBwYXRoLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0cmVzb2x2ZUNyb3NzaW5nczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdFx0cGF0aHMgPSBjaGlsZHJlbiB8fCBbdGhpc107XG5cblx0XHRcdGZ1bmN0aW9uIGhhc092ZXJsYXAoc2VnLCBwYXRoKSB7XG5cdFx0XHRcdHZhciBpbnRlciA9IHNlZyAmJiBzZWcuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0cmV0dXJuIGludGVyICYmIGludGVyLl9vdmVybGFwICYmIGludGVyLl9wYXRoID09PSBwYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGFzT3ZlcmxhcHMgPSBmYWxzZSxcblx0XHRcdFx0aGFzQ3Jvc3NpbmdzID0gZmFsc2UsXG5cdFx0XHRcdGludGVyc2VjdGlvbnMgPSB0aGlzLmdldEludGVyc2VjdGlvbnMobnVsbCwgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpICYmIChoYXNPdmVybGFwcyA9IHRydWUpIHx8XG5cdFx0XHRcdFx0XHRcdGludGVyLmlzQ3Jvc3NpbmcoKSAmJiAoaGFzQ3Jvc3NpbmdzID0gdHJ1ZSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRjbGVhckN1cnZlcyA9IGhhc092ZXJsYXBzICYmIGhhc0Nyb3NzaW5ncyAmJiBbXTtcblx0XHRcdGludGVyc2VjdGlvbnMgPSBDdXJ2ZUxvY2F0aW9uLmV4cGFuZChpbnRlcnNlY3Rpb25zKTtcblx0XHRcdGlmIChoYXNPdmVybGFwcykge1xuXHRcdFx0XHR2YXIgb3ZlcmxhcHMgPSBkaXZpZGVMb2NhdGlvbnMoaW50ZXJzZWN0aW9ucywgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpO1xuXHRcdFx0XHR9LCBjbGVhckN1cnZlcyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBvdmVybGFwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHZhciBvdmVybGFwID0gb3ZlcmxhcHNbaV0sXG5cdFx0XHRcdFx0XHRwYXRoID0gb3ZlcmxhcC5fcGF0aCxcblx0XHRcdFx0XHRcdHNlZyA9IG92ZXJsYXAuX3NlZ21lbnQsXG5cdFx0XHRcdFx0XHRwcmV2ID0gc2VnLmdldFByZXZpb3VzKCksXG5cdFx0XHRcdFx0XHRuZXh0ID0gc2VnLmdldE5leHQoKTtcblx0XHRcdFx0XHRpZiAoaGFzT3ZlcmxhcChwcmV2LCBwYXRoKSAmJiBoYXNPdmVybGFwKG5leHQsIHBhdGgpKSB7XG5cdFx0XHRcdFx0XHRzZWcucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRwcmV2Ll9oYW5kbGVPdXQuX3NldCgwLCAwKTtcblx0XHRcdFx0XHRcdG5leHQuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG5cdFx0XHRcdFx0XHRpZiAocHJldiAhPT0gc2VnICYmICFwcmV2LmdldEN1cnZlKCkuaGFzTGVuZ3RoKCkpIHtcblx0XHRcdFx0XHRcdFx0bmV4dC5faGFuZGxlSW4uc2V0KHByZXYuX2hhbmRsZUluKTtcblx0XHRcdFx0XHRcdFx0cHJldi5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNDcm9zc2luZ3MpIHtcblx0XHRcdFx0ZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMsIGhhc092ZXJsYXBzICYmIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnZlMSA9IGludGVyLmdldEN1cnZlKCksXG5cdFx0XHRcdFx0XHRzZWcxID0gaW50ZXIuZ2V0U2VnbWVudCgpLFxuXHRcdFx0XHRcdFx0b3RoZXIgPSBpbnRlci5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdFx0Y3VydmUyID0gb3RoZXIuX2N1cnZlLFxuXHRcdFx0XHRcdFx0c2VnMiA9IG90aGVyLl9zZWdtZW50O1xuXHRcdFx0XHRcdGlmIChjdXJ2ZTEgJiYgY3VydmUyICYmIGN1cnZlMS5fcGF0aCAmJiBjdXJ2ZTIuX3BhdGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRpZiAoc2VnMSlcblx0XHRcdFx0XHRcdHNlZzEuX2ludGVyc2VjdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKHNlZzIpXG5cdFx0XHRcdFx0XHRzZWcyLl9pbnRlcnNlY3Rpb24gPSBudWxsO1xuXHRcdFx0XHR9LCBjbGVhckN1cnZlcyk7XG5cdFx0XHRcdGlmIChjbGVhckN1cnZlcylcblx0XHRcdFx0XHRjbGVhckN1cnZlSGFuZGxlcyhjbGVhckN1cnZlcyk7XG5cdFx0XHRcdHBhdGhzID0gdHJhY2VQYXRocyhCYXNlLmVhY2gocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdFx0XHRCYXNlLnB1c2godGhpcywgcGF0aC5fc2VnbWVudHMpO1xuXHRcdFx0XHR9LCBbXSkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcblx0XHRcdFx0aXRlbTtcblx0XHRcdGlmIChsZW5ndGggPiAxICYmIGNoaWxkcmVuKSB7XG5cdFx0XHRcdGlmIChwYXRocyAhPT0gY2hpbGRyZW4pXG5cdFx0XHRcdFx0dGhpcy5zZXRDaGlsZHJlbihwYXRocyk7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPT09IDEgJiYgIWNoaWxkcmVuKSB7XG5cdFx0XHRcdGlmIChwYXRoc1swXSAhPT0gdGhpcylcblx0XHRcdFx0XHR0aGlzLnNldFNlZ21lbnRzKHBhdGhzWzBdLnJlbW92ZVNlZ21lbnRzKCkpO1xuXHRcdFx0XHRpdGVtID0gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICghaXRlbSkge1xuXHRcdFx0XHRpdGVtID0gbmV3IENvbXBvdW5kUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdGl0ZW0uYWRkQ2hpbGRyZW4ocGF0aHMpO1xuXHRcdFx0XHRpdGVtID0gaXRlbS5yZWR1Y2UoKTtcblx0XHRcdFx0aXRlbS5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRcdFx0dGhpcy5yZXBsYWNlV2l0aChpdGVtKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0sXG5cblx0XHRyZW9yaWVudDogZnVuY3Rpb24obm9uWmVybywgY2xvY2t3aXNlKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5zZXRDaGlsZHJlbihyZW9yaWVudFBhdGhzKHRoaXMucmVtb3ZlQ2hpbGRyZW4oKSxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICEhKG5vblplcm8gPyB3IDogdyAmIDEpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSkpO1xuXHRcdFx0fSBlbHNlIGlmIChjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb2Nrd2lzZShjbG9ja3dpc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGdldEludGVyaW9yUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRcdGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHtcblx0XHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHRcdFx0aW50ZXJjZXB0cyA9IFtdLFxuXHRcdFx0XHRcdHJvb3RzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2ID0gY3VydmVzW2ldLmdldFZhbHVlcygpLFxuXHRcdFx0XHRcdFx0bzAgPSB2WzFdLFxuXHRcdFx0XHRcdFx0bzEgPSB2WzNdLFxuXHRcdFx0XHRcdFx0bzIgPSB2WzVdLFxuXHRcdFx0XHRcdFx0bzMgPSB2WzddO1xuXHRcdFx0XHRcdGlmICh5ID49IG1pbihvMCwgbzEsIG8yLCBvMykgJiYgeSA8PSBtYXgobzAsIG8xLCBvMiwgbzMpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbW9ub0N1cnZlcyA9IEN1cnZlLmdldE1vbm9DdXJ2ZXModik7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IG1vbm9DdXJ2ZXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtdiA9IG1vbm9DdXJ2ZXNbal0sXG5cdFx0XHRcdFx0XHRcdFx0bW8wID0gbXZbMV0sXG5cdFx0XHRcdFx0XHRcdFx0bW8zID0gbXZbN107XG5cdFx0XHRcdFx0XHRcdGlmICgobW8wICE9PSBtbzMpICYmXG5cdFx0XHRcdFx0XHRcdFx0KHkgPj0gbW8wICYmIHkgPD0gbW8zIHx8IHkgPj0gbW8zICYmIHkgPD0gbW8wKSl7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHggPSB5ID09PSBtbzAgPyBtdlswXVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB5ID09PSBtbzMgPyBtdls2XVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBDdXJ2ZS5zb2x2ZUN1YmljKG12LCAxLCB5LCByb290cywgMCwgMSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0PT09IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0PyBDdXJ2ZS5nZXRQb2ludChtdiwgcm9vdHNbMF0pLnhcblx0XHRcdFx0XHRcdFx0XHRcdFx0OiAobXZbMF0gKyBtdls2XSkgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdGludGVyY2VwdHMucHVzaCh4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW50ZXJjZXB0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0aW50ZXJjZXB0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblx0XHRcdFx0XHRwb2ludC54ID0gKGludGVyY2VwdHNbMF0gKyBpbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cdH07XG59KTtcblxudmFyIFBhdGhGbGF0dGVuZXIgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhGbGF0dGVuZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIGZsYXRuZXNzLCBtYXhSZWN1cnNpb24sIGlnbm9yZVN0cmFpZ2h0LCBtYXRyaXgpIHtcblx0XHR2YXIgY3VydmVzID0gW10sXG5cdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0bGVuZ3RoID0gMCxcblx0XHRcdG1pblNwYW4gPSAxIC8gKG1heFJlY3Vyc2lvbiB8fCAzMiksXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50c1swXSxcblx0XHRcdHNlZ21lbnQyO1xuXG5cdFx0ZnVuY3Rpb24gYWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBDdXJ2ZS5nZXRWYWx1ZXMoc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpO1xuXHRcdFx0Y3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0Y29tcHV0ZVBhcnRzKGN1cnZlLCBzZWdtZW50MS5faW5kZXgsIDAsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgaW5kZXgsIHQxLCB0Mikge1xuXHRcdFx0aWYgKCh0MiAtIHQxKSA+IG1pblNwYW5cblx0XHRcdFx0XHQmJiAhKGlnbm9yZVN0cmFpZ2h0ICYmIEN1cnZlLmlzU3RyYWlnaHQoY3VydmUpKVxuXHRcdFx0XHRcdCYmICFDdXJ2ZS5pc0ZsYXRFbm91Z2goY3VydmUsIGZsYXRuZXNzIHx8IDAuMjUpKSB7XG5cdFx0XHRcdHZhciBoYWx2ZXMgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUsIDAuNSksXG5cdFx0XHRcdFx0dE1pZCA9ICh0MSArIHQyKSAvIDI7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhoYWx2ZXNbMF0sIGluZGV4LCB0MSwgdE1pZCk7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhoYWx2ZXNbMV0sIGluZGV4LCB0TWlkLCB0Mik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZHggPSBjdXJ2ZVs2XSAtIGN1cnZlWzBdLFxuXHRcdFx0XHRcdGR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdFx0aWYgKGRpc3QgPiAwKSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdFx0cGFydHMucHVzaCh7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGxlbmd0aCxcblx0XHRcdFx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0XHRcdHRpbWU6IHQyLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50Mjtcblx0XHR9XG5cdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQyIHx8IHNlZ21lbnQxLCBzZWdtZW50c1swXSk7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBjdXJ2ZXM7XG5cdFx0dGhpcy5wYXJ0cyA9IHBhcnRzO1xuXHRcdHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHR9LFxuXG5cdF9nZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMucGFydHMsXG5cdFx0XHRsZW5ndGggPSBwYXJ0cy5sZW5ndGgsXG5cdFx0XHRzdGFydCxcblx0XHRcdGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKCFqIHx8IHBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHRcdGlmIChwYXJ0Lm9mZnNldCA+PSBvZmZzZXQpIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IGk7XG5cdFx0XHRcdHZhciBwcmV2ID0gcGFydHNbaSAtIDFdLFxuXHRcdFx0XHRcdHByZXZUaW1lID0gcHJldiAmJiBwcmV2LmluZGV4ID09PSBwYXJ0LmluZGV4ID8gcHJldi50aW1lIDogMCxcblx0XHRcdFx0XHRwcmV2T2Zmc2V0ID0gcHJldiA/IHByZXYub2Zmc2V0IDogMDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpbmRleDogcGFydC5pbmRleCxcblx0XHRcdFx0XHR0aW1lOiBwcmV2VGltZSArIChwYXJ0LnRpbWUgLSBwcmV2VGltZSlcblx0XHRcdFx0XHRcdCogKG9mZnNldCAtIHByZXZPZmZzZXQpIC8gKHBhcnQub2Zmc2V0IC0gcHJldk9mZnNldClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGluZGV4OiBwYXJ0c1tsZW5ndGggLSAxXS5pbmRleCxcblx0XHRcdHRpbWU6IDFcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXdQYXJ0OiBmdW5jdGlvbihjdHgsIGZyb20sIHRvKSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5fZ2V0KGZyb20pLFxuXHRcdFx0ZW5kID0gdGhpcy5fZ2V0KHRvKTtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQuaW5kZXgsIGwgPSBlbmQuaW5kZXg7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBDdXJ2ZS5nZXRQYXJ0KHRoaXMuY3VydmVzW2ldLFxuXHRcdFx0XHRcdGkgPT09IHN0YXJ0LmluZGV4ID8gc3RhcnQudGltZSA6IDAsXG5cdFx0XHRcdFx0aSA9PT0gZW5kLmluZGV4ID8gZW5kLnRpbWUgOiAxKTtcblx0XHRcdGlmIChpID09PSBzdGFydC5pbmRleClcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJ2ZVswXSwgY3VydmVbMV0pO1xuXHRcdFx0Y3R4LmJlemllckN1cnZlVG8uYXBwbHkoY3R4LCBjdXJ2ZS5zbGljZSgyKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goQ3VydmUuX2V2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHR2YXIgcGFyYW0gPSB0aGlzLl9nZXQob2Zmc2V0KTtcblx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh0aGlzLmN1cnZlc1twYXJhbS5pbmRleF0sIHBhcmFtLnRpbWUpO1xuXHRcdH07XG5cdH0sIHt9KVxuKTtcblxudmFyIFBhdGhGaXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMgPSBbXSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRjbG9zZWQgPSBwYXRoLl9jbG9zZWQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIHByZXYsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50O1xuXHRcdFx0aWYgKCFwcmV2IHx8ICFwcmV2LmVxdWFscyhwb2ludCkpIHtcblx0XHRcdFx0cG9pbnRzLnB1c2gocHJldiA9IHBvaW50LmNsb25lKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG5cdFx0fVxuXHRcdHRoaXMuY2xvc2VkID0gY2xvc2VkO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oZXJyb3IpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0c2VnbWVudHMgPSBudWxsO1xuXHRcdGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRzZWdtZW50cyA9IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXTtcblx0XHRcdGlmIChsZW5ndGggPiAxKSB7XG5cdFx0XHRcdHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCAwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRcdFx0cG9pbnRzWzFdLnN1YnRyYWN0KHBvaW50c1swXSksXG5cdFx0XHRcdFx0XHRwb2ludHNbbGVuZ3RoIC0gMl0uc3VidHJhY3QocG9pbnRzW2xlbmd0aCAtIDFdKSk7XG5cdFx0XHRcdGlmICh0aGlzLmNsb3NlZCkge1xuXHRcdFx0XHRcdHNlZ21lbnRzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0c2VnbWVudHMucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihzZWdtZW50cywgZXJyb3IsIGZpcnN0LCBsYXN0LCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT09IDEpIHtcblx0XHRcdHZhciBwdDEgPSBwb2ludHNbZmlyc3RdLFxuXHRcdFx0XHRwdDIgPSBwb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKHNlZ21lbnRzLCBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGRpc3QpKSxcblx0XHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGRpc3QpKSwgcHQyXSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB1UHJpbWUgPSB0aGlzLmNob3JkTGVuZ3RoUGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0KSxcblx0XHRcdG1heEVycm9yID0gTWF0aC5tYXgoZXJyb3IsIGVycm9yICogZXJyb3IpLFxuXHRcdFx0c3BsaXQsXG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdlbmVyYXRlQmV6aWVyKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpO1xuXHRcdFx0dmFyIG1heCA9IHRoaXMuZmluZE1heEVycm9yKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdVByaW1lKTtcblx0XHRcdGlmIChtYXguZXJyb3IgPCBlcnJvciAmJiBwYXJhbWV0ZXJzSW5PcmRlcikge1xuXHRcdFx0XHR0aGlzLmFkZEN1cnZlKHNlZ21lbnRzLCBjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuXHRcdFx0bWF4RXJyb3IgPSBtYXguZXJyb3I7XG5cdFx0fVxuXHRcdHZhciB0YW5DZW50ZXIgPSBwb2ludHNbc3BsaXQgLSAxXS5zdWJ0cmFjdChwb2ludHNbc3BsaXQgKyAxXSk7XG5cdFx0dGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIGZpcnN0LCBzcGxpdCwgdGFuMSwgdGFuQ2VudGVyKTtcblx0XHR0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG5cdH0sXG5cblx0YWRkQ3VydmU6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjdXJ2ZSkge1xuXHRcdHZhciBwcmV2ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdFx0cHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcblx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcblx0fSxcblxuXHRnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0cHQxID0gcG9pbnRzW2ZpcnN0XSxcblx0XHRcdHB0MiA9IHBvaW50c1tsYXN0XSxcblx0XHRcdEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuXHRcdFx0WCA9IFswLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHUgPSB1UHJpbWVbaV0sXG5cdFx0XHRcdHQgPSAxIC0gdSxcblx0XHRcdFx0YiA9IDMgKiB1ICogdCxcblx0XHRcdFx0YjAgPSB0ICogdCAqIHQsXG5cdFx0XHRcdGIxID0gYiAqIHQsXG5cdFx0XHRcdGIyID0gYiAqIHUsXG5cdFx0XHRcdGIzID0gdSAqIHUgKiB1LFxuXHRcdFx0XHRhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcblx0XHRcdFx0YTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG5cdFx0XHRcdHRtcCA9IHBvaW50c1tmaXJzdCArIGldXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0MS5tdWx0aXBseShiMCArIGIxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QocHQyLm11bHRpcGx5KGIyICsgYjMpKTtcblx0XHRcdENbMF1bMF0gKz0gYTEuZG90KGExKTtcblx0XHRcdENbMF1bMV0gKz0gYTEuZG90KGEyKTtcblx0XHRcdENbMV1bMF0gPSBDWzBdWzFdO1xuXHRcdFx0Q1sxXVsxXSArPSBhMi5kb3QoYTIpO1xuXHRcdFx0WFswXSArPSBhMS5kb3QodG1wKTtcblx0XHRcdFhbMV0gKz0gYTIuZG90KHRtcCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRldEMwQzEgPSBDWzBdWzBdICogQ1sxXVsxXSAtIENbMV1bMF0gKiBDWzBdWzFdLFxuXHRcdFx0YWxwaGExLFxuXHRcdFx0YWxwaGEyO1xuXHRcdGlmIChhYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHR2YXIgZGV0QzBYID0gQ1swXVswXSAqIFhbMV0gICAgLSBDWzFdWzBdICogWFswXSxcblx0XHRcdFx0ZGV0WEMxID0gWFswXSAgICAqIENbMV1bMV0gLSBYWzFdICAgICogQ1swXVsxXTtcblx0XHRcdGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG5cdFx0XHRhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcblx0XHRcdFx0YzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IGFicyhjMCkgPiBlcHNpbG9uID8gWFswXSAvIGMwXG5cdFx0XHRcdFx0XHRcdDogYWJzKGMxKSA+IGVwc2lsb24gPyBYWzFdIC8gYzFcblx0XHRcdFx0XHRcdFx0OiAwO1xuXHRcdH1cblxuXHRcdHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKSxcblx0XHRcdGVwcyA9IGVwc2lsb24gKiBzZWdMZW5ndGgsXG5cdFx0XHRoYW5kbGUxLFxuXHRcdFx0aGFuZGxlMjtcblx0XHRpZiAoYWxwaGExIDwgZXBzIHx8IGFscGhhMiA8IGVwcykge1xuXHRcdFx0YWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpbmUgPSBwdDIuc3VidHJhY3QocHQxKTtcblx0XHRcdGhhbmRsZTEgPSB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpO1xuXHRcdFx0aGFuZGxlMiA9IHRhbjIubm9ybWFsaXplKGFscGhhMik7XG5cdFx0XHRpZiAoaGFuZGxlMS5kb3QobGluZSkgLSBoYW5kbGUyLmRvdChsaW5lKSA+IHNlZ0xlbmd0aCAqIHNlZ0xlbmd0aCkge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdFx0XHRoYW5kbGUxID0gaGFuZGxlMiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtwdDEsXG5cdFx0XHRcdHB0MS5hZGQoaGFuZGxlMSB8fCB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpKSxcblx0XHRcdFx0cHQyLmFkZChoYW5kbGUyIHx8IHRhbjIubm9ybWFsaXplKGFscGhhMikpLFxuXHRcdFx0XHRwdDJdO1xuXHR9LFxuXG5cdHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSB1Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHVbaV0gPD0gdVtpIC0gMV0pXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuXHRcdHZhciBjdXJ2ZTEgPSBbXSxcblx0XHRcdGN1cnZlMiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuXHRcdFx0Y3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuXHRcdFx0cHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuXHRcdFx0cHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuXHRcdFx0ZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcblx0XHRcdGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oZGYpID8gdSA6IHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKGRlZ3JlZSwgY3VydmUsIHQpIHtcblx0XHR2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG5cdFx0XHRcdHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG1wWzBdO1xuXHR9LFxuXG5cdGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCkge1xuXHRcdHZhciB1ID0gWzBdO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdXG5cdFx0XHRcdFx0KyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcblx0XHRcdHVbaV0gLz0gdVttXTtcblx0XHR9XG5cdFx0cmV0dXJuIHU7XG5cdH0sXG5cblx0ZmluZE1heEVycm9yOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuXHRcdFx0bWF4RGlzdCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuXHRcdFx0dmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuXHRcdFx0dmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcblx0XHRcdHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55O1xuXHRcdFx0aWYgKGRpc3QgPj0gbWF4RGlzdCkge1xuXHRcdFx0XHRtYXhEaXN0ID0gZGlzdDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXJyb3I6IG1heERpc3QsXG5cdFx0XHRpbmRleDogaW5kZXhcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFRleHRJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUZXh0SXRlbScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNPcHRpb25zOiB7IHN0cm9rZTogZmFsc2UsIGhhbmRsZTogZmFsc2UgfSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJyc7XG5cdFx0dGhpcy5fbGluZXMgPSBbXTtcblx0XHR2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0JiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0Q29udGVudChzb3VyY2UuX2NvbnRlbnQpO1xuXHR9LFxuXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuXHRcdHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXHRcdHRoaXMuX2NoYW5nZWQoNTIxKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0Z2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cblx0Z2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbn0pO1xuXG52YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG5cdFx0VGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXHRcdHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcblx0XHRjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcblx0XHRcdGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0d2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcblx0XHRcdHggPSAwO1xuXHRcdGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpXG5cdFx0XHR4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMjogMSk7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCkgOiByZWN0O1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0Z3JheTogWydncmF5J10sXG5cdFx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdFx0aHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcblx0XHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdFx0Z3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG5cdH07XG5cblx0dmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcblx0XHRuYW1lZENvbG9ycyA9IHtcblx0XHRcdHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF1cblx0XHR9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKFxuXHRcdFx0XHQvXiMoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pPyQvaVxuXHRcdFx0KSB8fCBzdHJpbmcubWF0Y2goXG5cdFx0XHRcdC9eIyhbXFxkYS1mXSkoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSk/JC9pXG5cdFx0XHQpLFxuXHRcdFx0dHlwZSA9ICdyZ2InLFxuXHRcdFx0Y29tcG9uZW50cztcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdHZhciBhbW91bnQgPSBtYXRjaFs0XSA/IDQgOiAzO1xuXHRcdFx0Y29tcG9uZW50cyA9IG5ldyBBcnJheShhbW91bnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuXHRcdFx0XHRcdFx0PyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKHJnYnxoc2wpYT9cXCgoLiopXFwpJC8pKSB7XG5cdFx0XHR0eXBlID0gbWF0Y2hbMV07XG5cdFx0XHRjb21wb25lbnRzID0gbWF0Y2hbMl0udHJpbSgpLnNwbGl0KC9bLFxcc10rL2cpO1xuXHRcdFx0dmFyIGlzSFNMID0gdHlwZSA9PT0gJ2hzbCc7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGNvbXBvbmVudHMubGVuZ3RoLCA0KTsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdChjb21wb25lbnQpO1xuXHRcdFx0XHRpZiAoaXNIU0wpIHtcblx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dmFyIHVuaXQgPSBjb21wb25lbnQubWF0Y2goLyhbYS16XSopJC8pWzFdO1xuXHRcdFx0XHRcdFx0dmFsdWUgKj0gKHtcblx0XHRcdFx0XHRcdFx0dHVybjogMzYwLFxuXHRcdFx0XHRcdFx0XHRyYWQ6IDE4MCAvIE1hdGguUEksXG5cdFx0XHRcdFx0XHRcdGdyYWQ6IDAuOVxuXHRcdFx0XHRcdFx0fVt1bml0XSB8fCAxKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPCAzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPCAzKSB7XG5cdFx0XHRcdFx0dmFsdWUgLz0gLyUkLy50ZXN0KGNvbXBvbmVudCkgPyAxMDAgOiAyNTU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY29sb3IgPSBuYW1lZENvbG9yc1tzdHJpbmddO1xuXHRcdFx0aWYgKCFjb2xvcikge1xuXHRcdFx0XHRpZiAod2luZG93KSB7XG5cdFx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdFx0Y29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0XHRcdFx0Y29sb3JDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gc3RyaW5nO1xuXHRcdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRcdHZhciBkYXRhID0gY29sb3JDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG5cdFx0XHRcdFx0Y29sb3IgPSBuYW1lZENvbG9yc1tzdHJpbmddID0gW1xuXHRcdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRcdGRhdGFbMV0gLyAyNTUsXG5cdFx0XHRcdFx0XHRkYXRhWzJdIC8gMjU1XG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb2xvciA9IFswLCAwLCAwXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLnNsaWNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBbdHlwZSwgY29tcG9uZW50c107XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sXG5cdFx0WzIsIDAsIDFdLFxuXHRcdFsxLCAwLCAzXSxcblx0XHRbMSwgMiwgMF0sXG5cdFx0WzMsIDEsIDBdLFxuXHRcdFswLCAxLCAyXVxuXHRdO1xuXG5cdHZhciBjb252ZXJ0ZXJzID0ge1xuXHRcdCdyZ2ItaHNiJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGggPSBkZWx0YSA9PT0gMCA/IDBcblx0XHRcdFx0XHQ6ICAgKCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDogICAgICAgICAgICAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSxcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogKDEgLSBmKSlcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcblx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMixcblx0XHRcdFx0cyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNVxuXHRcdFx0XHRcdFx0PyBkZWx0YSAvIChtYXggKyBtaW4pXG5cdFx0XHRcdFx0XHQ6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHRcdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0XHR9LFxuXG5cdFx0J2hzbC1yZ2InOiBmdW5jdGlvbihoLCBzLCBsKSB7XG5cdFx0XHRoID0gKCgoaCAvIDM2MCkgJSAxKSArIDEpICUgMTtcblx0XHRcdGlmIChzID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdFx0dmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcblx0XHRcdFx0dDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuXHRcdFx0XHR0MSA9IDIgKiBsIC0gdDIsXG5cdFx0XHRcdGMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB0MyA9IHQzc1tpXTtcblx0XHRcdFx0aWYgKHQzIDwgMCkgdDMgKz0gMTtcblx0XHRcdFx0aWYgKHQzID4gMSkgdDMgLT0gMTtcblx0XHRcdFx0Y1tpXSA9IDYgKiB0MyA8IDFcblx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG5cdFx0XHRcdFx0OiAyICogdDMgPCAxXG5cdFx0XHRcdFx0XHQ/IHQyXG5cdFx0XHRcdFx0XHQ6IDMgKiB0MyA8IDJcblx0XHRcdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuXHRcdFx0XHRcdFx0XHQ6IHQxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JheSc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG5cdFx0fSxcblxuXHRcdCdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbZywgZywgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzbCc6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0XHRjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG5cdFx0QmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0aGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG5cdFx0XHRcdHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdD8gbmFtZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0PyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudCA9IHRoaXMuX2NvbXBvbmVudHNbMF07XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gR3JhZGllbnQucmVhZChcblx0XHRcdFx0XHRcdFx0XHRBcnJheS5pc0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudClcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuX3JlbW92ZU93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlLl9hZGRPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSA/IDAgOiArdmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdHx8IGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2NvbnZlcnQodHlwZSlbaW5kZXhdO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09IHR5cGVcblx0XHRcdFx0XHRcdCYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9O1xuXHRcdH0sIHRoaXMpO1xuXHR9LCB7XG5cdFx0X2NsYXNzOiAnQ29sb3InLFxuXHRcdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb2xvcihhcmcpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWFkaW5nID0gdGhpcy5fX3JlYWQsXG5cdFx0XHRcdHJlYWQgPSAwLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRhcmdzID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuXHRcdFx0XHR0eXBlID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzFdO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZztcblx0XHRcdFx0XHRhbHBoYSA9IGFyZ3NbMl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdFx0XHRhcmdzID0gQmFzZS5zbGljZShhcmdzLCAxKTtcblx0XHRcdFx0XHRhcmdUeXBlID0gdHlwZW9mIGFyZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHZhbHVlcyA9IGFyZ1R5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGFyZ3Ncblx0XHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ29iamVjdCcgJiYgYXJnLmxlbmd0aCAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0XHRcdGlmICghdHlwZSlcblx0XHRcdFx0XHRcdHR5cGUgPSB2YWx1ZXMubGVuZ3RoID49IDNcblx0XHRcdFx0XHRcdFx0XHQ/ICdyZ2InXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheSc7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHR5cGVzW3R5cGVdLmxlbmd0aDtcblx0XHRcdFx0XHRhbHBoYSA9IHZhbHVlc1tsZW5ndGhdO1xuXHRcdFx0XHRcdGlmIChyZWFkaW5nKSB7XG5cdFx0XHRcdFx0XHRyZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdD8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcblx0XHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aClcblx0XHRcdFx0XHRcdHZhbHVlcyA9IEJhc2Uuc2xpY2UodmFsdWVzLCAwLCBsZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnZlcnRlZCA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHR0eXBlID0gY29udmVydGVkWzBdO1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBjb252ZXJ0ZWRbMV07XG5cdFx0XHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gYXJnLl90eXBlO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuX2FscGhhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gYXJncztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdodWUnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHQ/ICdsaWdodG5lc3MnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2hzbCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdoc2InXG5cdFx0XHRcdFx0XHRcdDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdHx8ICdyYWRpYWwnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyAnZ3JheSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJ3JnYic7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdFx0XHRwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgIWkgJiYgdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdFx0JiYgJ3N0b3BzJyBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0b3BzOiBhcmcuc3RvcHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRyYWRpYWw6IGFyZy5yYWRpYWxcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuYWxwaGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWFkaW5nICYmIHR5cGUpXG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHR2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0c2V0OiAnI2luaXRpYWxpemUnLFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLmdldENvbXBvbmVudHMoKTtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShcblx0XHRcdFx0XHQvXihncmF5fHJnYikkLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IGNvbXBvbmVudHNcblx0XHRcdFx0XHRcdDogW3RoaXMuX3R5cGVdLmNvbmNhdChjb21wb25lbnRzKSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9LFxuXG5cdFx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX293bmVyKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zZXR0ZXIpIHtcblx0XHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLmdldEFscGhhKCkgPT09IGNvbC5nZXRBbHBoYSgpXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fY2FudmFzU3R5bGUpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZTtcblx0XHRcdGlmICh0aGlzLl90eXBlICE9PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGdyYWRpZW50ID0gY29tcG9uZW50c1swXSxcblx0XHRcdFx0c3RvcHMgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29tcG9uZW50c1syXSxcblx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXSxcblx0XHRcdFx0aW52ZXJzZSA9IG1hdHJpeCAmJiBtYXRyaXguaW52ZXJ0ZWQoKSxcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQ7XG5cdFx0XHRpZiAoaW52ZXJzZSkge1xuXHRcdFx0XHRvcmlnaW4gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChvcmlnaW4pO1xuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGludmVyc2UuX3RyYW5zZm9ybVBvaW50KGRlc3RpbmF0aW9uKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodClcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChoaWdobGlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbik7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdG9mZnNldCA9IHN0b3AuX29mZnNldDtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID09IG51bGwgPyBpIC8gKGwgLSAxKSA6IG9mZnNldCxcblx0XHRcdFx0XHRcdHN0b3AuX2NvbG9yLnRvQ2FudmFzU3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSBjYW52YXNHcmFkaWVudDtcblx0XHR9LFxuXG5cdFx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0X3R5cGVzOiB0eXBlcyxcblxuXHRcdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHJhbmRvbSgpLCByYW5kb20oKSwgcmFuZG9tKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldE93bmVyOiBmdW5jdGlvbihjb2xvciwgb3duZXIsIHNldHRlcikge1xuXHRcdFx0XHRpZiAoY29sb3IpIHtcblx0XHRcdFx0XHRpZiAoY29sb3IuX293bmVyICYmIG93bmVyICYmIGNvbG9yLl9vd25lciAhPT0gb3duZXIpIHtcblx0XHRcdFx0XHRcdGNvbG9yID0gY29sb3IuY2xvbmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFjb2xvci5fb3duZXIgXiAhb3duZXIpIHtcblx0XHRcdFx0XHRcdGNvbG9yLl9vd25lciA9IG93bmVyIHx8IG51bGw7XG5cdFx0XHRcdFx0XHRjb2xvci5fc2V0dGVyID0gc2V0dGVyIHx8IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb2xvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICsgYjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICogYjtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAvIGI7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbihvcGVyYXRvciwgbmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Y29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuXHRcdFx0XHRcdHRoaXMuX2FscGhhICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcblx0XHRcdFx0XHRcdFx0OiBudWxsKTtcblx0XHR9O1xuXHR9LCB7XG5cdH0pO1xufSk7XG5cbnZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcblx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHRpZiAoc3RvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHN0b3BzKSkge1xuXHRcdFx0dGhpcy5zZXQoc3RvcHMpO1xuXHRcdFx0c3RvcHMgPSByYWRpYWwgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fc3RvcHMgPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zZXRTdG9wcyhzdG9wcyB8fCBbJ3doaXRlJywgJ2JsYWNrJ10pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fcmFkaWFsID09IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0UmFkaWFsKHR5cGVvZiByYWRpYWwgPT09ICdzdHJpbmcnICYmIHJhZGlhbCA9PT0gJ3JhZGlhbCdcblx0XHRcdFx0XHR8fCByYWRpYWwgfHwgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fb3duZXJzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRpZiAoIXRoaXMuX293bmVycylcblx0XHRcdHRoaXMuX293bmVycyA9IFtdO1xuXHRcdHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcblx0fSxcblxuXHRfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICghdGhpcy5fb3duZXJzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0b3BzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcywgdGhpcy5fcmFkaWFsKTtcblx0fSxcblxuXHRnZXRTdG9wczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0b3BzO1xuXHR9LFxuXG5cdHNldFN0b3BzOiBmdW5jdGlvbihzdG9wcykge1xuXHRcdGlmIChzdG9wcy5sZW5ndGggPCAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcblx0XHR9XG5cdFx0dmFyIF9zdG9wcyA9IHRoaXMuX3N0b3BzO1xuXHRcdGlmIChfc3RvcHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0X3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0X3N0b3BzID0gdGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZExpc3Qoc3RvcHMsIDAsIHsgY2xvbmU6IHRydWUgfSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBfc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0X3N0b3BzW2ldLl9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhZGlhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGlhbDtcblx0fSxcblxuXHRzZXRSYWRpYWw6IGZ1bmN0aW9uKHJhZGlhbCkge1xuXHRcdHRoaXMuX3JhZGlhbCA9IHJhZGlhbDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihncmFkaWVudCkge1xuXHRcdGlmIChncmFkaWVudCA9PT0gdGhpcylcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGlmIChncmFkaWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gZ3JhZGllbnQuX2NsYXNzKSB7XG5cdFx0XHR2YXIgc3RvcHMxID0gdGhpcy5fc3RvcHMsXG5cdFx0XHRcdHN0b3BzMiA9IGdyYWRpZW50Ll9zdG9wcyxcblx0XHRcdFx0bGVuZ3RoID0gc3RvcHMxLmxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPT09IHN0b3BzMi5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICghc3RvcHMxW2ldLmVxdWFscyhzdG9wczJbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIGNvbG9yID0gYXJnMCxcblx0XHRcdG9mZnNldCA9IGFyZzE7XG5cdFx0aWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiBhcmcxID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApICYmIHR5cGVvZiBhcmcwWzBdICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjb2xvciA9IGFyZzBbMF07XG5cdFx0XHRcdG9mZnNldCA9IGFyZzBbMV07XG5cdFx0XHR9IGVsc2UgaWYgKCdjb2xvcicgaW4gYXJnMCB8fCAnb2Zmc2V0JyBpbiBhcmcwXG5cdFx0XHRcdFx0fHwgJ3JhbXBQb2ludCcgaW4gYXJnMCkge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdG9mZnNldCA9IGFyZzAub2Zmc2V0IHx8IGFyZzAucmFtcFBvaW50IHx8IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2V0Q29sb3IoY29sb3IpO1xuXHRcdHRoaXMuc2V0T2Zmc2V0KG9mZnNldCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgR3JhZGllbnRTdG9wKHRoaXMuX2NvbG9yLmNsb25lKCksIHRoaXMuX29mZnNldCk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuX2NvbG9yLFxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShvZmZzZXQgPT0gbnVsbCA/IFtjb2xvcl0gOiBbY29sb3IsIG9mZnNldF0sXG5cdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCgxMjkpO1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29mZnNldDtcblx0fSxcblxuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHRoaXMuX29mZnNldCA9IG9mZnNldDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFtcFBvaW50OiAnI2dldE9mZnNldCcsXG5cdHNldFJhbXBQb2ludDogJyNzZXRPZmZzZXQnLFxuXG5cdGdldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3I7XG5cdH0sXG5cblx0c2V0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdENvbG9yLl9zZXRPd25lcih0aGlzLl9jb2xvciwgbnVsbCk7XG5cdFx0dGhpcy5fY29sb3IgPSBDb2xvci5fc2V0T3duZXIoQ29sb3IucmVhZChhcmd1bWVudHMsIDApLCB0aGlzLFxuXHRcdFx0XHQnc2V0Q29sb3InKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9vZmZzZXQgPT0gc3RvcC5fb2Zmc2V0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaXRlbURlZmF1bHRzID0ge1xuXHRcdGZpbGxDb2xvcjogbnVsbCxcblx0XHRmaWxsUnVsZTogJ25vbnplcm8nLFxuXHRcdHN0cm9rZUNvbG9yOiBudWxsLFxuXHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRcdHN0cm9rZUpvaW46ICdtaXRlcicsXG5cdFx0c3Ryb2tlU2NhbGluZzogdHJ1ZSxcblx0XHRtaXRlckxpbWl0OiAxMCxcblx0XHRkYXNoT2Zmc2V0OiAwLFxuXHRcdGRhc2hBcnJheTogW10sXG5cdFx0c2hhZG93Q29sb3I6IG51bGwsXG5cdFx0c2hhZG93Qmx1cjogMCxcblx0XHRzaGFkb3dPZmZzZXQ6IG5ldyBQb2ludCgpLFxuXHRcdHNlbGVjdGVkQ29sb3I6IG51bGxcblx0fSxcblx0Z3JvdXBEZWZhdWx0cyA9IEJhc2Uuc2V0KHt9LCBpdGVtRGVmYXVsdHMsIHtcblx0XHRmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG5cdFx0Zm9udFdlaWdodDogJ25vcm1hbCcsXG5cdFx0Zm9udFNpemU6IDEyLFxuXHRcdGxlYWRpbmc6IG51bGwsXG5cdFx0anVzdGlmaWNhdGlvbjogJ2xlZnQnXG5cdH0pLFxuXHR0ZXh0RGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgZ3JvdXBEZWZhdWx0cywge1xuXHRcdGZpbGxDb2xvcjogbmV3IENvbG9yKClcblx0fSksXG5cdGZsYWdzID0ge1xuXHRcdHN0cm9rZVdpZHRoOiAxOTMsXG5cdFx0c3Ryb2tlQ2FwOiAxOTMsXG5cdFx0c3Ryb2tlSm9pbjogMTkzLFxuXHRcdHN0cm9rZVNjYWxpbmc6IDIwMSxcblx0XHRtaXRlckxpbWl0OiAxOTMsXG5cdFx0Zm9udEZhbWlseTogOSxcblx0XHRmb250V2VpZ2h0OiA5LFxuXHRcdGZvbnRTaXplOiA5LFxuXHRcdGZvbnQ6IDksXG5cdFx0bGVhZGluZzogOSxcblx0XHRqdXN0aWZpY2F0aW9uOiA5XG5cdH0sXG5cdGl0ZW0gPSB7XG5cdFx0YmVhbnM6IHRydWVcblx0fSxcblx0ZmllbGRzID0ge1xuXHRcdF9jbGFzczogJ1N0eWxlJyxcblx0XHRiZWFuczogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN0eWxlKHN0eWxlLCBfb3duZXIsIF9wcm9qZWN0KSB7XG5cdFx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHRcdHRoaXMuX293bmVyID0gX293bmVyO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IF9vd25lciAmJiBfb3duZXIuX3Byb2plY3QgfHwgX3Byb2plY3Rcblx0XHRcdFx0XHR8fCBwYXBlci5wcm9qZWN0O1xuXHRcdFx0dGhpcy5fZGVmYXVsdHMgPSAhX293bmVyIHx8IF9vd25lciBpbnN0YW5jZW9mIEdyb3VwID8gZ3JvdXBEZWZhdWx0c1xuXHRcdFx0XHRcdDogX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0gPyB0ZXh0RGVmYXVsdHNcblx0XHRcdFx0XHQ6IGl0ZW1EZWZhdWx0cztcblx0XHRcdGlmIChzdHlsZSlcblx0XHRcdFx0dGhpcy5zZXQoc3R5bGUpO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goZ3JvdXBEZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdHZhciBpc0NvbG9yID0gL0NvbG9yJC8udGVzdChrZXkpLFxuXHRcdFx0aXNQb2ludCA9IGtleSA9PT0gJ3NoYWRvd09mZnNldCcsXG5cdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRmbGFnID0gZmxhZ3Nba2V5XSxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydCxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydDtcblxuXHRcdGZpZWxkc1tzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0YXBwbHlUb0NoaWxkcmVuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpO1xuXHRcdFx0aWYgKGFwcGx5VG9DaGlsZHJlbikge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGtleSA9PT0gJ3NlbGVjdGVkQ29sb3InIHx8ICFhcHBseVRvQ2hpbGRyZW4pXG5cdFx0XHRcdFx0JiYga2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKG9sZCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNDb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKG9sZCkge1xuXHRcdFx0XHRcdFx0XHRDb2xvci5fc2V0T3duZXIob2xkLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0b2xkLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gQ29sb3IuX3NldE93bmVyKHZhbHVlLCBvd25lcixcblx0XHRcdFx0XHRcdFx0XHRcdGFwcGx5VG9DaGlsZHJlbiAmJiBzZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgMTI5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0YXBwbHlUb0NoaWxkcmVuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmIChhcHBseVRvQ2hpbGRyZW4gJiYgIV9kb250TWVyZ2UpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cdFx0XHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGNoaWxkVmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKSB7XG5cdFx0XHRcdHZhbHVlID0gQ29sb3IuX3NldE93bmVyKHZhbHVlLCBvd25lciwgYXBwbHlUb0NoaWxkcmVuICYmIHNldCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZVtnZXRdKF9kb250TWVyZ2UpO1xuXHRcdH07XG5cblx0XHRpdGVtW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0fTtcblx0fSk7XG5cblx0QmFzZS5lYWNoKHtcblx0XHRGb250OiAnRm9udEZhbWlseScsXG5cdFx0V2luZGluZ1J1bGU6ICdGaWxsUnVsZSdcblx0fSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdHZhciBnZXQgPSAnZ2V0JyArIGtleSxcblx0XHRcdHNldCA9ICdzZXQnICsga2V5O1xuXHRcdGZpZWxkc1tnZXRdID0gaXRlbVtnZXRdID0gJyNnZXQnICsgdmFsdWU7XG5cdFx0ZmllbGRzW3NldF0gPSBpdGVtW3NldF0gPSAnI3NldCcgKyB2YWx1ZTtcblx0fSk7XG5cblx0SXRlbS5pbmplY3QoaXRlbSk7XG5cdHJldHVybiBmaWVsZHM7XG59LCB7XG5cdHNldDogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR2YXIgaXNTdHlsZSA9IHN0eWxlIGluc3RhbmNlb2YgU3R5bGUsXG5cdFx0XHR2YWx1ZXMgPSBpc1N0eWxlID8gc3R5bGUuX3ZhbHVlcyA6IHN0eWxlO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlICYmIGlzU3R5bGUgJiYgdmFsdWUuY2xvbmVcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdGZ1bmN0aW9uIGNvbXBhcmUoc3R5bGUxLCBzdHlsZTIsIHNlY29uZGFyeSkge1xuXHRcdFx0dmFyIHZhbHVlczEgPSBzdHlsZTEuX3ZhbHVlcyxcblx0XHRcdFx0dmFsdWVzMiA9IHN0eWxlMi5fdmFsdWVzLFxuXHRcdFx0XHRkZWZhdWx0czIgPSBzdHlsZTIuX2RlZmF1bHRzO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlczEpIHtcblx0XHRcdFx0dmFyIHZhbHVlMSA9IHZhbHVlczFba2V5XSxcblx0XHRcdFx0XHR2YWx1ZTIgPSB2YWx1ZXMyW2tleV07XG5cdFx0XHRcdGlmICghKHNlY29uZGFyeSAmJiBrZXkgaW4gdmFsdWVzMikgJiYgIUJhc2UuZXF1YWxzKHZhbHVlMSxcblx0XHRcdFx0XHRcdHZhbHVlMiA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdHMyW2tleV0gOiB2YWx1ZTIpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHlsZSA9PT0gdGhpcyB8fCBzdHlsZSAmJiB0aGlzLl9jbGFzcyA9PT0gc3R5bGUuX2NsYXNzXG5cdFx0XHRcdCYmIGNvbXBhcmUodGhpcywgc3R5bGUpXG5cdFx0XHRcdCYmIGNvbXBhcmUoc3R5bGUsIHRoaXMsIHRydWUpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdF9kaXNwb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sb3I7XG5cdFx0Y29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuXHRcdGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcblx0XHRpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0Y29sb3IgPSB0aGlzLmdldFNoYWRvd0NvbG9yKCk7XG5cdFx0aWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdFx0cmV0dXJuICEhY29sb3IgJiYgY29sb3IuYWxwaGEgPiAwO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTdHJva2VDb2xvcigpO1xuXHRcdHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMCAmJiB0aGlzLmdldFN0cm9rZVdpZHRoKCkgPiAwO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMCAmJiAodGhpcy5nZXRTaGFkb3dCbHVyKCkgPiAwXG5cdFx0XHRcdHx8ICF0aGlzLmdldFNoYWRvd09mZnNldCgpLmlzWmVybygpKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRnZXRGb250U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRGb250V2VpZ2h0KClcblx0XHRcdFx0KyAnICcgKyBmb250U2l6ZSArICgvW2Etel0vaS50ZXN0KGZvbnRTaXplICsgJycpID8gJyAnIDogJ3B4ICcpXG5cdFx0XHRcdCsgdGhpcy5nZXRGb250RmFtaWx5KCk7XG5cdH0sXG5cblx0Z2V0Rm9udDogJyNnZXRGb250RmFtaWx5Jyxcblx0c2V0Rm9udDogJyNzZXRGb250RmFtaWx5JyxcblxuXHRnZXRMZWFkaW5nOiBmdW5jdGlvbiBnZXRMZWFkaW5nKCkge1xuXHRcdHZhciBsZWFkaW5nID0gZ2V0TGVhZGluZy5iYXNlLmNhbGwodGhpcyksXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRpZiAoL3B0fGVtfCV8cHgvLnRlc3QoZm9udFNpemUpKVxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldFZpZXcoKS5nZXRQaXhlbFNpemUoZm9udFNpemUpO1xuXHRcdHJldHVybiBsZWFkaW5nICE9IG51bGwgPyBsZWFkaW5nIDogZm9udFNpemUgKiAxLjI7XG5cdH1cblxufSk7XG5cbnZhciBEb21FbGVtZW50ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHNldCwgdmFsdWUpIHtcblx0XHR2YXIgcHJlZml4ZXMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01veicsICdtcycsICdvJ10sXG5cdFx0XHRzdWZmaXggPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0dmFyIHByZWZpeCA9IHByZWZpeGVzW2ldLFxuXHRcdFx0XHRrZXkgPSBwcmVmaXggPyBwcmVmaXggKyBzdWZmaXggOiBuYW1lO1xuXHRcdFx0aWYgKGtleSBpbiBlbCkge1xuXHRcdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdFx0ZWxba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0U3R5bGVzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsICYmIGVsLm5vZGVUeXBlICE9PSA5ID8gZWwub3duZXJEb2N1bWVudCA6IGVsLFxuXHRcdFx0XHR2aWV3ID0gZG9jICYmIGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdHJldHVybiB2aWV3ICYmIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdGJvZHkgPSBkb2MuYm9keSxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRcdHJlY3Q7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlY3QgPSB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSByZWN0LmxlZnQgLSAoaHRtbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcblx0XHRcdFx0eSA9IHJlY3QudG9wIC0gKGh0bWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDApO1xuXHRcdFx0aWYgKCF2aWV3cG9ydCkge1xuXHRcdFx0XHR2YXIgdmlldyA9IGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdFx0eCArPSB2aWV3LnBhZ2VYT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRcdHkgKz0gdmlldy5wYWdlWU9mZnNldCB8fCBodG1sLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0dmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLFxuXHRcdFx0XHR2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0dmlldy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdmlld3BvcnQpLmdldFBvaW50KCk7XG5cdFx0fSxcblxuXHRcdGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcblx0XHR9LFxuXG5cdFx0aXNJbnZpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRTaXplKGVsKS5lcXVhbHMobmV3IFNpemUoMCwgMCkpO1xuXHRcdH0sXG5cblx0XHRpc0luVmlldzogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiAhRG9tRWxlbWVudC5pc0ludmlzaWJsZShlbClcblx0XHRcdFx0XHQmJiBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsKS5pbnRlcnNlY3RzKFxuXHRcdFx0XHRcdFx0RG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpKTtcblx0XHR9LFxuXG5cdFx0aXNJbnNlcnRlZDogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKTtcblx0XHR9LFxuXG5cdFx0Z2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZWwgJiYgaGFuZGxlUHJlZml4KGVsLCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0c2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbmFtZSlcblx0XHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIGtleSwgdHJ1ZSwgbmFtZVtrZXldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZVByZWZpeChlbCwgbmFtZSwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbnZhciBEb21FdmVudCA9IHtcblx0YWRkOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBwYXJ0c1tpXTtcblx0XHRcdFx0XHR2YXIgb3B0aW9ucyA9IChcblx0XHRcdFx0XHRcdGVsID09PSBkb2N1bWVudFxuXHRcdFx0XHRcdFx0JiYgKG5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBuYW1lID09PSAndG91Y2htb3ZlJylcblx0XHRcdFx0XHQpID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XG5cdFx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuXHRcdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlc1xuXHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoXG5cdFx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzWzBdXG5cdFx0XHRcdFx0OiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuXHRcdFx0XHQ6IGV2ZW50O1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb3MucGFnZVggfHwgcG9zLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcblx0XHRcdHBvcy5wYWdlWSB8fCBwb3MuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Bcblx0XHQpO1xuXHR9LFxuXG5cdGdldFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UmVsYXRlZFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihldmVudCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldFBvaW50KGV2ZW50KS5zdWJ0cmFjdChEb21FbGVtZW50LmdldE9mZnNldChcblx0XHRcdFx0dGFyZ2V0IHx8IERvbUV2ZW50LmdldFRhcmdldChldmVudCkpKTtcblx0fVxufTtcblxuRG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbmF0aXZlUmVxdWVzdCA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQod2luZG93LCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyksXG5cdFx0cmVxdWVzdGVkID0gZmFsc2UsXG5cdFx0Y2FsbGJhY2tzID0gW10sXG5cdFx0dGltZXI7XG5cblx0ZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2tzKCkge1xuXHRcdHZhciBmdW5jdGlvbnMgPSBjYWxsYmFja3M7XG5cdFx0Y2FsbGJhY2tzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBmdW5jdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0ZnVuY3Rpb25zW2ldKCk7XG5cdFx0cmVxdWVzdGVkID0gbmF0aXZlUmVxdWVzdCAmJiBjYWxsYmFja3MubGVuZ3RoO1xuXHRcdGlmIChyZXF1ZXN0ZWQpXG5cdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U2l6ZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudFtuYW1lXSB8fCBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSwgMTApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENhbnZhc1NpemUoKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdHJldHVybiBzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKVxuXHRcdFx0XHRcdD8gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpXG5cdFx0XHRcdFx0OiBzaXplO1xuXHRcdH1cblxuXHRcdHZhciBzaXplO1xuXHRcdGlmICh3aW5kb3cgJiYgZWxlbWVudCkge1xuXHRcdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRcdGlmICh0aGlzLl9pZCA9PSBudWxsKVxuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCA9ICdwYXBlci12aWV3LScgKyBWaWV3Ll9pZCsrKTtcblx0XHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHRcdHZhciBub25lID0gJ25vbmUnO1xuXHRcdFx0RG9tRWxlbWVudC5zZXRQcmVmaXhlZChlbGVtZW50LnN0eWxlLCB7XG5cdFx0XHRcdHVzZXJEcmFnOiBub25lLFxuXHRcdFx0XHR1c2VyU2VsZWN0OiBub25lLFxuXHRcdFx0XHR0b3VjaENhbGxvdXQ6IG5vbmUsXG5cdFx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0XHR0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyA9IHtcblx0XHRcdFx0XHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhhdC5zZXRWaWV3U2l6ZShnZXRDYW52YXNTaXplKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHNpemUgPSBnZXRDYW52YXNTaXplKCk7XG5cblx0XHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAnc3RhdHMnKVxuXHRcdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0dGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcblx0XHRcdFx0dmFyIHN0YXRzID0gdGhpcy5fc3RhdHMuZG9tRWxlbWVudCxcblx0XHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRcdG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRcdHN0eWxlLnRvcCA9IG9mZnNldC55ICsgJ3B4Jztcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShlbGVtZW50KTtcblx0XHRcdGVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHR0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdGlmICghdGhpcy5fcGl4ZWxSYXRpbylcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0XHR0aGlzLl9zZXRFbGVtZW50U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fdmlld1NpemUgPSBzaXplO1xuXHRcdFZpZXcuX3ZpZXdzLnB1c2godGhpcyk7XG5cdFx0Vmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0KHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGhpcztcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0dGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX2l0ZW1FdmVudHMgPSB7IG5hdGl2ZToge30sIHZpcnR1YWw6IHt9IH07XG5cdFx0dGhpcy5fYXV0b1VwZGF0ZSA9ICFwYXBlci5hZ2VudC5ub2RlO1xuXHRcdHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblx0XHRWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cdFx0ZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmIChwcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuXHRcdFx0cHJvamVjdC5fdmlldyA9IG51bGw7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuXHRcdHRoaXMub2ZmKCdmcmFtZScpO1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2V2ZW50czogQmFzZS5lYWNoKFxuXHRcdEl0ZW0uX2l0ZW1IYW5kbGVycy5jb25jYXQoWydvblJlc2l6ZScsICdvbktleURvd24nLCAnb25LZXlVcCddKSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzW25hbWVdID0ge307XG5cdFx0fSwge1xuXHRcdFx0b25GcmFtZToge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0KSxcblxuXHRfYW5pbWF0ZTogZmFsc2UsXG5cdF90aW1lOiAwLFxuXHRfY291bnQ6IDAsXG5cblx0Z2V0QXV0b1VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG5cdH0sXG5cblx0c2V0QXV0b1VwZGF0ZTogZnVuY3Rpb24oYXV0b1VwZGF0ZSkge1xuXHRcdHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlO1xuXHRcdGlmIChhdXRvVXBkYXRlKVxuXHRcdFx0dGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdHJlcXVlc3RVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcmVxdWVzdGVkKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHREb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuX3JlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhhdC5fYW5pbWF0ZSkge1xuXHRcdFx0XHRcdHRoYXQucmVxdWVzdFVwZGF0ZSgpO1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gdGhhdC5fZWxlbWVudDtcblx0XHRcdFx0XHRpZiAoKCFEb21FbGVtZW50LmdldFByZWZpeGVkKGRvY3VtZW50LCAnaGlkZGVuJylcblx0XHRcdFx0XHRcdFx0fHwgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2tlZXBhbGl2ZScpXG5cdFx0XHRcdFx0XHRcdFx0PT09ICd0cnVlJykgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbGVtZW50KSkge1xuXHRcdFx0XHRcdFx0dGhhdC5faGFuZGxlRnJhbWUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoYXQuX2F1dG9VcGRhdGUpXG5cdFx0XHRcdFx0dGhhdC51cGRhdGUoKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fcmVxdWVzdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0cGxheTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IHRydWU7XG5cdFx0dGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0fSxcblxuXHRfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwLFxuXHRcdFx0ZGVsdGEgPSB0aGlzLl9sYXN0ID8gbm93IC0gdGhpcy5fbGFzdCA6IDA7XG5cdFx0dGhpcy5fbGFzdCA9IG5vdztcblx0XHR0aGlzLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2Uoe1xuXHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0dGltZTogdGhpcy5fdGltZSArPSBkZWx0YSxcblx0XHRcdGNvdW50OiB0aGlzLl9jb3VudCsrXG5cdFx0fSkpO1xuXHRcdGlmICh0aGlzLl9zdGF0cylcblx0XHRcdHRoaXMuX3N0YXRzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oaXRlbSwgYW5pbWF0ZSkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2ZyYW1lSXRlbXM7XG5cdFx0aWYgKGFuaW1hdGUpIHtcblx0XHRcdGl0ZW1zW2l0ZW0uX2lkXSA9IHtcblx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0dGltZTogMCxcblx0XHRcdFx0Y291bnQ6IDBcblx0XHRcdH07XG5cdFx0XHRpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSlcblx0XHRcdFx0dGhpcy5vbignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGl0ZW1zW2l0ZW0uX2lkXTtcblx0XHRcdGlmICgtLXRoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAwKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlRnJhbWVJdGVtczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2ZyYW1lSXRlbXMpIHtcblx0XHRcdHZhciBlbnRyeSA9IHRoaXMuX2ZyYW1lSXRlbXNbaV07XG5cdFx0XHRlbnRyeS5pdGVtLmVtaXQoJ2ZyYW1lJywgbmV3IEJhc2UoZXZlbnQsIHtcblx0XHRcdFx0dGltZTogZW50cnkudGltZSArPSBldmVudC5kZWx0YSxcblx0XHRcdFx0Y291bnQ6IGVudHJ5LmNvdW50Kytcblx0XHRcdH0pKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2NoYW5nZWQoNDA5Nyk7XG5cdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fZGVjb21wb3NlZCA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWxlbWVudDtcblx0fSxcblxuXHRnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyAqIDcyO1xuXHR9LFxuXG5cdGdldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFZpZXdTaXplJyk7XG5cdH0sXG5cblx0c2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRkZWx0YSA9IHNpemUuc3VidHJhY3QodGhpcy5fdmlld1NpemUpO1xuXHRcdGlmIChkZWx0YS5pc1plcm8oKSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl9zZXRFbGVtZW50U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fdmlld1NpemUuc2V0KHNpemUpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR0aGlzLmVtaXQoJ3Jlc2l6ZScsIHsgc2l6ZTogc2l6ZSwgZGVsdGE6IGRlbHRhIH0pO1xuXHRcdGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdGlmIChlbGVtZW50LndpZHRoICE9PSB3aWR0aClcblx0XHRcdFx0ZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuXHRcdFx0aWYgKGVsZW1lbnQuaGVpZ2h0ICE9PSBoZWlnaHQpXG5cdFx0XHRcdGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdH1cblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhcblx0XHRcdFx0XHRuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuXHR9LFxuXG5cdGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIERvbUVsZW1lbnQuaXNJblZpZXcodGhpcy5fZWxlbWVudCk7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIERvbUVsZW1lbnQuaXNJbnNlcnRlZCh0aGlzLl9lbGVtZW50KTtcblx0fSxcblxuXHRnZXRQaXhlbFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRwaXhlbHM7XG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsXG5cdFx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHRlbXAuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuXHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKHRlbXApO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldFN0eWxlcyh0ZW1wKS5mb250U2l6ZSk7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQodGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQocGl4ZWxzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVscztcblx0fSxcblxuXHRnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGZvbnQsIGxpbmVzKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdGF0ZScsICdzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgcm90YXRlID0ga2V5ID09PSAncm90YXRlJztcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHR2YWx1ZSA9IChyb3RhdGUgPyBCYXNlIDogUG9pbnQpLnJlYWQoYXJncyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtrZXldKHZhbHVlLFxuXHRcdFx0XHRjZW50ZXIgfHwgdGhpcy5nZXRDZW50ZXIodHJ1ZSkpKTtcblx0fTtcbn0sIHtcblx0X2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgfHwgKHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCkpO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHRoaXMuZ2V0Q2VudGVyKCkuc3VidHJhY3QoY2VudGVyKSk7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjYWxpbmcgPSB0aGlzLl9kZWNvbXBvc2UoKS5zY2FsaW5nO1xuXHRcdHJldHVybiAoc2NhbGluZy54ICsgc2NhbGluZy55KSAvIDI7XG5cdH0sXG5cblx0c2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuXHRcdHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5nZXRab29tKCksXG5cdFx0XHR0aGlzLmdldENlbnRlcigpKSk7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2UoKS5yb3RhdGlvbjtcblx0fSxcblxuXHRzZXRSb3RhdGlvbjogZnVuY3Rpb24ocm90YXRpb24pIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblx0XHRpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcblx0XHRcdHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsaW5nID0gdGhpcy5fZGVjb21wb3NlKCkuc2NhbGluZztcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHNjYWxpbmcueCwgc2NhbGluZy55LCB0aGlzLCAnc2V0U2NhbGluZycpO1xuXHR9LFxuXG5cdHNldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCksXG5cdFx0XHRzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUsIHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjdXJyZW50ICYmIHNjYWxpbmcpIHtcblx0XHRcdHRoaXMuc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH0sXG5cblx0c2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdG1hdHJpeC5zZXQuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmFwcGVuZChtYXRyaXgpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpO1xuXHR9XG59KSwge1xuXG5cdHByb2plY3RUb1ZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0dmlld1RvUHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldEV2ZW50UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHRoaXMuX2VsZW1lbnQpKTtcblx0fSxcblxufSwge1xuXHRzdGF0aWNzOiB7XG5cdFx0X3ZpZXdzOiBbXSxcblx0XHRfdmlld3NCeUlkOiB7fSxcblx0XHRfaWQ6IDAsXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHRcdGlmIChkb2N1bWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcblx0XHRcdHZhciBjdG9yID0gd2luZG93ID8gQ2FudmFzVmlldyA6IFZpZXc7XG5cdFx0XHRyZXR1cm4gbmV3IGN0b3IocHJvamVjdCwgZWxlbWVudCk7XG5cdFx0fVxuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXdpbmRvdylcblx0XHRyZXR1cm47XG5cdHZhciBwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2UsXG5cdFx0bW91c2VEb3duID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFtcblx0XHRcdFx0dGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKV07XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVGb2N1cygpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICF2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoKHZpZXcgPSBWaWV3Ll92aWV3c1tpXSkuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdmlldztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgcG9pbnQpIHtcblx0XHR2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQpO1xuXHR9XG5cblx0dmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IsXG5cdFx0bW91c2Vkb3duLCBtb3VzZW1vdmUsIG1vdXNldXA7XG5cdGlmIChuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcblx0XHRtb3VzZWRvd24gPSAncG9pbnRlcmRvd24gTVNQb2ludGVyRG93bic7XG5cdFx0bW91c2Vtb3ZlID0gJ3BvaW50ZXJtb3ZlIE1TUG9pbnRlck1vdmUnO1xuXHRcdG1vdXNldXAgPSAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcblx0fSBlbHNlIHtcblx0XHRtb3VzZWRvd24gPSAndG91Y2hzdGFydCc7XG5cdFx0bW91c2Vtb3ZlID0gJ3RvdWNobW92ZSc7XG5cdFx0bW91c2V1cCA9ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cdFx0aWYgKCEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goXG5cdFx0XHRcdC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pKSkpIHtcblx0XHRcdG1vdXNlZG93biArPSAnIG1vdXNlZG93bic7XG5cdFx0XHRtb3VzZW1vdmUgKz0gJyBtb3VzZW1vdmUnO1xuXHRcdFx0bW91c2V1cCArPSAnIG1vdXNldXAnO1xuXHRcdH1cblx0fVxuXG5cdHZhciB2aWV3RXZlbnRzID0ge30sXG5cdFx0ZG9jRXZlbnRzID0ge1xuXHRcdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0XHR0YXJnZXQgPSBEb21FdmVudC5nZXRSZWxhdGVkVGFyZ2V0KGV2ZW50KTtcblx0XHRcdFx0aWYgKHZpZXcgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpKSB7XG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCksXG5cdFx0XHRcdFx0XHR4ID0gb2Zmc2V0LngsXG5cdFx0XHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0XHRcdGF4ID0gYWJzKHgpLFxuXHRcdFx0XHRcdFx0bWF4ID0gMSA8PCAyNSxcblx0XHRcdFx0XHRcdGRpZmYgPSBheCAtIG1heDtcblx0XHRcdFx0XHRvZmZzZXQueCA9IGFicyhkaWZmKSA8IGF4ID8gZGlmZiAqICh4IDwgMCA/IC0xIDogMSkgOiB4O1xuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgdmlldy52aWV3VG9Qcm9qZWN0KG9mZnNldCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdFx0fTtcblxuXHR2aWV3RXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IGdldFZpZXcoZXZlbnQpO1xuXHRcdGlmICghZHJhZ2dpbmcpIHtcblx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIW1vdXNlRG93bikge1xuXHRcdFx0dmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuXHRcdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0XHRpZiAodmlldyAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0aWYgKHZpZXcpXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQpO1xuXHRcdFx0XHRcdGlmICghcHJldkZvY3VzKVxuXHRcdFx0XHRcdFx0cHJldkZvY3VzID0gdmlldztcblx0XHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHRhcmdldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdGlmIChwcmV2Rm9jdXMgJiYgIXByZXZGb2N1cy5pc0luc2VydGVkKCkpXG5cdFx0XHRcdFx0cHJldkZvY3VzID0gbnVsbDtcblx0XHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBwcmV2Rm9jdXM7XG5cdFx0XHRcdHByZXZGb2N1cyA9IG51bGw7XG5cdFx0XHRcdHVwZGF0ZUZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2aWV3KVxuXHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50KTtcblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKCkge1xuXHRcdG1vdXNlRG93biA9IHRydWU7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKHZpZXcgJiYgZHJhZ2dpbmcpXG5cdFx0XHR2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZXVwJywgZXZlbnQpO1xuXHRcdG1vdXNlRG93biA9IGRyYWdnaW5nID0gZmFsc2U7XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCBkb2NFdmVudHMpO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRsb2FkOiB1cGRhdGVGb2N1c1xuXHR9KTtcblxuXHR2YXIgY2FsbGVkID0gZmFsc2UsXG5cdFx0cHJldmVudGVkID0gZmFsc2UsXG5cdFx0ZmFsbGJhY2tzID0ge1xuXHRcdFx0ZG91YmxlY2xpY2s6ICdjbGljaycsXG5cdFx0XHRtb3VzZWRyYWc6ICdtb3VzZW1vdmUnXG5cdFx0fSxcblx0XHR3YXNJblZpZXcgPSBmYWxzZSxcblx0XHRvdmVyVmlldyxcblx0XHRkb3duUG9pbnQsXG5cdFx0bGFzdFBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGNsaWNrSXRlbSxcblx0XHRjbGlja1RpbWUsXG5cdFx0ZGJsQ2xpY2s7XG5cblx0ZnVuY3Rpb24gZW1pdE1vdXNlRXZlbnQob2JqLCB0YXJnZXQsIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50LFxuXHRcdFx0c3RvcEl0ZW0pIHtcblx0XHR2YXIgc3RvcHBlZCA9IGZhbHNlLFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGVtaXQob2JqLCB0eXBlKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsXG5cdFx0XHRcdFx0XHRcdHRhcmdldCB8fCBvYmosXG5cdFx0XHRcdFx0XHRcdHByZXZQb2ludCA/IHBvaW50LnN1YnRyYWN0KHByZXZQb2ludCkgOiBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2JqLmVtaXQodHlwZSwgbW91c2VFdmVudCkpIHtcblx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChtb3VzZUV2ZW50LnByZXZlbnRlZClcblx0XHRcdFx0XHRcdHByZXZlbnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKG1vdXNlRXZlbnQuc3RvcHBlZClcblx0XHRcdFx0XHRcdHJldHVybiBzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW3R5cGVdO1xuXHRcdFx0XHRpZiAoZmFsbGJhY2spXG5cdFx0XHRcdFx0cmV0dXJuIGVtaXQob2JqLCBmYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKG9iaiAmJiBvYmogIT09IHN0b3BJdGVtKSB7XG5cdFx0XHRpZiAoZW1pdChvYmosIHR5cGUpKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdG9iaiA9IG9iai5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gc3RvcHBlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGVtaXRNb3VzZUV2ZW50cyh2aWV3LCBoaXRJdGVtLCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCkge1xuXHRcdHZpZXcuX3Byb2plY3QucmVtb3ZlT24odHlwZSk7XG5cdFx0cHJldmVudGVkID0gY2FsbGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIChkcmFnSXRlbSAmJiBlbWl0TW91c2VFdmVudChkcmFnSXRlbSwgbnVsbCwgdHlwZSwgZXZlbnQsXG5cdFx0XHRcdFx0cG9pbnQsIHByZXZQb2ludClcblx0XHRcdHx8IGhpdEl0ZW0gJiYgaGl0SXRlbSAhPT0gZHJhZ0l0ZW1cblx0XHRcdFx0JiYgIWhpdEl0ZW0uaXNEZXNjZW5kYW50KGRyYWdJdGVtKVxuXHRcdFx0XHQmJiBlbWl0TW91c2VFdmVudChoaXRJdGVtLCBudWxsLCB0eXBlID09PSAnbW91c2VkcmFnJyA/XG5cdFx0XHRcdFx0J21vdXNlbW92ZScgOiB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCwgZHJhZ0l0ZW0pXG5cdFx0XHR8fCBlbWl0TW91c2VFdmVudCh2aWV3LCBkcmFnSXRlbSB8fCBoaXRJdGVtIHx8IHZpZXcsIHR5cGUsIGV2ZW50LFxuXHRcdFx0XHRcdHBvaW50LCBwcmV2UG9pbnQpKTtcblx0fVxuXG5cdHZhciBpdGVtRXZlbnRzTWFwID0ge1xuXHRcdG1vdXNlZG93bjoge1xuXHRcdFx0bW91c2Vkb3duOiAxLFxuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRkb3VibGVjbGljazogMVxuXHRcdH0sXG5cdFx0bW91c2V1cDoge1xuXHRcdFx0bW91c2V1cDogMSxcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHR9LFxuXHRcdG1vdXNlbW92ZToge1xuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0bW91c2Vtb3ZlOiAxLFxuXHRcdFx0bW91c2VlbnRlcjogMSxcblx0XHRcdG1vdXNlbGVhdmU6IDFcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCwgcG9pbnQpIHtcblx0XHRcdHZhciBpdGVtRXZlbnRzID0gdGhpcy5faXRlbUV2ZW50cyxcblx0XHRcdFx0aGl0SXRlbXMgPSBpdGVtRXZlbnRzLm5hdGl2ZVt0eXBlXSxcblx0XHRcdFx0bmF0aXZlTW92ZSA9IHR5cGUgPT09ICdtb3VzZW1vdmUnLFxuXHRcdFx0XHR0b29sID0gdGhpcy5fc2NvcGUudG9vbCxcblx0XHRcdFx0dmlldyA9IHRoaXM7XG5cblx0XHRcdGZ1bmN0aW9uIHJlc3BvbmRzKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW1FdmVudHMudmlydHVhbFt0eXBlXSB8fCB2aWV3LnJlc3BvbmRzKHR5cGUpXG5cdFx0XHRcdFx0XHR8fCB0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuYXRpdmVNb3ZlICYmIGRyYWdnaW5nICYmIHJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0dHlwZSA9ICdtb3VzZWRyYWcnO1xuXHRcdFx0aWYgKCFwb2ludClcblx0XHRcdFx0cG9pbnQgPSB0aGlzLmdldEV2ZW50UG9pbnQoZXZlbnQpO1xuXG5cdFx0XHR2YXIgaW5WaWV3ID0gdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCksXG5cdFx0XHRcdGhpdCA9IGhpdEl0ZW1zICYmIGluVmlldyAmJiB2aWV3Ll9wcm9qZWN0LmhpdFRlc3QocG9pbnQsIHtcblx0XHRcdFx0XHR0b2xlcmFuY2U6IDAsXG5cdFx0XHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdFx0XHRzdHJva2U6IHRydWVcblx0XHRcdFx0fSksXG5cdFx0XHRcdGhpdEl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0gfHwgbnVsbCxcblx0XHRcdFx0aGFuZGxlID0gZmFsc2UsXG5cdFx0XHRcdG1vdXNlID0ge307XG5cdFx0XHRtb3VzZVt0eXBlLnN1YnN0cig1KV0gPSB0cnVlO1xuXG5cdFx0XHRpZiAoaGl0SXRlbXMgJiYgaGl0SXRlbSAhPT0gb3Zlckl0ZW0pIHtcblx0XHRcdFx0aWYgKG92ZXJJdGVtKSB7XG5cdFx0XHRcdFx0ZW1pdE1vdXNlRXZlbnQob3Zlckl0ZW0sIG51bGwsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGl0SXRlbSkge1xuXHRcdFx0XHRcdGVtaXRNb3VzZUV2ZW50KGhpdEl0ZW0sIG51bGwsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvdmVySXRlbSA9IGhpdEl0ZW07XG5cdFx0XHR9XG5cdFx0XHRpZiAod2FzSW5WaWV3IF4gaW5WaWV3KSB7XG5cdFx0XHRcdGVtaXRNb3VzZUV2ZW50KHRoaXMsIG51bGwsIGluVmlldyA/ICdtb3VzZWVudGVyJyA6ICdtb3VzZWxlYXZlJyxcblx0XHRcdFx0XHRcdGV2ZW50LCBwb2ludCk7XG5cdFx0XHRcdG92ZXJWaWV3ID0gaW5WaWV3ID8gdGhpcyA6IG51bGw7XG5cdFx0XHRcdGhhbmRsZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGluVmlldyB8fCBtb3VzZS5kcmFnKSAmJiAhcG9pbnQuZXF1YWxzKGxhc3RQb2ludCkpIHtcblx0XHRcdFx0ZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIG5hdGl2ZU1vdmUgPyB0eXBlIDogJ21vdXNlbW92ZScsXG5cdFx0XHRcdFx0XHRldmVudCwgcG9pbnQsIGxhc3RQb2ludCk7XG5cdFx0XHRcdGhhbmRsZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR3YXNJblZpZXcgPSBpblZpZXc7XG5cdFx0XHRpZiAobW91c2UuZG93biAmJiBpblZpZXcgfHwgbW91c2UudXAgJiYgZG93blBvaW50KSB7XG5cdFx0XHRcdGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCB0eXBlLCBldmVudCwgcG9pbnQsIGRvd25Qb2ludCk7XG5cdFx0XHRcdGlmIChtb3VzZS5kb3duKSB7XG5cdFx0XHRcdFx0ZGJsQ2xpY2sgPSBoaXRJdGVtID09PSBjbGlja0l0ZW1cblx0XHRcdFx0XHRcdCYmIChEYXRlLm5vdygpIC0gY2xpY2tUaW1lIDwgMzAwKTtcblx0XHRcdFx0XHRkb3duSXRlbSA9IGNsaWNrSXRlbSA9IGhpdEl0ZW07XG5cdFx0XHRcdFx0aWYgKCFwcmV2ZW50ZWQgJiYgaGl0SXRlbSkge1xuXHRcdFx0XHRcdFx0dmFyIGl0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGl0ZW0gJiYgIWl0ZW0ucmVzcG9uZHMoJ21vdXNlZHJhZycpKVxuXHRcdFx0XHRcdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdFx0XHRcdFx0aWYgKGl0ZW0pXG5cdFx0XHRcdFx0XHRcdGRyYWdJdGVtID0gaGl0SXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG93blBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAobW91c2UudXApIHtcblx0XHRcdFx0XHRpZiAoIXByZXZlbnRlZCAmJiBoaXRJdGVtID09PSBkb3duSXRlbSkge1xuXHRcdFx0XHRcdFx0Y2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRcdGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCBkYmxDbGljayA/ICdkb3VibGVjbGljaydcblx0XHRcdFx0XHRcdFx0XHQ6ICdjbGljaycsIGV2ZW50LCBwb2ludCwgZG93blBvaW50KTtcblx0XHRcdFx0XHRcdGRibENsaWNrID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdhc0luVmlldyA9IGZhbHNlO1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFBvaW50ID0gcG9pbnQ7XG5cdFx0XHRpZiAoaGFuZGxlICYmIHRvb2wpIHtcblx0XHRcdFx0Y2FsbGVkID0gdG9vbC5faGFuZGxlTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIG1vdXNlKVxuXHRcdFx0XHRcdHx8IGNhbGxlZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZVxuXHRcdFx0XHQmJiAoY2FsbGVkICYmICFtb3VzZS5tb3ZlIHx8IG1vdXNlLmRvd24gJiYgcmVzcG9uZHMoJ21vdXNldXAnKSlcblx0XHRcdCkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGFuZGxlS2V5RXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcikge1xuXHRcdFx0dmFyIHNjb3BlID0gdGhpcy5fc2NvcGUsXG5cdFx0XHRcdHRvb2wgPSBzY29wZS50b29sLFxuXHRcdFx0XHRrZXlFdmVudDtcblxuXHRcdFx0ZnVuY3Rpb24gZW1pdChvYmopIHtcblx0XHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHRcdFx0b2JqLmVtaXQodHlwZSwga2V5RXZlbnQgPSBrZXlFdmVudFxuXHRcdFx0XHRcdFx0XHR8fCBuZXcgS2V5RXZlbnQodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0ZW1pdCh0aGlzKTtcblx0XHRcdFx0aWYgKHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKSlcblx0XHRcdFx0XHRlbWl0KHRvb2wpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfY291bnRJdGVtRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHNpZ24pIHtcblx0XHRcdHZhciBpdGVtRXZlbnRzID0gdGhpcy5faXRlbUV2ZW50cyxcblx0XHRcdFx0bmF0aXZlID0gaXRlbUV2ZW50cy5uYXRpdmUsXG5cdFx0XHRcdHZpcnR1YWwgPSBpdGVtRXZlbnRzLnZpcnR1YWw7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gaXRlbUV2ZW50c01hcCkge1xuXHRcdFx0XHRuYXRpdmVba2V5XSA9IChuYXRpdmVba2V5XSB8fCAwKVxuXHRcdFx0XHRcdFx0KyAoaXRlbUV2ZW50c01hcFtrZXldW3R5cGVdIHx8IDApICogc2lnbjtcblx0XHRcdH1cblx0XHRcdHZpcnR1YWxbdHlwZV0gPSAodmlydHVhbFt0eXBlXSB8fCAwKSArIHNpZ247XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1cyxcblxuXHRcdFx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkcmFnZ2luZyA9IG1vdXNlRG93biA9IGNhbGxlZCA9IHdhc0luVmlldyA9IGZhbHNlO1xuXHRcdFx0XHRwcmV2Rm9jdXMgPSB0ZW1wRm9jdXMgPSBvdmVyVmlldyA9IGRvd25Qb2ludCA9IGxhc3RQb2ludCA9XG5cdFx0XHRcdFx0ZG93bkl0ZW0gPSBvdmVySXRlbSA9IGRyYWdJdGVtID0gY2xpY2tJdGVtID0gY2xpY2tUaW1lID1cblx0XHRcdFx0XHRkYmxDbGljayA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBDYW52YXNWaWV3ID0gVmlldy5leHRlbmQoe1xuXHRfY2xhc3M6ICdDYW52YXNWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDYW52YXNWaWV3KHByb2plY3QsIGNhbnZhcykge1xuXHRcdGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJ1xuXHRcdFx0XHRcdFx0KyBCYXNlLnNsaWNlKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdH1cblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG5cdFx0aWYgKCEvXm9mZnxmYWxzZSQvLnRlc3QoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoY2FudmFzLCAnaGlkcGknKSkpIHtcblx0XHRcdHZhciBkZXZpY2VSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdGJhY2tpbmdTdG9yZVJhdGlvID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZChjdHgsXG5cdFx0XHRcdFx0XHQnYmFja2luZ1N0b3JlUGl4ZWxSYXRpbycpIHx8IDE7XG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gZGV2aWNlUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblx0XHR9XG5cdFx0Vmlldy5jYWxsKHRoaXMsIHByb2plY3QsIGNhbnZhcyk7XG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuXHRcdHJldHVybiByZW1vdmUuYmFzZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdF9zZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24gX3NldEVsZW1lbnRTaXplKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW87XG5cdFx0X3NldEVsZW1lbnRTaXplLmJhc2UuY2FsbCh0aGlzLCB3aWR0aCAqIHBpeGVsUmF0aW8sIGhlaWdodCAqIHBpeGVsUmF0aW8pO1xuXHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRcdGN0eCA9IHRoaXMuX2NvbnRleHQ7XG5cdFx0XHRpZiAoIVBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH1cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0fSxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGV4dDtcblx0fSxcblxuXHRnZXRQaXhlbFNpemU6IGZ1bmN0aW9uIGdldFBpeGVsU2l6ZShzaXplKSB7XG5cdFx0dmFyIGFnZW50ID0gcGFwZXIuYWdlbnQsXG5cdFx0XHRwaXhlbHM7XG5cdFx0aWYgKGFnZW50ICYmIGFnZW50LmZpcmVmb3gpIHtcblx0XHRcdHBpeGVscyA9IGdldFBpeGVsU2l6ZS5iYXNlLmNhbGwodGhpcywgc2l6ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdFx0Y3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udCxcblx0XHRcdHdpZHRoID0gMDtcblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiB3aWR0aDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fbmVlZHNVcGRhdGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0Y3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHRcdGlmIChwcm9qZWN0KVxuXHRcdFx0cHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIEV2ZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gRXZlbnQoZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdFx0dGhpcy50eXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZTtcblx0fSxcblxuXHRwcmV2ZW50ZWQ6IGZhbHNlLFxuXHRzdG9wcGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdHRoaXMucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRnZXRUaW1lU3RhbXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmV2ZW50LnRpbWVTdGFtcDtcblx0fSxcblxuXHRnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBLZXkubW9kaWZpZXJzO1xuXHR9XG59KTtcblxudmFyIEtleUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnS2V5RXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcikge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywga2V5OiAnXCIgKyB0aGlzLmtleVxuXHRcdFx0XHQrIFwiJywgY2hhcmFjdGVyOiAnXCIgKyB0aGlzLmNoYXJhY3RlclxuXHRcdFx0XHQrIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyBcIiB9XCI7XG5cdH1cbn0pO1xuXG52YXIgS2V5ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIga2V5TG9va3VwID0ge1xuXHRcdFx0J1xcdCc6ICd0YWInLFxuXHRcdFx0JyAnOiAnc3BhY2UnLFxuXHRcdFx0J1xcYic6ICdiYWNrc3BhY2UnLFxuXHRcdFx0J1xceDdmJzogJ2RlbGV0ZScsXG5cdFx0XHQnU3BhY2ViYXInOiAnc3BhY2UnLFxuXHRcdFx0J0RlbCc6ICdkZWxldGUnLFxuXHRcdFx0J1dpbic6ICdtZXRhJyxcblx0XHRcdCdFc2MnOiAnZXNjYXBlJ1xuXHRcdH0sXG5cblx0XHRjaGFyTG9va3VwID0ge1xuXHRcdFx0J3RhYic6ICdcXHQnLFxuXHRcdFx0J3NwYWNlJzogJyAnLFxuXHRcdFx0J2VudGVyJzogJ1xccidcblx0XHR9LFxuXG5cdFx0a2V5TWFwID0ge30sXG5cdFx0Y2hhck1hcCA9IHt9LFxuXHRcdG1ldGFGaXhNYXAsXG5cdFx0ZG93bktleSxcblxuXHRcdG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcblx0XHRcdHNoaWZ0OiBmYWxzZSxcblx0XHRcdGNvbnRyb2w6IGZhbHNlLFxuXHRcdFx0YWx0OiBmYWxzZSxcblx0XHRcdG1ldGE6IGZhbHNlLFxuXHRcdFx0Y2Fwc0xvY2s6IGZhbHNlLFxuXHRcdFx0c3BhY2U6IGZhbHNlXG5cdFx0fSkuaW5qZWN0KHtcblx0XHRcdG9wdGlvbjoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFsdDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Y29tbWFuZDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXHRcdFx0XHRcdHJldHVybiBhZ2VudCAmJiBhZ2VudC5tYWMgPyB0aGlzLm1ldGEgOiB0aGlzLmNvbnRyb2w7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRmdW5jdGlvbiBnZXRLZXkoZXZlbnQpIHtcblx0XHR2YXIga2V5ID0gZXZlbnQua2V5IHx8IGV2ZW50LmtleUlkZW50aWZpZXI7XG5cdFx0a2V5ID0gL15VXFwrLy50ZXN0KGtleSlcblx0XHRcdFx0PyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtleS5zdWJzdHIoMiksIDE2KSlcblx0XHRcdFx0OiAvXkFycm93W0EtWl0vLnRlc3Qoa2V5KSA/IGtleS5zdWJzdHIoNSlcblx0XHRcdFx0OiBrZXkgPT09ICdVbmlkZW50aWZpZWQnICB8fCBrZXkgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdD8gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5rZXlDb2RlKVxuXHRcdFx0XHRcdDoga2V5O1xuXHRcdHJldHVybiBrZXlMb29rdXBba2V5XSB8fFxuXHRcdFx0XHQoa2V5Lmxlbmd0aCA+IDEgPyBCYXNlLmh5cGhlbmF0ZShrZXkpIDoga2V5LnRvTG93ZXJDYXNlKCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuXHRcdHZhciB0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG5cdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdG5hbWU7XG5cdFx0a2V5TWFwW2tleV0gPSBkb3duO1xuXHRcdGlmIChkb3duKSB7XG5cdFx0XHRjaGFyTWFwW2tleV0gPSBjaGFyYWN0ZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBjaGFyTWFwW2tleV07XG5cdFx0fVxuXHRcdGlmIChrZXkubGVuZ3RoID4gMSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoa2V5KSkgaW4gbW9kaWZpZXJzKSB7XG5cdFx0XHRtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuXHRcdFx0dmFyIGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cdFx0XHRpZiAobmFtZSA9PT0gJ21ldGEnICYmIGFnZW50ICYmIGFnZW50Lm1hYykge1xuXHRcdFx0XHRpZiAoZG93bikge1xuXHRcdFx0XHRcdG1ldGFGaXhNYXAgPSB7fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIG1ldGFGaXhNYXApIHtcblx0XHRcdFx0XHRcdGlmIChrIGluIGNoYXJNYXApXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgaywgbWV0YUZpeE1hcFtrXSwgZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtZXRhRml4TWFwID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZG93biAmJiBtZXRhRml4TWFwKSB7XG5cdFx0XHRtZXRhRml4TWFwW2tleV0gPSBjaGFyYWN0ZXI7XG5cdFx0fVxuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHR2aWV3Ll9oYW5kbGVLZXlFdmVudChkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJywgZXZlbnQsIGtleSxcblx0XHRcdFx0XHRjaGFyYWN0ZXIpO1xuXHRcdH1cblx0fVxuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KSxcblx0XHRcdFx0YWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblx0XHRcdGlmIChrZXkubGVuZ3RoID4gMSB8fCBhZ2VudCAmJiAoYWdlbnQuY2hyb21lICYmIChldmVudC5hbHRLZXlcblx0XHRcdFx0XHRcdHx8IGFnZW50Lm1hYyAmJiBldmVudC5tZXRhS2V5XG5cdFx0XHRcdFx0XHR8fCAhYWdlbnQubWFjICYmIGV2ZW50LmN0cmxLZXkpKSkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwga2V5LFxuXHRcdFx0XHRcdFx0Y2hhckxvb2t1cFtrZXldIHx8IChrZXkubGVuZ3RoID4gMSA/ICcnIDoga2V5KSwgZXZlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG93bktleSA9IGtleTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZG93bktleSkge1xuXHRcdFx0XHR2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KSxcblx0XHRcdFx0XHRjb2RlID0gZXZlbnQuY2hhckNvZGUsXG5cdFx0XHRcdFx0Y2hhcmFjdGVyID0gY29kZSA+PSAzMiA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcblx0XHRcdFx0XHRcdDoga2V5Lmxlbmd0aCA+IDEgPyAnJyA6IGtleTtcblx0XHRcdFx0aWYgKGtleSAhPT0gZG93bktleSkge1xuXHRcdFx0XHRcdGtleSA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpO1xuXHRcdFx0XHRkb3duS2V5ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIga2V5ID0gZ2V0S2V5KGV2ZW50KTtcblx0XHRcdGlmIChrZXkgaW4gY2hhck1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBrZXksIGNoYXJNYXBba2V5XSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGJsdXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gY2hhck1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBrZXksIGNoYXJNYXBba2V5XSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRtb2RpZmllcnM6IG1vZGlmaWVycyxcblxuXHRcdGlzRG93bjogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRyZXR1cm4gISFrZXlNYXBba2V5XTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgTW91c2VFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ01vdXNlRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGRlbHRhKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdFx0dGhpcy5wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnRcblx0XHRcdFx0KyAnLCB0YXJnZXQ6ICcgKyB0aGlzLnRhcmdldFxuXHRcdFx0XHQrICh0aGlzLmRlbHRhID8gJywgZGVsdGE6ICcgKyB0aGlzLmRlbHRhIDogJycpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbEV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbEV2ZW50Jyxcblx0X2l0ZW06IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSB7XG5cdFx0dGhpcy50b29sID0gdG9vbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRfY2hvb3NlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCB0b29sUG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX3BvaW50LCB0aGlzLnRvb2wuX3BvaW50KTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHR9LFxuXG5cdGdldExhc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuXHR9LFxuXG5cdHNldExhc3RQb2ludDogZnVuY3Rpb24obGFzdFBvaW50KSB7XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuXHR9LFxuXG5cdGdldERvd25Qb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2Rvd25Qb2ludCwgdGhpcy50b29sLl9kb3duUG9pbnQpO1xuXHR9LFxuXG5cdHNldERvd25Qb2ludDogZnVuY3Rpb24oZG93blBvaW50KSB7XG5cdFx0dGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuXHR9LFxuXG5cdGdldE1pZGRsZVBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX21pZGRsZVBvaW50ICYmIHRoaXMudG9vbC5fbGFzdFBvaW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b29sLl9wb2ludC5hZGQodGhpcy50b29sLl9sYXN0UG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21pZGRsZVBvaW50O1xuXHR9LFxuXG5cdHNldE1pZGRsZVBvaW50OiBmdW5jdGlvbihtaWRkbGVQb2ludCkge1xuXHRcdHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0Z2V0RGVsdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZGVsdGEgJiYgdGhpcy50b29sLl9sYXN0UG9pbnRcblx0XHRcdFx0PyB0aGlzLnRvb2wuX3BvaW50LnN1YnRyYWN0KHRoaXMudG9vbC5fbGFzdFBvaW50KVxuXHRcdFx0XHQ6IHRoaXMuX2RlbHRhO1xuXHR9LFxuXG5cdHNldERlbHRhOiBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuX2RlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0Z2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuXHRcdFx0XHQ/ICdfZG93bkNvdW50JyA6ICdfbW92ZUNvdW50J107XG5cdH0sXG5cblx0c2V0Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0dGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnZG93bkNvdW50JyA6ICdjb3VudCddXG5cdFx0XHQ9IGNvdW50O1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5faXRlbSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMudG9vbC5fc2NvcGUucHJvamVjdC5oaXRUZXN0KHRoaXMuZ2V0UG9pbnQoKSk7XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG5cdFx0XHRcdFx0cGFyZW50ID0gaXRlbS5fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcblx0XHRcdFx0XHRpdGVtID0gcGFyZW50O1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgJywgcG9pbnQ6ICcgKyB0aGlzLmdldFBvaW50KClcblx0XHRcdFx0KyAnLCBjb3VudDogJyArIHRoaXMuZ2V0Q291bnQoKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2wgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sJyxcblx0X2xpc3Q6ICd0b29scycsXG5cdF9yZWZlcmVuY2U6ICd0b29sJyxcblx0X2V2ZW50czogWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLFxuXHRcdFx0J29uQWN0aXZhdGUnLCAnb25EZWFjdGl2YXRlJywgJ29uRWRpdE9wdGlvbnMnLCAnb25LZXlEb3duJyxcblx0XHRcdCdvbktleVVwJ10sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbChwcm9wcykge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fbW92ZUNvdW50ID0gLTE7XG5cdFx0dGhpcy5fZG93bkNvdW50ID0gLTE7XG5cdFx0dGhpcy5zZXQocHJvcHMpO1xuXHR9LFxuXG5cdGdldE1pbkRpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKG1pbkRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblx0XHRpZiAobWluRGlzdGFuY2UgIT0gbnVsbCAmJiB0aGlzLl9tYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIG1pbkRpc3RhbmNlID4gdGhpcy5fbWF4RGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21heERpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1heERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4RGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHRpZiAodGhpcy5fbWluRGlzdGFuY2UgIT0gbnVsbCAmJiBtYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIG1heERpc3RhbmNlIDwgdGhpcy5fbWluRGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZSA9PSB0aGlzLl9tYXhEaXN0YW5jZVxuXHRcdFx0PyB0aGlzLl9taW5EaXN0YW5jZSA6IG51bGw7XG5cdH0sXG5cblx0c2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oZGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IHRoaXMuX21heERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBwb2ludCwgbW91c2UpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdGlmIChtb3VzZS5kcmFnICYmICF0aGlzLnJlc3BvbmRzKHR5cGUpKVxuXHRcdFx0dHlwZSA9ICdtb3VzZW1vdmUnO1xuXHRcdHZhciBtb3ZlID0gbW91c2UubW92ZSB8fCBtb3VzZS5kcmFnLFxuXHRcdFx0cmVzcG9uZHMgPSB0aGlzLnJlc3BvbmRzKHR5cGUpLFxuXHRcdFx0bWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0bWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlLFxuXHRcdFx0Y2FsbGVkID0gZmFsc2UsXG5cdFx0XHR0b29sID0gdGhpcztcblx0XHRmdW5jdGlvbiB1cGRhdGUobWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSB7XG5cdFx0XHR2YXIgcHQgPSBwb2ludCxcblx0XHRcdFx0dG9vbFBvaW50ID0gbW92ZSA/IHRvb2wuX3BvaW50IDogKHRvb2wuX2Rvd25Qb2ludCB8fCBwdCk7XG5cdFx0XHRpZiAobW92ZSkge1xuXHRcdFx0XHRpZiAodG9vbC5fbW92ZUNvdW50ID49IDAgJiYgcHQuZXF1YWxzKHRvb2xQb2ludCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRvb2xQb2ludCAmJiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSkge1xuXHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBwdC5zdWJ0cmFjdCh0b29sUG9pbnQpLFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2UgPSB2ZWN0b3IuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgKG1pbkRpc3RhbmNlIHx8IDApKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdGlmIChtYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cHQgPSB0b29sUG9pbnQuYWRkKHZlY3Rvci5ub3JtYWxpemUoXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5taW4oZGlzdGFuY2UsIG1heERpc3RhbmNlKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0b29sLl9tb3ZlQ291bnQrKztcblx0XHRcdH1cblx0XHRcdHRvb2wuX3BvaW50ID0gcHQ7XG5cdFx0XHR0b29sLl9sYXN0UG9pbnQgPSB0b29sUG9pbnQgfHwgcHQ7XG5cdFx0XHRpZiAobW91c2UuZG93bikge1xuXHRcdFx0XHR0b29sLl9tb3ZlQ291bnQgPSAtMTtcblx0XHRcdFx0dG9vbC5fZG93blBvaW50ID0gcHQ7XG5cdFx0XHRcdHRvb2wuX2Rvd25Db3VudCsrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW1pdCgpIHtcblx0XHRcdGlmIChyZXNwb25kcykge1xuXHRcdFx0XHRjYWxsZWQgPSB0b29sLmVtaXQodHlwZSwgbmV3IFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkpXG5cdFx0XHRcdFx0XHR8fCBjYWxsZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1vdXNlLmRvd24pIHtcblx0XHRcdHVwZGF0ZSgpO1xuXHRcdFx0ZW1pdCgpO1xuXHRcdH0gZWxzZSBpZiAobW91c2UudXApIHtcblx0XHRcdHVwZGF0ZShudWxsLCBtYXhEaXN0YW5jZSk7XG5cdFx0XHRlbWl0KCk7XG5cdFx0fSBlbHNlIGlmIChyZXNwb25kcykge1xuXHRcdFx0d2hpbGUgKHVwZGF0ZShtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpKVxuXHRcdFx0XHRlbWl0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBjYWxsZWQ7XG5cdH1cblxufSk7XG5cbnZhciBUd2VlbiA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0X2NsYXNzOiAnVHdlZW4nLFxuXG5cdHN0YXRpY3M6IHtcblx0XHRlYXNpbmdzOiBuZXcgQmFzZSh7XG5cdFx0XHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5RdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0ICogKDIgLSB0KTtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgPCAwLjVcblx0XHRcdFx0XHQ/IDIgKiB0ICogdFxuXHRcdFx0XHRcdDogLTEgKyAyICogKDIgLSB0KSAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiAtLXQgKiB0ICogdCArIDE7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCA8IDAuNVxuXHRcdFx0XHRcdD8gNCAqIHQgKiB0ICogdFxuXHRcdFx0XHRcdDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIDEgLSAoLS10KSAqIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0IDwgMC41XG5cdFx0XHRcdFx0PyA4ICogdCAqIHQgKiB0ICogdFxuXHRcdFx0XHRcdDogMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCA8IDAuNVxuXHRcdFx0XHRcdD8gMTYgKiB0ICogdCAqIHQgKiB0ICogdFxuXHRcdFx0XHRcdDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0O1xuXHRcdFx0fVxuXHRcdH0pXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVHdlZW4ob2JqZWN0LCBmcm9tLCB0bywgZHVyYXRpb24sIGVhc2luZywgc3RhcnQpIHtcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBlYXNpbmc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0eXBlID09PSAnZnVuY3Rpb24nO1xuXHRcdHRoaXMudHlwZSA9IGlzRnVuY3Rpb25cblx0XHRcdD8gdHlwZVxuXHRcdFx0OiB0eXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHQ/IGVhc2luZ1xuXHRcdFx0XHQ6ICdsaW5lYXInO1xuXHRcdHRoaXMuZWFzaW5nID0gaXNGdW5jdGlvbiA/IGVhc2luZyA6IFR3ZWVuLmVhc2luZ3NbdGhpcy50eXBlXTtcblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl90aGVuID0gbnVsbDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXHRcdHZhciBzdGF0ZSA9IGZyb20gfHwgdG87XG5cdFx0dGhpcy5fa2V5cyA9IHN0YXRlID8gT2JqZWN0LmtleXMoc3RhdGUpIDogW107XG5cdFx0dGhpcy5fcGFyc2VkS2V5cyA9IHRoaXMuX3BhcnNlS2V5cyh0aGlzLl9rZXlzKTtcblx0XHR0aGlzLl9mcm9tID0gc3RhdGUgJiYgdGhpcy5fZ2V0U3RhdGUoZnJvbSk7XG5cdFx0dGhpcy5fdG8gPSBzdGF0ZSAmJiB0aGlzLl9nZXRTdGF0ZSh0byk7XG5cdFx0aWYgKHN0YXJ0ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zdGFydCgpO1xuXHRcdH1cblx0fSxcblxuXHR0aGVuOiBmdW5jdGlvbih0aGVuKSB7XG5cdFx0dGhpcy5fdGhlbiA9IHRoZW47XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHByb2dyZXNzKSB7XG5cdFx0aWYgKHRoaXMucnVubmluZykge1xuXHRcdFx0aWYgKHByb2dyZXNzID49IDEpIHtcblx0XHRcdFx0cHJvZ3Jlc3MgPSAxO1xuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGZhY3RvciA9IHRoaXMuZWFzaW5nKHByb2dyZXNzKSxcblx0XHRcdFx0a2V5cyA9IHRoaXMuX2tleXMsXG5cdFx0XHRcdGdldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHZhbHVlKGZhY3RvciwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzICYmIGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRcdGZyb20gPSBnZXRWYWx1ZSh0aGlzLl9mcm9tW2tleV0pLFxuXHRcdFx0XHRcdHRvID0gZ2V0VmFsdWUodGhpcy5fdG9ba2V5XSksXG5cdFx0XHRcdFx0dmFsdWUgPSAoZnJvbSAmJiB0byAmJiBmcm9tLl9fYWRkICYmIHRvLl9fYWRkKVxuXHRcdFx0XHRcdFx0PyB0by5fX3N1YnRyYWN0KGZyb20pLl9fbXVsdGlwbHkoZmFjdG9yKS5fX2FkZChmcm9tKVxuXHRcdFx0XHRcdFx0OiAoKHRvIC0gZnJvbSkgKiBmYWN0b3IpICsgZnJvbTtcblx0XHRcdFx0dGhpcy5fc2V0UHJvcGVydHkodGhpcy5fcGFyc2VkS2V5c1trZXldLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnJlc3BvbmRzKCd1cGRhdGUnKSkge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBCYXNlKHtcblx0XHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3MsXG5cdFx0XHRcdFx0ZmFjdG9yOiBmYWN0b3Jcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0aGlzLnJ1bm5pbmcgJiYgdGhpcy5fdGhlbikge1xuXHRcdFx0XHR0aGlzLl90aGVuKHRoaXMub2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdG9uVXBkYXRlOiB7fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZTogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRwcm9ncmVzcyA9IHN0YXJ0VGltZVxuXHRcdFx0XHQ/ICh0aW1lIC0gc3RhcnRUaW1lKSAvIHRoaXMuZHVyYXRpb25cblx0XHRcdFx0OiAwO1xuXHRcdGlmICghc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZShwcm9ncmVzcyk7XG5cdH0sXG5cblx0X2dldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fa2V5cyxcblx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5fcGFyc2VkS2V5c1trZXldLFxuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCksXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0aWYgKHN0YXRlKSB7XG5cdFx0XHRcdHZhciByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVWYWx1ZShjdXJyZW50LCBzdGF0ZVtrZXldKTtcblx0XHRcdFx0dGhpcy5fc2V0UHJvcGVydHkocGF0aCwgcmVzb2x2ZWQpO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLmNsb25lID8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9wZXJ0eShwYXRoLCBjdXJyZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gY3VycmVudCAmJiBjdXJyZW50LmNsb25lID8gY3VycmVudC5jbG9uZSgpIDogY3VycmVudDtcblx0XHRcdH1cblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Jlc29sdmVWYWx1ZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWUpIHtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0dmFyIG9wZXJhdG9yID0gdmFsdWVbMF07XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0b3BlcmF0b3IgJiZcblx0XHRcdFx0XHRvcGVyYXRvci5tYXRjaCAmJlxuXHRcdFx0XHRcdG9wZXJhdG9yLm1hdGNoKC9eWytcXC1cXCpcXC9dPS8pXG5cdFx0XHRcdClcblx0XHRcdFx0XHQ/IHRoaXMuX2NhbGN1bGF0ZShjdXJyZW50LCBvcGVyYXRvclswXSwgdmFsdWVbMV0pXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXlsrXFwtKi9dPSguKikvKTtcblx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0dmFyIHBhcnNlZCA9IEpTT04ucGFyc2UobWF0Y2hbMV0ucmVwbGFjZShcblx0XHRcdFx0XHRcdC8oWydcIl0pPyhbYS16QS1aMC05X10rKShbJ1wiXSk/Oi9nLFxuXHRcdFx0XHRcdFx0J1wiJDJcIjogJ1xuXHRcdFx0XHRcdCkpO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjdWxhdGUoY3VycmVudCwgdmFsdWVbMF0sIHBhcnNlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXG5cdF9jYWxjdWxhdGU6IGZ1bmN0aW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHJldHVybiBwYXBlci5QYXBlclNjcmlwdC5jYWxjdWxhdGVCaW5hcnkobGVmdCwgb3BlcmF0b3IsIHJpZ2h0KTtcblx0fSxcblxuXHRfcGFyc2VLZXlzOiBmdW5jdGlvbihrZXlzKSB7XG5cdFx0dmFyIHBhcnNlZCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRwYXRoID0ga2V5XG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcLihbXi5dKikvZywgJy8kMScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcW1snXCJdPyhbXidcIlxcXV0qKVsnXCJdP1xcXS9nLCAnLyQxJyk7XG5cdFx0XHRwYXJzZWRba2V5XSA9IHBhdGguc3BsaXQoJy8nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlZDtcblx0fSxcblxuXHRfZ2V0UHJvcGVydHk6IGZ1bmN0aW9uKHBhdGgsIG9mZnNldCkge1xuXHRcdHZhciBvYmogPSB0aGlzLm9iamVjdDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoIC0gKG9mZnNldCB8fCAwKTsgaSA8IGwgJiYgb2JqOyBpKyspIHtcblx0XHRcdG9iaiA9IG9ialtwYXRoW2ldXTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHRfc2V0UHJvcGVydHk6IGZ1bmN0aW9uKHBhdGgsIHZhbHVlKSB7XG5cdFx0dmFyIGRlc3QgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoLCAxKTtcblx0XHRpZiAoZGVzdCkge1xuXHRcdFx0ZGVzdFtwYXRoW3BhdGgubGVuZ3RoIC0gMV1dID0gdmFsdWU7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgeGhyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3Blbigob3B0aW9ucy5tZXRob2QgfHwgJ2dldCcpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMudXJsLFxuXHRcdFx0XHRCYXNlLnBpY2sob3B0aW9ucy5hc3luYywgdHJ1ZSkpO1xuXHRcdGlmIChvcHRpb25zLm1pbWVUeXBlKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9uTG9hZCkge1xuXHRcdFx0XHRcdG9wdGlvbnMub25Mb2FkLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eGhyLm9uZXJyb3IoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cyxcblx0XHRcdFx0bWVzc2FnZSA9ICdDb3VsZCBub3QgbG9hZCBcIicgKyBvcHRpb25zLnVybCArICdcIiAoU3RhdHVzOiAnXG5cdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJztcblx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3IpIHtcblx0XHRcdFx0b3B0aW9ucy5vbkVycm9yKG1lc3NhZ2UsIHN0YXR1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4geGhyLnNlbmQobnVsbCk7XG5cdH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IEJhc2UuZXhwb3J0cy5DYW52YXNQcm92aWRlciA9IHtcblx0Y2FudmFzZXM6IFtdLFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICghd2luZG93KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdGNsZWFyID0gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW52YXMgJyArIGNhbnZhcyArXG5cdFx0XHRcdFx0JyBpcyB1bmFibGUgdG8gcHJvdmlkZSBhIDJEIGNvbnRleHQuJyk7XG5cdFx0fVxuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqICYmIG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGlmIChjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLFxuXHRcdGJyLCBiZywgYmIsIGJhLFxuXHRcdGRyLCBkZywgZGI7XG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSxcblx0XHRcdG1uID0gbWluKHIsIGcsIGIpLFxuXHRcdFx0bWQ7XG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdGlmIChjdHgpIHtcblx0XHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW5cblx0XHRcdFx0XHRcdFx0PyAxNzAgOiA1MTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHRcdH0pO1xuXHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0fVxuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHRcdHNyID0gc3JjW2ldO1xuXHRcdFx0XHRiciA9IGRzdFtpXTtcblx0XHRcdFx0c2cgPSBzcmNbaSArIDFdO1xuXHRcdFx0XHRiZyA9IGRzdFtpICsgMV07XG5cdFx0XHRcdHNiID0gc3JjW2kgKyAyXTtcblx0XHRcdFx0YmIgPSBkc3RbaSArIDJdO1xuXHRcdFx0XHRzYSA9IHNyY1tpICsgM107XG5cdFx0XHRcdGJhID0gZHN0W2kgKyAzXTtcblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHR2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuXHRcdFx0XHRcdGEyID0gMSAtIGExO1xuXHRcdFx0XHRkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcblx0XHRcdFx0ZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuXHRcdFx0XHRkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG5cdFx0XHRcdGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcblx0XHRcdH1cblx0XHRcdGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFN2Z0VsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBzdmcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnLFxuXHRcdHhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHtcblx0XHRcdGhyZWY6IHhsaW5rLFxuXHRcdFx0eGxpbms6IHhtbG5zLFxuXHRcdFx0eG1sbnM6IHhtbG5zICsgJy8nLFxuXHRcdFx0J3htbG5zOnhsaW5rJzogeG1sbnMgKyAnLydcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZSh0YWcsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuXHRcdHJldHVybiBzZXQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2ZywgdGFnKSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldChub2RlLCBuYW1lKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZVtuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbnVsbCcgPyBudWxsIDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobm9kZSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBmb3JtYXR0ZXIpXG5cdFx0XHRcdHZhbHVlID0gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdmc6IHN2Zyxcblx0XHR4bWxuczogeG1sbnMsXG5cdFx0eGxpbms6IHhsaW5rLFxuXG5cdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0Z2V0OiBnZXQsXG5cdFx0c2V0OiBzZXRcblx0fTtcbn07XG5cbnZhciBTdmdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRmaWxsUnVsZTogWydmaWxsLXJ1bGUnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0eWxlJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRsb29rdXAgPSBlbnRyeVsyXTtcblx0dGhpc1trZXldID0ge1xuXHRcdHR5cGU6IGVudHJ5WzFdLFxuXHRcdHByb3BlcnR5OiBrZXksXG5cdFx0YXR0cmlidXRlOiBlbnRyeVswXSxcblx0XHR0b1NWRzogbG9va3VwLFxuXHRcdGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0dGhpc1t2YWx1ZV0gPSBuYW1lO1xuXHRcdH0sIHt9KSxcblx0XHRleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHR2YXIgcG9pbnQ7XG5cdFx0XHRpZiAobWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG5cdFx0XHRcdG1hdHJpeCA9IG1hdHJpeC5fc2hpZnRsZXNzKCk7XG5cdFx0XHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcblx0XHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBuZXcgUG9pbnQoKTtcblx0XHRcdH1cblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcblx0XHR9XG5cdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0XHRcdGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcblx0XHRcdFx0XHRzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZyxcblx0XHRcdFx0XHRza2V3ID0gZGVjb21wb3NlZC5za2V3aW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmIChhbmdsZSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRpZiAoc2tldy54KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdYKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueCkgKyAnKScpO1xuXHRcdFx0XHRpZiAoc2tldy55KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdZKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0U3ZnRWxlbWVudC5zZXQobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKSxcblx0XHRcdGltYWdlID0gaXRlbS5nZXRJbWFnZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBvcHRpb25zLmVtYmVkSW1hZ2VzID09IGZhbHNlICYmIGltYWdlICYmIGltYWdlLnNyY1xuXHRcdFx0XHR8fCBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgnaW1hZ2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBtYXRjaFNoYXBlcyA9IG9wdGlvbnMubWF0Y2hTaGFwZXM7XG5cdFx0aWYgKG1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiBsZW5ndGggPj0gMiAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChsZW5ndGggPiAyKSB7XG5cdFx0XHRcdHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBzdGFydCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRlbmQgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IHN0YXJ0LngsXG5cdFx0XHRcdFx0eTE6IHN0YXJ0LnksXG5cdFx0XHRcdFx0eDI6IGVuZC54LFxuXHRcdFx0XHRcdHkyOiBlbmQueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCdwYXRoJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTeW1ib2xJdGVtKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuXHRcdFx0bm9kZSA9IGdldERlZmluaXRpb24oZGVmaW5pdGlvbiwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbkl0ZW0gPSBkZWZpbml0aW9uLl9pdGVtLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbkl0ZW0uZ2V0U3Ryb2tlQm91bmRzKCk7XG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb25JdGVtLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKGRlZmluaXRpb24sIG5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIG5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gYm91bmRzLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG5cdFx0YXR0cnMub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCd1c2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJylcblx0XHRcdFx0XHQrICdHcmFkaWVudCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpLFxuXHRcdFx0XHRcdG9mZnNldCA9IHN0b3AuX29mZnNldDtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBvZmZzZXQgPT0gbnVsbCA/IGkgLyAobCAtIDEpIDogb2Zmc2V0XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChzdG9wQ29sb3IpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3BDb2xvci50b0NTUyh0cnVlKTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKFxuXHRcdFx0XHRcdFx0U3ZnRWxlbWVudC5jcmVhdGUoJ3N0b3AnLCBhdHRycywgZm9ybWF0dGVyKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdFx0Zm9ybWF0dGVyKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRTeW1ib2xJdGVtOiBleHBvcnRTeW1ib2xJdGVtLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCksXG5cdFx0XHRzdHlsZSA9IFtdO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdHN0eWxlLnB1c2goZW50cnkuYXR0cmlidXRlICsgJzogJyArIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbCA/ICdub25lJ1xuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcicgPyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheScgPyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJyA/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoc3R5bGUubGVuZ3RoKVxuXHRcdFx0YXR0cnMuc3R5bGUgPSBzdHlsZS5qb2luKCc7Jyk7XG5cblx0XHRpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSlcblx0XHRcdGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuXG5cdFx0aWYgKCFpdGVtLl92aXNpYmxlKVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuc2V0KG5vZGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nXG5cdFx0XHRcdCsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCB8fCAoaXRlbS5fX2lkID0gVUlELmdldCgnc3ZnJykpKV07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciB0eXBlSWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIHR5cGVJZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyAoaXRlbS5faWQgfHwgaXRlbS5fX2lkKV0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoU3ZnRWxlbWVudC5jcmVhdGUoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IHNlbGYuWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0Ym91bmRzID0gQmFzZS5waWNrKG9wdGlvbnMuYm91bmRzLCAndmlldycpLFxuXHRcdFx0XHRteCA9IG9wdGlvbnMubWF0cml4IHx8IGJvdW5kcyA9PT0gJ3ZpZXcnICYmIHZpZXcuX21hdHJpeCxcblx0XHRcdFx0bWF0cml4ID0gbXggJiYgTWF0cml4LnJlYWQoW214XSksXG5cdFx0XHRcdHJlY3QgPSBib3VuZHMgPT09ICd2aWV3J1xuXHRcdFx0XHRcdD8gbmV3IFJlY3RhbmdsZShbMCwgMF0sIHZpZXcuZ2V0Vmlld1NpemUoKSlcblx0XHRcdFx0XHQ6IGJvdW5kcyA9PT0gJ2NvbnRlbnQnXG5cdFx0XHRcdFx0XHQ/IEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCB7IHN0cm9rZTogdHJ1ZSB9KVxuXHRcdFx0XHRcdFx0XHQucmVjdFxuXHRcdFx0XHRcdFx0OiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSwgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6IFN2Z0VsZW1lbnQuc3ZnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6IFN2Z0VsZW1lbnQueGxpbmssXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRhdHRycy53aWR0aCA9IHJlY3Qud2lkdGg7XG5cdFx0XHRcdGF0dHJzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXHRcdFx0XHRpZiAocmVjdC54IHx8IHJlY3QueCA9PT0gMCB8fCByZWN0LnkgfHwgcmVjdC55ID09PSAwKVxuXHRcdFx0XHRcdGF0dHJzLnZpZXdCb3ggPSBmb3JtYXR0ZXIucmVjdGFuZ2xlKHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywgYXR0cnMsIGZvcm1hdHRlciksXG5cdFx0XHRcdHBhcmVudCA9IG5vZGU7XG5cdFx0XHRpZiAobWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHRcdHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLFxuXHRcdFx0XHRcdFx0Z2V0VHJhbnNmb3JtKG1hdHJpeCksIGZvcm1hdHRlcikpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhjaGlsZHJlbltpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGRlZmluaXRpb25zID0ge30sXG5cdFx0cm9vdFNpemU7XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LFxuXHRcdFx0ZGVmYXVsdFZhbHVlKSB7XG5cdFx0dmFyIHZhbHVlID0gU3ZnRWxlbWVudC5nZXQobm9kZSwgbmFtZSkgfHwgZGVmYXVsdFZhbHVlLFxuXHRcdFx0cmVzID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmcgPyAnJyA6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdHJldHVybiAvJVxccyokLy50ZXN0KHZhbHVlKVxuXHRcdFx0PyAocmVzIC8gMTAwKSAqIChhbGxvd1BlcmNlbnQgPyAxXG5cdFx0XHRcdDogcm9vdFNpemVbL3h8XndpZHRoLy50ZXN0KG5hbWUpID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSlcblx0XHRcdDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRYLCBkZWZhdWx0WSkge1xuXHRcdHggPSBnZXRWYWx1ZShub2RlLCB4IHx8ICd4JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHkgfHwgJ3knLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRZKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KSB7XG5cdFx0dyA9IGdldFZhbHVlKG5vZGUsIHcgfHwgJ3dpZHRoJywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCB8fCAnaGVpZ2h0JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgU2l6ZSh3LCBoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbm9uZScgPyBudWxsXG5cdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheScgP1xuXHRcdFx0XHRcdHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW11cblx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InID8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWVcblx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJyA/IGxvb2t1cFt2YWx1ZV1cblx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpc0RlZnMgPSB0eXBlID09PSAnZGVmcycsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXAgJiYgIWlzRGVmcykge1xuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcblx0XHR9XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0dmFyIGRlZnMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RlZnMnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZGVmcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW1wb3J0Tm9kZShkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmICEvXmRlZnMkL2kudGVzdChjaGlsZE5vZGUubm9kZU5hbWUpXG5cdFx0XHRcdFx0JiYgKGNoaWxkID0gaW1wb3J0Tm9kZShjaGlsZE5vZGUsIG9wdGlvbnMsIGZhbHNlKSlcblx0XHRcdFx0XHQmJiAhKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IGlzRGVmcykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0cmV0dXJuIFBhdGhJdGVtLmNyZWF0ZShub2RlLmdldEF0dHJpYnV0ZSgnZCcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyYWRpZW50KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0cmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsIF4gcmFkaWFsKSB7XG5cdFx0XHRcdGdyYWRpZW50ID0gZ3JhZGllbnQuY2xvbmUoKTtcblx0XHRcdFx0Z3JhZGllbnQuX3JhZGlhbCA9IHJhZGlhbDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgcmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCxcblx0XHRcdHNjYWxlVG9Cb3VuZHMgPSBnZXRWYWx1ZShub2RlLCAnZ3JhZGllbnRVbml0cycsIHRydWUpICE9PVxuXHRcdFx0XHQndXNlclNwYWNlT25Vc2UnO1xuXHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScsIGZhbHNlLCBzY2FsZVRvQm91bmRzLFxuXHRcdFx0XHQnNTAlJywgJzUwJScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKFxuXHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicsIGZhbHNlLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzUwJScpLCAwKTtcblx0XHRcdGhpZ2hsaWdodCA9IGdldFBvaW50KG5vZGUsICdmeCcsICdmeScsIHRydWUsIHNjYWxlVG9Cb3VuZHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcmlnaW4gPSBnZXRQb2ludChub2RlLCAneDEnLCAneTEnLCBmYWxzZSwgc2NhbGVUb0JvdW5kcyxcblx0XHRcdFx0JzAlJywgJzAlJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicsIGZhbHNlLCBzY2FsZVRvQm91bmRzLFxuXHRcdFx0XHQnMTAwJScsICcwJScpO1xuXHRcdH1cblx0XHR2YXIgY29sb3IgPSBhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRcdG5ldyBDb2xvcihncmFkaWVudCwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0KSwgbm9kZSk7XG5cdFx0Y29sb3IuX3NjYWxlVG9Cb3VuZHMgPSBzY2FsZVRvQm91bmRzO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRyZXR1cm4gaW1wb3J0Tm9kZShjaGlsZCwgb3B0aW9ucywgaXNSb290KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGc6IGltcG9ydEdyb3VwLFxuXHRcdHN2ZzogaW1wb3J0R3JvdXAsXG5cdFx0Y2xpcHBhdGg6IGltcG9ydEdyb3VwLFxuXHRcdHBvbHlnb246IGltcG9ydFBvbHksXG5cdFx0cG9seWxpbmU6IGltcG9ydFBvbHksXG5cdFx0cGF0aDogaW1wb3J0UGF0aCxcblx0XHRsaW5lYXJncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cdFx0cmFkaWFsZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXG5cdFx0aW1hZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpKTtcblx0XHRcdHJhc3Rlci5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGdldFNpemUobm9kZSk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldFBvaW50KG5vZGUpLmFkZChzaXplLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHRoaXMuX21hdHJpeC5hcHBlbmQobmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbihcblx0XHRcdFx0XHRpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb25cblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlKSxcblx0XHRcdFx0XHRcdGdldFNpemUobm9kZSlcblx0XHRcdFx0XHQpLCBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpKTtcblx0XHRcdH0sXG5cblx0XHRsaW5lOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBhdGguTGluZShcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSxcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDInLCAneTInKSk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlKS5hZGQoXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9LFxuXG5cdFx0c3dpdGNoOiBpbXBvcnRHcm91cFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG5cdFx0aWYgKGl0ZW0udHJhbnNmb3JtKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcblx0XHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdFx0diA9IHBhcnRzWzFdLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRtYXRyaXguYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0gfHwgMCwgdlsyXSB8fCAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0gfHwgMCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBrZXkgPSBuYW1lID09PSAnZmlsbC1vcGFjaXR5JyA/ICdnZXRGaWxsQ29sb3InIDogJ2dldFN0cm9rZUNvbG9yJyxcblx0XHRcdGNvbG9yID0gaXRlbVtrZXldICYmIGl0ZW1ba2V5XSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5zZXQoQmFzZS5lYWNoKFN2Z1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW1bZW50cnkuc2V0XSkge1xuXHRcdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRcdGlmIChlbnRyeS50eXBlID09PSAnY29sb3InKSB7XG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29sb3IuX3NjYWxlVG9Cb3VuZHMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGl0ZW0uZ2V0Qm91bmRzKCk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KClcblx0XHRcdFx0XHRcdFx0XHQudHJhbnNsYXRlKGJvdW5kcy5nZXRQb2ludCgpKVxuXHRcdFx0XHRcdFx0XHRcdC5zY2FsZShib3VuZHMuZ2V0U2l6ZSgpKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwge30pLCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldFZpc2libGUpXG5cdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0ZGlzcGxheTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldFZpc2libGUpXG5cdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uc2V0T2Zmc2V0KSB7XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuXHRcdFx0XHRpdGVtLnNldE9mZnNldChwZXJjZW50ID8gcGVyY2VudFsxXSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dmlld0JveDogZnVuY3Rpb24oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuXHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCBudWxsLCBudWxsLCB0cnVlKSxcblx0XHRcdFx0Z3JvdXAsXG5cdFx0XHRcdG1hdHJpeDtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gc2l6ZSA/IHNpemUuZGl2aWRlKHJlY3QuZ2V0U2l6ZSgpKSA6IDEsXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSlcblx0XHRcdFx0XHRcdC50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpLm5lZ2F0ZSgpKTtcblx0XHRcdFx0Z3JvdXAgPSBpdGVtO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikge1xuXHRcdFx0XHRpZiAoc2l6ZSlcblx0XHRcdFx0XHRyZWN0LnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdGdyb3VwID0gaXRlbS5faXRlbTtcblx0XHRcdH1cblx0XHRcdGlmIChncm91cCkgIHtcblx0XHRcdFx0aWYgKGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9PSAndmlzaWJsZScpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCk7XG5cdFx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0XHRncm91cC5hZGRDaGlsZChjbGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWF0cml4KVxuXHRcdFx0XHRcdGdyb3VwLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuXHRcdHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cdFx0aWYgKCF2YWx1ZSAmJiBub2RlLnN0eWxlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWUgPyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbFxuXHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG5cdFx0XHRzdHlsZXMgPSB7XG5cdFx0XHRcdG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuXHRcdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgIS9eZGVmcyQvaS50ZXN0KHBhcmVudC50YWdOYW1lKVxuXHRcdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRTdHlsZXMocGFyZW50KSB8fCB7fVxuXHRcdFx0fTtcblx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuXHRcdFx0aXRlbSA9IHZhbHVlICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQmJiBhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB8fCBpdGVtO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzpbXCInI10qKShbXlwiJyldKykvKSxcblx0XHRcdG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXSxcblx0XHRcdHJlcyA9IG5hbWUgJiYgZGVmaW5pdGlvbnNbd2luZG93XG5cdFx0XHRcdFx0PyBuYW1lLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJywgJycpXG5cdFx0XHRcdFx0OiBuYW1lXTtcblx0XHRpZiAocmVzICYmIHJlcy5fc2NhbGVUb0JvdW5kcykge1xuXHRcdFx0cmVzID0gcmVzLmNsb25lKCk7XG5cdFx0XHRyZXMuX3NjYWxlVG9Cb3VuZHMgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzRWxlbWVudCA9IHR5cGUgIT09ICcjZG9jdW1lbnQnLFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0XHRjb250YWluZXIsXG5cdFx0XHRwYXJlbnQsXG5cdFx0XHRuZXh0O1xuXHRcdGlmIChpc1Jvb3QgJiYgaXNFbGVtZW50KSB7XG5cdFx0XHRyb290U2l6ZSA9IHBhcGVyLmdldFZpZXcoKS5nZXRTaXplKCk7XG5cdFx0XHRyb290U2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSkgfHwgcm9vdFNpemU7XG5cdFx0XHRjb250YWluZXIgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywge1xuXHRcdFx0XHRzdHlsZTogJ3N0cm9rZS13aWR0aDogMXB4OyBzdHJva2UtbWl0ZXJsaW1pdDogMTAnXG5cdFx0XHR9KTtcblx0XHRcdHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdH1cblx0XHR2YXIgc2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncyxcblx0XHRcdGFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXgsXG5cdFx0XHRpbnNlcnRJdGVtcyA9IHNldHRpbmdzLmluc2VydEl0ZW1zO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0c2V0dGluZ3MuaW5zZXJ0SXRlbXMgPSBmYWxzZTtcblx0XHR2YXIgaW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuXHRcdHNldHRpbmdzLmluc2VydEl0ZW1zID0gaW5zZXJ0SXRlbXM7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKGlzRWxlbWVudCAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHZhciBvbkltcG9ydCA9IG9wdGlvbnMub25JbXBvcnQsXG5cdFx0XHRcdGRhdGEgPSBpc0VsZW1lbnQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpO1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgb3duZXIpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHsgb25Mb2FkOiBvcHRpb25zIH1cblx0XHRcdFx0OiBvcHRpb25zIHx8IHt9O1xuXHRcdHZhciBzY29wZSA9IHBhcGVyLFxuXHRcdFx0aXRlbSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWQoc3ZnKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBzdmcgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0PyBzdmdcblx0XHRcdFx0XHQ6IG5ldyBzZWxmLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhcblx0XHRcdFx0XHRcdHN2Zy50cmltKCksXG5cdFx0XHRcdFx0XHQnaW1hZ2Uvc3ZnK3htbCdcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoIW5vZGUubm9kZU5hbWUpIHtcblx0XHRcdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHRcdGl0ZW0gPSBpbXBvcnROb2RlKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5pbnNlcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgb25Mb2FkID0gb3B0aW9ucy5vbkxvYWQ7XG5cdFx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdFx0b25Mb2FkKGl0ZW0sIHN2Zyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25FcnJvcihtZXNzYWdlLCBzdGF0dXMpIHtcblx0XHRcdHZhciBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0b25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL15bXFxzXFxTXSo8Ly50ZXN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdG9uTG9hZChub2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEh0dHAucmVxdWVzdCh7XG5cdFx0XHRcdFx0dXJsOiBzb3VyY2UsXG5cdFx0XHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRcdFx0b25Mb2FkOiBvbkxvYWQsXG5cdFx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0b25Mb2FkKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0fTtcblx0XHRcdHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG9uRXJyb3IocmVhZGVyLmVycm9yKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25Mb2FkKHNvdXJjZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdFx0cmV0dXJuIGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xufTtcblxuQmFzZS5leHBvcnRzLlBhcGVyU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG5cdHZhciBnbG9iYWwgPSB0aGlzLFxuXHRcdGFjb3JuID0gZ2xvYmFsLmFjb3JuO1xuXHRpZiAoIWFjb3JuICYmIHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHRyeSB7IGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTsgfSBjYXRjaChlKSB7fVxuXHR9XG5cdGlmICghYWNvcm4pIHtcblx0XHR2YXIgZXhwb3J0cywgbW9kdWxlO1xuXHRcdGFjb3JuID0gZXhwb3J0cyA9IG1vZHVsZSA9IHt9O1xuXG4oZnVuY3Rpb24ocm9vdCwgbW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgcmV0dXJuIG1vZChleHBvcnRzKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHJldHVybiBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgbW9kKTtcbiAgbW9kKHJvb3QuYWNvcm4gfHwgKHJvb3QuYWNvcm4gPSB7fSkpO1xufSkodGhpcywgZnVuY3Rpb24oZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLnZlcnNpb24gPSBcIjAuNS4wXCI7XG5cbiAgdmFyIG9wdGlvbnMsIGlucHV0LCBpbnB1dExlbiwgc291cmNlRmlsZTtcblxuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oaW5wdCwgb3B0cykge1xuXHRpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG5cdHNldE9wdGlvbnMob3B0cyk7XG5cdGluaXRUb2tlblN0YXRlKCk7XG5cdHJldHVybiBwYXJzZVRvcExldmVsKG9wdGlvbnMucHJvZ3JhbSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcblx0ZWNtYVZlcnNpb246IDUsXG5cdHN0cmljdFNlbWljb2xvbnM6IGZhbHNlLFxuXHRhbGxvd1RyYWlsaW5nQ29tbWFzOiB0cnVlLFxuXHRmb3JiaWRSZXNlcnZlZDogZmFsc2UsXG5cdGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcblx0bG9jYXRpb25zOiBmYWxzZSxcblx0b25Db21tZW50OiBudWxsLFxuXHRyYW5nZXM6IGZhbHNlLFxuXHRwcm9ncmFtOiBudWxsLFxuXHRzb3VyY2VGaWxlOiBudWxsLFxuXHRkaXJlY3RTb3VyY2VGaWxlOiBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG5cdG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuXHRmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdCkpXG5cdCAgb3B0aW9uc1tvcHRdID0gZGVmYXVsdE9wdGlvbnNbb3B0XTtcblx0c291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZSB8fCBudWxsO1xuICB9XG5cbiAgdmFyIGdldExpbmVJbmZvID0gZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGZ1bmN0aW9uKGlucHV0LCBvZmZzZXQpIHtcblx0Zm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuXHQgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBjdXI7XG5cdCAgdmFyIG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpO1xuXHQgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuXHRcdCsrbGluZTtcblx0XHRjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0ICB9IGVsc2UgYnJlYWs7XG5cdH1cblx0cmV0dXJuIHtsaW5lOiBsaW5lLCBjb2x1bW46IG9mZnNldCAtIGN1cn07XG4gIH07XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uKGlucHQsIG9wdHMpIHtcblx0aW5wdXQgPSBTdHJpbmcoaW5wdCk7IGlucHV0TGVuID0gaW5wdXQubGVuZ3RoO1xuXHRzZXRPcHRpb25zKG9wdHMpO1xuXHRpbml0VG9rZW5TdGF0ZSgpO1xuXG5cdHZhciB0ID0ge307XG5cdGZ1bmN0aW9uIGdldFRva2VuKGZvcmNlUmVnZXhwKSB7XG5cdCAgbGFzdEVuZCA9IHRva0VuZDtcblx0ICByZWFkVG9rZW4oZm9yY2VSZWdleHApO1xuXHQgIHQuc3RhcnQgPSB0b2tTdGFydDsgdC5lbmQgPSB0b2tFbmQ7XG5cdCAgdC5zdGFydExvYyA9IHRva1N0YXJ0TG9jOyB0LmVuZExvYyA9IHRva0VuZExvYztcblx0ICB0LnR5cGUgPSB0b2tUeXBlOyB0LnZhbHVlID0gdG9rVmFsO1xuXHQgIHJldHVybiB0O1xuXHR9XG5cdGdldFRva2VuLmp1bXBUbyA9IGZ1bmN0aW9uKHBvcywgcmVBbGxvd2VkKSB7XG5cdCAgdG9rUG9zID0gcG9zO1xuXHQgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdHRva0N1ckxpbmUgPSAxO1xuXHRcdHRva0xpbmVTdGFydCA9IGxpbmVCcmVhay5sYXN0SW5kZXggPSAwO1xuXHRcdHZhciBtYXRjaDtcblx0XHR3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHBvcykge1xuXHRcdCAgKyt0b2tDdXJMaW5lO1xuXHRcdCAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdFx0fVxuXHQgIH1cblx0ICB0b2tSZWdleHBBbGxvd2VkID0gcmVBbGxvd2VkO1xuXHQgIHNraXBTcGFjZSgpO1xuXHR9O1xuXHRyZXR1cm4gZ2V0VG9rZW47XG4gIH07XG5cbiAgdmFyIHRva1BvcztcblxuICB2YXIgdG9rU3RhcnQsIHRva0VuZDtcblxuICB2YXIgdG9rU3RhcnRMb2MsIHRva0VuZExvYztcblxuICB2YXIgdG9rVHlwZSwgdG9rVmFsO1xuXG4gIHZhciB0b2tSZWdleHBBbGxvd2VkO1xuXG4gIHZhciB0b2tDdXJMaW5lLCB0b2tMaW5lU3RhcnQ7XG5cbiAgdmFyIGxhc3RTdGFydCwgbGFzdEVuZCwgbGFzdEVuZExvYztcblxuICB2YXIgaW5GdW5jdGlvbiwgbGFiZWxzLCBzdHJpY3Q7XG5cbiAgZnVuY3Rpb24gcmFpc2UocG9zLCBtZXNzYWdlKSB7XG5cdHZhciBsb2MgPSBnZXRMaW5lSW5mbyhpbnB1dCwgcG9zKTtcblx0bWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuXHR2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuXHRlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0b2tQb3M7XG5cdHRocm93IGVycjtcbiAgfVxuXG4gIHZhciBlbXB0eSA9IFtdO1xuXG4gIHZhciBfbnVtID0ge3R5cGU6IFwibnVtXCJ9LCBfcmVnZXhwID0ge3R5cGU6IFwicmVnZXhwXCJ9LCBfc3RyaW5nID0ge3R5cGU6IFwic3RyaW5nXCJ9O1xuICB2YXIgX25hbWUgPSB7dHlwZTogXCJuYW1lXCJ9LCBfZW9mID0ge3R5cGU6IFwiZW9mXCJ9O1xuXG4gIHZhciBfYnJlYWsgPSB7a2V5d29yZDogXCJicmVha1wifSwgX2Nhc2UgPSB7a2V5d29yZDogXCJjYXNlXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfY2F0Y2ggPSB7a2V5d29yZDogXCJjYXRjaFwifTtcbiAgdmFyIF9jb250aW51ZSA9IHtrZXl3b3JkOiBcImNvbnRpbnVlXCJ9LCBfZGVidWdnZXIgPSB7a2V5d29yZDogXCJkZWJ1Z2dlclwifSwgX2RlZmF1bHQgPSB7a2V5d29yZDogXCJkZWZhdWx0XCJ9O1xuICB2YXIgX2RvID0ge2tleXdvcmQ6IFwiZG9cIiwgaXNMb29wOiB0cnVlfSwgX2Vsc2UgPSB7a2V5d29yZDogXCJlbHNlXCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2ZpbmFsbHkgPSB7a2V5d29yZDogXCJmaW5hbGx5XCJ9LCBfZm9yID0ge2tleXdvcmQ6IFwiZm9yXCIsIGlzTG9vcDogdHJ1ZX0sIF9mdW5jdGlvbiA9IHtrZXl3b3JkOiBcImZ1bmN0aW9uXCJ9O1xuICB2YXIgX2lmID0ge2tleXdvcmQ6IFwiaWZcIn0sIF9yZXR1cm4gPSB7a2V5d29yZDogXCJyZXR1cm5cIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9zd2l0Y2ggPSB7a2V5d29yZDogXCJzd2l0Y2hcIn07XG4gIHZhciBfdGhyb3cgPSB7a2V5d29yZDogXCJ0aHJvd1wiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3RyeSA9IHtrZXl3b3JkOiBcInRyeVwifSwgX3ZhciA9IHtrZXl3b3JkOiBcInZhclwifTtcbiAgdmFyIF93aGlsZSA9IHtrZXl3b3JkOiBcIndoaWxlXCIsIGlzTG9vcDogdHJ1ZX0sIF93aXRoID0ge2tleXdvcmQ6IFwid2l0aFwifSwgX25ldyA9IHtrZXl3b3JkOiBcIm5ld1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF90aGlzID0ge2tleXdvcmQ6IFwidGhpc1wifTtcblxuICB2YXIgX251bGwgPSB7a2V5d29yZDogXCJudWxsXCIsIGF0b21WYWx1ZTogbnVsbH0sIF90cnVlID0ge2tleXdvcmQ6IFwidHJ1ZVwiLCBhdG9tVmFsdWU6IHRydWV9O1xuICB2YXIgX2ZhbHNlID0ge2tleXdvcmQ6IFwiZmFsc2VcIiwgYXRvbVZhbHVlOiBmYWxzZX07XG5cbiAgdmFyIF9pbiA9IHtrZXl3b3JkOiBcImluXCIsIGJpbm9wOiA3LCBiZWZvcmVFeHByOiB0cnVlfTtcblxuICB2YXIga2V5d29yZFR5cGVzID0ge1wiYnJlYWtcIjogX2JyZWFrLCBcImNhc2VcIjogX2Nhc2UsIFwiY2F0Y2hcIjogX2NhdGNoLFxuXHRcdFx0XHRcdCAgXCJjb250aW51ZVwiOiBfY29udGludWUsIFwiZGVidWdnZXJcIjogX2RlYnVnZ2VyLCBcImRlZmF1bHRcIjogX2RlZmF1bHQsXG5cdFx0XHRcdFx0ICBcImRvXCI6IF9kbywgXCJlbHNlXCI6IF9lbHNlLCBcImZpbmFsbHlcIjogX2ZpbmFsbHksIFwiZm9yXCI6IF9mb3IsXG5cdFx0XHRcdFx0ICBcImZ1bmN0aW9uXCI6IF9mdW5jdGlvbiwgXCJpZlwiOiBfaWYsIFwicmV0dXJuXCI6IF9yZXR1cm4sIFwic3dpdGNoXCI6IF9zd2l0Y2gsXG5cdFx0XHRcdFx0ICBcInRocm93XCI6IF90aHJvdywgXCJ0cnlcIjogX3RyeSwgXCJ2YXJcIjogX3ZhciwgXCJ3aGlsZVwiOiBfd2hpbGUsIFwid2l0aFwiOiBfd2l0aCxcblx0XHRcdFx0XHQgIFwibnVsbFwiOiBfbnVsbCwgXCJ0cnVlXCI6IF90cnVlLCBcImZhbHNlXCI6IF9mYWxzZSwgXCJuZXdcIjogX25ldywgXCJpblwiOiBfaW4sXG5cdFx0XHRcdFx0ICBcImluc3RhbmNlb2ZcIjoge2tleXdvcmQ6IFwiaW5zdGFuY2VvZlwiLCBiaW5vcDogNywgYmVmb3JlRXhwcjogdHJ1ZX0sIFwidGhpc1wiOiBfdGhpcyxcblx0XHRcdFx0XHQgIFwidHlwZW9mXCI6IHtrZXl3b3JkOiBcInR5cGVvZlwiLCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9LFxuXHRcdFx0XHRcdCAgXCJ2b2lkXCI6IHtrZXl3b3JkOiBcInZvaWRcIiwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSxcblx0XHRcdFx0XHQgIFwiZGVsZXRlXCI6IHtrZXl3b3JkOiBcImRlbGV0ZVwiLCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9fTtcblxuICB2YXIgX2JyYWNrZXRMID0ge3R5cGU6IFwiW1wiLCBiZWZvcmVFeHByOiB0cnVlfSwgX2JyYWNrZXRSID0ge3R5cGU6IFwiXVwifSwgX2JyYWNlTCA9IHt0eXBlOiBcIntcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYnJhY2VSID0ge3R5cGU6IFwifVwifSwgX3BhcmVuTCA9IHt0eXBlOiBcIihcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9wYXJlblIgPSB7dHlwZTogXCIpXCJ9O1xuICB2YXIgX2NvbW1hID0ge3R5cGU6IFwiLFwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3NlbWkgPSB7dHlwZTogXCI7XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2NvbG9uID0ge3R5cGU6IFwiOlwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX2RvdCA9IHt0eXBlOiBcIi5cIn0sIF9xdWVzdGlvbiA9IHt0eXBlOiBcIj9cIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG5cbiAgdmFyIF9zbGFzaCA9IHtiaW5vcDogMTAsIGJlZm9yZUV4cHI6IHRydWV9LCBfZXEgPSB7aXNBc3NpZ246IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2Fzc2lnbiA9IHtpc0Fzc2lnbjogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfaW5jRGVjID0ge3Bvc3RmaXg6IHRydWUsIHByZWZpeDogdHJ1ZSwgaXNVcGRhdGU6IHRydWV9LCBfcHJlZml4ID0ge3ByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfbG9naWNhbE9SID0ge2Jpbm9wOiAxLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9sb2dpY2FsQU5EID0ge2Jpbm9wOiAyLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9iaXR3aXNlT1IgPSB7Ymlub3A6IDMsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdHdpc2VYT1IgPSB7Ymlub3A6IDQsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdHdpc2VBTkQgPSB7Ymlub3A6IDUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2VxdWFsaXR5ID0ge2Jpbm9wOiA2LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9yZWxhdGlvbmFsID0ge2Jpbm9wOiA3LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9iaXRTaGlmdCA9IHtiaW5vcDogOCwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfcGx1c01pbiA9IHtiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9tdWx0aXBseU1vZHVsbyA9IHtiaW5vcDogMTAsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIGV4cG9ydHMudG9rVHlwZXMgPSB7YnJhY2tldEw6IF9icmFja2V0TCwgYnJhY2tldFI6IF9icmFja2V0UiwgYnJhY2VMOiBfYnJhY2VMLCBicmFjZVI6IF9icmFjZVIsXG5cdFx0XHRcdFx0ICBwYXJlbkw6IF9wYXJlbkwsIHBhcmVuUjogX3BhcmVuUiwgY29tbWE6IF9jb21tYSwgc2VtaTogX3NlbWksIGNvbG9uOiBfY29sb24sXG5cdFx0XHRcdFx0ICBkb3Q6IF9kb3QsIHF1ZXN0aW9uOiBfcXVlc3Rpb24sIHNsYXNoOiBfc2xhc2gsIGVxOiBfZXEsIG5hbWU6IF9uYW1lLCBlb2Y6IF9lb2YsXG5cdFx0XHRcdFx0ICBudW06IF9udW0sIHJlZ2V4cDogX3JlZ2V4cCwgc3RyaW5nOiBfc3RyaW5nfTtcbiAgZm9yICh2YXIga3cgaW4ga2V5d29yZFR5cGVzKSBleHBvcnRzLnRva1R5cGVzW1wiX1wiICsga3ddID0ga2V5d29yZFR5cGVzW2t3XTtcblxuICBmdW5jdGlvbiBtYWtlUHJlZGljYXRlKHdvcmRzKSB7XG5cdHdvcmRzID0gd29yZHMuc3BsaXQoXCIgXCIpO1xuXHR2YXIgZiA9IFwiXCIsIGNhdHMgPSBbXTtcblx0b3V0OiBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG5cdCAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxuXHRcdGlmIChjYXRzW2pdWzBdLmxlbmd0aCA9PSB3b3Jkc1tpXS5sZW5ndGgpIHtcblx0XHQgIGNhdHNbal0ucHVzaCh3b3Jkc1tpXSk7XG5cdFx0ICBjb250aW51ZSBvdXQ7XG5cdFx0fVxuXHQgIGNhdHMucHVzaChbd29yZHNbaV1dKTtcblx0fVxuXHRmdW5jdGlvbiBjb21wYXJlVG8oYXJyKSB7XG5cdCAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcblx0ICBmICs9IFwic3dpdGNoKHN0cil7XCI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGYgKz0gXCJjYXNlIFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyW2ldKSArIFwiOlwiO1xuXHQgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG5cdH1cblxuXHRpZiAoY2F0cy5sZW5ndGggPiAzKSB7XG5cdCAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDt9KTtcblx0ICBmICs9IFwic3dpdGNoKHN0ci5sZW5ndGgpe1wiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBjYXQgPSBjYXRzW2ldO1xuXHRcdGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuXHRcdGNvbXBhcmVUbyhjYXQpO1xuXHQgIH1cblx0ICBmICs9IFwifVwiO1xuXG5cdH0gZWxzZSB7XG5cdCAgY29tcGFyZVRvKHdvcmRzKTtcblx0fVxuXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RyXCIsIGYpO1xuICB9XG5cbiAgdmFyIGlzUmVzZXJ2ZWRXb3JkMyA9IG1ha2VQcmVkaWNhdGUoXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIpO1xuXG4gIHZhciBpc1Jlc2VydmVkV29yZDUgPSBtYWtlUHJlZGljYXRlKFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIik7XG5cbiAgdmFyIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkID0gbWFrZVByZWRpY2F0ZShcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIik7XG5cbiAgdmFyIGlzU3RyaWN0QmFkSWRXb3JkID0gbWFrZVByZWRpY2F0ZShcImV2YWwgYXJndW1lbnRzXCIpO1xuXG4gIHZhciBpc0tleXdvcmQgPSBtYWtlUHJlZGljYXRlKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpO1xuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgdmFyIG5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbiAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS9nO1xuXG4gIHZhciBpc0lkZW50aWZpZXJTdGFydCA9IGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjb2RlKSB7XG5cdGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcblx0aWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG5cdGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcblx0aWYgKGNvZGUgPCAxMjMpcmV0dXJuIHRydWU7XG5cdHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfTtcblxuICB2YXIgaXNJZGVudGlmaWVyQ2hhciA9IGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGZ1bmN0aW9uKGNvZGUpIHtcblx0aWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuXHRpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcblx0aWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuXHRpZiAoY29kZSA8IDEyMylyZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfTtcblxuICBmdW5jdGlvbiBsaW5lX2xvY190KCkge1xuXHR0aGlzLmxpbmUgPSB0b2tDdXJMaW5lO1xuXHR0aGlzLmNvbHVtbiA9IHRva1BvcyAtIHRva0xpbmVTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRUb2tlblN0YXRlKCkge1xuXHR0b2tDdXJMaW5lID0gMTtcblx0dG9rUG9zID0gdG9rTGluZVN0YXJ0ID0gMDtcblx0dG9rUmVnZXhwQWxsb3dlZCA9IHRydWU7XG5cdHNraXBTcGFjZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG5cdHRva0VuZCA9IHRva1Bvcztcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tFbmRMb2MgPSBuZXcgbGluZV9sb2NfdDtcblx0dG9rVHlwZSA9IHR5cGU7XG5cdHNraXBTcGFjZSgpO1xuXHR0b2tWYWwgPSB2YWw7XG5cdHRva1JlZ2V4cEFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwQmxvY2tDb21tZW50KCkge1xuXHR2YXIgc3RhcnRMb2MgPSBvcHRpb25zLm9uQ29tbWVudCAmJiBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdDtcblx0dmFyIHN0YXJ0ID0gdG9rUG9zLCBlbmQgPSBpbnB1dC5pbmRleE9mKFwiKi9cIiwgdG9rUG9zICs9IDIpO1xuXHRpZiAoZW5kID09PSAtMSkgcmFpc2UodG9rUG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTtcblx0dG9rUG9zID0gZW5kICsgMjtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdCAgbGluZUJyZWFrLmxhc3RJbmRleCA9IHN0YXJ0O1xuXHQgIHZhciBtYXRjaDtcblx0ICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRva1Bvcykge1xuXHRcdCsrdG9rQ3VyTGluZTtcblx0XHR0b2tMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0ICB9XG5cdH1cblx0aWYgKG9wdGlvbnMub25Db21tZW50KVxuXHQgIG9wdGlvbnMub25Db21tZW50KHRydWUsIGlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRva1Bvcyxcblx0XHRcdFx0XHRcdHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCk7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwTGluZUNvbW1lbnQoKSB7XG5cdHZhciBzdGFydCA9IHRva1Bvcztcblx0dmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3Q7XG5cdHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKz0yKTtcblx0d2hpbGUgKHRva1BvcyA8IGlucHV0TGVuICYmIGNoICE9PSAxMCAmJiBjaCAhPT0gMTMgJiYgY2ggIT09IDgyMzIgJiYgY2ggIT09IDgyMzMpIHtcblx0ICArK3Rva1Bvcztcblx0ICBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0fVxuXHRpZiAob3B0aW9ucy5vbkNvbW1lbnQpXG5cdCAgb3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIGlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdG9rUG9zKSwgc3RhcnQsIHRva1Bvcyxcblx0XHRcdFx0XHRcdHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdCk7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwU3BhY2UoKSB7XG5cdHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbikge1xuXHQgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0ICBpZiAoY2ggPT09IDMyKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gMTMpIHtcblx0XHQrK3Rva1Bvcztcblx0XHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0XHRpZiAobmV4dCA9PT0gMTApIHtcblx0XHQgICsrdG9rUG9zO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0XHQgICsrdG9rQ3VyTGluZTtcblx0XHQgIHRva0xpbmVTdGFydCA9IHRva1Bvcztcblx0XHR9XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHtcblx0XHQrK3Rva1Bvcztcblx0XHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0XHQgICsrdG9rQ3VyTGluZTtcblx0XHQgIHRva0xpbmVTdGFydCA9IHRva1Bvcztcblx0XHR9XG5cdCAgfSBlbHNlIGlmIChjaCA+IDggJiYgY2ggPCAxNCkge1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDQ3KSB7XG5cdFx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRcdGlmIChuZXh0ID09PSA0Mikge1xuXHRcdCAgc2tpcEJsb2NrQ29tbWVudCgpO1xuXHRcdH0gZWxzZSBpZiAobmV4dCA9PT0gNDcpIHtcblx0XHQgIHNraXBMaW5lQ29tbWVudCgpO1xuXHRcdH0gZWxzZSBicmVhaztcblx0ICB9IGVsc2UgaWYgKGNoID09PSAxNjApIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2UgaWYgKGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIHtcblx0XHRicmVhaztcblx0ICB9XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9kb3QoKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgcmV0dXJuIHJlYWROdW1iZXIodHJ1ZSk7XG5cdCsrdG9rUG9zO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4oX2RvdCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fc2xhc2goKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKHRva1JlZ2V4cEFsbG93ZWQpIHsrK3Rva1BvczsgcmV0dXJuIHJlYWRSZWdleHAoKTt9XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoX3NsYXNoLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9tdWx0X21vZHVsbygpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKF9tdWx0aXBseU1vZHVsbywgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSBjb2RlKSByZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gX2xvZ2ljYWxPUiA6IF9sb2dpY2FsQU5ELCAyKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfYml0d2lzZU9SIDogX2JpdHdpc2VBTkQsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2NhcmV0KCkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoX2JpdHdpc2VYT1IsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA9PT0gY29kZSkge1xuXHQgIGlmIChuZXh0ID09IDQ1ICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT0gNjIgJiZcblx0XHQgIG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tQb3MpKSkge1xuXHRcdHRva1BvcyArPSAzO1xuXHRcdHNraXBMaW5lQ29tbWVudCgpO1xuXHRcdHNraXBTcGFjZSgpO1xuXHRcdHJldHVybiByZWFkVG9rZW4oKTtcblx0ICB9XG5cdCAgcmV0dXJuIGZpbmlzaE9wKF9pbmNEZWMsIDIpO1xuXHR9XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoX3BsdXNNaW4sIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHR2YXIgc2l6ZSA9IDE7XG5cdGlmIChuZXh0ID09PSBjb2RlKSB7XG5cdCAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYyID8gMyA6IDI7XG5cdCAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgc2l6ZSkgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgc2l6ZSArIDEpO1xuXHQgIHJldHVybiBmaW5pc2hPcChfYml0U2hpZnQsIHNpemUpO1xuXHR9XG5cdGlmIChuZXh0ID09IDMzICYmIGNvZGUgPT0gNjAgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PSA0NSAmJlxuXHRcdGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMykgPT0gNDUpIHtcblx0ICB0b2tQb3MgKz0gNDtcblx0ICBza2lwTGluZUNvbW1lbnQoKTtcblx0ICBza2lwU3BhY2UoKTtcblx0ICByZXR1cm4gcmVhZFRva2VuKCk7XG5cdH1cblx0aWYgKG5leHQgPT09IDYxKVxuXHQgIHNpemUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSA/IDMgOiAyO1xuXHRyZXR1cm4gZmluaXNoT3AoX3JlbGF0aW9uYWwsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9lcXVhbGl0eSwgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG5cdHJldHVybiBmaW5pc2hPcChjb2RlID09PSA2MSA/IF9lcSA6IF9wcmVmaXgsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG5cdHN3aXRjaChjb2RlKSB7XG5cdGNhc2UgNDY6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9kb3QoKTtcblxuXHRjYXNlIDQwOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9wYXJlbkwpO1xuXHRjYXNlIDQxOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9wYXJlblIpO1xuXHRjYXNlIDU5OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9zZW1pKTtcblx0Y2FzZSA0NDogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfY29tbWEpO1xuXHRjYXNlIDkxOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFja2V0TCk7XG5cdGNhc2UgOTM6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRSKTtcblx0Y2FzZSAxMjM6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNlTCk7XG5cdGNhc2UgMTI1OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZVIpO1xuXHRjYXNlIDU4OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9jb2xvbik7XG5cdGNhc2UgNjM6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3F1ZXN0aW9uKTtcblxuXHRjYXNlIDQ4OlxuXHQgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0ICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSByZXR1cm4gcmVhZEhleE51bWJlcigpO1xuXHRjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OlxuXHQgIHJldHVybiByZWFkTnVtYmVyKGZhbHNlKTtcblxuXHRjYXNlIDM0OiBjYXNlIDM5OlxuXHQgIHJldHVybiByZWFkU3RyaW5nKGNvZGUpO1xuXG5cdGNhc2UgNDc6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9zbGFzaChjb2RlKTtcblxuXHRjYXNlIDM3OiBjYXNlIDQyOlxuXHQgIHJldHVybiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oKTtcblxuXHRjYXNlIDEyNDogY2FzZSAzODpcblx0ICByZXR1cm4gcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuXG5cdGNhc2UgOTQ6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9jYXJldCgpO1xuXG5cdGNhc2UgNDM6IGNhc2UgNDU6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcblxuXHRjYXNlIDYwOiBjYXNlIDYyOlxuXHQgIHJldHVybiByZWFkVG9rZW5fbHRfZ3QoY29kZSk7XG5cblx0Y2FzZSA2MTogY2FzZSAzMzpcblx0ICByZXR1cm4gcmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG5cblx0Y2FzZSAxMjY6XG5cdCAgcmV0dXJuIGZpbmlzaE9wKF9wcmVmaXgsIDEpO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuKGZvcmNlUmVnZXhwKSB7XG5cdGlmICghZm9yY2VSZWdleHApIHRva1N0YXJ0ID0gdG9rUG9zO1xuXHRlbHNlIHRva1BvcyA9IHRva1N0YXJ0ICsgMTtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tTdGFydExvYyA9IG5ldyBsaW5lX2xvY190O1xuXHRpZiAoZm9yY2VSZWdleHApIHJldHVybiByZWFkUmVnZXhwKCk7XG5cdGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJldHVybiBmaW5pc2hUb2tlbihfZW9mKTtcblxuXHR2YXIgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0aWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHx8IGNvZGUgPT09IDkyICkgcmV0dXJuIHJlYWRXb3JkKCk7XG5cblx0dmFyIHRvayA9IGdldFRva2VuRnJvbUNvZGUoY29kZSk7XG5cblx0aWYgKHRvayA9PT0gZmFsc2UpIHtcblx0ICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHQgIGlmIChjaCA9PT0gXCJcXFxcXCIgfHwgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChjaCkpIHJldHVybiByZWFkV29yZCgpO1xuXHQgIHJhaXNlKHRva1BvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJ1wiKTtcblx0fVxuXHRyZXR1cm4gdG9rO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoT3AodHlwZSwgc2l6ZSkge1xuXHR2YXIgc3RyID0gaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyBzaXplKTtcblx0dG9rUG9zICs9IHNpemU7XG5cdGZpbmlzaFRva2VuKHR5cGUsIHN0cik7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKCkge1xuXHR2YXIgY29udGVudCA9IFwiXCIsIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdG9rUG9zO1xuXHRmb3IgKDs7KSB7XG5cdCAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQodG9rUG9zKTtcblx0ICBpZiAobmV3bGluZS50ZXN0KGNoKSkgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcblx0ICBpZiAoIWVzY2FwZWQpIHtcblx0XHRpZiAoY2ggPT09IFwiW1wiKSBpbkNsYXNzID0gdHJ1ZTtcblx0XHRlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgaW5DbGFzcyA9IGZhbHNlO1xuXHRcdGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgYnJlYWs7XG5cdFx0ZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcblx0ICB9IGVsc2UgZXNjYXBlZCA9IGZhbHNlO1xuXHQgICsrdG9rUG9zO1xuXHR9XG5cdHZhciBjb250ZW50ID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG5cdCsrdG9rUG9zO1xuXHR2YXIgbW9kcyA9IHJlYWRXb3JkMSgpO1xuXHRpZiAobW9kcyAmJiAhL15bZ21zaXldKiQvLnRlc3QobW9kcykpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgcmVnZXhwIGZsYWdcIik7XG5cdHRyeSB7XG5cdCAgdmFyIHZhbHVlID0gbmV3IFJlZ0V4cChjb250ZW50LCBtb2RzKTtcblx0fSBjYXRjaCAoZSkge1xuXHQgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHJhaXNlKHN0YXJ0LCBlLm1lc3NhZ2UpO1xuXHQgIHJhaXNlKGUpO1xuXHR9XG5cdHJldHVybiBmaW5pc2hUb2tlbihfcmVnZXhwLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSW50KHJhZGl4LCBsZW4pIHtcblx0dmFyIHN0YXJ0ID0gdG9rUG9zLCB0b3RhbCA9IDA7XG5cdGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuXHQgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpLCB2YWw7XG5cdCAgaWYgKGNvZGUgPj0gOTcpIHZhbCA9IGNvZGUgLSA5NyArIDEwO1xuXHQgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHZhbCA9IGNvZGUgLSA2NSArIDEwO1xuXHQgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgdmFsID0gY29kZSAtIDQ4O1xuXHQgIGVsc2UgdmFsID0gSW5maW5pdHk7XG5cdCAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG5cdCAgKyt0b2tQb3M7XG5cdCAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuXHR9XG5cdGlmICh0b2tQb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRva1BvcyAtIHN0YXJ0ICE9PSBsZW4pIHJldHVybiBudWxsO1xuXG5cdHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRIZXhOdW1iZXIoKSB7XG5cdHRva1BvcyArPSAyO1xuXHR2YXIgdmFsID0gcmVhZEludCgxNik7XG5cdGlmICh2YWwgPT0gbnVsbCkgcmFpc2UodG9rU3RhcnQgKyAyLCBcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKTtcblx0aWYgKGlzSWRlbnRpZmllclN0YXJ0KGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkpIHJhaXNlKHRva1BvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblx0cmV0dXJuIGZpbmlzaFRva2VuKF9udW0sIHZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkTnVtYmVyKHN0YXJ0c1dpdGhEb3QpIHtcblx0dmFyIHN0YXJ0ID0gdG9rUG9zLCBpc0Zsb2F0ID0gZmFsc2UsIG9jdGFsID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0ODtcblx0aWYgKCFzdGFydHNXaXRoRG90ICYmIHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblx0aWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gNDYpIHtcblx0ICArK3Rva1Bvcztcblx0ICByZWFkSW50KDEwKTtcblx0ICBpc0Zsb2F0ID0gdHJ1ZTtcblx0fVxuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0aWYgKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkge1xuXHQgIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcblx0ICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpICsrdG9rUG9zO1xuXHQgIGlmIChyZWFkSW50KDEwKSA9PT0gbnVsbCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG5cdCAgaXNGbG9hdCA9IHRydWU7XG5cdH1cblx0aWYgKGlzSWRlbnRpZmllclN0YXJ0KGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkpIHJhaXNlKHRva1BvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblxuXHR2YXIgc3RyID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1BvcyksIHZhbDtcblx0aWYgKGlzRmxvYXQpIHZhbCA9IHBhcnNlRmxvYXQoc3RyKTtcblx0ZWxzZSBpZiAoIW9jdGFsIHx8IHN0ci5sZW5ndGggPT09IDEpIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO1xuXHRlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHN0cmljdCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG5cdGVsc2UgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcblx0cmV0dXJuIGZpbmlzaFRva2VuKF9udW0sIHZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RyaW5nKHF1b3RlKSB7XG5cdHRva1BvcysrO1xuXHR2YXIgb3V0ID0gXCJcIjtcblx0Zm9yICg7Oykge1xuXHQgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG5cdCAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHQgIGlmIChjaCA9PT0gcXVvdGUpIHtcblx0XHQrK3Rva1Bvcztcblx0XHRyZXR1cm4gZmluaXNoVG9rZW4oX3N0cmluZywgb3V0KTtcblx0ICB9XG5cdCAgaWYgKGNoID09PSA5Mikge1xuXHRcdGNoID0gaW5wdXQuY2hhckNvZGVBdCgrK3Rva1Bvcyk7XG5cdFx0dmFyIG9jdGFsID0gL15bMC03XSsvLmV4ZWMoaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyAzKSk7XG5cdFx0aWYgKG9jdGFsKSBvY3RhbCA9IG9jdGFsWzBdO1xuXHRcdHdoaWxlIChvY3RhbCAmJiBwYXJzZUludChvY3RhbCwgOCkgPiAyNTUpIG9jdGFsID0gb2N0YWwuc2xpY2UoMCwgLTEpO1xuXHRcdGlmIChvY3RhbCA9PT0gXCIwXCIpIG9jdGFsID0gbnVsbDtcblx0XHQrK3Rva1Bvcztcblx0XHRpZiAob2N0YWwpIHtcblx0XHQgIGlmIChzdHJpY3QpIHJhaXNlKHRva1BvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKTtcblx0XHQgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG9jdGFsLCA4KSk7XG5cdFx0ICB0b2tQb3MgKz0gb2N0YWwubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgc3dpdGNoIChjaCkge1xuXHRcdCAgY2FzZSAxMTA6IG91dCArPSBcIlxcblwiOyBicmVhaztcblx0XHQgIGNhc2UgMTE0OiBvdXQgKz0gXCJcXHJcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDEyMDogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoMikpOyBicmVhaztcblx0XHQgIGNhc2UgMTE3OiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcig0KSk7IGJyZWFrO1xuXHRcdCAgY2FzZSA4NTogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoOCkpOyBicmVhaztcblx0XHQgIGNhc2UgMTE2OiBvdXQgKz0gXCJcXHRcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDk4OiBvdXQgKz0gXCJcXGJcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDExODogb3V0ICs9IFwiXFx1MDAwYlwiOyBicmVhaztcblx0XHQgIGNhc2UgMTAyOiBvdXQgKz0gXCJcXGZcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDQ4OiBvdXQgKz0gXCJcXDBcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDEzOiBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSAxMCkgKyt0b2tQb3M7XG5cdFx0ICBjYXNlIDEwOlxuXHRcdFx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7IHRva0xpbmVTdGFydCA9IHRva1BvczsgKyt0b2tDdXJMaW5lOyB9XG5cdFx0XHRicmVhaztcblx0XHQgIGRlZmF1bHQ6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTsgYnJlYWs7XG5cdFx0ICB9XG5cdFx0fVxuXHQgIH0gZWxzZSB7XG5cdFx0aWYgKGNoID09PSAxMyB8fCBjaCA9PT0gMTAgfHwgY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG5cdFx0b3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXHRcdCsrdG9rUG9zO1xuXHQgIH1cblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEhleENoYXIobGVuKSB7XG5cdHZhciBuID0gcmVhZEludCgxNiwgbGVuKTtcblx0aWYgKG4gPT09IG51bGwpIHJhaXNlKHRva1N0YXJ0LCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuXHRyZXR1cm4gbjtcbiAgfVxuXG4gIHZhciBjb250YWluc0VzYztcblxuICBmdW5jdGlvbiByZWFkV29yZDEoKSB7XG5cdGNvbnRhaW5zRXNjID0gZmFsc2U7XG5cdHZhciB3b3JkLCBmaXJzdCA9IHRydWUsIHN0YXJ0ID0gdG9rUG9zO1xuXHRmb3IgKDs7KSB7XG5cdCAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHQgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoKSkge1xuXHRcdGlmIChjb250YWluc0VzYykgd29yZCArPSBpbnB1dC5jaGFyQXQodG9rUG9zKTtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuXHRcdGlmICghY29udGFpbnNFc2MpIHdvcmQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcblx0XHRjb250YWluc0VzYyA9IHRydWU7XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpICE9IDExNylcblx0XHQgIHJhaXNlKHRva1BvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpO1xuXHRcdCsrdG9rUG9zO1xuXHRcdHZhciBlc2MgPSByZWFkSGV4Q2hhcig0KTtcblx0XHR2YXIgZXNjU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShlc2MpO1xuXHRcdGlmICghZXNjU3RyKSByYWlzZSh0b2tQb3MgLSAxLCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG5cdFx0aWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydChlc2MpIDogaXNJZGVudGlmaWVyQ2hhcihlc2MpKSlcblx0XHQgIHJhaXNlKHRva1BvcyAtIDQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcblx0XHR3b3JkICs9IGVzY1N0cjtcblx0ICB9IGVsc2Uge1xuXHRcdGJyZWFrO1xuXHQgIH1cblx0ICBmaXJzdCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBjb250YWluc0VzYyA/IHdvcmQgOiBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRXb3JkKCkge1xuXHR2YXIgd29yZCA9IHJlYWRXb3JkMSgpO1xuXHR2YXIgdHlwZSA9IF9uYW1lO1xuXHRpZiAoIWNvbnRhaW5zRXNjICYmIGlzS2V5d29yZCh3b3JkKSlcblx0ICB0eXBlID0ga2V5d29yZFR5cGVzW3dvcmRdO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuXHRsYXN0U3RhcnQgPSB0b2tTdGFydDtcblx0bGFzdEVuZCA9IHRva0VuZDtcblx0bGFzdEVuZExvYyA9IHRva0VuZExvYztcblx0cmVhZFRva2VuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdHJpY3Qoc3RyY3QpIHtcblx0c3RyaWN0ID0gc3RyY3Q7XG5cdHRva1BvcyA9IHRva1N0YXJ0O1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0ICB3aGlsZSAodG9rUG9zIDwgdG9rTGluZVN0YXJ0KSB7XG5cdFx0dG9rTGluZVN0YXJ0ID0gaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgdG9rTGluZVN0YXJ0IC0gMikgKyAxO1xuXHRcdC0tdG9rQ3VyTGluZTtcblx0ICB9XG5cdH1cblx0c2tpcFNwYWNlKCk7XG5cdHJlYWRUb2tlbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9kZV90KCkge1xuXHR0aGlzLnR5cGUgPSBudWxsO1xuXHR0aGlzLnN0YXJ0ID0gdG9rU3RhcnQ7XG5cdHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGVfbG9jX3QoKSB7XG5cdHRoaXMuc3RhcnQgPSB0b2tTdGFydExvYztcblx0dGhpcy5lbmQgPSBudWxsO1xuXHRpZiAoc291cmNlRmlsZSAhPT0gbnVsbCkgdGhpcy5zb3VyY2UgPSBzb3VyY2VGaWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnROb2RlKCkge1xuXHR2YXIgbm9kZSA9IG5ldyBub2RlX3QoKTtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKVxuXHQgIG5vZGUubG9jID0gbmV3IG5vZGVfbG9jX3QoKTtcblx0aWYgKG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcblx0ICBub2RlLnNvdXJjZUZpbGUgPSBvcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7XG5cdGlmIChvcHRpb25zLnJhbmdlcylcblx0ICBub2RlLnJhbmdlID0gW3Rva1N0YXJ0LCAwXTtcblx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydE5vZGVGcm9tKG90aGVyKSB7XG5cdHZhciBub2RlID0gbmV3IG5vZGVfdCgpO1xuXHRub2RlLnN0YXJ0ID0gb3RoZXIuc3RhcnQ7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHQgIG5vZGUubG9jID0gbmV3IG5vZGVfbG9jX3QoKTtcblx0ICBub2RlLmxvYy5zdGFydCA9IG90aGVyLmxvYy5zdGFydDtcblx0fVxuXHRpZiAob3B0aW9ucy5yYW5nZXMpXG5cdCAgbm9kZS5yYW5nZSA9IFtvdGhlci5yYW5nZVswXSwgMF07XG5cblx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcblx0bm9kZS50eXBlID0gdHlwZTtcblx0bm9kZS5lbmQgPSBsYXN0RW5kO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG5cdCAgbm9kZS5sb2MuZW5kID0gbGFzdEVuZExvYztcblx0aWYgKG9wdGlvbnMucmFuZ2VzKVxuXHQgIG5vZGUucmFuZ2VbMV0gPSBsYXN0RW5kO1xuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVXNlU3RyaWN0KHN0bXQpIHtcblx0cmV0dXJuIG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG5cdCAgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHN0bXQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCI7XG4gIH1cblxuICBmdW5jdGlvbiBlYXQodHlwZSkge1xuXHRpZiAodG9rVHlwZSA9PT0gdHlwZSkge1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuSW5zZXJ0U2VtaWNvbG9uKCkge1xuXHRyZXR1cm4gIW9wdGlvbnMuc3RyaWN0U2VtaWNvbG9ucyAmJlxuXHQgICh0b2tUeXBlID09PSBfZW9mIHx8IHRva1R5cGUgPT09IF9icmFjZVIgfHwgbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1N0YXJ0KSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VtaWNvbG9uKCkge1xuXHRpZiAoIWVhdChfc2VtaSkgJiYgIWNhbkluc2VydFNlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3QodHlwZSkge1xuXHRpZiAodG9rVHlwZSA9PT0gdHlwZSkgbmV4dCgpO1xuXHRlbHNlIHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoKSB7XG5cdHJhaXNlKHRva1N0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0xWYWwoZXhwcikge1xuXHRpZiAoZXhwci50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBleHByLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuXHQgIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcblx0aWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGlzU3RyaWN0QmFkSWRXb3JkKGV4cHIubmFtZSkpXG5cdCAgcmFpc2UoZXhwci5zdGFydCwgXCJBc3NpZ25pbmcgdG8gXCIgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVG9wTGV2ZWwocHJvZ3JhbSkge1xuXHRsYXN0U3RhcnQgPSBsYXN0RW5kID0gdG9rUG9zO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIGxhc3RFbmRMb2MgPSBuZXcgbGluZV9sb2NfdDtcblx0aW5GdW5jdGlvbiA9IHN0cmljdCA9IG51bGw7XG5cdGxhYmVscyA9IFtdO1xuXHRyZWFkVG9rZW4oKTtcblxuXHR2YXIgbm9kZSA9IHByb2dyYW0gfHwgc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZTtcblx0aWYgKCFwcm9ncmFtKSBub2RlLmJvZHkgPSBbXTtcblx0d2hpbGUgKHRva1R5cGUgIT09IF9lb2YpIHtcblx0ICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG5cdCAgaWYgKGZpcnN0ICYmIGlzVXNlU3RyaWN0KHN0bXQpKSBzZXRTdHJpY3QodHJ1ZSk7XG5cdCAgZmlyc3QgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIik7XG4gIH1cblxuICB2YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG5cdGlmICh0b2tUeXBlID09PSBfc2xhc2ggfHwgdG9rVHlwZSA9PT0gX2Fzc2lnbiAmJiB0b2tWYWwgPT0gXCIvPVwiKVxuXHQgIHJlYWRUb2tlbih0cnVlKTtcblxuXHR2YXIgc3RhcnR0eXBlID0gdG9rVHlwZSwgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXG5cdHN3aXRjaCAoc3RhcnR0eXBlKSB7XG5cdGNhc2UgX2JyZWFrOiBjYXNlIF9jb250aW51ZTpcblx0ICBuZXh0KCk7XG5cdCAgdmFyIGlzQnJlYWsgPSBzdGFydHR5cGUgPT09IF9icmVhaztcblx0ICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkgbm9kZS5sYWJlbCA9IG51bGw7XG5cdCAgZWxzZSBpZiAodG9rVHlwZSAhPT0gX25hbWUpIHVuZXhwZWN0ZWQoKTtcblx0ICBlbHNlIHtcblx0XHRub2RlLmxhYmVsID0gcGFyc2VJZGVudCgpO1xuXHRcdHNlbWljb2xvbigpO1xuXHQgIH1cblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGxhYiA9IGxhYmVsc1tpXTtcblx0XHRpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcblx0XHQgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuXHRcdCAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG5cdFx0fVxuXHQgIH1cblx0ICBpZiAoaSA9PT0gbGFiZWxzLmxlbmd0aCkgcmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIHN0YXJ0dHlwZS5rZXl3b3JkKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9kZWJ1Z2dlcjpcblx0ICBuZXh0KCk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9kbzpcblx0ICBuZXh0KCk7XG5cdCAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcblx0ICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIGxhYmVscy5wb3AoKTtcblx0ICBleHBlY3QoX3doaWxlKTtcblx0ICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIHNlbWljb2xvbigpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9mb3I6XG5cdCAgbmV4dCgpO1xuXHQgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG5cdCAgZXhwZWN0KF9wYXJlbkwpO1xuXHQgIGlmICh0b2tUeXBlID09PSBfc2VtaSkgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIG51bGwpO1xuXHQgIGlmICh0b2tUeXBlID09PSBfdmFyKSB7XG5cdFx0dmFyIGluaXQgPSBzdGFydE5vZGUoKTtcblx0XHRuZXh0KCk7XG5cdFx0cGFyc2VWYXIoaW5pdCwgdHJ1ZSk7XG5cdFx0ZmluaXNoTm9kZShpbml0LCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG5cdFx0aWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBlYXQoX2luKSlcblx0XHQgIHJldHVybiBwYXJzZUZvckluKG5vZGUsIGluaXQpO1xuXHRcdHJldHVybiBwYXJzZUZvcihub2RlLCBpbml0KTtcblx0ICB9XG5cdCAgdmFyIGluaXQgPSBwYXJzZUV4cHJlc3Npb24oZmFsc2UsIHRydWUpO1xuXHQgIGlmIChlYXQoX2luKSkge2NoZWNrTFZhbChpbml0KTsgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7fVxuXHQgIHJldHVybiBwYXJzZUZvcihub2RlLCBpbml0KTtcblxuXHRjYXNlIF9mdW5jdGlvbjpcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIHBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSk7XG5cblx0Y2FzZSBfaWY6XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBub2RlLmFsdGVybmF0ZSA9IGVhdChfZWxzZSkgPyBwYXJzZVN0YXRlbWVudCgpIDogbnVsbDtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3JldHVybjpcblx0ICBpZiAoIWluRnVuY3Rpb24gJiYgIW9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG5cdFx0cmFpc2UodG9rU3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcblx0ICBuZXh0KCk7XG5cblx0ICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkgbm9kZS5hcmd1bWVudCA9IG51bGw7XG5cdCAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTsgc2VtaWNvbG9uKCk7IH1cblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9zd2l0Y2g6XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuZGlzY3JpbWluYW50ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBub2RlLmNhc2VzID0gW107XG5cdCAgZXhwZWN0KF9icmFjZUwpO1xuXHQgIGxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcblxuXHQgIGZvciAodmFyIGN1ciwgc2F3RGVmYXVsdDsgdG9rVHlwZSAhPSBfYnJhY2VSOykge1xuXHRcdGlmICh0b2tUeXBlID09PSBfY2FzZSB8fCB0b2tUeXBlID09PSBfZGVmYXVsdCkge1xuXHRcdCAgdmFyIGlzQ2FzZSA9IHRva1R5cGUgPT09IF9jYXNlO1xuXHRcdCAgaWYgKGN1cikgZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcblx0XHQgIG5vZGUuY2FzZXMucHVzaChjdXIgPSBzdGFydE5vZGUoKSk7XG5cdFx0ICBjdXIuY29uc2VxdWVudCA9IFtdO1xuXHRcdCAgbmV4dCgpO1xuXHRcdCAgaWYgKGlzQ2FzZSkgY3VyLnRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0XHQgIGVsc2Uge1xuXHRcdFx0aWYgKHNhd0RlZmF1bHQpIHJhaXNlKGxhc3RTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IHNhd0RlZmF1bHQgPSB0cnVlO1xuXHRcdFx0Y3VyLnRlc3QgPSBudWxsO1xuXHRcdCAgfVxuXHRcdCAgZXhwZWN0KF9jb2xvbik7XG5cdFx0fSBlbHNlIHtcblx0XHQgIGlmICghY3VyKSB1bmV4cGVjdGVkKCk7XG5cdFx0ICBjdXIuY29uc2VxdWVudC5wdXNoKHBhcnNlU3RhdGVtZW50KCkpO1xuXHRcdH1cblx0ICB9XG5cdCAgaWYgKGN1cikgZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcblx0ICBuZXh0KCk7XG5cdCAgbGFiZWxzLnBvcCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3Rocm93OlxuXHQgIG5leHQoKTtcblx0ICBpZiAobmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1N0YXJ0KSkpXG5cdFx0cmFpc2UobGFzdEVuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7XG5cdCAgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIHNlbWljb2xvbigpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfdHJ5OlxuXHQgIG5leHQoKTtcblx0ICBub2RlLmJsb2NrID0gcGFyc2VCbG9jaygpO1xuXHQgIG5vZGUuaGFuZGxlciA9IG51bGw7XG5cdCAgaWYgKHRva1R5cGUgPT09IF9jYXRjaCkge1xuXHRcdHZhciBjbGF1c2UgPSBzdGFydE5vZGUoKTtcblx0XHRuZXh0KCk7XG5cdFx0ZXhwZWN0KF9wYXJlbkwpO1xuXHRcdGNsYXVzZS5wYXJhbSA9IHBhcnNlSWRlbnQoKTtcblx0XHRpZiAoc3RyaWN0ICYmIGlzU3RyaWN0QmFkSWRXb3JkKGNsYXVzZS5wYXJhbS5uYW1lKSlcblx0XHQgIHJhaXNlKGNsYXVzZS5wYXJhbS5zdGFydCwgXCJCaW5kaW5nIFwiICsgY2xhdXNlLnBhcmFtLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcblx0XHRleHBlY3QoX3BhcmVuUik7XG5cdFx0Y2xhdXNlLmd1YXJkID0gbnVsbDtcblx0XHRjbGF1c2UuYm9keSA9IHBhcnNlQmxvY2soKTtcblx0XHRub2RlLmhhbmRsZXIgPSBmaW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcblx0ICB9XG5cdCAgbm9kZS5ndWFyZGVkSGFuZGxlcnMgPSBlbXB0eTtcblx0ICBub2RlLmZpbmFsaXplciA9IGVhdChfZmluYWxseSkgPyBwYXJzZUJsb2NrKCkgOiBudWxsO1xuXHQgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcblx0XHRyYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfdmFyOlxuXHQgIG5leHQoKTtcblx0ICBwYXJzZVZhcihub2RlKTtcblx0ICBzZW1pY29sb24oKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG5cblx0Y2FzZSBfd2hpbGU6XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcblx0ICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIGxhYmVscy5wb3AoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3dpdGg6XG5cdCAgaWYgKHN0cmljdCkgcmFpc2UodG9rU3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpO1xuXHQgIG5leHQoKTtcblx0ICBub2RlLm9iamVjdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfYnJhY2VMOlxuXHQgIHJldHVybiBwYXJzZUJsb2NrKCk7XG5cblx0Y2FzZSBfc2VtaTpcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKTtcblxuXHRkZWZhdWx0OlxuXHQgIHZhciBtYXliZU5hbWUgPSB0b2tWYWwsIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICBpZiAoc3RhcnR0eXBlID09PSBfbmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGVhdChfY29sb24pKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpXG5cdFx0ICBpZiAobGFiZWxzW2ldLm5hbWUgPT09IG1heWJlTmFtZSkgcmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcblx0XHR2YXIga2luZCA9IHRva1R5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0b2tUeXBlID09PSBfc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG5cdFx0bGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZH0pO1xuXHRcdG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdFx0bGFiZWxzLnBvcCgpO1xuXHRcdG5vZGUubGFiZWwgPSBleHByO1xuXHRcdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcblx0ICB9IGVsc2Uge1xuXHRcdG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG5cdFx0c2VtaWNvbG9uKCk7XG5cdFx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuXHQgIH1cblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJlbkV4cHJlc3Npb24oKSB7XG5cdGV4cGVjdChfcGFyZW5MKTtcblx0dmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRleHBlY3QoX3BhcmVuUik7XG5cdHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUJsb2NrKGFsbG93U3RyaWN0KSB7XG5cdHZhciBub2RlID0gc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgc3RyaWN0ID0gZmFsc2UsIG9sZFN0cmljdDtcblx0bm9kZS5ib2R5ID0gW107XG5cdGV4cGVjdChfYnJhY2VMKTtcblx0d2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcblx0ICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG5cdCAgaWYgKGZpcnN0ICYmIGFsbG93U3RyaWN0ICYmIGlzVXNlU3RyaWN0KHN0bXQpKSB7XG5cdFx0b2xkU3RyaWN0ID0gc3RyaWN0O1xuXHRcdHNldFN0cmljdChzdHJpY3QgPSB0cnVlKTtcblx0ICB9XG5cdCAgZmlyc3QgPSBmYWxzZTtcblx0fVxuXHRpZiAoc3RyaWN0ICYmICFvbGRTdHJpY3QpIHNldFN0cmljdChmYWxzZSk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZvcihub2RlLCBpbml0KSB7XG5cdG5vZGUuaW5pdCA9IGluaXQ7XG5cdGV4cGVjdChfc2VtaSk7XG5cdG5vZGUudGVzdCA9IHRva1R5cGUgPT09IF9zZW1pID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRleHBlY3QoX3NlbWkpO1xuXHRub2RlLnVwZGF0ZSA9IHRva1R5cGUgPT09IF9wYXJlblIgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfcGFyZW5SKTtcblx0bm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0bGFiZWxzLnBvcCgpO1xuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9ySW4obm9kZSwgaW5pdCkge1xuXHRub2RlLmxlZnQgPSBpbml0O1xuXHRub2RlLnJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfcGFyZW5SKTtcblx0bm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0bGFiZWxzLnBvcCgpO1xuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZvckluU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWYXIobm9kZSwgbm9Jbikge1xuXHRub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuXHRub2RlLmtpbmQgPSBcInZhclwiO1xuXHRmb3IgKDs7KSB7XG5cdCAgdmFyIGRlY2wgPSBzdGFydE5vZGUoKTtcblx0ICBkZWNsLmlkID0gcGFyc2VJZGVudCgpO1xuXHQgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZGVjbC5pZC5uYW1lKSlcblx0XHRyYWlzZShkZWNsLmlkLnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBkZWNsLmlkLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcblx0ICBkZWNsLmluaXQgPSBlYXQoX2VxKSA/IHBhcnNlRXhwcmVzc2lvbih0cnVlLCBub0luKSA6IG51bGw7XG5cdCAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaChmaW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcblx0ICBpZiAoIWVhdChfY29tbWEpKSBicmVhaztcblx0fVxuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihub0NvbW1hLCBub0luKSB7XG5cdHZhciBleHByID0gcGFyc2VNYXliZUFzc2lnbihub0luKTtcblx0aWYgKCFub0NvbW1hICYmIHRva1R5cGUgPT09IF9jb21tYSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcblx0ICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuXHQgIHdoaWxlIChlYXQoX2NvbW1hKSkgbm9kZS5leHByZXNzaW9ucy5wdXNoKHBhcnNlTWF5YmVBc3NpZ24obm9JbikpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZUFzc2lnbihub0luKSB7XG5cdHZhciBsZWZ0ID0gcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4pO1xuXHRpZiAodG9rVHlwZS5pc0Fzc2lnbikge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcblx0ICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuXHQgIG5vZGUubGVmdCA9IGxlZnQ7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUucmlnaHQgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuXHQgIGNoZWNrTFZhbChsZWZ0KTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBsZWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4pIHtcblx0dmFyIGV4cHIgPSBwYXJzZUV4cHJPcHMobm9Jbik7XG5cdGlmIChlYXQoX3F1ZXN0aW9uKSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcblx0ICBub2RlLnRlc3QgPSBleHByO1xuXHQgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlRXhwcmVzc2lvbih0cnVlKTtcblx0ICBleHBlY3QoX2NvbG9uKTtcblx0ICBub2RlLmFsdGVybmF0ZSA9IHBhcnNlRXhwcmVzc2lvbih0cnVlLCBub0luKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwck9wcyhub0luKSB7XG5cdHJldHVybiBwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkoKSwgLTEsIG5vSW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByT3AobGVmdCwgbWluUHJlYywgbm9Jbikge1xuXHR2YXIgcHJlYyA9IHRva1R5cGUuYmlub3A7XG5cdGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRva1R5cGUgIT09IF9pbikpIHtcblx0ICBpZiAocHJlYyA+IG1pblByZWMpIHtcblx0XHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obGVmdCk7XG5cdFx0bm9kZS5sZWZ0ID0gbGVmdDtcblx0XHRub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuXHRcdHZhciBvcCA9IHRva1R5cGU7XG5cdFx0bmV4dCgpO1xuXHRcdG5vZGUucmlnaHQgPSBwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkoKSwgcHJlYywgbm9Jbik7XG5cdFx0dmFyIGV4cHJOb2RlID0gZmluaXNoTm9kZShub2RlLCAob3AgPT09IF9sb2dpY2FsT1IgfHwgb3AgPT09IF9sb2dpY2FsQU5EKSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcblx0XHRyZXR1cm4gcGFyc2VFeHByT3AoZXhwck5vZGUsIG1pblByZWMsIG5vSW4pO1xuXHQgIH1cblx0fVxuXHRyZXR1cm4gbGVmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVVbmFyeSgpIHtcblx0aWYgKHRva1R5cGUucHJlZml4KSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgdXBkYXRlID0gdG9rVHlwZS5pc1VwZGF0ZTtcblx0ICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuXHQgIG5vZGUucHJlZml4ID0gdHJ1ZTtcblx0ICB0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5hcmd1bWVudCA9IHBhcnNlTWF5YmVVbmFyeSgpO1xuXHQgIGlmICh1cGRhdGUpIGNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTtcblx0ICBlbHNlIGlmIChzdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuXHRcdFx0ICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcblx0XHRyYWlzZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG5cdH1cblx0dmFyIGV4cHIgPSBwYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG5cdHdoaWxlICh0b2tUeXBlLnBvc3RmaXggJiYgIWNhbkluc2VydFNlbWljb2xvbigpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuXHQgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdCAgbm9kZS5wcmVmaXggPSBmYWxzZTtcblx0ICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcblx0ICBjaGVja0xWYWwoZXhwcik7XG5cdCAgbmV4dCgpO1xuXHQgIGV4cHIgPSBmaW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdHMoKSB7XG5cdHJldHVybiBwYXJzZVN1YnNjcmlwdHMocGFyc2VFeHByQXRvbSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBub0NhbGxzKSB7XG5cdGlmIChlYXQoX2RvdCkpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG5cdCAgbm9kZS5vYmplY3QgPSBiYXNlO1xuXHQgIG5vZGUucHJvcGVydHkgPSBwYXJzZUlkZW50KHRydWUpO1xuXHQgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcblx0ICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcblx0fSBlbHNlIGlmIChlYXQoX2JyYWNrZXRMKSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcblx0ICBub2RlLm9iamVjdCA9IGJhc2U7XG5cdCAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIG5vZGUuY29tcHV0ZWQgPSB0cnVlO1xuXHQgIGV4cGVjdChfYnJhY2tldFIpO1xuXHQgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuXHR9IGVsc2UgaWYgKCFub0NhbGxzICYmIGVhdChfcGFyZW5MKSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcblx0ICBub2RlLmNhbGxlZSA9IGJhc2U7XG5cdCAgbm9kZS5hcmd1bWVudHMgPSBwYXJzZUV4cHJMaXN0KF9wYXJlblIsIGZhbHNlKTtcblx0ICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG5cdH0gZWxzZSByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwckF0b20oKSB7XG5cdHN3aXRjaCAodG9rVHlwZSkge1xuXHRjYXNlIF90aGlzOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG5cdGNhc2UgX25hbWU6XG5cdCAgcmV0dXJuIHBhcnNlSWRlbnQoKTtcblx0Y2FzZSBfbnVtOiBjYXNlIF9zdHJpbmc6IGNhc2UgX3JlZ2V4cDpcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHQgIG5vZGUudmFsdWUgPSB0b2tWYWw7XG5cdCAgbm9kZS5yYXcgPSBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKTtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG5cdGNhc2UgX251bGw6IGNhc2UgX3RydWU6IGNhc2UgX2ZhbHNlOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbm9kZS52YWx1ZSA9IHRva1R5cGUuYXRvbVZhbHVlO1xuXHQgIG5vZGUucmF3ID0gdG9rVHlwZS5rZXl3b3JkO1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cblx0Y2FzZSBfcGFyZW5MOlxuXHQgIHZhciB0b2tTdGFydExvYzEgPSB0b2tTdGFydExvYywgdG9rU3RhcnQxID0gdG9rU3RhcnQ7XG5cdCAgbmV4dCgpO1xuXHQgIHZhciB2YWwgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICB2YWwuc3RhcnQgPSB0b2tTdGFydDE7XG5cdCAgdmFsLmVuZCA9IHRva0VuZDtcblx0ICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0XHR2YWwubG9jLnN0YXJ0ID0gdG9rU3RhcnRMb2MxO1xuXHRcdHZhbC5sb2MuZW5kID0gdG9rRW5kTG9jO1xuXHQgIH1cblx0ICBpZiAob3B0aW9ucy5yYW5nZXMpXG5cdFx0dmFsLnJhbmdlID0gW3Rva1N0YXJ0MSwgdG9rRW5kXTtcblx0ICBleHBlY3QoX3BhcmVuUik7XG5cdCAgcmV0dXJuIHZhbDtcblxuXHRjYXNlIF9icmFja2V0TDpcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHQgIG5leHQoKTtcblx0ICBub2RlLmVsZW1lbnRzID0gcGFyc2VFeHByTGlzdChfYnJhY2tldFIsIHRydWUsIHRydWUpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuXG5cdGNhc2UgX2JyYWNlTDpcblx0ICByZXR1cm4gcGFyc2VPYmooKTtcblxuXHRjYXNlIF9mdW5jdGlvbjpcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gcGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSk7XG5cblx0Y2FzZSBfbmV3OlxuXHQgIHJldHVybiBwYXJzZU5ldygpO1xuXG5cdGRlZmF1bHQ6XG5cdCAgdW5leHBlY3RlZCgpO1xuXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5ldygpIHtcblx0dmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0bmV4dCgpO1xuXHRub2RlLmNhbGxlZSA9IHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCksIHRydWUpO1xuXHRpZiAoZWF0KF9wYXJlbkwpKSBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO1xuXHRlbHNlIG5vZGUuYXJndW1lbnRzID0gZW1wdHk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqKCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHNhd0dldFNldCA9IGZhbHNlO1xuXHRub2RlLnByb3BlcnRpZXMgPSBbXTtcblx0bmV4dCgpO1xuXHR3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuXHQgIGlmICghZmlyc3QpIHtcblx0XHRleHBlY3QoX2NvbW1hKTtcblx0XHRpZiAob3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWFzICYmIGVhdChfYnJhY2VSKSkgYnJlYWs7XG5cdCAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cblx0ICB2YXIgcHJvcCA9IHtrZXk6IHBhcnNlUHJvcGVydHlOYW1lKCl9LCBpc0dldFNldCA9IGZhbHNlLCBraW5kO1xuXHQgIGlmIChlYXQoX2NvbG9uKSkge1xuXHRcdHByb3AudmFsdWUgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG5cdFx0a2luZCA9IHByb3Aua2luZCA9IFwiaW5pdFwiO1xuXHQgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG5cdFx0XHRcdCAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSkge1xuXHRcdGlzR2V0U2V0ID0gc2F3R2V0U2V0ID0gdHJ1ZTtcblx0XHRraW5kID0gcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcblx0XHRwcm9wLmtleSA9IHBhcnNlUHJvcGVydHlOYW1lKCk7XG5cdFx0aWYgKHRva1R5cGUgIT09IF9wYXJlbkwpIHVuZXhwZWN0ZWQoKTtcblx0XHRwcm9wLnZhbHVlID0gcGFyc2VGdW5jdGlvbihzdGFydE5vZGUoKSwgZmFsc2UpO1xuXHQgIH0gZWxzZSB1bmV4cGVjdGVkKCk7XG5cblx0ICBpZiAocHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKHN0cmljdCB8fCBzYXdHZXRTZXQpKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcblx0XHQgIHZhciBvdGhlciA9IG5vZGUucHJvcGVydGllc1tpXTtcblx0XHQgIGlmIChvdGhlci5rZXkubmFtZSA9PT0gcHJvcC5rZXkubmFtZSkge1xuXHRcdFx0dmFyIGNvbmZsaWN0ID0ga2luZCA9PSBvdGhlci5raW5kIHx8IGlzR2V0U2V0ICYmIG90aGVyLmtpbmQgPT09IFwiaW5pdFwiIHx8XG5cdFx0XHQgIGtpbmQgPT09IFwiaW5pdFwiICYmIChvdGhlci5raW5kID09PSBcImdldFwiIHx8IG90aGVyLmtpbmQgPT09IFwic2V0XCIpO1xuXHRcdFx0aWYgKGNvbmZsaWN0ICYmICFzdHJpY3QgJiYga2luZCA9PT0gXCJpbml0XCIgJiYgb3RoZXIua2luZCA9PT0gXCJpbml0XCIpIGNvbmZsaWN0ID0gZmFsc2U7XG5cdFx0XHRpZiAoY29uZmxpY3QpIHJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTtcblx0XHQgIH1cblx0XHR9XG5cdCAgfVxuXHQgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuXHR9XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlOYW1lKCkge1xuXHRpZiAodG9rVHlwZSA9PT0gX251bSB8fCB0b2tUeXBlID09PSBfc3RyaW5nKSByZXR1cm4gcGFyc2VFeHByQXRvbSgpO1xuXHRyZXR1cm4gcGFyc2VJZGVudCh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcblx0aWYgKHRva1R5cGUgPT09IF9uYW1lKSBub2RlLmlkID0gcGFyc2VJZGVudCgpO1xuXHRlbHNlIGlmIChpc1N0YXRlbWVudCkgdW5leHBlY3RlZCgpO1xuXHRlbHNlIG5vZGUuaWQgPSBudWxsO1xuXHRub2RlLnBhcmFtcyA9IFtdO1xuXHR2YXIgZmlyc3QgPSB0cnVlO1xuXHRleHBlY3QoX3BhcmVuTCk7XG5cdHdoaWxlICghZWF0KF9wYXJlblIpKSB7XG5cdCAgaWYgKCFmaXJzdCkgZXhwZWN0KF9jb21tYSk7IGVsc2UgZmlyc3QgPSBmYWxzZTtcblx0ICBub2RlLnBhcmFtcy5wdXNoKHBhcnNlSWRlbnQoKSk7XG5cdH1cblxuXHR2YXIgb2xkSW5GdW5jID0gaW5GdW5jdGlvbiwgb2xkTGFiZWxzID0gbGFiZWxzO1xuXHRpbkZ1bmN0aW9uID0gdHJ1ZTsgbGFiZWxzID0gW107XG5cdG5vZGUuYm9keSA9IHBhcnNlQmxvY2sodHJ1ZSk7XG5cdGluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7IGxhYmVscyA9IG9sZExhYmVscztcblxuXHRpZiAoc3RyaWN0IHx8IG5vZGUuYm9keS5ib2R5Lmxlbmd0aCAmJiBpc1VzZVN0cmljdChub2RlLmJvZHkuYm9keVswXSkpIHtcblx0ICBmb3IgKHZhciBpID0gbm9kZS5pZCA/IC0xIDogMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGlkID0gaSA8IDAgPyBub2RlLmlkIDogbm9kZS5wYXJhbXNbaV07XG5cdFx0aWYgKGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKGlkLm5hbWUpIHx8IGlzU3RyaWN0QmFkSWRXb3JkKGlkLm5hbWUpKVxuXHRcdCAgcmFpc2UoaWQuc3RhcnQsIFwiRGVmaW5pbmcgJ1wiICsgaWQubmFtZSArIFwiJyBpbiBzdHJpY3QgbW9kZVwiKTtcblx0XHRpZiAoaSA+PSAwKSBmb3IgKHZhciBqID0gMDsgaiA8IGk7ICsraikgaWYgKGlkLm5hbWUgPT09IG5vZGUucGFyYW1zW2pdLm5hbWUpXG5cdFx0ICByYWlzZShpZC5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpO1xuXHQgIH1cblx0fVxuXG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwckxpc3QoY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSkge1xuXHR2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG5cdHdoaWxlICghZWF0KGNsb3NlKSkge1xuXHQgIGlmICghZmlyc3QpIHtcblx0XHRleHBlY3QoX2NvbW1hKTtcblx0XHRpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoY2xvc2UpKSBicmVhaztcblx0ICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuXHQgIGlmIChhbGxvd0VtcHR5ICYmIHRva1R5cGUgPT09IF9jb21tYSkgZWx0cy5wdXNoKG51bGwpO1xuXHQgIGVsc2UgZWx0cy5wdXNoKHBhcnNlRXhwcmVzc2lvbih0cnVlKSk7XG5cdH1cblx0cmV0dXJuIGVsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUlkZW50KGxpYmVyYWwpIHtcblx0dmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0aWYgKGxpYmVyYWwgJiYgb3B0aW9ucy5mb3JiaWRSZXNlcnZlZCA9PSBcImV2ZXJ5d2hlcmVcIikgbGliZXJhbCA9IGZhbHNlO1xuXHRpZiAodG9rVHlwZSA9PT0gX25hbWUpIHtcblx0ICBpZiAoIWxpYmVyYWwgJiZcblx0XHQgIChvcHRpb25zLmZvcmJpZFJlc2VydmVkICYmXG5cdFx0ICAgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDMgPyBpc1Jlc2VydmVkV29yZDMgOiBpc1Jlc2VydmVkV29yZDUpKHRva1ZhbCkgfHxcblx0XHQgICBzdHJpY3QgJiYgaXNTdHJpY3RSZXNlcnZlZFdvcmQodG9rVmFsKSkgJiZcblx0XHQgIGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpLmluZGV4T2YoXCJcXFxcXCIpID09IC0xKVxuXHRcdHJhaXNlKHRva1N0YXJ0LCBcIlRoZSBrZXl3b3JkICdcIiArIHRva1ZhbCArIFwiJyBpcyByZXNlcnZlZFwiKTtcblx0ICBub2RlLm5hbWUgPSB0b2tWYWw7XG5cdH0gZWxzZSBpZiAobGliZXJhbCAmJiB0b2tUeXBlLmtleXdvcmQpIHtcblx0ICBub2RlLm5hbWUgPSB0b2tUeXBlLmtleXdvcmQ7XG5cdH0gZWxzZSB7XG5cdCAgdW5leHBlY3RlZCgpO1xuXHR9XG5cdHRva1JlZ2V4cEFsbG93ZWQgPSBmYWxzZTtcblx0bmV4dCgpO1xuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIH1cblxufSk7XG5cblx0XHRpZiAoIWFjb3JuLnZlcnNpb24pXG5cdFx0XHRhY29ybiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIChnbG9iYWwuYWNvcm4gfHwgYWNvcm4pLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuXHR9XG5cblx0dmFyIGJpbmFyeU9wZXJhdG9ycyA9IHtcblx0XHQnKyc6ICdfX2FkZCcsXG5cdFx0Jy0nOiAnX19zdWJ0cmFjdCcsXG5cdFx0JyonOiAnX19tdWx0aXBseScsXG5cdFx0Jy8nOiAnX19kaXZpZGUnLFxuXHRcdCclJzogJ19fbW9kdWxvJyxcblx0XHQnPT0nOiAnX19lcXVhbHMnLFxuXHRcdCchPSc6ICdfX2VxdWFscydcblx0fTtcblxuXHR2YXIgdW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0Jy0nOiAnX19uZWdhdGUnLFxuXHRcdCcrJzogJ19fc2VsZidcblx0fTtcblxuXHR2YXIgZmllbGRzID0gQmFzZS5lYWNoKFxuXHRcdFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnZXF1YWxzJywgJ25lZ2F0ZSddLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbJ19fJyArIG5hbWVdID0gJyMnICsgbmFtZTtcblx0XHR9LFxuXHRcdHtcblx0XHRcdF9fc2VsZjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcblx0UG9pbnQuaW5qZWN0KGZpZWxkcyk7XG5cdFNpemUuaW5qZWN0KGZpZWxkcyk7XG5cdENvbG9yLmluamVjdChmaWVsZHMpO1xuXG5cdGZ1bmN0aW9uIF9fJF9fKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG5cdFx0XHR2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuXHRcdH1cblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cdFx0Y2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cdFx0Y2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cdFx0Y2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cdFx0Y2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PSByaWdodDtcblx0XHRjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uICRfXyhvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAodmFsdWUgJiYgdmFsdWVbaGFuZGxlcl0pXG5cdFx0XHRyZXR1cm4gdmFsdWVbaGFuZGxlcl0oKTtcblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiArdmFsdWU7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiAtdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZShjb2RlLCBvcHRpb25zKSB7XG5cdFx0aWYgKCFjb2RlKVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIGluc2VydGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG5cdFx0XHRcdGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCZXR3ZWVuKGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KGxlZnQucmFuZ2VbMV0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChyaWdodC5yYW5nZVswXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlcGxhY2VDb2RlKG5vZGUsIHN0cikge1xuXHRcdFx0dmFyIHN0YXJ0ID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRlbmQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSksXG5cdFx0XHRcdGluc2VydCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5zZXJ0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoc3RhcnQgPiBpbnNlcnRpb25zW2ldWzBdKSB7XG5cdFx0XHRcdFx0aW5zZXJ0ID0gaSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluc2VydGlvbnMuc3BsaWNlKGluc2VydCwgMCwgW3N0YXJ0LCBzdHIubGVuZ3RoIC0gZW5kICsgc3RhcnRdKTtcblx0XHRcdGNvZGUgPSBjb2RlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzdHIgKyBjb2RlLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU92ZXJsb2FkaW5nKG5vZGUsIHBhcmVudCkge1xuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICckX18oXCInICsgbm9kZS5vcGVyYXRvciArICdcIiwgJ1xuXHRcdFx0XHRcdFx0XHQrIGFyZyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRiZXR3ZWVuID0gZ2V0QmV0d2Vlbihub2RlLmxlZnQsIG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICdfXyRfXygnICsgbGVmdCArICcsJ1xuXHRcdFx0XHRcdFx0XHQrIGJldHdlZW4ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJyArIG9wZXJhdG9yKSxcblx0XHRcdFx0XHRcdFx0XHQnXCInICsgb3BlcmF0b3IgKyAnXCInKVxuXHRcdFx0XHRcdFx0XHQrICcsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcblx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcblx0XHRcdFx0dmFyIHBhcmVudFR5cGUgPSBwYXJlbnQgJiYgcGFyZW50LnR5cGU7XG5cdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0ZvclN0YXRlbWVudCdcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHQmJiAvXls9ITw+XS8udGVzdChwYXJlbnQub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgcGFyZW50LmNvbXB1dGVkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpLFxuXHRcdFx0XHRcdFx0XHRleHAgPSAnX18kX18oJyArIGFyZyArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF1cblx0XHRcdFx0XHRcdFx0XHRcdCsgJ1wiLCAxKScsXG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICcgPSAnICsgZXhwO1xuXHRcdFx0XHRcdFx0aWYgKG5vZGUucHJlZml4KSB7XG5cdFx0XHRcdFx0XHRcdHN0ciA9ICcoJyArIHN0ciArICcpJztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdHBhcmVudFR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgfHxcblx0XHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgfHxcblx0XHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdldENvZGUocGFyZW50LmxlZnQgfHwgcGFyZW50LmlkKSA9PT0gYXJnKVxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IGV4cDtcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJzsgJyArIHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIHN0cik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgvXi49JC8udGVzdChub2RlLm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0XHRcdGV4cCA9IGxlZnQgKyAnID0gX18kX18oJyArIGxlZnQgKyAnLCBcIidcblx0XHRcdFx0XHRcdFx0XHRcdCsgbm9kZS5vcGVyYXRvclswXSArICdcIiwgJyArIHJpZ2h0ICsgJyknO1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAvXlxcKC4qXFwpJC8udGVzdChnZXRDb2RlKG5vZGUpKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyAnKCcgKyBleHAgKyAnKScgOiBleHApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVFeHBvcnRzKG5vZGUpIHtcblx0XHRcdHN3aXRjaCAobm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nOlxuXHRcdFx0XHRyZXBsYWNlQ29kZSh7XG5cdFx0XHRcdFx0cmFuZ2U6IFtub2RlLnN0YXJ0LCBub2RlLmRlY2xhcmF0aW9uLnN0YXJ0XVxuXHRcdFx0XHR9LCAnbW9kdWxlLmV4cG9ydHMgPSAnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJzpcblx0XHRcdFx0dmFyIGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcblx0XHRcdFx0dmFyIHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnM7XG5cdFx0XHRcdGlmIChkZWNsYXJhdGlvbikge1xuXHRcdFx0XHRcdHZhciBkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnM7XG5cdFx0XHRcdFx0aWYgKGRlY2xhcmF0aW9ucykge1xuXHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVjKSB7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKGRlYywgJ21vZHVsZS5leHBvcnRzLicgKyBnZXRDb2RlKGRlYykpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRyZXBsYWNlQ29kZSh7XG5cdFx0XHRcdFx0XHRcdHJhbmdlOiBbXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5zdGFydCxcblx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvbi5zdGFydCArIGRlY2xhcmF0aW9uLmtpbmQubGVuZ3RoXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdH0sICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3BlY2lmaWVycykge1xuXHRcdFx0XHRcdHZhciBleHBvcnRzID0gc3BlY2lmaWVycy5tYXAoZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgbmFtZSA9IGdldENvZGUoc3BlY2lmaWVyKTtcblx0XHRcdFx0XHRcdHJldHVybiAnbW9kdWxlLmV4cG9ydHMuJyArIG5hbWUgKyAnID0gJyArIG5hbWUgKyAnOyAnO1xuXHRcdFx0XHRcdH0pLmpvaW4oJycpO1xuXHRcdFx0XHRcdGlmIChleHBvcnRzKSB7XG5cdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBleHBvcnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQsIHBhcGVyRmVhdHVyZXMpIHtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdFx0aWYgKGtleSAhPT0gJ3JhbmdlJyAmJiBrZXkgIT09ICdsb2MnKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlW2ldLCBub2RlLCBwYXBlckZlYXR1cmVzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdHdhbGtBU1QodmFsdWUsIG5vZGUsIHBhcGVyRmVhdHVyZXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFwZXJGZWF0dXJlcy5vcGVyYXRvck92ZXJsb2FkaW5nICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdGhhbmRsZU92ZXJsb2FkaW5nKG5vZGUsIHBhcmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhcGVyRmVhdHVyZXMubW9kdWxlRXhwb3J0cyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRoYW5kbGVFeHBvcnRzKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlVkxRKHZhbHVlKSB7XG5cdFx0XHR2YXIgcmVzID0gJycsXG5cdFx0XHRcdGJhc2U2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblx0XHRcdHZhbHVlID0gKE1hdGguYWJzKHZhbHVlKSA8PCAxKSArICh2YWx1ZSA8IDAgPyAxIDogMCk7XG5cdFx0XHR3aGlsZSAodmFsdWUgfHwgIXJlcykge1xuXHRcdFx0XHR2YXIgbmV4dCA9IHZhbHVlICYgKDMyIC0gMSk7XG5cdFx0XHRcdHZhbHVlID4+PSA1O1xuXHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0bmV4dCB8PSAzMjtcblx0XHRcdFx0cmVzICs9IGJhc2U2NFtuZXh0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXG5cdFx0dmFyIHVybCA9IG9wdGlvbnMudXJsIHx8ICcnLFxuXHRcdFx0c291cmNlTWFwcyA9IG9wdGlvbnMuc291cmNlTWFwcyxcblx0XHRcdHBhcGVyRmVhdHVyZXMgPSBvcHRpb25zLnBhcGVyRmVhdHVyZXMgfHwge30sXG5cdFx0XHRzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCBjb2RlLFxuXHRcdFx0b2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMCxcblx0XHRcdGFnZW50ID0gcGFwZXIuYWdlbnQsXG5cdFx0XHR2ZXJzaW9uID0gYWdlbnQudmVyc2lvbk51bWJlcixcblx0XHRcdG9mZnNldENvZGUgPSBmYWxzZSxcblx0XHRcdGxpbmVCcmVha3MgPSAvXFxyXFxufFxcbnxcXHIvbWcsXG5cdFx0XHRtYXA7XG5cdFx0aWYgKHNvdXJjZU1hcHMgJiYgKGFnZW50LmNocm9tZSAmJiB2ZXJzaW9uID49IDMwXG5cdFx0XHRcdHx8IGFnZW50LndlYmtpdCAmJiB2ZXJzaW9uID49IDUzNy43NlxuXHRcdFx0XHR8fCBhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gMjNcblx0XHRcdFx0fHwgYWdlbnQubm9kZSkpIHtcblx0XHRcdGlmIChhZ2VudC5ub2RlKSB7XG5cdFx0XHRcdG9mZnNldCAtPSAyO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cgJiYgdXJsICYmICF3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKHVybCkpIHtcblx0XHRcdFx0dmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTDtcblx0XHRcdFx0b2Zmc2V0ID0gaHRtbC5zdWJzdHIoMCwgaHRtbC5pbmRleE9mKGNvZGUpICsgMSkubWF0Y2goXG5cdFx0XHRcdFx0XHRsaW5lQnJlYWtzKS5sZW5ndGggKyAxO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0Q29kZSA9IG9mZnNldCA+IDAgJiYgIShcblx0XHRcdFx0XHRhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzNiB8fFxuXHRcdFx0XHRcdGFnZW50LnNhZmFyaSAmJiB2ZXJzaW9uID49IDYwMCB8fFxuXHRcdFx0XHRcdGFnZW50LmZpcmVmb3ggJiYgdmVyc2lvbiA+PSA0MCB8fFxuXHRcdFx0XHRcdGFnZW50Lm5vZGUpO1xuXHRcdFx0dmFyIG1hcHBpbmdzID0gWydBQScgKyBlbmNvZGVWTFEob2Zmc2V0Q29kZSA/IDAgOiBvZmZzZXQpICsgJ0EnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxXG5cdFx0XHRcdFx0KyAob2Zmc2V0Q29kZSA/IG9mZnNldCA6IDApO1xuXHRcdFx0bWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdLFxuXHRcdFx0XHRzb3VyY2VzQ29udGVudDogW3NvdXJjZV1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChcblx0XHRcdHBhcGVyRmVhdHVyZXMub3BlcmF0b3JPdmVybG9hZGluZyAhPT0gZmFsc2UgfHxcblx0XHRcdHBhcGVyRmVhdHVyZXMubW9kdWxlRXhwb3J0cyAhPT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHdhbGtBU1QocGFyc2UoY29kZSwge1xuXHRcdFx0XHRyYW5nZXM6IHRydWUsXG5cdFx0XHRcdHByZXNlcnZlUGFyZW5zOiB0cnVlLFxuXHRcdFx0XHRzb3VyY2VUeXBlOiAnbW9kdWxlJ1xuXHRcdFx0fSksIG51bGwsIHBhcGVyRmVhdHVyZXMpO1xuXHRcdH1cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRpZiAob2Zmc2V0Q29kZSkge1xuXHRcdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZTtcblx0XHRcdH1cblx0XHRcdGlmICgvXihpbmxpbmV8Ym90aCkkLy50ZXN0KHNvdXJjZU1hcHMpKSB7XG5cdFx0XHRcdGNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0XHQrIHNlbGYuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KG1hcCkpKSk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlICs9IFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArICh1cmwgfHwgJ3BhcGVyc2NyaXB0Jyk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHNvdXJjZTogc291cmNlLFxuXHRcdFx0Y29kZTogY29kZSxcblx0XHRcdG1hcDogbWFwXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXGJ0b29sXFwuXFx3K3xcXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiL1xuXHRcdFx0XHRcdC50ZXN0KGNvZGUpICYmICEvXFxibmV3XFxzK1Rvb2xcXGIvLnRlc3QoY29kZSlcblx0XHRcdFx0XHRcdD8gbmV3IFRvb2woKSA6IG51bGwsXG5cdFx0XHR0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG5cdFx0XHRoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuXHRcdFx0cGFyYW1zID0gW10sXG5cdFx0XHRhcmdzID0gW10sXG5cdFx0XHRmdW5jLFxuXHRcdFx0Y29tcGlsZWQgPSB0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcgPyBjb2RlIDogY29tcGlsZShjb2RlLCBvcHRpb25zKTtcblx0XHRjb2RlID0gY29tcGlsZWQuY29kZTtcblx0XHRmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG5cdFx0XHRcdGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cCgnKFtcXFxcYlxcXFxzXFxcXFddfF4pJ1xuXHRcdFx0XHRcdFx0KyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJncy5wdXNoKHNjb3BlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4cG9zZSh7IF9fJF9fOiBfXyRfXywgJF9fOiAkX18sIHBhcGVyOiBzY29wZSwgdG9vbDogdG9vbCB9LFxuXHRcdFx0XHR0cnVlKTtcblx0XHRleHBvc2Uoc2NvcGUpO1xuXHRcdGNvZGUgPSAndmFyIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfTsgJyArIGNvZGU7XG5cdFx0dmFyIGV4cG9ydHMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdHRoaXMucHVzaCgnbW9kdWxlLmV4cG9ydHMuJyArIGtleSArICcgPSAnICsga2V5ICsgJzsnKTtcblx0XHRcdH1cblx0XHR9LCBbXSkuam9pbignXFxuJyk7XG5cdFx0aWYgKGV4cG9ydHMpIHtcblx0XHRcdGNvZGUgKz0gJ1xcbicgKyBleHBvcnRzO1xuXHRcdH1cblx0XHRjb2RlICs9ICdcXG5yZXR1cm4gbW9kdWxlLmV4cG9ydHM7Jztcblx0XHR2YXIgYWdlbnQgPSBwYXBlci5hZ2VudDtcblx0XHRpZiAoZG9jdW1lbnQgJiYgKGFnZW50LmNocm9tZVxuXHRcdFx0XHR8fCBhZ2VudC5maXJlZm94ICYmIGFnZW50LnZlcnNpb25OdW1iZXIgPCA0MCkpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcblx0XHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0XHRcdGlmIChhZ2VudC5maXJlZm94KVxuXHRcdFx0XHRjb2RlID0gJ1xcbicgKyBjb2RlO1xuXHRcdFx0c2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuXHRcdFx0XHQnZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICtcblx0XHRcdFx0XHRjb2RlICtcblx0XHRcdFx0J1xcbn0nXG5cdFx0XHQpKTtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHRcdGZ1bmMgPSBkb2N1bWVudC5fX3BhcGVyc2NyaXB0X187XG5cdFx0XHRkZWxldGUgZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fO1xuXHRcdFx0aGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmdW5jID0gRnVuY3Rpb24ocGFyYW1zLCBjb2RlKTtcblx0XHR9XG5cdFx0dmFyIGV4cG9ydHMgPSBmdW5jICYmIGZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXHRcdHZhciBvYmogPSBleHBvcnRzIHx8IHt9O1xuXHRcdEJhc2UuZWFjaCh0b29sSGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIHZhbHVlID0gb2JqW2tleV07XG5cdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdHRvb2xba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHRpZiAob2JqLm9uUmVzaXplKVxuXHRcdFx0XHR2aWV3LnNldE9uUmVzaXplKG9iai5vblJlc2l6ZSk7XG5cdFx0XHR2aWV3LmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdFx0c2l6ZTogdmlldy5zaXplLFxuXHRcdFx0XHRkZWx0YTogbmV3IFBvaW50KClcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG9iai5vbkZyYW1lKVxuXHRcdFx0XHR2aWV3LnNldE9uRnJhbWUob2JqLm9uRnJhbWUpO1xuXHRcdFx0dmlldy5yZXF1ZXN0VXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBleHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHQpIHtcblx0XHRpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSlcblx0XHRcdFx0JiYgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnaWdub3JlJykgIT09ICd0cnVlJykge1xuXHRcdFx0dmFyIGNhbnZhc0lkID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKSxcblx0XHRcdFx0c3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpLFxuXHRcdFx0XHRhc3luYyA9IFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKHNjcmlwdCwgJ2FzeW5jJyksXG5cdFx0XHRcdHNjb3BlQXR0cmlidXRlID0gJ2RhdGEtcGFwZXItc2NvcGUnO1xuXHRcdFx0aWYgKCFjYW52YXMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzIHdpdGggaWQgXCInXG5cdFx0XHRcdFx0XHQrIGNhbnZhc0lkICsgJ1wiJyk7XG5cdFx0XHR2YXIgc2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMuZ2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlKSlcblx0XHRcdFx0XHRcdHx8IG5ldyBQYXBlclNjb3BlKCkuc2V0dXAoY2FudmFzKTtcblx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUsIHNjb3BlLl9pZCk7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdEh0dHAucmVxdWVzdCh7XG5cdFx0XHRcdFx0dXJsOiBzcmMsXG5cdFx0XHRcdFx0YXN5bmM6IGFzeW5jLFxuXHRcdFx0XHRcdG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG5cdFx0XHRcdFx0b25Mb2FkOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0XHRleGVjdXRlKGNvZGUsIHNjb3BlLCBzcmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGVjdXRlKHNjcmlwdC5pbm5lckhUTUwsIHNjb3BlLCBzY3JpcHQuYmFzZVVSSSk7XG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScsICd0cnVlJyk7XG5cdFx0XHRyZXR1cm4gc2NvcGU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZEFsbCgpIHtcblx0XHRCYXNlLmVhY2goZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLFxuXHRcdFx0XHRsb2FkU2NyaXB0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWQoc2NyaXB0KSB7XG5cdFx0cmV0dXJuIHNjcmlwdCA/IGxvYWRTY3JpcHQoc2NyaXB0KSA6IGxvYWRBbGwoKTtcblx0fVxuXG5cdGlmICh3aW5kb3cpIHtcblx0XHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0c2V0VGltZW91dChsb2FkQWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgeyBsb2FkOiBsb2FkQWxsIH0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlLFxuXHRcdGNhbGN1bGF0ZUJpbmFyeTogX18kX18sXG5cdFx0Y2FsY3VsYXRlVW5hcnk6ICRfX1xuXHR9O1xuXG59LmNhbGwodGhpcyk7XG5cbnZhciBwYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG5cdEJhc2U6IEJhc2UsXG5cdE51bWVyaWNhbDogTnVtZXJpY2FsLFxuXHRLZXk6IEtleSxcblx0RG9tRXZlbnQ6IERvbUV2ZW50LFxuXHREb21FbGVtZW50OiBEb21FbGVtZW50LFxuXHRkb2N1bWVudDogZG9jdW1lbnQsXG5cdHdpbmRvdzogd2luZG93LFxuXHRTeW1ib2w6IFN5bWJvbERlZmluaXRpb24sXG5cdFBsYWNlZFN5bWJvbDogU3ltYm9sSXRlbVxufSkpKCk7XG5cbmlmIChwYXBlci5hZ2VudC5ub2RlKSB7XG5cdHJlcXVpcmUoJy4vbm9kZS9leHRlbmQuanMnKShwYXBlcik7XG59XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcGFwZXI7XG59XG5cbnJldHVybiBwYXBlcjtcbn0uY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogbnVsbCk7XG4iLCJcclxuaW1wb3J0IHBhcGVyIGZyb20gJ3BhcGVyJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbmlCYXNlIHtcclxuXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICBwcm90ZWN0ZWQgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9wcm9qZWN0OiBwYXBlci5Qcm9qZWN0O1xyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IFdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLndpZHRoO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCBIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXMuaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICB0aGlzLl9wcm9qZWN0ID0gbmV3IHBhcGVyLlByb2plY3QodGhpcy5fY2FudmFzKTtcclxuICAgIHRoaXMuSW5pdGlhbGl6ZUNhbnZhcygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBJbml0aWFsaXplQ2FudmFzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fZWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9lbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIHRoaXMuX3Byb2plY3Qudmlldy52aWV3U2l6ZSA9IG5ldyBwYXBlci5TaXplKHRoaXMuV2lkdGgsIHRoaXMuSGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBTdGFydEFuaSgpOiB2b2lkO1xyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBBbmlCYXNlIH0gZnJvbSAnLi9hYnN0cmFjdGlvbnMvYW5pLWJhc2UnO1xyXG5pbXBvcnQgcGFwZXIgZnJvbSAncGFwZXInO1xyXG5pbXBvcnQgeyBBbmlIZWxwZXJzIH0gZnJvbSAnLi9oZWxwZXJzL2FuaS1oZWxwZXJzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDb25jZW50cmljQW5pIGV4dGVuZHMgQW5pQmFzZSB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBfY2lyY2xlczogcGFwZXIuUGF0aC5DaXJjbGVbXSA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgc3VwZXIoZWxlbWVudCk7XHJcbiAgICB0aGlzLlN0YXJ0QW5pKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIENyZWF0ZUVsZW1lbnRzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgbWF4UmFkaXVzOiBudW1iZXIgPSB0aGlzLkhlaWdodCA+PSB0aGlzLldpZHRoID8gKHRoaXMuSGVpZ2h0IC0gMTApIC8gMiA6ICh0aGlzLldpZHRoIC0gMTApIC8gMjtcclxuXHJcbiAgICBsZXQgY3VycmVudFJhZGl1czogbnVtYmVyID0gbWF4UmFkaXVzO1xyXG4gICAgY29uc3Qgc3Ryb2tlQ29sb3I6IHBhcGVyLkNvbG9yID0gbmV3IHBhcGVyLkNvbG9yKCdibGFjaycpO1xyXG5cclxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgY29uc3QgY2VudGVyOiBbeDogbnVtYmVyLCB5OiBudW1iZXJdID0gQW5pSGVscGVycy5HZXRDZW50ZXJGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgY29uc3QgcG9pbnQ6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KGNlbnRlclswXSwgY2VudGVyWzFdKTtcclxuICAgICAgY29uc3QgY2lyY2xlOiBwYXBlci5QYXRoLkNpcmNsZSA9IG5ldyBwYXBlci5QYXRoLkNpcmNsZShwb2ludCwgY3VycmVudFJhZGl1cyk7XHJcbiAgICAgIGNpcmNsZS5zdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgIGNpcmNsZS5zdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yO1xyXG5cclxuICAgICAgdGhpcy5fY2lyY2xlcy5wdXNoKGNpcmNsZSk7XHJcblxyXG4gICAgICBjdXJyZW50UmFkaXVzIC09IG1heFJhZGl1cyAvIDQ7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIFN0YXJ0QW5pKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2NpcmNsZXMubGVuZ3RoID09PSAwKSB0aGlzLkNyZWF0ZUVsZW1lbnRzKCk7XHJcbiAgICB0aGlzLkRvQW5pbWF0aW9uKDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBEb0FuaW1hdGlvbihpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsZXQgZGlyZWN0aW9uOiAndXAnIHwgJ2Rvd24nID0gJ3VwJztcclxuXHJcbiAgICBjb25zdCBpbnRlcnZhbDogbnVtYmVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xyXG4gICAgICAgIHRoaXMuX2NpcmNsZXNbaW5kZXhdLnN0cm9rZVdpZHRoICs9IDAuNTtcclxuICAgICAgICBpZiAodGhpcy5fY2lyY2xlc1tpbmRleF0uc3Ryb2tlV2lkdGggPT09IDQpIHtcclxuICAgICAgICAgIGRpcmVjdGlvbiA9ICdkb3duJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fY2lyY2xlc1tpbmRleF0uc3Ryb2tlV2lkdGggLT0gMC41O1xyXG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGVzW2luZGV4XS5zdHJva2VXaWR0aCA9PT0gMSkge1xyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgICAgICB0aGlzLkRvQW5pbWF0aW9uKGluZGV4ID09PSAzID8gMCA6ICsraW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMTYpO1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgY2xhc3MgQW5pSGVscGVycyB7XHJcbiAgcHVibGljIHN0YXRpYyBHZXRDZW50ZXJGcm9tRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCk6IFt4OiBudW1iZXIsIHk6IG51bWJlcl0ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBbeDogbnVtYmVyLCB5OiBudW1iZXJdID0gW2VsZW1lbnQuY2xpZW50V2lkdGggLyAyLCBlbGVtZW50LmNsaWVudEhlaWdodCAvIDJdO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgR2V0UG9pbnRPbkNpcmNsZShyYWRpdXM6IG51bWJlciwgZGVnOiBudW1iZXIpOiBbeDogbnVtYmVyLCB5OiBudW1iZXJdIHtcclxuICAgIGNvbnN0IHJhZGlhbnM6IG51bWJlciA9IGRlZyAqIChNYXRoLlBJIC8gMTgwKTtcclxuXHJcbiAgICByZXR1cm4gW3JhZGl1cyAqIE1hdGguc2luKHJhZGlhbnMpLCByYWRpdXMgKiBNYXRoLmNvcyhyYWRpYW5zKV07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIFRyYW5zZm9ybUNlbnRlcihjZW50ZXI6IFt4OiBudW1iZXIsIHk6IG51bWJlcl0sIHBvaW50OiBbeDogbnVtYmVyLCB5OiBudW1iZXJdKTogW3g6IG51bWJlciwgeTogbnVtYmVyXSB7XHJcbiAgICByZXR1cm4gW2NlbnRlclswXSAtIHBvaW50WzBdLCBjZW50ZXJbMV0gLSBwb2ludFsxXV07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFuaUJhc2UgfSBmcm9tICcuL2Fic3RyYWN0aW9ucy9hbmktYmFzZSc7XHJcbmltcG9ydCBwYXBlciBmcm9tICdwYXBlcic7XHJcbmltcG9ydCB7IEFuaUhlbHBlcnMgfSBmcm9tICcuL2hlbHBlcnMvYW5pLWhlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEhvcml6b250YWxMaW5lc0FuaSBleHRlbmRzIEFuaUJhc2Uge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2xpbmVzOiBwYXBlci5QYXRoLkxpbmVbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2xpbmVzQ291bnQgPSAwO1xyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBsaW5lczogbnVtYmVyID0gNSkge1xyXG4gICAgc3VwZXIoZWxlbWVudCk7XHJcbiAgICB0aGlzLl9saW5lc0NvdW50ID0gbGluZXM7XHJcbiAgICB0aGlzLlN0YXJ0QW5pKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIENyZWF0ZUVsZW1lbnRzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgY29sb3I6IHBhcGVyLkNvbG9yID0gbmV3IHBhcGVyLkNvbG9yKCdibGFjaycpO1xyXG4gICAgY29uc3QgY2VudGVyOiBbeDogbnVtYmVyLCB5Om51bWJlcl0gID0gQW5pSGVscGVycy5HZXRDZW50ZXJGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgICBsZXQgaGVpZ2h0SW5jcmVtZW50ID0gdGhpcy5IZWlnaHQgLyAodGhpcy5fbGluZXNDb3VudCArIDEpO1xyXG5cclxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDE7IGkgPD0gdGhpcy5fbGluZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgIGxldCBzdGFydDogcGFwZXIuUG9pbnQgPSBuZXcgcGFwZXIuUG9pbnQoMCwgaGVpZ2h0SW5jcmVtZW50ICogaSk7XHJcbiAgICAgIGxldCBlbmQ6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KHRoaXMuV2lkdGggLyAyLCBoZWlnaHRJbmNyZW1lbnQgKiBpKTtcclxuICAgICAgdmFyIGxpbmUgPSBuZXcgcGFwZXIuUGF0aC5MaW5lKHN0YXJ0LCBlbmQpO1xyXG4gICAgICBsaW5lLnN0cm9rZUNvbG9yID0gY29sb3I7XHJcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICB0aGlzLl9saW5lcy5wdXNoKGxpbmUpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBTdGFydEFuaSgpOiB2b2lkIHtcclxuICAgIHRoaXMuQ3JlYXRlRWxlbWVudHMoKTtcclxuICAgIHRoaXMuRG9BbmltYXRpb24oKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBEb0FuaW1hdGlvbigpOiB2b2lkIHtcclxuICAgIGNvbnN0IGNlbnRlcjogcGFwZXIuUG9pbnQgPSBuZXcgcGFwZXIuUG9pbnQoQW5pSGVscGVycy5HZXRDZW50ZXJGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KSk7XHJcblxyXG4gICAgY29uc3QgZGlyZWN0aW9uczogbnVtYmVyW10gPSB0aGlzLl9saW5lcy5tYXAoKCkgPT4gMCk7XHJcbiAgICBjb25zdCBzdGFydGVkOiBib29sZWFuW10gPSB0aGlzLl9saW5lcy5tYXAoKCkgPT4gZmFsc2UpO1xyXG5cclxuICAgIHN0YXJ0ZWRbMF0gPSB0cnVlO1xyXG5cclxuICAgIHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLl9saW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghc3RhcnRlZFtpXSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXSA9PT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5fbGluZXNbaV0ucG9zaXRpb24ueCsrO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9saW5lc1tpXS5wb3NpdGlvbi54ID4gdGhpcy5XaWR0aCAqIDAuNzUpIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uc1tpXSA9IDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9saW5lc1tpXS5wb3NpdGlvbi54LS07XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2xpbmVzW2ldLnBvc2l0aW9uLnggPD0gdGhpcy5XaWR0aCAqIDAuMjUpIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uc1tpXSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCAxNik7XHJcblxyXG4gICAgbGV0IHRpbWVvdXQ6IG51bWJlciA9IDgwO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGFydGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzdGFydGVkW2ldID0gdHJ1ZTtcclxuICAgICAgfSwgdGltZW91dClcclxuICAgICAgdGltZW91dCArPSA4MDtcclxuICAgIH1cclxuXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFuaUJhc2UgfSBmcm9tICcuL2Fic3RyYWN0aW9ucy9hbmktYmFzZSc7XHJcbmltcG9ydCBwYXBlciBmcm9tICdwYXBlcic7XHJcbmltcG9ydCB7IEFuaUhlbHBlcnMgfSBmcm9tICcuL2hlbHBlcnMvYW5pLWhlbHBlcnMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNwaW5uaW5nQXJjc0FubmkgZXh0ZW5kcyBBbmlCYXNlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IF9hcmNzOiBwYXBlci5QYXRoLkFyY1tdID0gW107XHJcbiAgcHJpdmF0ZSBfYXJjc0NvdW50ID0gMDtcclxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgYXJjczogbnVtYmVyID0gNSkge1xyXG4gICAgc3VwZXIoZWxlbWVudCk7XHJcbiAgICB0aGlzLl9hcmNzQ291bnQgPSBhcmNzO1xyXG4gICAgdGhpcy5TdGFydEFuaSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBDcmVhdGVFbGVtZW50cygpOiB2b2lkIHtcclxuICAgIGNvbnN0IGNvbG9yOiBwYXBlci5Db2xvciA9IG5ldyBwYXBlci5Db2xvcignYmxhY2snKTtcclxuICAgIGNvbnN0IGNlbnRlcjogW3g6IG51bWJlciwgeTpudW1iZXJdICA9IEFuaUhlbHBlcnMuR2V0Q2VudGVyRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XHJcbiAgICBsZXQgZGVnOiBudW1iZXIgPSAwO1xyXG4gICAgbGV0IGRlZ3JlZXNJbmNyZW1lbnQ6IG51bWJlciA9ICgzNjAgLyB0aGlzLl9hcmNzQ291bnQpO1xyXG4gICAgbGV0IHJhZGl1czogbnVtYmVyID0gdGhpcy5XaWR0aCA+PSB0aGlzLkhlaWdodCA/ICh0aGlzLldpZHRoIC0gMSkgLyAyIDogKHRoaXMuSGVpZ2h0IC0gMSkgLyAyO1xyXG5cclxuICAgIGxldCByYWRpdXNEZWNyZW1lbnQ6IG51bWJlciA9IHJhZGl1cyAvIHRoaXMuX2FyY3NDb3VudDtcclxuXHJcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5fYXJjc0NvdW50OyBpKyspIHtcclxuICAgICAgY29uc3Qgc3RhcnQ6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KEFuaUhlbHBlcnMuVHJhbnNmb3JtQ2VudGVyKGNlbnRlciwgQW5pSGVscGVycy5HZXRQb2ludE9uQ2lyY2xlKHJhZGl1cywgZGVnKSkpO1xyXG4gICAgICBjb25zdCBtaWRkbGU6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KEFuaUhlbHBlcnMuVHJhbnNmb3JtQ2VudGVyKGNlbnRlciwgQW5pSGVscGVycy5HZXRQb2ludE9uQ2lyY2xlKHJhZGl1cywgZGVnICsgZGVncmVlc0luY3JlbWVudCAvIDIpKSk7XHJcbiAgICAgIGNvbnN0IGVuZDogcGFwZXIuUG9pbnQgPSBuZXcgcGFwZXIuUG9pbnQoQW5pSGVscGVycy5UcmFuc2Zvcm1DZW50ZXIoY2VudGVyLCBBbmlIZWxwZXJzLkdldFBvaW50T25DaXJjbGUocmFkaXVzLCBkZWcgKyBkZWdyZWVzSW5jcmVtZW50KSkpO1xyXG5cclxuICAgICAgY29uc3QgYXJjOiBwYXBlci5QYXRoLkFyYyA9IG5ldyBwYXBlci5QYXRoLkFyYyhzdGFydCwgbWlkZGxlLCBlbmQpO1xyXG4gICAgICBhcmMuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICBhcmMuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcclxuXHJcbiAgICAgIHRoaXMuX2FyY3MucHVzaChhcmMpO1xyXG4gICAgICBkZWcgKz0gZGVncmVlc0luY3JlbWVudCAvIDI7XHJcbiAgICAgIHJhZGl1cyAtPSByYWRpdXNEZWNyZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgU3RhcnRBbmkoKTogdm9pZCB7XHJcbiAgICB0aGlzLkNyZWF0ZUVsZW1lbnRzKCk7XHJcbiAgICB0aGlzLkRvQW5pbWF0aW9uKCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgRG9BbmltYXRpb24oKTogdm9pZCB7XHJcbiAgICBjb25zdCBjZW50ZXI6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KEFuaUhlbHBlcnMuR2V0Q2VudGVyRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCkpO1xyXG4gICAgd2luZG93LnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuX2FyY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9hcmNzW2ldLnJvdGF0ZSg4LCBjZW50ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxNik7XHJcbiAgfVxyXG59XHJcbiJdfQ==
