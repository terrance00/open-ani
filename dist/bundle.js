(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concentric_ani_1 = require("./src/concentric-ani");
var element = document.getElementById("concentricCircles");
var concentricAni = new concentric_ani_1.ConcentricAni(element);
},{"./src/concentric-ani":6}],2:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, (function (exports) { 'use strict';

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `bin/generate-identifier-regex.js`.
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range. They were
  // generated by bin/generate-identifier-regex.js

  // eslint-disable-next-line comma-spacing
  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

  // eslint-disable-next-line comma-spacing
  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords$1 = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  // Checks if an object has a property.

  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 10.
    ecmaVersion: 10,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  // Switch to a getter for 7.0.0.
  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) { return true } // '['
    if (context) { return false }

    if (nextCh === 123) { return true } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$1.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (this.type !== types.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };

  // Parses module export declaration.

  pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseIdent(true);
          this.checkExport(exports, node.exported.name, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };

  // Parses import declaration.

  pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // Verify that a node is an lval — something that can be assigned
  // to.
  // bindingType can be either:
  // 'var' indicating that the lval creates a 'var' binding
  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  // A recursive descent parser operates by defining functions for all

  var pp$3 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
            // Backwards-compat kludge. Can be removed in version 6.0
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var coalesce = this.type === types.coalesce;
        if (coalesce) {
          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
          prec = types.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };

  // Parse call, dot, and `[]`-subscript expressions.

  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types.bracketL);
    if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();

    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); // skip `(`

    // Parse node.source.
    node.source = this.parseMaybeAssign();

    // Verify ending.
    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseImportMeta = function(node) {
    this.next(); // skip `.`

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module")
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call — at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  // Parses yield expression inside generator.

  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };

  // Start an AST node, attaching a start offset.

  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };

  // Finish node at given position

  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Token-specific context update code

  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A /* * */) ||
      state.eat(0x2B /* + */) ||
      state.eat(0x3F /* ? */) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24 /* $ */ ||
      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
      ch === 0x2E /* . */ ||
      ch === 0x3F /* ? */ ||
      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24 /* $ */ &&
      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
      ch !== 0x2E /* . */ &&
      ch !== 0x3F /* ? */ &&
      ch !== 0x5B /* [ */ &&
      ch !== 0x5E /* ^ */ &&
      ch !== 0x7C /* | */
    ) {
      state.advance();
      return true
    }
    return false
  };

  // GroupSpecifier ::
  //   [empty]
  //   `?` GroupName
  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  // GroupName ::
  //   `<` RegExpIdentifierName `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  // RegExpIdentifierName ::
  //   RegExpIdentifierStart
  //   RegExpIdentifierName RegExpIdentifierPart
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  // RegExpIdentifierStart ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
  }

  // RegExpIdentifierPart ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B /* { */) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D /* } */) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50 /* P */ || ch === 0x70 /* p */)
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B /* { */) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D /* } */)
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64 /* d */ ||
      ch === 0x44 /* D */ ||
      ch === 0x73 /* s */ ||
      ch === 0x53 /* S */ ||
      ch === 0x77 /* w */ ||
      ch === 0x57 /* W */
    )
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* ] */)) {
        return true
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D /* ] */) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }

    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true
    }

    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */)
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */)
    }
    return ch - 0x30 /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };

  // ## Tokenizer

  var pp$9 = Parser.prototype;

  // Move to the next token

  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: // ' '
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: // '*'
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.readToken_question = function() { // '?'
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
        }
        return this.finishOp(types.coalesce, 2)
      }
    }
    return this.finishOp(types.question, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46: // '.'
      return this.readToken_dot()

    // Punctuation tokens.
    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)

    case 96: // '`'
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return this.readNumber(false)

    // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return this.readToken_slash()

    case 37: case 42: // '%*'
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: // '|&'
      return this.readToken_pipe_amp(code)

    case 94: // '^'
      return this.readToken_caret()

    case 43: case 45: // '+-'
      return this.readToken_plus_min(code)

    case 60: case 62: // '<>'
      return this.readToken_lt_gt(code)

    case 61: case 33: // '=!'
      return this.readToken_eq_excl(code)

    case 63: // '?'
      return this.readToken_question()

    case 126: // '~'
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } // a
      else if (code >= 65) { val = code - 65 + 10; } // A
      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""))
  }

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };

  // Read an integer, octal integer, or floating-point number.

  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } // '+-'
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val)
  };

  // Read a string value, interpreting backslash-escapes.

  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { // '{'
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }
      // falls through

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" // 'n' -> '\n'
    case 114: return "\r" // 'r' -> '\r'
    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
    case 117: return codePointToString$1(this.readCodePoint()) // 'u'
    case 116: return "\t" // 't' -> '\t'
    case 98: return "\b" // 'b' -> '\b'
    case 118: return "\u000b" // 'v' -> '\u000b'
    case 102: return "\f" // 'f' -> '\f'
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
    case 10: // ' \n'
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return ""
      }
      return String.fromCharCode(ch)
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "7.4.1";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options)
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
/*!
 * Paper.js v0.12.15 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Mar 17 10:49:48 2021 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = function(self, undefined) {

self = self || require('./node/self.js');
var window = self.window,
	document = self.document;

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,
		array = [],
		slice = array.slice,
		create = Object.create,
		describe = Object.getOwnPropertyDescriptor,
		define = Object.defineProperty,

		forEach = array.forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++) {
				iter.call(bind, this[i], i, this);
			}
		},

		forIn = function(iter, bind) {
			for (var i in this) {
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
			}
		},

		set = Object.assign || function(dst) {
			for (var i = 1, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				for (var key in src) {
					if (src.hasOwnProperty(key))
						dst[key] = src[key];
				}
			}
			return dst;
		},

		each = function(obj, iter, bind) {
			if (obj) {
				var desc = describe(obj, 'length');
				(desc && typeof desc.value === 'number' ? forEach : forIn)
					.call(obj, iter, bind = bind || obj);
			}
			return bind;
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res)) {
					res = { value: res, writable: true };
				}
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable != null ? enumerable : !bean;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function Base() {
		for (var i = 0, l = arguments.length; i < l; i++) {
			var src = arguments[i];
			if (src)
				set(this, src);
		}
		return this;
	}

	return inject(Base, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, null, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, obj, l = arguments.length;
					i < l && !(ctor && proto); i++) {
				obj = arguments[i];
				ctor = ctor || obj.initialize;
				proto = proto || obj.prototype;
			}
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = proto || create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}).inject({
		enumerable: false,

		initialize: Base,

		set: Base,

		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src) {
					inject(this, src, src.enumerable, src.beans, src.preserve);
				}
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			set: set,
			each: each,
			create: create,
			define: define,
			describe: describe,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			},

			slice: function(list, begin, end) {
				return slice.call(list, begin, end);
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	enumerable: false,

	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	importJSON: function(json) {
		return Base.importJSON(json, this);
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	set: function(props, exclude) {
		if (props)
			Base.filter(this, props, exclude, this._prioritize);
		return this;
	}
}, {

beans: false,
statics: {
	exports: {},

	extend: function extend() {
		var res = extend.base.apply(this, arguments),
			name = res.prototype._class;
		if (name && !Base.exports[name])
			Base.exports[name] = res;
		return res;
	},

	equals: function(obj1, obj2) {
		if (obj1 === obj2)
			return true;
		if (obj1 && obj1.equals)
			return obj1.equals(obj2);
		if (obj2 && obj2.equals)
			return obj2.equals(obj1);
		if (obj1 && obj2
				&& typeof obj1 === 'object' && typeof obj2 === 'object') {
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				var length = obj1.length;
				if (length !== obj2.length)
					return false;
				while (length--) {
					if (!Base.equals(obj1[length], obj2[length]))
						return false;
				}
			} else {
				var keys = Object.keys(obj1),
					length = keys.length;
				if (length !== Object.keys(obj2).length)
					return false;
				while (length--) {
					var key = keys[length];
					if (!(obj2.hasOwnProperty(key)
							&& Base.equals(obj1[key], obj2[key])))
						return false;
				}
			}
			return true;
		}
		return false;
	},

	read: function(list, start, options, amount) {
		if (this === Base) {
			var value = this.peek(list, start);
			list.__index++;
			return value;
		}
		var proto = this.prototype,
			readIndex = proto._readIndex,
			begin = start || readIndex && list.__index || 0,
			length = list.length,
			obj = list[begin];
		amount = amount || length - begin;
		if (obj instanceof this
			|| options && options.readNull && obj == null && amount <= 1) {
			if (readIndex)
				list.__index = begin + 1;
			return obj && options && options.clone ? obj.clone() : obj;
		}
		obj = Base.create(proto);
		if (readIndex)
			obj.__read = true;
		obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
				? Base.slice(list, begin, begin + amount)
				: list) || obj;
		if (readIndex) {
			list.__index = begin + obj.__read;
			var filtered = obj.__filtered;
			if (filtered) {
				list.__filtered = filtered;
				obj.__filtered = undefined;
			}
			obj.__read = undefined;
		}
		return obj;
	},

	peek: function(list, start) {
		return list[list.__index = start || list.__index || 0];
	},

	remain: function(list) {
		return list.length - (list.__index || 0);
	},

	readList: function(list, start, options, amount) {
		var res = [],
			entry,
			begin = start || 0,
			end = amount ? begin + amount : list.length;
		for (var i = begin; i < end; i++) {
			res.push(Array.isArray(entry = list[i])
					? this.read(entry, 0, options)
					: this.read(list, i, options, 1));
		}
		return res;
	},

	readNamed: function(list, name, start, options, amount) {
		var value = this.getNamed(list, name),
			hasValue = value !== undefined;
		if (hasValue) {
			var filtered = list.__filtered;
			if (!filtered) {
				var source = this.getSource(list);
				filtered = list.__filtered = Base.create(source);
				filtered.__unfiltered = source;
			}
			filtered[name] = undefined;
		}
		return this.read(hasValue ? [value] : list, start, options, amount);
	},

	readSupported: function(list, dest) {
		var source = this.getSource(list),
			that = this,
			read = false;
		if (source) {
			Object.keys(source).forEach(function(key) {
				if (key in dest) {
					var value = that.readNamed(list, key);
					if (value !== undefined) {
						dest[key] = value;
					}
					read = true;
				}
			});
		}
		return read;
	},

	getSource: function(list) {
		var source = list.__source;
		if (source === undefined) {
			var arg = list.length === 1 && list[0];
			source = list.__source = arg && Base.isPlainObject(arg)
				? arg : null;
		}
		return source;
	},

	getNamed: function(list, name) {
		var source = this.getSource(list);
		if (source) {
			return name ? source[name] : list.__filtered || source;
		}
	},

	hasNamed: function(list, name) {
		return !!this.getNamed(list, name);
	},

	filter: function(dest, source, exclude, prioritize) {
		var processed;

		function handleKey(key) {
			if (!(exclude && key in exclude) &&
				!(processed && key in processed)) {
				var value = source[key];
				if (value !== undefined)
					dest[key] = value;
			}
		}

		if (prioritize) {
			var keys = {};
			for (var i = 0, key, l = prioritize.length; i < l; i++) {
				if ((key = prioritize[i]) in source) {
					handleKey(key);
					keys[key] = true;
				}
			}
			processed = keys;
		}

		Object.keys(source.__unfiltered || source).forEach(handleKey);
		return dest;
	},

	isPlainValue: function(obj, asString) {
		return Base.isPlainObject(obj) || Array.isArray(obj)
				|| asString && typeof obj === 'string';
	},

	serialize: function(obj, options, compact, dictionary) {
		options = options || {};

		var isRoot = !dictionary,
			res;
		if (isRoot) {
			options.formatter = new Formatter(options.precision);
			dictionary = {
				length: 0,
				definitions: {},
				references: {},
				add: function(item, create) {
					var id = '#' + item._id,
						ref = this.references[id];
					if (!ref) {
						this.length++;
						var res = create.call(item),
							name = item._class;
						if (name && res[0] !== name)
							res.unshift(name);
						this.definitions[id] = res;
						ref = this.references[id] = [id];
					}
					return ref;
				}
			};
		}
		if (obj && obj._serialize) {
			res = obj._serialize(options, dictionary);
			var name = obj._class;
			if (name && !obj._compactSerialize && (isRoot || !compact)
					&& res[0] !== name) {
				res.unshift(name);
			}
		} else if (Array.isArray(obj)) {
			res = [];
			for (var i = 0, l = obj.length; i < l; i++)
				res[i] = Base.serialize(obj[i], options, compact, dictionary);
		} else if (Base.isPlainObject(obj)) {
			res = {};
			var keys = Object.keys(obj);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				res[key] = Base.serialize(obj[key], options, compact,
						dictionary);
			}
		} else if (typeof obj === 'number') {
			res = options.formatter.number(obj, options.precision);
		} else {
			res = obj;
		}
		return isRoot && dictionary.length > 0
				? [['dictionary', dictionary.definitions], res]
				: res;
	},

	deserialize: function(json, create, _data, _setDictionary, _isRoot) {
		var res = json,
			isFirst = !_data,
			hasDictionary = isFirst && json && json.length
				&& json[0][0] === 'dictionary';
		_data = _data || {};
		if (Array.isArray(json)) {
			var type = json[0],
				isDictionary = type === 'dictionary';
			if (json.length == 1 && /^#/.test(type)) {
				return _data.dictionary[type];
			}
			type = Base.exports[type];
			res = [];
			for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
				res.push(Base.deserialize(json[i], create, _data,
						isDictionary, hasDictionary));
			}
			if (type) {
				var args = res;
				if (create) {
					res = create(type, args, isFirst || _isRoot);
				} else {
					res = new type(args);
				}
			}
		} else if (Base.isPlainObject(json)) {
			res = {};
			if (_setDictionary)
				_data.dictionary = res;
			for (var key in json)
				res[key] = Base.deserialize(json[key], create, _data);
		}
		return hasDictionary ? res[1] : res;
	},

	exportJSON: function(obj, options) {
		var json = Base.serialize(obj, options);
		return options && options.asString == false
				? json
				: JSON.stringify(json);
	},

	importJSON: function(json, target) {
		return Base.deserialize(
				typeof json === 'string' ? JSON.parse(json) : json,
				function(ctor, args, isRoot) {
					var useTarget = isRoot && target
							&& target.constructor === ctor,
						obj = useTarget ? target
							: Base.create(ctor.prototype);
					if (args.length === 1 && obj instanceof Item
							&& (useTarget || !(obj instanceof Layer))) {
						var arg = args[0];
						if (Base.isPlainObject(arg)) {
							arg.insert = false;
							if (useTarget) {
								args = args.concat([{ insert: true }]);
							}
						}
					}
					(useTarget ? obj.set : ctor).apply(obj, args);
					if (useTarget)
						target = null;
					return obj;
				});
	},

	push: function(list, items) {
		var itemsLength = items.length;
		if (itemsLength < 4096) {
			list.push.apply(list, items);
		} else {
			var startLength = list.length;
			list.length += itemsLength;
			for (var i = 0; i < itemsLength; i++) {
				list[startLength + i] = items[i];
			}
		}
		return list;
	},

	splice: function(list, items, index, remove) {
		var amount = items && items.length,
			append = index === undefined;
		index = append ? list.length : index;
		if (index > list.length)
			index = list.length;
		for (var i = 0; i < amount; i++)
			items[i]._index = index + i;
		if (append) {
			Base.push(list, items);
			return [];
		} else {
			var args = [index, remove];
			if (items)
				Base.push(args, items);
			var removed = list.splice.apply(list, args);
			for (var i = 0, l = removed.length; i < l; i++)
				removed[i]._index = undefined;
			for (var i = index + amount, l = list.length; i < l; i++)
				list[i]._index = i;
			return removed;
		}
	},

	capitalize: function(str) {
		return str.replace(/\b[a-z]/g, function(match) {
			return match.toUpperCase();
		});
	},

	camelize: function(str) {
		return str.replace(/-(.)/g, function(match, chr) {
			return chr.toUpperCase();
		});
	},

	hyphenate: function(str) {
		return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	}
}});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function handler() {
			func.apply(this, arguments);
			this.off(type, handler);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = Base.slice(arguments, 1),
			setTarget = event && event.target && !event.currentTarget;
		handlers = handlers.slice();
		if (setTarget)
			event.currentTarget = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) == false) {
				if (event && event.stop)
					event.stop();
				break;
		   }
		}
		if (setTarget)
			delete event.currentTarget;
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var types = this._eventTypes,
			handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		if (types) {
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var entry = types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			insertItems: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1) || {};
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
		if (!this.agent) {
			var user = self.navigator.userAgent.toLowerCase(),
				os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
				platform = os === 'darwin' ? 'mac' : os,
				agent = proto.agent = proto.browser = { platform: platform };
			if (platform)
				agent[platform] = true;
			user.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
				function(match, n, v1, v2, rv) {
					if (!agent.chrome) {
						var v = n === 'opera' ? v2 :
								/^(node|trident)$/.test(n) ? rv : v1;
						agent.version = v;
						agent.versionNumber = parseFloat(v);
						n = { trident: 'msie', jsdom: 'node' }[n] || n;
						agent.name = n;
						agent[n] = true;
					}
				}
			);
			if (agent.chrome)
				delete agent.webkit;
			if (agent.atom)
				delete agent.chrome;
		}
	},

	version: "0.12.15",

	getView: function() {
		var project = this.project;
		return project && project._view;
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, options) {
			var exports = paper.PaperScript.execute(code, this, options);
			View.updateFocus();
			return exports;
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	createCanvas: function(width, height) {
		return CanvasProvider.getCanvas(width, height);
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		var projects = this.projects,
			tools = this.tools;
		for (var i = projects.length - 1; i >= 0; i--)
			projects[i].remove();
		for (var i = tools.length - 1; i >= 0; i--)
			tools[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	},

	getView: function() {
		return this._scope.getView();
	}
});

var CollisionDetection = {
	findItemBoundsCollisions: function(items1, items2, tolerance) {
		function getBounds(items) {
			var bounds = new Array(items.length);
			for (var i = 0; i < items.length; i++) {
				var rect = items[i].getBounds();
				bounds[i] = [rect.left, rect.top, rect.right, rect.bottom];
			}
			return bounds;
		}

		var bounds1 = getBounds(items1),
			bounds2 = !items2 || items2 === items1
				? bounds1
				: getBounds(items2);
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {
		function getBounds(curves) {
			var min = Math.min,
				max = Math.max,
				bounds = new Array(curves.length);
			for (var i = 0; i < curves.length; i++) {
				var v = curves[i];
				bounds[i] = [
					min(v[0], v[2], v[4], v[6]),
					min(v[1], v[3], v[5], v[7]),
					max(v[0], v[2], v[4], v[6]),
					max(v[1], v[3], v[5], v[7])
				];
			}
			return bounds;
		}

		var bounds1 = getBounds(curves1),
			bounds2 = !curves2 || curves2 === curves1
				? bounds1
				: getBounds(curves2);
		if (bothAxis) {
			var hor = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, false, true),
				ver = this.findBoundsCollisions(
					bounds1, bounds2, tolerance || 0, true, true),
				list = [];
			for (var i = 0, l = hor.length; i < l; i++) {
				list[i] = { hor: hor[i], ver: ver[i] };
			}
			return list;
		}
		return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);
	},

	findBoundsCollisions: function(boundsA, boundsB, tolerance,
		sweepVertical, onlySweepAxisCollisions) {
		var self = !boundsB || boundsA === boundsB,
			allBounds = self ? boundsA : boundsA.concat(boundsB),
			lengthA = boundsA.length,
			lengthAll = allBounds.length;

		function binarySearch(indices, coord, value) {
			var lo = 0,
				hi = indices.length;
			while (lo < hi) {
				var mid = (hi + lo) >>> 1;
				if (allBounds[indices[mid]][coord] < value) {
					lo = mid + 1;
				} else {
					hi = mid;
				}
			}
			return lo - 1;
		}

		var pri0 = sweepVertical ? 1 : 0,
			pri1 = pri0 + 2,
			sec0 = sweepVertical ? 0 : 1,
			sec1 = sec0 + 2;
		var allIndicesByPri0 = new Array(lengthAll);
		for (var i = 0; i < lengthAll; i++) {
			allIndicesByPri0[i] = i;
		}
		allIndicesByPri0.sort(function(i1, i2) {
			return allBounds[i1][pri0] - allBounds[i2][pri0];
		});
		var activeIndicesByPri1 = [],
			allCollisions = new Array(lengthA);
		for (var i = 0; i < lengthAll; i++) {
			var curIndex = allIndicesByPri0[i],
				curBounds = allBounds[curIndex],
				origIndex = self ? curIndex : curIndex - lengthA,
				isCurrentA = curIndex < lengthA,
				isCurrentB = self || !isCurrentA,
				curCollisions = isCurrentA ? [] : null;
			if (activeIndicesByPri1.length) {
				var pruneCount = binarySearch(activeIndicesByPri1, pri1,
						curBounds[pri0] - tolerance) + 1;
				activeIndicesByPri1.splice(0, pruneCount);
				if (self && onlySweepAxisCollisions) {
					curCollisions = curCollisions.concat(activeIndicesByPri1);
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j];
						allCollisions[activeIndex].push(origIndex);
					}
				} else {
					var curSec1 = curBounds[sec1],
						curSec0 = curBounds[sec0];
					for (var j = 0; j < activeIndicesByPri1.length; j++) {
						var activeIndex = activeIndicesByPri1[j],
							activeBounds = allBounds[activeIndex],
							isActiveA = activeIndex < lengthA,
							isActiveB = self || activeIndex >= lengthA;

						if (
							onlySweepAxisCollisions ||
							(
								isCurrentA && isActiveB ||
								isCurrentB && isActiveA
							) && (
								curSec1 >= activeBounds[sec0] - tolerance &&
								curSec0 <= activeBounds[sec1] + tolerance
							)
						) {
							if (isCurrentA && isActiveB) {
								curCollisions.push(
									self ? activeIndex : activeIndex - lengthA);
							}
							if (isCurrentB && isActiveA) {
								allCollisions[activeIndex].push(origIndex);
							}
						}
					}
				}
			}
			if (isCurrentA) {
				if (boundsA === boundsB) {
					curCollisions.push(curIndex);
				}
				allCollisions[curIndex] = curCollisions;
			}
			if (activeIndicesByPri1.length) {
				var curPri1 = curBounds[pri1],
					index = binarySearch(activeIndicesByPri1, pri1, curPri1);
				activeIndicesByPri1.splice(index + 1, 0, curIndex);
			} else {
				activeIndicesByPri1.push(curIndex);
			}
		}
		for (var i = 0; i < allCollisions.length; i++) {
			var collisions = allCollisions[i];
			if (collisions) {
				collisions.sort(function(i1, i2) { return i1 - i2; });
			}
		}
		return allCollisions;
	}
};

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = Base.pick(precision, 5);
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return this.precision < 16
				? Math.round(val * this.multiplier) / this.multiplier : val;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		log2 = Math.log2 || function(x) {
			return Math.log(x) * Math.LOG2E;
		},
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clamp(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	function getDiscriminant(a, b, c) {
		function split(v) {
			var x = v * 134217729,
				y = v - x,
				hi = y + x,
				lo = v - hi;
			return [hi, lo];
		}

		var D = b * b - a * c,
			E = b * b + a * c;
		if (abs(D) * 3 < E) {
			var ad = split(a),
				bd = split(b),
				cd = split(c),
				p = b * b,
				dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
				q = a * c,
				dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
						+ ad[1] * cd[1];
			D = (p - q) + (dp - dq);
		}
		return D;
	}

	function getNormalizationFactor() {
		var norm = Math.max.apply(Math, arguments);
		return norm && (norm < 1e-8 || norm > 1e8)
				? pow(2, -Math.round(log2(norm)))
				: 0;
	}

	return {
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 1e-8,
		GEOMETRIC_EPSILON: 1e-7,
		TRIGONOMETRIC_EPSILON: 1e-8,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		isMachineZero: function(val) {
			return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;
		},

		clamp: clamp,

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance) {
					x = nx;
					break;
				}
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return clamp(x, a, b);
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var x1, x2 = Infinity;
			if (abs(a) < EPSILON) {
				if (abs(b) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / b;
			} else {
				b *= -0.5;
				var D = getDiscriminant(a, b, c);
				if (D && abs(D) < MACHINE_EPSILON) {
					var f = getNormalizationFactor(abs(a), abs(b), abs(c));
					if (f) {
						a *= f;
						b *= f;
						c *= f;
						D = getDiscriminant(a, b, c);
					}
				}
				if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
			}
			var count = 0,
				boundless = min == null,
				minB = min - EPSILON,
				maxB = max + EPSILON;
			if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
				roots[count++] = boundless ? x1 : clamp(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
				roots[count++] = boundless ? x2 : clamp(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
				x, b1, c2, qd, q;
			if (f) {
				a *= f;
				b *= f;
				c *= f;
				d *= f;
			}

			function evaluate(x0) {
				x = x0;
				var tmp = a * x;
				b1 = tmp + b;
				c2 = b1 * x + c;
				qd = (tmp + b1) * x + c2;
				q = c2 * x + d;
			}

			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				evaluate(-(b / a) / 3);
				var t = q / a,
					r = pow(abs(t), 1/3),
					s = t < 0 ? -1 : 1,
					td = -qd / a,
					rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
					x0 = x - s * rd;
				if (x0 !== x) {
					do {
						evaluate(x0);
						x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
				boundless = min == null;
			if (isFinite(x) && (count === 0
					|| count > 0 && x !== roots[0] && x !== roots[1])
					&& (boundless || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = boundless ? x : clamp(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(name) {
		if (name) {
			var pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this._set(arg0, hasY ? arg1 : arg0);
			if (reading)
				read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('angle' in obj) {
				this._set(obj.length || 0, 0);
				this.setAngle(obj.angle || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this._set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var args = arguments,
			point = Point.read(args),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(args);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var args = arguments,
			point = Point.read(args),
			tolerance = Base.read(args);
		return this.getDistance(point) <= tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.x) && isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	isInQuadrant: function(q) {
		return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
			&& this.y * (q > 2 ? -1 : 1) >= 0;
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var args = arguments,
				point1 = Point.read(args),
				point2 = Point.read(args);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		return this._setter === 'setPosition' ? 4 : 0;
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this._set(arg0, hasHeight ? arg1 : arg0);
			if (reading)
				read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.width) && isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var args = arguments,
			type = typeof arg0,
			read;
		if (type === 'number') {
			this._set(arg0, arg1, arg2, arg3);
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0, 0, 0);
			read = arg0 === null ? 1 : 0;
		} else if (args.length === 1) {
			if (Array.isArray(arg0)) {
				this._set.apply(this, arg0);
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this._set(arg0.x || 0, arg0.y || 0,
						arg0.width || 0, arg0.height || 0);
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this._set(0, 0, 0, 0);
				if (Base.readSupported(args, this)) {
					read = 1;
				}
			}
		}
		if (read === undefined) {
			var frm = Point.readNamed(args, 'from'),
				next = Base.peek(args),
				x = frm.x,
				y = frm.y,
				width,
				height;
			if (next && next.x !== undefined || Base.hasNamed(args, 'to')) {
				var to = Point.readNamed(args, 'to');
				width = to.x - x;
				height = to.y - y;
				if (width < 0) {
					x = to.x;
					width = -width;
				}
				if (height < 0) {
					y = to.y;
					height = -height;
				}
			} else {
				var size = Size.read(args);
				width = size.width;
				height = size.height;
			}
			this._set(x, y, width, height);
			read = args.__index;
		}
		var filtered = args.__filtered;
		if (filtered)
			this.__filtered = filtered;
		if (this.__read)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	_fw: 1,
	_fh: 1,

	setSize: function() {
		var size = Size.read(arguments),
			sx = this._sx,
			sy = this._sy,
			w = size.width,
			h = size.height;
		if (sx) {
			this.x += (this.width - w) * sx;
		}
		if (sy) {
			this.y += (this.height - h) * sy;
		}
		this.width = w;
		this.height = h;
		this._fw = this._fh = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fw) {
			var amount = left - this.x;
			this.width -= this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = left;
		this._sx = this._fw = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fh) {
			var amount = top - this.y;
			this.height -= this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = top;
		this._sy = this._fh = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (!this._fw) {
			var amount = right - this.x;
			this.width = this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = right - this.width;
		this._sx = 1;
		this._fw = 0;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (!this._fh) {
			var amount = bottom - this.y;
			this.height = this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = bottom - this.height;
		this._sy = 1;
		this._fh = 0;
	},

	getCenterX: function() {
		return this.x + this.width / 2;
	},

	setCenterX: function(x) {
		if (this._fw || this._sx === 0.5) {
			this.x = x - this.width / 2;
		} else {
			if (this._sx) {
				this.x += (x - this.x) * 2 * this._sx;
			}
			this.width = (x - this.x) * 2;
		}
		this._sx = 0.5;
		this._fw = 0;
	},

	getCenterY: function() {
		return this.y + this.height / 2;
	},

	setCenterY: function(y) {
		if (this._fh || this._sy === 0.5) {
			this.y = y - this.height / 2;
		} else {
			if (this._sy) {
				this.y += (y - this.y) * 2 * this._sy;
			}
			this.height = (y - this.y) * 2;
		}
		this._sy = 0.5;
		this._fh = 0;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length === 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments),
			epsilon = Base.read(arguments) || 0;
		return rect.x + rect.width > this.x - epsilon
				&& rect.y + rect.height > this.y - epsilon
				&& rect.x < this.x + this.width + epsilon
				&& rect.y < this.y + this.height + epsilon;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join(''),
			xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this._set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key),
			internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return !!(this._owner._selection & 2);
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner._changeSelection) {
					owner._changeSelection(2, selected);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg, _dontNotify) {
		var args = arguments,
			count = args.length,
			ok = true;
		if (count >= 6) {
			this._set.apply(this, args);
		} else if (count === 1 || count === 2) {
			if (arg instanceof Matrix) {
				this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
						_dontNotify);
			} else if (Array.isArray(arg)) {
				this._set.apply(this,
						_dontNotify ? arg.concat([_dontNotify]) : arg);
			} else {
				ok = false;
			}
		} else if (!count) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok) {
			throw new Error('Unsupported matrix parameters');
		}
		return this;
	},

	set: '#initialize',

	_set: function(a, b, c, d, tx, ty, _dontNotify) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.getValues(), options, true, dictionary);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(25);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._b, this._c, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._c),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._b), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._b = this._c = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._c;
		this._ty += x * this._b + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var args = arguments,
			scale = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._b *= scale.x;
		this._c *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * c;
		this._b = cos * b + sin * d;
		this._c = -sin * a + cos * c;
		this._d = -sin * b + cos * d;
		this._tx += tx * a + ty * c;
		this._ty += tx * b + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var args = arguments,
			shear = Point.read(args),
			center = Point.read(args, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			b = this._b;
		this._a += shear.y * this._c;
		this._b += shear.y * this._d;
		this._c += shear.x * a;
		this._d += shear.x * b;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var args = arguments,
			skew = Point.read(args),
			center = Point.read(args, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	append: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * c1;
			this._c = b2 * a1 + d2 * c1;
			this._b = a2 * b1 + c2 * d1;
			this._d = b2 * b1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * c1;
			this._ty += tx2 * b1 + ty2 * d1;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	prepend: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * b1;
			this._c = a2 * c1 + b2 * d1;
			this._b = c2 * a1 + d2 * b1;
			this._d = c2 * c1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	appended: function(mx) {
		return this.clone().append(mx);
	},

	prepended: function(mx) {
		return this.clone().prepend(mx);
	},

	invert: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			this._a = d / det;
			this._b = -b / det;
			this._c = -c / det;
			this._d = a / det;
			this._tx = (c * ty - d * tx) / det;
			this._ty = (b * tx - a * ty) / det;
			res = this;
		}
		return res;
	},

	inverted: function() {
		return this.clone().invert();
	},

	concatenate: '#append',
	preConcatenate: '#prepend',
	chain: '#appended',

	_shiftless: function() {
		return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
	},

	_orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isIdentity: function() {
		return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	isInvertible: function() {
		var det = this._a * this._d - this._c * this._b;
		return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
	},

	isSingular: function() {
		return !this.isInvertible();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest._set(
				x * this._a + y * this._c + this._tx,
				x * this._b + y * this._d + this._ty,
				_dontNotify);
	},

	_transformCoordinates: function(src, dst, count) {
		for (var i = 0, max = 2 * count; i < max; i += 2) {
			var x = src[i],
				y = src[i + 1];
			dst[i] = x * this._a + y * this._c + this._tx;
			dst[i + 1] = x * this._b + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j]) {
				min[j] = val;
			} else if (val > max[j]) {
				max[j] = val;
			}
		}
		if (!dest)
			dest = new Rectangle();
		return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			res = dest._set(
					(x * d - y * c) / det,
					(y * a - x * b) / det,
					_dontNotify);
		}
		return res;
	},

	decompose: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			det = a * d - b * c,
			sqrt = Math.sqrt,
			atan2 = Math.atan2,
			degrees = 180 / Math.PI,
			rotate,
			scale,
			skew;
		if (a !== 0 || b !== 0) {
			var r = sqrt(a * a + b * b);
			rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
			scale = [r, det / r];
			skew = [atan2(a * c + b * d, r * r), 0];
		} else if (c !== 0 || d !== 0) {
			var s = sqrt(c * c + d * d);
			rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
			scale = [det / s, s];
			skew = [0, atan2(a * c + b * d, s * s)];
		} else {
			rotate = 0;
			skew = scale = [0, 0];
		}
		return {
			translation: this.getTranslation(),
			rotation: rotate * degrees,
			scaling: new Point(scale),
			skewing: new Point(skew[0] * degrees, skew[1] * degrees)
		};
	},

	getValues: function() {
		return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return this.decompose().scaling;
	},

	getRotation: function() {
		return this.decompose().rotation;
	},

	applyToContext: function(ctx) {
		if (!this.isIdentity()) {
			ctx.transform(this._a, this._b, this._c, this._d,
					this._tx, this._ty);
		}
	}
}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
	var part = Base.capitalize(key),
		prop = '_' + key;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(this.getSignedDistance(point));
	},

	getSignedDistance: function(point) {
		return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isMachineZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (!isInfinite && Numerical.isMachineZero(ccw)) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			  return  vx === 0 ? (vy > 0 ? x - px : px - x)
					: vy === 0 ? (vx < 0 ? y - py : py - y)
					: ((x - px) * vy - (y - py) * vx) / (
						vy > vx
							? vy * Math.sqrt(1 + (vx * vx) / (vy * vy))
							: vx * Math.sqrt(1 + (vy * vy) / (vx * vx))
					);
		},

		getDistance: function(px, py, vx, vy, x, y, asVector) {
			return Math.abs(
					Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',
	_compactSerialize: true,

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this._children = [];
		this._namedChildren = {};
		this._activeLayer = null;
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectionItems = {};
		this._selectionCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this._children, options, true, dictionary);
	},

	_changed: function(flags, item) {
		if (flags & 1) {
			var view = this._view;
			if (view) {
				view._needsUpdate = true;
				if (!view._requested && view._autoUpdate)
					view.requestUpdate();
			}
		}
		var changes = this._changes;
		if (changes && item) {
			var changesById = this._changesById,
				id = item._id,
				entry = changesById[id];
			if (entry) {
				entry.flags |= flags;
			} else {
				changes.push(changesById[id] = { item: item, flags: flags });
			}
		}
	},

	clear: function() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--)
			children[i].remove();
	},

	isEmpty: function() {
		return !this._children.length;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.set(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getLayers: function() {
		return this._children;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this, insert: true });
	},

	getSymbolDefinitions: function() {
		var definitions = [],
			ids = {};
		this.getItems({
			class: SymbolItem,
			match: function(item) {
				var definition = item._definition,
					id = definition._id;
				if (!ids[id]) {
					ids[id] = true;
					definitions.push(definition);
				}
				return false;
			}
		});
		return definitions;
	},

	getSymbols: 'getSymbolDefinitions',

	getSelectedItems: function() {
		var selectionItems = this._selectionItems,
			items = [];
		for (var id in selectionItems) {
			var item = selectionItems[id],
				selection = item._selection;
			if ((selection & 1) && item.isInserted()) {
				items.push(item);
			} else if (!selection) {
				this._updateSelection(item);
			}
		}
		return items;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectionItems = this._selectionItems;
		if (item._selection) {
			if (selectionItems[id] !== item) {
				this._selectionCount++;
				selectionItems[id] = item;
			}
		} else if (selectionItems[id] === item) {
			this._selectionCount--;
			delete selectionItems[id];
		}
	},

	selectAll: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectionItems = this._selectionItems;
		for (var i in selectionItems)
			selectionItems[i].setFullySelected(false);
	},

	addLayer: function(layer) {
		return this.insertLayer(undefined, layer);
	},

	insertLayer: function(index, layer) {
		if (layer instanceof Layer) {
			layer._remove(false, true);
			Base.splice(this._children, [layer], index, 0);
			layer._setProject(this, true);
			var name = layer._name;
			if (name)
				layer.setName(name);
			if (this._changes)
				layer._changed(5);
			if (!this._activeLayer)
				this._activeLayer = layer;
		} else {
			layer = null;
		}
		return layer;
	},

	_insertItem: function(index, item, _created) {
		item = this.insertLayer(index, item)
				|| (this._activeLayer || this._insertItem(undefined,
						new Layer(Item.NO_INSERT), true))
						.insertChild(index, item);
		if (_created && item.activate)
			item.activate();
		return item;
	},

	getItems: function(options) {
		return Item._getItems(this, options);
	},

	getItem: function(options) {
		return Item._getItems(this, options, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	removeOn: function(type) {
		var sets = this._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var children = this._children,
			param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].draw(ctx, param);
		}
		ctx.restore();

		if (this._selectionCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectionItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items) {
				items[id]._drawSelection(ctx, matrix, size, items, version);
			}
			ctx.restore();
		}
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = Base.set({},
					this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_name: null,
	_applyMatrix: true,
	_canApplyMatrix: true,
	_canScaleStroke: false,
	_pivot: null,
	_visible: true,
	_blendMode: 'normal',
	_opacity: 1,
	_locked: false,
	_guide: false,
	_clipMask: false,
	_selection: 0,
	_selectBounds: true,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		locked: false,
		guide: false,
		clipMask: false,
		selected: false,
		data: {}
	},
	_prioritize: ['applyMatrix']
},
new function() {
	var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
	return Base.each(handlers,
		function(name) {
			this._events[name] = {
				install: function(type) {
					this.getView()._countItemEvent(type, 1);
				},

				uninstall: function(type) {
					this.getView()._countItemEvent(type, -1);
				}
			};
		}, {
			_events: {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},

					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},

				onLoad: {},
				onError: {}
			},
			statics: {
				_itemHandlers: handlers
			}
		}
	);
}, {
	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project,
			settings = paper.settings;
		this._id = internal ? null : UID.get();
		this._parent = this._index = null;
		this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (internal || hasProps && props.insert == false
			|| !settings.insertItems && !(hasProps && props.insert === true)) {
			this._setProject(project);
		} else {
			(hasProps && props.parent || project)
					._insertItem(undefined, this, true);
		}
		if (hasProps && props !== Item.NO_INSERT) {
			this.set(props, {
				internal: true, insert: true, project: true, parent: true
			});
		}
		return hasProps;
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._symbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed = undefined;
		}
		if (flags & 16) {
			this._globalMatrix = undefined;
		}
		if (cacheParent
				&& (flags & 72)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project)
			project._changed(flags, this);
		if (symbol)
			symbol._changed(flags);
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var owner = this._getOwner();
		if (name && owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren;
			(namedChildren[name] = namedChildren[name] || []).push(this);
			if (!(name in children))
				children[name] = this;
		}
		this._name = name || undefined;
		this._changed(256);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			key = '_' + name,
			flags = {
				locked: 256,
				visible: 265
			};
		this['get' + part] = function() {
			return this[key];
		};
		this['set' + part] = function(value) {
			if (value != this[key]) {
				this[key] = value;
				this._changed(flags[name] || 257);
			}
		};
	},
{}), {
	beans: true,

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		if (selection !== this._selection) {
			this._selection = selection;
			var project = this._project;
			if (project) {
				project._updateSelection(this);
				this._changed(257);
			}
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return !!(this._selection & 1);
	},

	setSelected: function(selected) {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isFullySelected: function() {
		var children = this._children,
			selected = !!(this._selection & 1);
		if (children && selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(257);
			if (this._parent)
				this._parent._changed(2048);
		}
	},

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		var position = this._position ||
			(this._position = this._getPositionFromBounds());
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	_getPositionFromBounds: function(bounds) {
		return this._pivot
				? this._matrix._transformPoint(this._pivot)
				: (bounds || this.getBounds()).getCenter(true);
	},

	getPivot: function() {
		var pivot = this._pivot;
		return pivot
				? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
				: null;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	}
}, Base.each({
		getStrokeBounds: { stroke: true },
		getHandleBounds: { handle: true },
		getInternalBounds: { internal: true }
	},
	function(options, key) {
		this[key] = function(matrix) {
			return this.getBounds(matrix, options);
		};
	},
{
	beans: true,

	getBounds: function(matrix, options) {
		var hasMatrix = options || matrix instanceof Matrix,
			opts = Base.set({}, hasMatrix ? options : matrix,
					this._boundsOptions);
		if (!opts.stroke || this.getStrokeScaling())
			opts.cacheItem = this;
		var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
		return !arguments.length
				? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
					this, 'setBounds')
				: rect;
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			_matrix = this._matrix,
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			if (!_matrix.isInvertible()) {
				_matrix.set(_matrix._backup
						|| new Matrix().translate(_matrix.getTranslation()));
				bounds = this.getBounds();
			}
			matrix.scale(
					bounds.width !== 0 ? rect.width / bounds.width : 0,
					bounds.height !== 0 ? rect.height / bounds.height : 0);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getBounds: function(matrix, options) {
		var children = this._children;
		if (!children || !children.length)
			return new Rectangle();
		Item._updateBoundsCache(this, options.cacheItem);
		return Item._getBounds(children, matrix, options);
	},

	_getBoundsCacheKey: function(options, internal) {
		return [
			options.stroke ? 1 : 0,
			options.handle ? 1 : 0,
			internal ? 1 : 0
		].join('');
	},

	_getCachedBounds: function(matrix, options, noInternal) {
		matrix = matrix && matrix._orNullIfIdentity();
		var internal = options.internal && !noInternal,
			cacheItem = options.cacheItem,
			_matrix = internal ? null : this._matrix._orNullIfIdentity(),
			cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
				&& this._getBoundsCacheKey(options, internal),
			bounds = this._bounds;
		Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
		if (cacheKey && bounds && cacheKey in bounds) {
			var cached = bounds[cacheKey];
			return {
				rect: cached.rect.clone(),
				nonscaling: cached.nonscaling
			};
		}
		var res = this._getBounds(matrix || _matrix, options),
			rect = res.rect || res,
			style = this._style,
			nonscaling = res.nonscaling || style.hasStroke()
				&& !style.getStrokeScaling();
		if (cacheKey) {
			if (!bounds) {
				this._bounds = bounds = {};
			}
			var cached = bounds[cacheKey] = {
				rect: rect.clone(),
				nonscaling: nonscaling,
				internal: internal
			};
		}
		return {
			rect: rect,
			nonscaling: nonscaling
		};
	},

	_getStrokeMatrix: function(matrix, options) {
		var parent = this.getStrokeScaling() ? null
				: options && options.internal ? this
					: this._parent || this._symbol && this._symbol._item,
			mx = parent ? parent.getViewMatrix().invert() : matrix;
		return mx && mx._shiftless();
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent && item) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		},

		_getBounds: function(items, matrix, options) {
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2,
				nonscaling = false;
			options = options || {};
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				if (item._visible && !item.isEmpty(true)) {
					var bounds = item._getCachedBounds(
						matrix && matrix.appended(item._matrix), options, true),
						rect = bounds.rect;
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
					if (bounds.nonscaling)
						nonscaling = true;
				}
			}
			return {
				rect: isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle(),
				nonscaling: nonscaling
			};
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._applyMatrix
			? null
			: this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	getRotation: function() {
		var decomposed = this._decompose();
		return decomposed ? decomposed.rotation : 0;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			if (decomposed) {
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		}
	},

	getScaling: function() {
		var decomposed = this._decompose(),
			s = decomposed && decomposed.scaling;
		return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling && !current.equals(scaling)) {
			var rotation = this.getRotation(),
				decomposed = this._decomposed,
				matrix = new Matrix(),
				isZero = Numerical.isZero;
			if (isZero(current.x) || isZero(current.y)) {
				matrix.translate(decomposed.translation);
				if (rotation) {
					matrix.rotate(rotation);
				}
				matrix.scale(scaling.x, scaling.y);
				this._matrix.set(matrix);
			} else {
				var center = this.getPosition(true);
				matrix.translate(center);
				if (rotation)
					matrix.rotate(rotation);
				matrix.scale(scaling.x / current.x, scaling.y / current.y);
				if (rotation)
					matrix.rotate(-rotation);
				matrix.translate(center.negate());
				this.transform(matrix);
			}
			if (decomposed) {
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.set.apply(matrix, arguments);
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix;
		if (matrix) {
			var parent = this._parent;
			var parents = [];
			while (parent) {
				if (!parent._globalMatrix) {
					matrix = null;
					for (var i = 0, l = parents.length; i < l; i++) {
						parents[i]._globalMatrix = null;
					}
					break;
				}
				parents.push(parent);
				parent = parent._parent;
			}
		}
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.prepend(parent.getGlobalMatrix(true));
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getViewMatrix: function() {
		return this.getGlobalMatrix().prepend(this.getView()._matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project._view;
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	_getOwner: '#getParent',

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(options) {
		var copy = new this.constructor(Item.NO_INSERT),
			children = this._children,
			insert = Base.pick(options ? options.insert : undefined,
					options === undefined || options === true),
			deep = Base.pick(options ? options.deep : undefined, true);
		if (children)
			copy.copyAttributes(this);
		if (!children || deep)
			copy.copyContent(this);
		if (!children)
			copy.copyAttributes(this);
		if (insert)
			copy.insertAbove(this);
		var name = this._name,
			parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				orig = name,
				i = 1;
			while (children[name])
				name = orig + ' ' + (i++);
			if (name !== orig)
				copy.setName(name);
		}
		return copy;
	},

	copyContent: function(source) {
		var children = source._children;
		for (var i = 0, l = children && children.length; i < l; i++) {
			this.addChild(children[i].clone(false), true);
		}
	},

	copyAttributes: function(source, excludeMatrix) {
		this.setStyle(source._style);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (source.hasOwnProperty(key))
				this[key] = source[key];
		}
		if (!excludeMatrix)
			this._matrix.set(source._matrix, true);
		this.setApplyMatrix(source._applyMatrix);
		this.setPivot(source._pivot);
		this.setSelection(source._selection);
		var data = source._data,
			name = source._name;
		this._data = data ? Base.clone(data) : null;
		if (name)
			this.setName(name);
	},

	rasterize: function(arg0, arg1) {
		var resolution,
			insert,
			raster;
		if (Base.isPlainObject(arg0)) {
			resolution = arg0.resolution;
			insert = arg0.insert;
			raster = arg0.raster;
		} else {
			resolution = arg0;
			insert = arg1;
		}
		if (raster) {
			raster.matrix.reset(true);
		} else {
			raster = new Raster(Item.NO_INSERT);
		}
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			boundsSize = new Size(bottomRight.subtract(topLeft)),
			rasterSize = boundsSize.multiply(scale);
		raster.setSize(rasterSize, true);

		if (!rasterSize.isZero()) {
			var ctx = raster.getContext(true),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
		}
		raster.transform(
			new Matrix()
				.translate(topLeft.add(boundsSize.divide(2)))
				.scale(1 / scale)
		);
		if (insert === undefined || insert) {
			raster.insertAbove(this);
		}
		return raster;
	},

	contains: function() {
		var matrix = this._matrix;
		return (
			matrix.isInvertible() &&
			!!this._contains(matrix._inverseTransform(Point.read(arguments)))
		);
	},

	_contains: function(point) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				if (children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix, true).length > 0;
	}
},
new function() {
	function hitTest() {
		var args = arguments;
		return this._hitTest(
				Point.read(args),
				HitResult.getOptions(args));
	}

	function hitTestAll() {
		var args = arguments,
			point = Point.read(args),
			options = HitResult.getOptions(args),
			all = [];
		this._hitTest(point, new Base({ all: all }, options));
		return all;
	}

	function hitTestChildren(point, options, viewMatrix, _exclude) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				var child = children[i];
				var res = child !== _exclude && child._hitTest(point, options,
						viewMatrix);
				if (res && !options.all)
					return res;
			}
		}
		return null;
	}

	Project.inject({
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTest: hitTestChildren
	});

	return {
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTestChildren: hitTestChildren,
	};
}, {

	_hitTest: function(point, options, parentViewMatrix) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty()) {
			return null;
		}

		var matrix = this._matrix,
			viewMatrix = parentViewMatrix
					? parentViewMatrix.appended(matrix)
					: this.getGlobalMatrix().prepend(this.getView()._matrix),
			tolerance = Math.max(options.tolerance, 1e-12),
			tolerancePadding = options._tolerancePadding = new Size(
					Path._getStrokePadding(tolerance,
						matrix._shiftless().invert()));
		point = matrix._inverseTransform(point);
		if (!point || !this._children &&
			!this.getBounds({ internal: true, stroke: true, handle: true })
				.expand(tolerancePadding.multiply(2))._containsPoint(point)) {
			return null;
		}

		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this.isSelected()
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			match = options.match,
			that = this,
			bounds,
			res;

		function filter(hit) {
			if (hit && match && !match(hit))
				hit = null;
			if (hit && options.all)
				options.all.push(hit);
			return hit;
		}

		function checkPoint(type, part) {
			var pt = part ? bounds['get' + part]() : that.getPosition();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
				return new HitResult(type, that, {
					name: part ? Base.hyphenate(part) : type,
					point: pt
				});
			}
		}

		var checkPosition = options.position,
			checkCenter = options.center,
			checkBounds = options.bounds;
		if (checkSelf && this._parent
				&& (checkPosition || checkCenter || checkBounds)) {
			if (checkCenter || checkBounds) {
				bounds = this.getInternalBounds();
			}
			res = checkPosition && checkPoint('position') ||
					checkCenter && checkPoint('center', 'Center');
			if (!res && checkBounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++) {
					res = checkPoint('bounds', points[i]);
				}
			}
			res = filter(res);
		}

		if (!res) {
			res = this._hitTestChildren(point, options, viewMatrix)
				|| checkSelf
					&& filter(this._hitTestSelf(point, options, viewMatrix,
						this.getStrokeScaling() ? null
							: viewMatrix._shiftless().invert()))
				|| null;
		}
		if (res && res.point) {
			res.point = matrix.transform(res.point);
		}
		return res;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
			return true;
		} else if (type === 'function') {
			return name(this);
		} else if (name === 'match') {
			return compare(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (name === 'class') {
				if (typeof compare === 'function')
					return this instanceof compare;
				value = this._class;
			}
			if (typeof compare === 'function') {
				return !!compare(value);
			} else if (compare) {
				if (compare.test) {
					return compare.test(value);
				} else if (Base.isPlainObject(compare)) {
					return matchObject(compare, value);
				}
			}
			return Base.equals(value, compare);
		}
	},

	getItems: function(options) {
		return Item._getItems(this, options, this._matrix);
	},

	getItem: function(options) {
		return Item._getItems(this, options, this._matrix, null, true)[0]
				|| null;
	},

	statics: {
		_getItems: function _getItems(item, options, matrix, param, firstOnly) {
			if (!param) {
				var obj = typeof options === 'object' && options,
					overlapping = obj && obj.overlapping,
					inside = obj && obj.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					recursive: obj && obj.recursive !== false,
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (obj) {
					options = Base.filter({}, options, {
						recursive: true, inside: true, overlapping: true
					});
				}
			}
			var children = item._children,
				items = param.items,
				rect = param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.appended(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(rect.contains(bounds)
							|| param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(options)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				if (param.recursive !== false) {
					_getItems(child, options, childMatrix, param, firstOnly);
				}
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this ? this.addChild(res) : res;
	},

	addChild: function(item) {
		return this.insertChild(undefined, item);
	},

	insertChild: function(index, item) {
		var res = item ? this.insertChildren(index, [item]) : null;
		return res && res[0];
	},

	addChildren: function(items) {
		return this.insertChildren(this._children.length, items);
	},

	insertChildren: function(index, items) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Base.slice(items);
			var inserted = {};
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i],
					id = item && item._id;
				if (!item || inserted[id]) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
					inserted[id] = true;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i],
					name = item._name;
				item._parent = this;
				item._setProject(project, true);
				if (name)
					item.setName(name);
				if (notifySelf)
					item._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertItem: '#insertChild',

	_insertAt: function(item, offset) {
		var owner = item && item._getOwner(),
			res = item !== this && owner ? this : null;
		if (res) {
			res._remove(false, true);
			owner._insertItem(item._index + offset, res);
		}
		return res;
	},

	insertAbove: function(item) {
		return this._insertAt(item, 1);
	},

	insertBelow: function(item) {
		return this._insertAt(item, 0);
	},

	sendToBack: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(0, this) : null;
	},

	bringToFront: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(undefined, this) : null;
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	addTo: function(owner) {
		return owner._insertItem(undefined, this);
	},

	copyTo: function(owner) {
		return this.clone(false).addTo(owner);
	},

	reduce: function(options) {
		var children = this._children;
		if (children && children.length === 1) {
			var child = children[0].reduce(options);
			if (this._parent) {
				child.insertAbove(this);
				this.remove();
			} else {
				child.remove();
			}
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var owner = this._getOwner();
		if (owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[0];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var owner = this._getOwner(),
			project = this._project,
			index = this._index;
		if (this._style)
			this._style._dispose();
		if (owner) {
			if (this._name)
				this._removeNamed();
			if (index != null) {
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(owner._children, null, index, 1);
			}
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent)
				owner._changed(11, this);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(start, end) {
		if (!this._children)
			return null;
		start = start || 0;
		end = Base.pick(end, this._children.length);
		var removed = Base.splice(this._children, null, start, end - start);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function(recursively) {
		var children = this._children;
		var numChildren = children ? children.length : 0;
		if (recursively) {
			for (var i = 0; i < numChildren; i++) {
				if (!children[i].isEmpty(recursively)) {
					return false;
				}
			}
			return true;
		}
		return !numChildren;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent === item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getPosition(true)));
	};
}, {
	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	transform: function(matrix, _applyRecursively, _setApplyMatrix) {
		var _matrix = this._matrix,
			transformMatrix = matrix && !matrix.isIdentity(),
			applyMatrix = (
				_setApplyMatrix && this._canApplyMatrix ||
				this._applyMatrix && (
					transformMatrix || !_matrix.isIdentity() ||
					_applyRecursively && this._children
				)
			);
		if (!transformMatrix && !applyMatrix)
			return this;
		if (transformMatrix) {
			if (!matrix.isInvertible() && _matrix.isInvertible())
				_matrix._backup = _matrix.getValues();
			_matrix.prepend(matrix, true);
			var style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (fillColor)
				fillColor.transform(matrix);
			if (strokeColor)
				strokeColor.transform(matrix);
		}

		if (applyMatrix && (applyMatrix = this._transformContent(
				_matrix, _applyRecursively, _setApplyMatrix))) {
			var pivot = this._pivot;
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		if (transformMatrix || applyMatrix) {
			this._changed(25);
		}
		var decomp = transformMatrix && bounds && matrix.decompose();
		if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var cache = bounds[key];
				if (cache.nonscaling) {
					delete bounds[key];
				} else if (applyMatrix || !cache.internal) {
					var rect = cache.rect;
					matrix._transformBounds(rect, rect);
				}
			}
			this._bounds = bounds;
			var cached = bounds[this._getBoundsCacheKey(
				this._boundsOptions || {})];
			if (cached) {
				this._position = this._getPositionFromBounds(cached.rect);
			}
		} else if (transformMatrix && position && this._pivot) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++) {
				children[i].transform(matrix, applyRecursively, setApplyMatrix);
			}
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	}
}), {

	_setStyles: function(ctx, param, viewMatrix) {
		var style = this._style,
			matrix = this._matrix;
		if (style.hasFill()) {
			ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
		}
		if (style.hasStroke()) {
			ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
			ctx.lineWidth = style.getStrokeWidth();
			var strokeJoin = style.getStrokeJoin(),
				strokeCap = style.getStrokeCap(),
				miterLimit = style.getMiterLimit();
			if (strokeJoin)
				ctx.lineJoin = strokeJoin;
			if (strokeCap)
				ctx.lineCap = strokeCap;
			if (miterLimit)
				ctx.miterLimit = miterLimit;
			if (paper.support.nativeDash) {
				var dashArray = style.getDashArray(),
					dashOffset = style.getDashOffset();
				if (dashArray && dashArray.length) {
					if ('setLineDash' in ctx) {
						ctx.setLineDash(dashArray);
						ctx.lineDashOffset = dashOffset;
					} else {
						ctx.mozDash = dashArray;
						ctx.mozDashOffset = dashOffset;
					}
				}
			}
		}
		if (style.hasShadow()) {
			var pixelRatio = param.pixelRatio || 1,
				mx = viewMatrix._shiftless().prepend(
					new Matrix().scale(pixelRatio, pixelRatio)),
				blur = mx.transform(new Point(style.getShadowBlur(), 0)),
				offset = mx.transform(this.getShadowOffset());
			ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
			ctx.shadowBlur = blur.getLength();
			ctx.shadowOffsetX = offset.x;
			ctx.shadowOffsetY = offset.y;
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].appended(matrix);
		if (!globalMatrix.isInvertible())
			return;

		viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
				: globalMatrix;

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = Numerical.clamp(this._opacity, 0, 1),
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(viewMatrix);
			if (!bounds.width || !bounds.height) {
				matrices.pop();
				return;
			}
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.appended(matrix)
				: this._canScaleStroke && !this.getStrokeScaling(true)
					&& viewMatrix,
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform) {
			(direct ? matrix : viewMatrix).applyToContext(ctx);
		}
		if (clip) {
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, viewMatrix, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish) {
			ctx.clip(this.getFillRule());
		}
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
		var selection = this._selection,
			itemSelected = selection & 1,
			boundsSelected = selection & 2
					|| itemSelected && this._selectBounds,
			positionSelected = selection & 4;
		if (!this._drawSelected)
			itemSelected = false;
		if ((itemSelected || boundsSelected || positionSelected)
				&& this._isUpdated(updateVersion)) {
			var layer,
				color = this.getSelectedColor(true) || (layer = this.getLayer())
					&& layer.getSelectedColor(true),
				mx = matrix.appended(this.getGlobalMatrix(true)),
				half = size / 2;
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (itemSelected)
				this._drawSelected(ctx, mx, selectionItems);
			if (positionSelected) {
				var pos = this.getPosition(true),
					parent = this._parent,
					point = parent ? parent.localToGlobal(pos) : pos,
					x = point.x,
					y = point.y;
				ctx.beginPath();
				ctx.arc(x, y, half, 0, Math.PI * 2, true);
				ctx.stroke();
				var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
					start = half,
					end = size + 1;
				for (var i = 0; i < 4; i++) {
					var delta = deltas[i],
						dx = delta[0],
						dy = delta[1];
					ctx.moveTo(x + dx * start, y + dy * start);
					ctx.lineTo(x + dx * end, y + dy * end);
					ctx.stroke();
				}
			}
			if (boundsSelected) {
				var coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++) {
					ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				}
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++) {
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
				}
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(key) {
	this['removeOn' + Base.capitalize(key)] = function() {
		var hash = {};
		hash[key] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}), {
	tween: function(from, to, options) {
		if (!options) {
			options = to;
			to = from;
			from = null;
			if (!options) {
				options = to;
				to = null;
			}
		}
		var easing = options && options.easing,
			start = options && options.start,
			duration = options != null && (
				typeof options === 'number' ? options : options.duration
			),
			tween = new Tween(this, from, to, duration, easing, start);
		function onFrame(event) {
			tween._handleFrame(event.time * 1000);
			if (!tween.running) {
				this.off('frame', onFrame);
			}
		}
		if (duration) {
			this.on('frame', onFrame);
		}
		return tween;
	},

	tweenTo: function(to, options) {
		return this.tween(null, to, options);
	},

	tweenFrom: function(from, options) {
		return this.tween(from, null, options);
	}
});

var Group = Item.extend({
	_class: 'Group',
	_selectBounds: false,
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 2050) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i]._clipMask) {
					clipItem = children[i];
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_getBounds: function _getBounds(matrix, options) {
		var clipItem = this._getClipItem();
		return clipItem
			? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),
				Base.set({}, options, { stroke: false }))
			: _getBounds.base.call(this, matrix, options);
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		var clipItem = this._getClipItem();
		return (!clipItem || clipItem.contains(point))
				&& _hitTestChildren.base.call(this, point, options, viewMatrix,
					clipItem);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem();
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			ctx.beginPath();
			param.dontStart = param.dontFinish = true;
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var item = children[i];
			if (item !== clipItem)
				item.draw(ctx, param);
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer() {
		Group.apply(this, arguments);
	},

	_getOwner: function() {
		return this._parent || this._index != null && this._project;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_hitTestSelf: function() {
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_canScaleStroke: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props, point) {
		this._initialize(props, point);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	copyContent: function(source) {
		this.setType(source._type);
		this.setSize(source._size);
		this.setRadius(source._radius);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				this._radius.set(Size.min(this._radius, size.divide(2).abs()));
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius._set(width / 2, height / 2);
			}
			this._size._set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size._set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size);
				} else if (type === 'ellipse') {
					this._size._set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.copyAttributes(this);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		if (insert === undefined || insert)
			path.insertAbove(this);
		return path;
	},

	toShape: '#clone',

	_asPathItem: function() {
		return this.toPath(false);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx, param, viewMatrix);
			if (hasFill) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0),
			style = this._style,
			strokeWidth = options.stroke && style.hasStroke()
					&& style.getStrokeWidth();
		if (matrix)
			rect = matrix._transformBounds(rect);
		return strokeWidth
				? rect.expand(Path._getStrokePadding(strokeWidth,
					this._getStrokeMatrix(matrix, options)))
				: rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var q = 1; q <= 4; q++) {
				var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(
							expand ? corner.add(dir.multiply(expand)) : corner,
							center);
				if (rect.contains(point))
					return { point: center, quadrant: q };
			}
		}
	}

	function isOnEllipseStroke(point, radius, padding, quadrant) {
		var vector = point.divide(radius);
		return (!quadrant || vector.isInQuadrant(quadrant)) &&
				vector.subtract(vector.normalize()).multiply(radius)
					.divide(padding).length <= 1;
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center.point).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
				strokeMatrix) {
			var hit = false,
				style = this._style,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill();
			if (hitStroke || hitFill) {
				var type = this._type,
					radius = this._radius,
					strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
					strokePadding = options._tolerancePadding.add(
						Path._getStrokePadding(strokeRadius,
							!style.getStrokeScaling() && strokeMatrix));
				if (type === 'rectangle') {
					var padding = strokePadding.multiply(2),
						center = getCornerCenter(this, point, padding);
					if (center) {
						hit = isOnEllipseStroke(point.subtract(center.point),
								radius, strokePadding, center.quadrant);
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(padding),
							inner = rect.expand(padding.negate());
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					hit = isOnEllipseStroke(point, radius, strokePadding);
				}
			}
			return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = Base.create(Shape.prototype);
		item._type = type;
		item._size = size;
		item._radius = radius;
		item._initialize(Base.getNamed(args), point);
		return item;
	}

	return {
		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.min(Size.readNamed(args, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, args);
		},

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, args);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: false, handle: false },
	_serializeFields: {
		crossOrigin: null,
		source: null
	},
	_prioritize: ['crossOrigin'],
	_smoothing: 'low',
	beans: true,

	initialize: function Raster(source, position) {
		if (!this._initialize(source,
				position !== undefined && Point.read(arguments))) {
			var image,
				type = typeof source,
				object = type === 'string'
					? document.getElementById(source)
					: type  === 'object'
						? source
						: null;
			if (object && object !== Item.NO_INSERT) {
				if (object.getContext || object.naturalHeight != null) {
					image = object;
				} else if (object) {
					var size = Size.read(arguments);
					if (!size.isZero()) {
						image = CanvasProvider.getCanvas(size);
					}
				}
			}
			if (image) {
				this.setImage(image);
			} else {
				this.setSource(source);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	copyContent: function(source) {
		var image = source._image,
			canvas = source._canvas;
		if (image) {
			this._setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(source._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			this._setImage(copyCanvas);
		}
		this._crossOrigin = source._crossOrigin;
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function(_size, _clear) {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = !_clear && this.getElement();
				this._setImage(CanvasProvider.getCanvas(size));
				if (element) {
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
				}
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		} else if (_clear) {
			this.clear();
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	getLoaded: function() {
		return this._loaded;
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		var that = this;

		function emit(event) {
			var view = that.getView(),
				type = event && event.type || 'load';
			if (view && that.responds(type)) {
				paper = view._scope;
				that.emit(type, new Event(event));
			}
		}

		this._setImage(image);
		if (this._loaded) {
			setTimeout(emit, 0);
		} else if (image) {
			DomEvent.add(image, {
				load: function(event) {
					that._setImage(image);
					emit(event);
				},
				error: emit
			});
		}
	},

	_setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = !!(image && image.src && image.complete);
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(1033);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(_change) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (_change) {
			this._image = null;
			this._changed(1025);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		var image = this._image;
		return image && image.src || this.toDataURL();
	},

	setSource: function(src) {
		var image = new self.Image(),
			crossOrigin = this._crossOrigin;
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (src)
			image.src = src;
		this.setImage(image);
	},

	getCrossOrigin: function() {
		var image = this._image;
		return image && image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		var image = this._image;
		if (image)
			image.crossOrigin = crossOrigin;
	},

	getSmoothing: function() {
		return this._smoothing;
	},

	setSmoothing: function(smoothing) {
		this._smoothing = typeof smoothing === 'string'
			? smoothing
			: smoothing ? 'low' : 'off';
		this._changed(257);
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster._setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.prepend(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var image = this._image,
			src = image && image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (typeof object === 'object') {
			if ('width' in object) {
				bounds = new Rectangle(object);
			} else if ('x' in object) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
		}
		if (!bounds)
			return null;
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var args = arguments,
			point = Point.read(args),
			color = Color.read(args),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	clear: function() {
		var size = this._size;
		this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx, param, viewMatrix) {
		var element = this.getElement();
		if (element && element.width > 0 && element.height > 0) {
			ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);

			this._setStyles(ctx, param, viewMatrix);

			var smoothing = this._smoothing,
				disabled = smoothing === 'off';
			DomElement.setPrefixed(
				ctx,
				disabled ? 'imageSmoothingEnabled' : 'imageSmoothingQuality',
				disabled ? false : smoothing
			);

			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var SymbolItem = Item.extend({
	_class: 'SymbolItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: true },
	_serializeFields: {
		symbol: null
	},

	initialize: function SymbolItem(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setDefinition(arg0 instanceof SymbolDefinition ?
					arg0 : new SymbolDefinition(arg0));
	},

	_equals: function(item) {
		return this._definition === item._definition;
	},

	copyContent: function(source) {
		this.setDefinition(source._definition);
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(definition) {
		this._definition = definition;
		this._changed(9);
	},

	getSymbol: '#getDefinition',
	setSymbol: '#setDefinition',

	isEmpty: function() {
		return this._definition._item.isEmpty();
	},

	_getBounds: function(matrix, options) {
		var item = this._definition._item;
		return item._getCachedBounds(item._matrix.prepended(matrix), options);
	},

	_hitTestSelf: function(point, options, viewMatrix) {
		var opts = options.extend({ all: false });
		var res = this._definition._item._hitTest(point, opts, viewMatrix);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this._definition._item.draw(ctx, param);
	}

});

var SymbolDefinition = Base.extend({
	_class: 'SymbolDefinition',

	initialize: function SymbolDefinition(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		if (item)
			this.setItem(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._item],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8)
			Item._clearBoundsCache(this);
		if (flags & 1)
			this.project._changed(flags);
	},

	getItem: function() {
		return this._item;
	},

	setItem: function(item, _dontCenter) {
		if (item._symbol)
			item = item.clone();
		if (this._item)
			this._item._symbol = null;
		this._item = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._symbol = this;
		this._changed(9);
	},

	getDefinition: '#getItem',
	setDefinition: '#setItem',

	place: function(position) {
		return new SymbolItem(this, position);
	},

	clone: function() {
		return new SymbolDefinition(this._item.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this._item.equals(symbol._item)
				|| false;
	}
});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values)
			this.inject(values);
	},

	statics: {
		getOptions: function(args) {
			var options = args && Base.read(args);
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				position: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,
	_selection: 0,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut, selection;
		if (count > 0) {
			if (arg0 == null || typeof arg0 === 'object') {
				if (count === 1 && arg0 && 'point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
					selection = arg0.selection;
				} else {
					point = arg0;
					handleIn = arg1;
					handleOut = arg2;
					selection = arg3;
				}
			} else {
				point = [ arg0, arg1 ];
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
		if (selection)
			this.setSelection(selection);
	},

	_serialize: function(options, dictionary) {
		var point = this._point,
			selection = this._selection,
			obj = selection || this.hasHandles()
					? [point, this._handleIn, this._handleOut]
					: point;
		if (selection)
			obj.push(selection);
		return Base.serialize(obj, options, true, dictionary);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(41);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		this._point.set(Point.read(arguments));
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		this._handleIn.set(Point.read(arguments));
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		this._handleOut.set(Point.read(arguments));
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	isSmooth: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut;
		return !handleIn.isZero() && !handleOut.isZero()
				&& handleIn.isCollinear(handleOut);
	},

	clearHandles: function() {
		this._handleIn._set(0, 0);
		this._handleOut._set(0, 0);
	},

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		var oldSelection = this._selection,
			path = this._path;
		this._selection = selection = selection || 0;
		if (path && selection !== oldSelection) {
			path._updateSelection(this, oldSelection, selection);
			path._changed(257);
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		return !!(this._selection & 7);
	},

	setSelected: function(selected) {
		this._changeSelection(7, selected);
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	smooth: function(options, _first, _last) {
		var opts = options || {},
			type = opts.type,
			factor = opts.factor,
			prev = this.getPrevious(),
			next = this.getNext(),
			p0 = (prev || this)._point,
			p1 = this._point,
			p2 = (next || this)._point,
			d1 = p0.getDistance(p1),
			d2 = p1.getDistance(p2);
		if (!type || type === 'catmull-rom') {
			var a = factor === undefined ? 0.5 : factor,
				d1_a = Math.pow(d1, a),
				d1_2a = d1_a * d1_a,
				d2_a = Math.pow(d2, a),
				d2_2a = d2_a * d2_a;
			if (!_first && prev) {
				var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
					N = 3 * d2_a * (d2_a + d1_a);
				this.setHandleIn(N !== 0
					? new Point(
						(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
						(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
					: new Point());
			}
			if (!_last && next) {
				var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
					N = 3 * d1_a * (d1_a + d2_a);
				this.setHandleOut(N !== 0
					? new Point(
						(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
						(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
					: new Point());
			}
		} else if (type === 'geometric') {
			if (prev && next) {
				var vector = p0.subtract(p2),
					t = factor === undefined ? 0.4 : factor,
					k = t * d1 / (d1 + d2);
				if (!_first)
					this.setHandleIn(vector.multiply(k));
				if (!_last)
					this.setHandleOut(vector.multiply(k - t));
			}
		} else {
			throw new Error('Smoothing method \'' + type + '\' not supported.');
		}
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return !this._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			tmp = handleIn.clone();
		handleIn.set(handleOut);
		handleOut.set(tmp);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(from, to, factor) {
		var u = 1 - factor,
			v = factor,
			point1 = from._point,
			point2 = to._point,
			handleIn1 = from._handleIn,
			handleIn2 = to._handleIn,
			handleOut2 = to._handleOut,
			handleOut1 = from._handleOut;
		this._point._set(
				u * point1._x + v * point2._x,
				u * point1._y + v * point2._y, true);
		this._handleIn._set(
				u * handleIn1._x + v * handleIn2._x,
				u * handleIn1._y + v * handleIn2._y, true);
		this._handleOut._set(
				u * handleOut1._x + v * handleOut2._x,
				u * handleOut1._y + v * handleOut2._y, true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y,
			selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	_set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this._x) && isZero(this._y);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		var owner = this._owner;
		return this === owner._point ? 1
			: this === owner._handleIn ? 2
			: this === owner._handleOut ? 4
			: 0;
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	beans: true,

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (!count) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true, dictionary);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	classify: function() {
		return Curve.classify(this.getValues());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		this._segment1._point.set(Point.read(arguments));
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		this._segment2._point.set(Point.read(arguments));
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		this._segment1._handleOut.set(Point.read(arguments));
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		this._segment2._handleIn.set(Point.read(arguments));
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return !this._segment1._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	}
}, {
	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	divideAt: function(location) {
		return this.divideAtTime(location && location.curve === this
				? location.time : this.getTimeAt(location));
	},

	divideAtTime: function(time, _setHandles) {
		var tMin = 1e-8,
			tMax = 1 - tMin,
			res = null;
		if (time >= tMin && time <= tMax) {
			var parts = Curve.subdivide(this.getValues(), time),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				seg1 = this._segment1,
				seg2 = this._segment2,
				path = this._path;
			if (setHandles) {
				seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
				seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(seg1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				this._changed();
				res = new Curve(segment, seg2);
			}
		}
		return res;
	},

	splitAt: function(location) {
		var path = this._path;
		return path ? path.splitAt(location) : null;
	},

	splitAtTime: function(time) {
		return this.splitAt(this.getLocationAtTime(time));
	},

	divide: function(offset, isTime) {
		return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	split: function(offset, isTime) {
		return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut._set(0, 0);
		this._segment2._handleIn._set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix, straight) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			x1 = p1.x, y1 = p1.y,
			x2 = p2.x, y2 = p2.y,
			values = straight
				? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
				: [
					x1, y1,
					x1 + h1._x, y1 + h1._y,
					x2 + h2._x, y2 + h2._y,
					x2, y2
				];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
			x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
			x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
			x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
			x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
			x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
		return [
			[x0, y0, x4, y4, x7, y7, x9, y9],
			[x9, y9, x8, y8, x6, y6, x3, y3]
		];
	},

	getMonoCurves: function(v, dir) {
		var curves = [],
			io = dir ? 0 : 1,
			o0 = v[io + 0],
			o1 = v[io + 2],
			o2 = v[io + 4],
			o3 = v[io + 6];
		if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
				|| Curve.isStraight(v)) {
			curves.push(v);
		} else {
			var a = 3 * (o1 - o2) - o0 + o3,
				b = 2 * (o0 + o2) - 4 * o1,
				c = o1 - o0,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [],
				n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
			if (!n) {
				curves.push(v);
			} else {
				roots.sort();
				var t = roots[0],
					parts = Curve.subdivide(v, t);
				curves.push(parts[0]);
				if (n > 1) {
					t = (roots[1] - t) / (1 - t);
					parts = Curve.subdivide(parts[1], t);
					curves.push(parts[0]);
				}
				curves.push(parts[1]);
			}
		}
		return curves;
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var v0 = v[coord],
			v1 = v[coord + 2],
			v2 = v[coord + 4],
			v3 = v[coord + 6],
			res = 0;
		if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
				v0 > val && v3 > val && v1 > val && v2 > val)) {
			var c = 3 * (v1 - v0),
				b = 3 * (v2 - v1) - c,
				a = v3 - v0 - c - b;
			res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
		}
		return res;
	},

	getTimeOf: function(v, point) {
		var p0 = new Point(v[0], v[1]),
			p3 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			geomEpsilon = 1e-7,
			t = point.isClose(p0, epsilon) ? 0
			  : point.isClose(p3, epsilon) ? 1
			  : null;
		if (t === null) {
			var coords = [point.x, point.y],
				roots = [];
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					var u = roots[i];
					if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
						return u;
				}
			}
		}
		return point.isClose(p0, geomEpsilon) ? 0
			 : point.isClose(p3, geomEpsilon) ? 1
			 : null;
	},

	getNearestTime: function(v, point) {
		if (Curve.isStraight(v)) {
			var x0 = v[0], y0 = v[1],
				x3 = v[6], y3 = v[7],
				vx = x3 - x0, vy = y3 - y0,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getTimeOf(v,
					new Point(x0 + u * vx, y0 + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 1e-8) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	isFlatEnough: function(v, flatness) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			ux = 3 * x1 - 2 * x0 - x3,
			uy = 3 * y1 - 2 * y0 - y3,
			vx = 3 * x2 - 2 * x3 - x0,
			vy = 3 * y2 - 2 * y3 - y0;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				<= 16 * flatness * flatness;
	},

	getArea: function(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
				+ y1 * (x0 - x2) - x1 * (y0 - y2)
				+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}

		padding /= 2;
		var minPad = min[coord] + padding,
			maxPad = max[coord] - padding;
		if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
				v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
			if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
				add(v0, 0);
				add(v3, 0);
			} else {
				var a = 3 * (v1 - v2) - v0 + v3,
					b = 2 * (v0 + v2) - 4 * v1,
					c = v1 - v0,
					count = Numerical.solveQuadratic(a, b, c, roots),
					tMin = 1e-8,
					tMax = 1 - tMin;
				add(v3, 0);
				for (var i = 0; i < count; i++) {
					var t = roots[i],
						u = 1 - t;
					if (tMin <= t && t <= tMax)
						add(u * u * u * v0
							+ 3 * u * u * t * v1
							+ 3 * u * t * t * v2
							+ t * t * t * v3,
							padding);
				}
			}
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false, this._path);
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(p1, h1, h2, p2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else {
			var v = p2.subtract(p1);
			if (v.isZero()) {
				return false;
			} else if (v.isCollinear(h1) && v.isCollinear(h2)) {
				var l = new Line(p1, p2),
					epsilon = 1e-7;
				if (l.getDistance(p1.add(h1)) < epsilon &&
					l.getDistance(p2.add(h2)) < epsilon) {
					var div = v.dot(v),
						s1 = v.dot(h1) / div,
						s2 = v.dot(h2) / div;
					return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
				}
			}
		}
		return false;
	},

	isLinear: function(p1, h1, h2, p2) {
		var third = p2.subtract(p1).divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function(epsilon) {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
				epsilon);
	};

	this.statics[name] = function(v, epsilon) {
		var x0 = v[0], y0 = v[1],
			x3 = v[6], y3 = v[7];
		return test(
				new Point(x0, y0),
				new Point(v[2] - x0, v[3] - y0),
				new Point(v[4] - x3, v[5] - y3),
				new Point(x3, y3), epsilon);
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	hasLength: function(epsilon) {
		return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
				&& this.getLength() > (epsilon || 0);
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
				< 1e-8;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
				< 1e-8;
	}
}), {
	beans: false,

	getLocationAt: function(offset, _isTime) {
		return this.getLocationAtTime(
				_isTime ? offset : this.getTimeAt(offset));
	},

	getLocationAtTime: function(t) {
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getTimeAt: function(offset, start) {
		return Curve.getTimeAt(this.getValues(), offset, start);
	},

	getParameterAt: '#getTimeAt',

	getTimesWithTangent: function () {
		var tangent = Point.read(arguments);
		return tangent.isZero()
				? []
				: Curve.getTimesWithTangent(this.getValues(), tangent);
	},

	getOffsetAtTime: function(t) {
		return this.getPartLength(0, t);
	},

	getLocationOf: function() {
		return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getTimeOf: function() {
		return Curve.getTimeOf(this.getValues(), Point.read(arguments));
	},

	getParameterOf: '#getTimeOf',

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestTime(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(location, _isTime) {
				var values = this.getValues();
				return Curve[name](values, _isTime ? location
						: Curve.getTimeAt(values, location));
			};

			this[name + 'AtTime'] = function(time) {
				return Curve[name](this.getValues(), time);
			};
		}, {
			statics: {
				_evaluateMethods: methods
			}
		}
	);
},
new function() {

	function getLengthIntegrand(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],

			ax = 9 * (x1 - x2) + 3 * (x3 - x0),
			bx = 6 * (x0 + x2) - 12 * x1,
			cx = 3 * (x1 - x0),

			ay = 9 * (y1 - y2) + 3 * (y3 - y0),
			by = 6 * (y0 + y2) - 12 * y1,
			cy = 3 * (y1 - y0);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			isZero = Numerical.isZero;
		if (isZero(x1 - x0) && isZero(y1 - y0)) {
			x1 = x0;
			y1 = y0;
		}
		if (isZero(x2 - x3) && isZero(y2 - y3)) {
			x2 = x3;
			y2 = y3;
		}
		var cx = 3 * (x1 - x0),
			bx = 3 * (x2 - x1) - cx,
			ax = x3 - x0 - cx - bx,
			cy = 3 * (y1 - y0),
			by = 3 * (y2 - y1) - cy,
			ay = y3 - y0 - cy - by,
			x, y;
		if (type === 0) {
			x = t === 0 ? x0 : t === 1 ? x3
					: ((ax * t + bx) * t + cx) * t + x0;
			y = t === 0 ? y0 : t === 1 ? y3
					: ((ay * t + by) * t + cy) * t + y0;
		} else {
			var tMin = 1e-8,
				tMax = 1 - tMin;
			if (t < tMin) {
				x = cx;
				y = cy;
			} else if (t > tMax) {
				x = 3 * (x3 - x2);
				y = 3 * (y3 - y2);
			} else {
				x = (3 * ax * t + 2 * bx) * t + cx;
				y = (3 * ay * t + 2 * by) * t + cy;
			}
			if (normalized) {
				if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
					x = x2 - x1;
					y = y2 - y1;
				}
				var len = Math.sqrt(x * x + y * y);
				if (len) {
					x /= len;
					y /= len;
				}
			}
			if (type === 3) {
				var x2 = 6 * ax * t + 2 * bx,
					y2 = 6 * ay * t + 2 * by,
					d = Math.pow(x * x + y * y, 3 / 2);
				x = d !== 0 ? (x * y2 - y * x2) / d : 0;
				y = 0;
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		classify: function(v) {

			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
				a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
				a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
				d3 = 3 * a3,
				d2 = d3 - a2,
				d1 = d2 - a2 + a1,
				l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
				s = l !== 0 ? 1 / l : 0,
				isZero = Numerical.isZero,
				serpentine = 'serpentine';
			d1 *= s;
			d2 *= s;
			d3 *= s;

			function type(type, t1, t2) {
				var hasRoots = t1 !== undefined,
					t1Ok = hasRoots && t1 > 0 && t1 < 1,
					t2Ok = hasRoots && t2 > 0 && t2 < 1;
				if (hasRoots && (!(t1Ok || t2Ok)
						|| type === 'loop' && !(t1Ok && t2Ok))) {
					type = 'arch';
					t1Ok = t2Ok = false;
				}
				return {
					type: type,
					roots: t1Ok || t2Ok
							? t1Ok && t2Ok
								? t1 < t2 ? [t1, t2] : [t2, t1]
								: [t1Ok ? t1 : t2]
							: null
				};
			}

			if (isZero(d1)) {
				return isZero(d2)
						? type(isZero(d3) ? 'line' : 'quadratic')
						: type(serpentine, d3 / (3 * d2));
			}
			var d = 3 * d2 * d2 - 4 * d1 * d3;
			if (isZero(d)) {
				return type('cusp', d2 / (2 * d1));
			}
			var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
				f2 = 2 * d1;
			return type(d > 0 ? serpentine : 'loop',
					(d2 + f1) / f2,
					(d2 - f1) / f2);
		},

		getLength: function(v, a, b, ds) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (Curve.isStraight(v)) {
				var c = v;
				if (b < 1) {
					c = Curve.subdivide(c, b)[0];
					a /= b;
				}
				if (a > 0) {
					c = Curve.subdivide(c, a)[1];
				}
				var dx = c[6] - c[0],
					dy = c[7] - c[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
					getIterations(a, b));
		},

		getTimeAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0;
			if (offset === 0)
				return start;
			var abs = Math.abs,
				epsilon = 1e-12,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Curve.getLength(v, a, b, ds),
				diff = abs(offset) - rangeLength;
			if (abs(diff) < epsilon) {
				return forward ? b : a;
			} else if (diff > epsilon) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		},

		getPeaks: function(v) {
			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				ax =     -x0 + 3 * x1 - 3 * x2 + x3,
				bx =  3 * x0 - 6 * x1 + 3 * x2,
				cx = -3 * x0 + 3 * x1,
				ay =     -y0 + 3 * y1 - 3 * y2 + y3,
				by =  3 * y0 - 6 * y1 + 3 * y2,
				cy = -3 * y0 + 3 * y1,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [];
			Numerical.solveCubic(
					9 * (ax * ax + ay * ay),
					9 * (ax * bx + by * ay),
					2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
					(cx * bx + by * cy),
					roots, tMin, tMax);
			return roots.sort();
		}
	}};
},
new function() {

	function addLocation(locations, include, c1, t1, c2, t2, overlap) {
		var excludeStart = !overlap && c1.getPrevious() === c2,
			excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
			t1 <= (excludeEnd ? tMax : 1)) {
			if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
				t2 <= (excludeStart ? tMax : 1)) {
				var loc1 = new CurveLocation(c1, t1, null, overlap),
					loc2 = new CurveLocation(c2, t2, null, overlap);
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc1)) {
					CurveLocation.insert(locations, loc1, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
			recursion, calls, tMin, tMax, uMin, uMax) {
		if (++calls >= 4096 || ++recursion >= 40)
			return calls;
		var fatLineEpsilon = 1e-9,
			q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if (d1 === 0 && d2 === 0
				&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
			|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
			|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return calls;
		var tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
			var t = (tMinNew + tMaxNew) / 2,
				u = (uMin + uMax) / 2;
			addLocation(locations, include,
					flip ? c2 : c1, flip ? u : t,
					flip ? c1 : c2, flip ? t : u);
		} else {
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			var uDiff = uMax - uMin;
			if (tMaxClip - tMinClip > 0.8) {
				if (tMaxNew - tMinNew > uDiff) {
					var parts = Curve.subdivide(v1, 0.5),
						t = (tMinNew + tMaxNew) / 2;
					calls = addCurveIntersections(
							v2, parts[0], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, t);
					calls = addCurveIntersections(
							v2, parts[1], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, t, tMaxNew);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						u = (uMin + uMax) / 2;
					calls = addCurveIntersections(
							parts[0], v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, u, tMinNew, tMaxNew);
					calls = addCurveIntersections(
							parts[1], v1, c2, c1, locations, include, !flip,
							recursion, calls, u, uMax, tMinNew, tMaxNew);
				}
			} else {
				if (uDiff === 0 || uDiff >= fatLineEpsilon) {
					calls = addCurveIntersections(
							v2, v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, tMaxNew);
				} else {
					calls = addCurveIntersections(
							v1, v2, c1, c2, locations, include, flip,
							recursion, calls, tMinNew, tMaxNew, uMin, uMax);
				}
			}
		}
		return calls;
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= 0.5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function getCurveLineIntersections(v, px, py, vx, vy) {
		var isZero = Numerical.isZero;
		if (isZero(vx) && isZero(vy)) {
			var t = Curve.getTimeOf(v, new Point(px, py));
			return t === null ? [] : [t];
		}
		var angle = Math.atan2(-vy, vx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rv = [],
			roots = [];
		for (var i = 0; i < 8; i += 2) {
			var x = v[i] - px,
				y = v[i + 1] - py;
			rv.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		Curve.solveCubic(rv, 1, 0, roots, 0, 1);
		return roots;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
			flip) {
		var x1 = v2[0], y1 = v2[1],
			x2 = v2[6], y2 = v2[7],
			roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
		for (var i = 0, l = roots.length; i < l; i++) {
			var t1 = roots[i],
				p1 = Curve.getPoint(v1, t1),
				t2 = Curve.getTimeOf(v2, p1);
			if (t2 !== null) {
				addLocation(locations, include,
						flip ? c2 : c1, flip ? t2 : t1,
						flip ? c1 : c2, flip ? t1 : t2);
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, include) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, include,
					c1, Curve.getTimeOf(v1, pt),
					c2, Curve.getTimeOf(v2, pt));
		}
	}

	function getCurveIntersections(v1, v2, c1, c2, locations, include) {
		var epsilon = 1e-12,
			min = Math.min,
			max = Math.max;

		if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
			min(v2[0], v2[2], v2[4], v2[6]) &&
			min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
			max(v2[0], v2[2], v2[4], v2[6]) &&
			max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
			min(v2[1], v2[3], v2[5], v2[7]) &&
			min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
			max(v2[1], v2[3], v2[5], v2[7])) {
			var overlaps = getOverlaps(v1, v2);
			if (overlaps) {
				for (var i = 0; i < 2; i++) {
					var overlap = overlaps[i];
					addLocation(locations, include,
							c1, overlap[0],
							c2, overlap[1], true);
				}
			} else {
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					flip = straight1 && !straight2,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							flip ? v2 : v1, flip ? v1 : v2,
							flip ? c2 : c1, flip ? c1 : c2,
							locations, include, flip,
							0, 0, 0, 1, 0, 1);
				if (!straight || locations.length === before) {
					for (var i = 0; i < 4; i++) {
						var t1 = i >> 1,
							t2 = i & 1,
							i1 = t1 * 6,
							i2 = t2 * 6,
							p1 = new Point(v1[i1], v1[i1 + 1]),
							p2 = new Point(v2[i2], v2[i2 + 1]);
						if (p1.isClose(p2, epsilon)) {
							addLocation(locations, include,
									c1, t1,
									c2, t2);
						}
					}
				}
			}
		}
		return locations;
	}

	function getSelfIntersection(v1, c1, locations, include) {
		var info = Curve.classify(v1);
		if (info.type === 'loop') {
			var roots = info.roots;
			addLocation(locations, include,
					c1, roots[0],
					c1, roots[1]);
		}
	  return locations;
	}

	function getIntersections(curves1, curves2, include, matrix1, matrix2,
			_returnFirst) {
		var epsilon = 1e-7,
			self = !curves2;
		if (self)
			curves2 = curves1;
		var length1 = curves1.length,
			length2 = curves2.length,
			values1 = new Array(length1),
			values2 = self ? values1 : new Array(length2),
			locations = [];

		for (var i = 0; i < length1; i++) {
			values1[i] = curves1[i].getValues(matrix1);
		}
		if (!self) {
			for (var i = 0; i < length2; i++) {
				values2[i] = curves2[i].getValues(matrix2);
			}
		}
		var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(
				values1, values2, epsilon);
		for (var index1 = 0; index1 < length1; index1++) {
			var curve1 = curves1[index1],
				v1 = values1[index1];
			if (self) {
				getSelfIntersection(v1, curve1, locations, include);
			}
			var collisions1 = boundsCollisions[index1];
			if (collisions1) {
				for (var j = 0; j < collisions1.length; j++) {
					if (_returnFirst && locations.length)
						return locations;
					var index2 = collisions1[j];
					if (!self || index2 > index1) {
						var curve2 = curves2[index2],
							v2 = values2[index2];
						getCurveIntersections(
								v1, v2, curve1, curve2, locations, include);
					}
				}
			}
		}
		return locations;
	}

	function getOverlaps(v1, v2) {

		function getSquaredLineLength(v) {
			var x = v[6] - v[0],
				y = v[7] - v[1];
			return x * x + y * y;
		}

		var abs = Math.abs,
			getDistance = Line.getDistance,
			timeEpsilon = 1e-8,
			geomEpsilon = 1e-7,
			straight1 = Curve.isStraight(v1),
			straight2 = Curve.isStraight(v2),
			straightBoth = straight1 && straight2,
			flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
			l1 = flip ? v2 : v1,
			l2 = flip ? v1 : v2,
			px = l1[0], py = l1[1],
			vx = l1[6] - px, vy = l1[7] - py;
		if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
			getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
			if (!straightBoth &&
				getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
				straight1 = straight2 = straightBoth = true;
			}
		} else if (straightBoth) {
			return null;
		}
		if (straight1 ^ straight2) {
			return null;
		}

		var v = [v1, v2],
			pairs = [];
		for (var i = 0; i < 4 && pairs.length < 2; i++) {
			var i1 = i & 1,
				i2 = i1 ^ 1,
				t1 = i >> 1,
				t2 = Curve.getTimeOf(v[i1], new Point(
					v[i2][t1 ? 6 : 0],
					v[i2][t1 ? 7 : 1]));
			if (t2 != null) {
				var pair = i1 ? [t1, t2] : [t2, t1];
				if (!pairs.length ||
					abs(pair[0] - pairs[0][0]) > timeEpsilon &&
					abs(pair[1] - pairs[0][1]) > timeEpsilon) {
					pairs.push(pair);
				}
			}
			if (i > 2 && !pairs.length)
				break;
		}
		if (pairs.length !== 2) {
			pairs = null;
		} else if (!straightBoth) {
			var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
				o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
			if (abs(o2[2] - o1[2]) > geomEpsilon ||
				abs(o2[3] - o1[3]) > geomEpsilon ||
				abs(o2[4] - o1[4]) > geomEpsilon ||
				abs(o2[5] - o1[5]) > geomEpsilon)
				pairs = null;
		}
		return pairs;
	}

	function getTimesWithTangent(v, tangent) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			normalized = tangent.normalize(),
			tx = normalized.x,
			ty = normalized.y,
			ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
			ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
			bx = 6 * x2 - 12 * x1 + 6 * x0,
			by = 6 * y2 - 12 * y1 + 6 * y0,
			cx = 3 * x1 - 3 * x0,
			cy = 3 * y1 - 3 * y0,
			den = 2 * ax * ty - 2 * ay * tx,
			times = [];
		if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
			var num = ax * cy - ay * cx,
				den = ax * by - ay * bx;
			if (den != 0) {
				var t = -num / den;
				if (t >= 0 && t <= 1) times.push(t);
			}
		} else {
			var delta = (bx * bx - 4 * ax * cx) * ty * ty +
				(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +
				(by * by - 4 * ay * cy) * tx * tx,
				k = bx * ty - by * tx;
			if (delta >= 0 && den != 0) {
				var d = Math.sqrt(delta),
					t0 = -(k + d) / den,
					t1 = (-k + d) / den;
				if (t0 >= 0 && t0 <= 1) times.push(t0);
				if (t1 >= 0 && t1 <= 1) times.push(t1);
			}
		}
		return times;
	}

	return {
		getIntersections: function(curve) {
			var v1 = this.getValues(),
				v2 = curve && curve !== this && curve.getValues();
			return v2 ? getCurveIntersections(v1, v2, this, curve, [])
					  : getSelfIntersection(v1, this, []);
		},

		statics: {
			getOverlaps: getOverlaps,
			getIntersections: getIntersections,
			getCurveLineIntersections: getCurveLineIntersections,
			getTimesWithTangent: getTimesWithTangent
		}
	};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',

	initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
		if (time >= 0.99999999) {
			var next = curve.getNext();
			if (next) {
				time = 0;
				curve = next;
			}
		}
		this._setCurve(curve);
		this._time = time;
		this._point = point || curve.getPointAtTime(time);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._previous = null;
	},

	_setPath: function(path) {
		this._path = path;
		this._version = path ? path._version : 0;
	},

	_setCurve: function(curve) {
		this._setPath(curve._path);
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		var curve = segment.getCurve();
		if (curve) {
			this._setCurve(curve);
		} else {
			this._setPath(segment._path);
			this._segment1 = segment;
			this._segment2 = null;
		}
		this._segment = segment;
		this._time = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var segment = this._segment;
		if (!segment) {
			var curve = this.getCurve(),
				time = this.getTime();
			if (time === 0) {
				segment = curve._segment1;
			} else if (time === 1) {
				segment = curve._segment2;
			} else if (time != null) {
				segment = curve.getPartLength(0, time)
					< curve.getPartLength(time, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var path = this._path,
			that = this;
		if (path && path._version !== this._version) {
			this._time = this._offset = this._curveOffset = this._curve = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
				that._setCurve(curve);
				return curve;
			}
		}

		return this._curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getTime: function() {
		var curve = this.getCurve(),
			time = this._time;
		return curve && time == null
			? this._time = curve.getTimeOf(this._point)
			: time;
	},

	getParameter: '#getTime',

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var offset = this._curveOffset;
		if (offset == null) {
			var curve = this.getCurve(),
				time = this.getTime();
			this._curveOffset = offset = time != null && curve
					&& curve.getPartLength(0, time);
		}
		return offset;
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = curve && curve.divideAtTime(this.getTime());
		if (res) {
			this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve(),
			path = curve._path,
			res = curve && curve.splitAtTime(this.getTime());
		if (res) {
			this._setSegment(path.getLastSegment());
		}
		return  res;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc;
		if (!res && loc instanceof CurveLocation) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				p1 = c1._path,
				p2 = c2._path;
			if (p1 === p2) {
				var abs = Math.abs,
					epsilon = 1e-7,
					diff = abs(this.getOffset() - loc.getOffset()),
					i1 = !_ignoreOther && this._intersection,
					i2 = !_ignoreOther && loc._intersection;
				res = (diff < epsilon
						|| p1 && abs(p1.getLength() - diff) < epsilon)
					&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
			}
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var time = this.getTime();
		if (time != null)
			parts.push('time: ' + f.number(time));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getTime(),
			t2 = inter.getTime(),
			tMin = 1e-8,
			tMax = 1 - tMin,
			t1Inside = t1 >= tMin && t1 <= tMax,
			t2Inside = t2 >= tMin && t2 <= tMax;
		if (t1Inside && t2Inside)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2 && t1 < tMin ? c2.getPrevious() : c2,
			c4 = inter.getCurve(),
			c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;
		if (t1 > tMax)
			c2 = c2.getNext();
		if (t2 > tMax)
			c4 = c4.getNext();
		if (!c1 || !c2 || !c3 || !c4)
			return false;

		var offsets = [];

		function addOffsets(curve, end) {
			var v = curve.getValues(),
				roots = Curve.classify(v).roots || Curve.getPeaks(v),
				count = roots.length,
				offset = Curve.getLength(v,
					end && count ? roots[count - 1] : 0,
					!end && count ? roots[0] : 1);
			offsets.push(count ? offset : offset / 32);
		}

		function isInRange(angle, min, max) {
			return min < max
					? angle > min && angle < max
					: angle > min || angle < max;
		}

		if (!t1Inside) {
			addOffsets(c1, true);
			addOffsets(c2, false);
		}
		if (!t2Inside) {
			addOffsets(c3, true);
			addOffsets(c4, false);
		}
		var pt = this.getPoint(),
			offset = Math.min.apply(Math, offsets),
			v2 = t1Inside ? c2.getTangentAtTime(t1)
					: c2.getPointAt(offset).subtract(pt),
			v1 = t1Inside ? v2.negate()
					: c1.getPointAt(-offset).subtract(pt),
			v4 = t2Inside ? c4.getTangentAtTime(t2)
					: c4.getPointAt(offset).subtract(pt),
			v3 = t2Inside ? v4.negate()
					: c3.getPointAt(-offset).subtract(pt),
			a1 = v1.getAngle(),
			a2 = v2.getAngle(),
			a3 = v3.getAngle(),
			a4 = v4.getAngle();
		return !!(t1Inside
				? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
				  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
				: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
				  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
	},

	hasOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve._evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var curve = this.getCurve(),
			time = this.getTime();
		return time != null && curve && curve[get](time, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						1e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 !== path2
				? path1._id - path2._id
				: (loc.getIndex() + loc.getTime())
				- (loc2.getIndex() + loc2.getTime());
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = locations.length - 1; i >= 0; i--) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',
	_selectBounds: false,
	_canScaleStroke: true,
	beans: true,

	initialize: function PathItem() {
	},

	statics: {
		create: function(arg) {
			var data,
				segments,
				compound;
			if (Base.isPlainObject(arg)) {
				segments = arg.segments;
				data = arg.pathData;
			} else if (Array.isArray(arg)) {
				segments = arg;
			} else if (typeof arg === 'string') {
				data = arg;
			}
			if (segments) {
				var first = segments[0];
				compound = first && Array.isArray(first[0]);
			} else if (data) {
				compound = (data.match(/m/gi) || []).length > 1
						|| /z\s*\S+/i.test(data);
			}
			var ctor = compound ? CompoundPath : Path;
			return new ctor(arg);
		}
	},

	_asPathItem: function() {
		return this;
	},

	isClockwise: function() {
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
	},

	setPathData: function(data) {

		var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2) {
					this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
					if (move) {
						start = current;
						move = false;
					}
				}
				control = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				current = current.clone();
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(1e-12);
				current = start;
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = point.isInside(
				this.getBounds({ internal: true, handle: true }))
					? this._getWinding(point)
					: {};
		return winding.onPath || !!(this.getFillRule() === 'evenodd'
				? winding.windingL & 1 || winding.windingR & 1
				: winding.winding);
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix._orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix)._orNullIfIdentity();
		return self || this.getBounds(matrix1).intersects(
				path.getBounds(matrix2), 1e-12)
				? Curve.getIntersections(
						this.getCurves(), !self && path.getCurves(), include,
						matrix1, matrix2, _returnFirst)
				: [];
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	},

	interpolate: function(from, to, factor) {
		var isPath = !this._children,
			name = isPath ? '_segments' : '_children',
			itemsFrom = from[name],
			itemsTo = to[name],
			items = this[name];
		if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
			throw new Error('Invalid operands in interpolate() call: ' +
					from + ', ' + to);
		}
		var current = items.length,
			length = itemsTo.length;
		if (current < length) {
			var ctor = isPath ? Segment : Path;
			for (var i = current; i < length; i++) {
				this.add(new ctor());
			}
		} else if (current > length) {
			this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
		}
		for (var i = 0; i < length; i++) {
			items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
		}
		if (isPath) {
			this.setClosed(from._closed);
			this._changed(9);
		}
	},

	compare: function(path) {
		var ok = false;
		if (path) {
			var paths1 = this._children || [this],
				paths2 = path._children ? path._children.slice() : [path],
				length1 = paths1.length,
				length2 = paths2.length,
				matched = [],
				count = 0;
			ok = true;
			var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);
			for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
				var path1 = paths1[i1];
				ok = false;
				var pathBoundsOverlaps = boundsOverlaps[i1];
				if (pathBoundsOverlaps) {
					for (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {
						if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {
							if (!matched[pathBoundsOverlaps[i2]]) {
								matched[pathBoundsOverlaps[i2]] = true;
								count++;
							}
							ok = true;
						}
					}
				}
			}
			ok = ok && count === length2;
		}
		return ok;
	},

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var args = arguments,
			segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: args
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? args
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._segmentSelection = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	copyContent: function(source) {
		this.setSegments(source._segments);
		this._closed = source._closed;
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			this._length = this._area = undefined;
			if (flags & 32) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 64) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected(),
			length = segments && segments.length;
		this._segments.length = 0;
		this._segmentSelection = 0;
		this._curves = undefined;
		if (length) {
			var last = segments[length - 1];
			if (typeof last === 'boolean') {
				this.setClosed(last);
				length--;
			}
			this._add(Segment.readList(segments, 0, {}, length));
		}
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(41);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine) {
						var dx = curX - prevX,
							dy = curY - prevY;
						parts.push(
							  dx === 0 ? 'v' + f.number(dy)
							: dy === 0 ? 'h' + f.number(dx)
							: 'l' + f.pair(dx, dy));
					}
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							 + ' ' + f.pair( inX - prevX,  inY - prevY)
							 + ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (!length)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	},

	isEmpty: function() {
		return !this._segments.length;
	},

	_transformContent: function(matrix) {
		var segments = this._segments,
			coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selection)
				this._updateSelection(segment, 0, segment._selection);
		}
		if (append) {
			Base.push(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				start = index > 0 && index + amount - 1 === total ? index - 1
					: index,
				insert = start,
				end = Math.min(start + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [start, 0].concat(segs._curves));
				insert += segs._curves.length;
			}
			for (var i = insert; i < end; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(start, end);
		}
		this._changed(41);
		return segs;
	},

	_adjustCurves: function(start, end) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = start; i < end; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && !start ? segments.length - 1
				: start - 1]) {
			curve._segment2 = segments[start] || segments[0];
			curve._changed();
		}
		if (curve = curves[end]) {
			curve._segment1 = segments[end];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		var args = arguments;
		return args.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args))
			: this._add([ Segment.read(args) ])[0];
	},

	insert: function(index, segment1 ) {
		var args = arguments;
		return args.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readList(args, 1), index)
			: this._add([ Segment.read(args, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readList(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readList(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(start, end, _includeCurves) {
		start = start || 0;
		end = Base.pick(end, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(start, end - start),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selection)
				this._updateSelection(segment, segment._selection, 0);
			segment._index = segment._path = null;
		}
		for (var i = start, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = start > 0 && end === count + (this._closed ? 1 : 0)
					? start - 1
					: start,
				curves = curves.splice(index, amount);
			for (var i = curves.length - 1; i >= 0; i--)
				curves[i]._path = null;
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(41);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		var area = this._area;
		if (area == null) {
			var segments = this._segments,
				closed = this._closed;
			area = 0;
			for (var i = 0, l = segments.length; i < l; i++) {
				var last = i + 1 === l;
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[last ? 0 : i + 1],
						null, last && !closed));
			}
			this._area = area;
		}
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this.isSelected() && length > 0 && this._segmentSelection
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelection: function setSelection(selection) {
		if (!(selection & 1))
			this._selectSegments(false);
		setSelection.base.call(this, selection);
	},

	_selectSegments: function(selected) {
		var segments = this._segments,
			length = segments.length,
			selection = selected ? 7 : 0;
		this._segmentSelection = selection * length;
		for (var i = 0; i < length; i++)
			segments[i]._selection = selection;
	},

	_updateSelection: function(segment, oldSelection, newSelection) {
		segment._selection = newSelection;
		var selection = this._segmentSelection += newSelection - oldSelection;
		if (selection > 0)
			this.setSelected(true);
	},

	divideAt: function(location) {
		var loc = this.getLocationAt(location),
			curve;
		return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
				? curve._segment1
				: null;
	},

	splitAt: function(location) {
		var loc = this.getLocationAt(location),
			index = loc && loc.index,
			time = loc && loc.time,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (time > tMax) {
			index++;
			time = 0;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (time >= tMin) {
				curves[index++].divideAtTime(time);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.copyAttributes(this);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	split: function(index, time) {
		var curve,
			location = time === undefined ? index
				: (curve = this.getCurves()[index])
					&& curve.getLocationAtTime(time);
		return location != null ? this.splitAt(location) : null;
	},

	join: function(path, tolerance) {
		var epsilon = tolerance || 0;
		if (path && path !== this) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.isClose(last2._point, epsilon))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.isClose(first2._point, epsilon)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.isClose(first2._point, epsilon))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.isClose(last2._point, epsilon)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.isClose(last._point, epsilon)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	reduce: function(options) {
		var curves = this.getCurves(),
			simplify = options && options.simplify,
			tolerance = simplify ? 1e-7 : 0;
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (!curve.hasLength(tolerance)
					|| simplify && curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		this._changed(9);
	},

	flatten: function(flatness) {
		var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
			parts = flattener.parts,
			length = parts.length,
			segments = [];
		for (var i = 0; i < length; i++) {
			segments.push(new Segment(parts[i].curve.slice(0, 2)));
		}
		if (!this._closed && length > 0) {
			segments.push(new Segment(parts[length - 1].curve.slice(6)));
		}
		this.setSegments(segments);
	},

	simplify: function(tolerance) {
		var segments = new PathFitter(this).fit(tolerance || 2.5);
		if (segments)
			this.setSegments(segments);
		return !!segments;
	},

	smooth: function(options) {
		var that = this,
			opts = options || {},
			type = opts.type || 'asymmetric',
			segments = this._segments,
			length = segments.length,
			closed = this._closed;

		function getIndex(value, _default) {
			var index = value && value.index;
			if (index != null) {
				var path = value.path;
				if (path && path !== that)
					throw new Error(value._class + ' ' + index + ' of ' + path
							+ ' is not part of ' + that);
				if (_default && value instanceof Curve)
					index++;
			} else {
				index = typeof value === 'number' ? value : _default;
			}
			return Math.min(index < 0 && closed
					? index % length
					: index < 0 ? index + length : index, length - 1);
		}

		var loop = closed && opts.from === undefined && opts.to === undefined,
			from = getIndex(opts.from, 0),
			to = getIndex(opts.to, length - 1);

		if (from > to) {
			if (closed) {
				from -= length;
			} else {
				var tmp = from;
				from = to;
				to = tmp;
			}
		}
		if (/^(?:asymmetric|continuous)$/.test(type)) {
			var asymmetric = type === 'asymmetric',
				min = Math.min,
				amount = to - from + 1,
				n = amount - 1,
				padding = loop ? min(amount, 4) : 1,
				paddingLeft = padding,
				paddingRight = padding,
				knots = [];
			if (!closed) {
				paddingLeft = min(1, from);
				paddingRight = min(1, length - to - 1);
			}
			n += paddingLeft + paddingRight;
			if (n <= 1)
				return;
			for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
				knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
			}

			var x = knots[0]._x + 2 * knots[1]._x,
				y = knots[0]._y + 2 * knots[1]._y,
				f = 2,
				n_1 = n - 1,
				rx = [x],
				ry = [y],
				rf = [f],
				px = [],
				py = [];
			for (var i = 1; i < n; i++) {
				var internal = i < n_1,
					a = internal ? 1 : asymmetric ? 1 : 2,
					b = internal ? 4 : asymmetric ? 2 : 7,
					u = internal ? 4 : asymmetric ? 3 : 8,
					v = internal ? 2 : asymmetric ? 0 : 1,
					m = a / f;
				f = rf[i] = b - m;
				x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
				y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
			}

			px[n_1] = rx[n_1] / rf[n_1];
			py[n_1] = ry[n_1] / rf[n_1];
			for (var i = n - 2; i >= 0; i--) {
				px[i] = (rx[i] - px[i + 1]) / rf[i];
				py[i] = (ry[i] - py[i + 1]) / rf[i];
			}
			px[n] = (3 * knots[n]._x - px[n_1]) / 2;
			py[n] = (3 * knots[n]._y - py[n_1]) / 2;

			for (var i = paddingLeft, max = n - paddingRight, j = from;
					i <= max; i++, j++) {
				var segment = segments[j < 0 ? j + length : j],
					pt = segment._point,
					hx = px[i] - pt._x,
					hy = py[i] - pt._y;
				if (loop || i < max)
					segment.setHandleOut(hx, hy);
				if (loop || i > paddingLeft)
					segment.setHandleIn(-hx, -hy);
			}
		} else {
			for (var i = from; i <= to; i++) {
				segments[i < 0 ? i + length : i].smooth(opts,
						!loop && i === from, !loop && i === to);
			}
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.copyAttributes(this, true);
			shape._matrix.prepend(this._matrix);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			if (insert === undefined || insert)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	toPath: '#clone',

	compare: function compare(path) {
		if (!path || path instanceof CompoundPath)
			return compare.base.call(this, path);
		var curves1 = this.getCurves(),
			curves2 = path.getCurves(),
			length1 = curves1.length,
			length2 = curves2.length;
		if (!length1 || !length2) {
			return length1 == length2;
		}
		var v1 = curves1[0].getValues(),
			values2 = [],
			pos1 = 0, pos2,
			end1 = 0, end2;
		for (var i = 0; i < length2; i++) {
			var v2 = curves2[i].getValues();
			values2.push(v2);
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
				end2 = overlaps[0][1];
				break;
			}
		}
		var abs = Math.abs,
			epsilon = 1e-8,
			v2 = values2[pos2],
			start2;
		while (v1 && v2) {
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				var t1 = overlaps[0][0];
				if (abs(t1 - end1) < epsilon) {
					end1 = overlaps[1][0];
					if (end1 === 1) {
						v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
						end1 = 0;
					}
					var t2 = overlaps[0][1];
					if (abs(t2 - end2) < epsilon) {
						if (!start2)
							start2 = [pos2, t2];
						end2 = overlaps[1][1];
						if (end2 === 1) {
							if (++pos2 >= length2)
								pos2 = 0;
							v2 = values2[pos2] || curves2[pos2].getValues();
							end2 = 0;
						}
						if (!v1) {
							return start2[0] === pos2 && start2[1] === end2;
						}
						continue;
					}
				}
			}
			break;
		}
		return false;
	},

	_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			strokeRadius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (strokeRadius !== null) {
			if (strokeRadius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = style.getMiterLimit();
				strokePadding = strokePadding.add(
					Path._getStrokePadding(strokeRadius, strokeMatrix));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			var isJoin = closed || segment._index > 0
					&& segment._index < numSegments - 1;
			if ((isJoin ? join : cap) === 'round') {
				return isCloseEnough(segment._point, strokePadding);
			} else {
				area = new Path({ internal: true, closed: true });
				if (isJoin) {
					if (!segment.isSmooth()) {
						Path._addBevelJoin(segment, join, strokeRadius,
							   miterLimit, null, strokeMatrix, addToArea, true);
					}
				} else if (cap === 'square') {
					Path._addSquareCap(segment, cap, strokeRadius, null,
							strokeMatrix, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (strokeRadius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var time = loc.getTime();
				if (time === 0 || time === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point)
							<= miterLimit * strokeRadius
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var loc = this.getLocationAt(offset);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset) {
		if (typeof offset === 'number') {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength()) {
				return new CurveLocation(curves[curves.length - 1], 1);
			}
		} else if (offset && offset.getPath && offset.getPath() === this) {
			return offset;
		}
		return null;
	},

	getOffsetsWithTangent: function() {
		var tangent = Point.read(arguments);
		if (tangent.isZero()) {
			return [];
		}

		var offsets = [];
		var curveStart = 0;
		var curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i];
			var curveTimes = curve.getTimesWithTangent(tangent);
			for (var j = 0, m = curveTimes.length; j < m; j++) {
				var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);
				if (offsets.indexOf(offset) < 0) {
					offsets.push(offset);
				}
			}
			curveStart += curve.length;
		}
		return offsets;
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		if (size <= 0) return;

		var half = size / 2,
			miniSize = size - 2,
			miniHalf = half - 1,
			coords = new Array(6),
			pX, pY;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i],
				selection = segment._selection;
			segment._transformCoordinates(matrix, coords);
			pX = coords[0];
			pY = coords[1];
			if (selection & 2)
				drawHandle(2);
			if (selection & 4)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (miniSize > 0 && !(selection & 1)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, viewMatrix, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx, param, viewMatrix);
				if (hasFill) {
					ctx.fill(style.getFillRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this, 0.25, 32, false,
								strokeMatrix),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (!segments.length)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				t = Base.pick(Base.read(args), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var args = arguments,
				abs = Math.abs,
				sqrt = Math.sqrt,
				current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(args),
				through,
				peek = Base.peek(args),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(args) <= 2) {
				through = to;
				to = Point.read(args);
			} else if (!from.equals(to)) {
				var radius = Size.read(args),
					isZero = Numerical.isZero;
				if (isZero(radius.width) || isZero(radius.height))
					return this.lineTo(to);
				var rotation = Base.read(args),
					clockwise = !!Base.read(args),
					large = !!Base.read(args),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq = x * x,
					ySq = y * y;
				var factor = sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1) * sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center, true);
				if (centerSide === 0) {
					extent = throughSide * abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			if (extent) {
				var epsilon = 1e-7,
					ext = abs(extent),
					count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (!i) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			}
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var args = arguments,
				through = Point.read(args),
				to = Point.read(args),
				parameter = Base.read(args),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var args = arguments,
				handle1 = Point.read(args),
				handle2 = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var args = arguments,
				handle = Point.read(args),
				to = Point.read(args),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var args = arguments,
				current = getCurrentSegment(this)._point,
				point = current.add(Point.read(args)),
				clockwise = Base.pick(Base.peek(args), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(args)));
			}
		},

		closePath: function(tolerance) {
			this.setClosed(true);
			this.join(this, tolerance);
		}
	};
}, {

	_getBounds: function(matrix, options) {
		var method = options.handle
				? 'getHandleBounds'
				: options.stroke
				? 'getStrokeBounds'
				: 'getBounds';
		return Path[method](this._segments, this._closed, this, matrix, options);
	},

statics: {
	getBounds: function(segments, closed, path, matrix, options, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6)),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = style.hasStroke(),
			strokeWidth = style.getStrokeWidth(),
			strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
			strokePadding = stroke && Path._getStrokePadding(strokeWidth,
				strokeMatrix),
			bounds = Path.getBounds(segments, closed, path, matrix, options,
				strokePadding);
		if (!stroke)
			return bounds;
		var strokeRadius = strokeWidth / 2,
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = style.getMiterLimit(),
			joinBounds = new Rectangle(new Size(strokePadding));

		function addPoint(point) {
			bounds = bounds.include(point);
		}

		function addRound(segment) {
			bounds = bounds.unite(
					joinBounds.setCenter(segment._point.transform(matrix)));
		}

		function addJoin(segment, join) {
			if (join === 'round' || segment.isSmooth()) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
						matrix, strokeMatrix, addPoint);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, strokeRadius, matrix,
						strokeMatrix, addPoint);
			}
		}

		var length = segments.length - (closed ? 0 : 1);
		if (length > 0) {
			for (var i = 1; i < length; i++) {
				addJoin(segments[i], join);
			}
			if (closed) {
				addJoin(segments[0], join);
			} else {
				addCap(segments[0], cap);
				addCap(segments[segments.length - 1], cap);
			}
		}
		return bounds;
	},

	_getStrokePadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var hor = new Point(radius, 0).transform(matrix),
			ver = new Point(0, radius).transform(matrix),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = Math.atan2(b * tan, a),
			ty = Math.atan2(b, tan * a);
		return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, matrix,
			strokeMatrix, addPoint, isArea) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPoint1().transform(matrix),
			normal1 = curve1.getNormalAtTime(1).multiply(radius)
				.transform(strokeMatrix),
			normal2 = curve2.getNormalAtTime(0).multiply(radius)
				.transform(strokeMatrix),
				angle = normal1.getDirectedAngle(normal2);
		if (angle < 0 || angle >= 180) {
			normal1 = normal1.negate();
			normal2 = normal2.negate();
		}
		if (isArea)
			addPoint(point);
		addPoint(point.add(normal1));
		if (join === 'miter') {
			var corner = new Line(point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit * radius) {
				addPoint(corner);
			}
		}
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
			addPoint, isArea) {
		var point = segment._point.transform(matrix),
			loc = segment.getLocation(),
			normal = loc.getNormal()
					.multiply(loc.getTime() === 0 ? radius : -radius)
					.transform(strokeMatrix);
		if (cap === 'square') {
			if (isArea) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			point = point.add(normal.rotate(-90));
		}
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = options.stroke && style.hasStroke(),
			strokePadding,
			joinPadding;
		if (stroke) {
			var strokeMatrix = path._getStrokeMatrix(matrix, options),
				strokeRadius = style.getStrokeWidth() / 2,
				joinRadius = strokeRadius;
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
			strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
			joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
		}
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords);
			for (var j = 0; j < 6; j += 2) {
				var padding = !j ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert == false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props, { insert: true });
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			var args = arguments;
			return createPath([
				new Segment(Point.readNamed(args, 'from')),
				new Segment(Point.readNamed(args, 'to'))
			], false, args);
		},

		Circle: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				radius = Base.readNamed(args, 'radius');
			return createEllipse(center, new Size(radius), args);
		},

		Rectangle: function() {
			var args = arguments,
				rect = Rectangle.readNamed(args, 'rectangle'),
				radius = Size.readNamed(args, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, args);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var args = arguments,
				ellipse = Shape._readEllipse(args);
			return createEllipse(ellipse.center, ellipse.radius, args);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var args = arguments,
				from = Point.readNamed(args, 'from'),
				through = Point.readNamed(args, 'through'),
				to = Point.readNamed(args, 'to'),
				props = Base.getNamed(args),
				path = new Path(props && props.insert == false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				sides = Base.readNamed(args, 'sides'),
				radius = Base.readNamed(args, 'radius'),
				step = 360 / sides,
				three = sides % 3 === 0,
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, args);
		},

		Star: function() {
			var args = arguments,
				center = Point.readNamed(args, 'center'),
				points = Base.readNamed(args, 'points') * 2,
				radius1 = Base.readNamed(args, 'radius1'),
				radius2 = Base.readNamed(args, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, args);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},
	beans: true,

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items) {
		var list = items,
			first = list[0];
		if (first && typeof first[0] === 'number')
			list = [list];
		for (var i = items.length - 1; i >= 0; i--) {
			var item = list[i];
			if (list === items && !(item instanceof Path))
				list = Base.slice(list);
			if (Array.isArray(item)) {
				list[i] = new Path({ segments: item, insert: false });
			} else if (item instanceof CompoundPath) {
				list.splice.apply(list, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		return insertChildren.base.call(this, index, list);
	},

	reduce: function reduce(options) {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce(options);
			if (path.isEmpty())
				path.remove();
		}
		if (!children.length) {
			var path = new Path(Item.NO_INSERT);
			path.copyAttributes(this);
			path.insertAbove(this);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClosed: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			if (!children[i]._closed)
				return false;
		}
		return true;
	},

	setClosed: function(closed) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].setClosed(closed);
		}
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++) {
			Base.push(curves, children[i].getCurves());
		}
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getLastCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	},

	getLength: function() {
		var children = this._children,
			length = 0;
		for (var i = 0, l = children.length; i < l; i++)
			length += children[i].getLength();
		return length;
	},

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.appended(mx) : _matrix, _precision));
		}
		return paths.join('');
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		return _hitTestChildren.base.call(this, point,
				options.class === Path || options.type === 'path' ? options
					: Base.set({}, options, { fill: false }),
				viewMatrix);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var children = this._children;
		if (!children.length)
			return;

		param = param.extend({ dontStart: true, dontFinish: true });
		ctx.beginPath();
		for (var i = 0, l = children.length; i < l; i++)
			children[i].draw(ctx, param, strokeMatrix);

		if (!param.clip) {
			this._setStyles(ctx, param, viewMatrix);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectionItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectionItems[child._id]) {
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.appended(mx));
			}
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && !children.length)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
			'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
			'arcBy'],
		function(key) {
			this[key] = function() {
				var path = getCurrentPath(this, true);
				path[key].apply(path, arguments);
			};
		}, {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},

			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},

			closePath: function(tolerance) {
				getCurrentPath(this, true).closePath(tolerance);
			}
		}
	);
}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
	this[key] = function(param) {
		var children = this._children,
			res;
		for (var i = 0, l = children.length; i < l; i++) {
			res = children[i][key](param) || res;
		}
		return res;
	};
}, {}));

PathItem.inject(new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		operators = {
			unite:     { '1': true, '2': true },
			intersect: { '2': true },
			subtract:  { '1': true },
			exclude:   { '1': true, '-1': true }
		};

	function getPaths(path) {
		return path._children || [path];
	}

	function preparePath(path, resolve) {
		var res = path
			.clone(false)
			.reduce({ simplify: true })
			.transform(null, true, true);
		if (resolve) {
			var paths = getPaths(res);
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				if (!path._closed && !path.isEmpty()) {
					path.closePath(1e-12);
					path.getFirstSegment().setHandleIn(0, 0);
					path.getLastSegment().setHandleOut(0, 0);
				}
			}
			res = res
				.resolveCrossings()
				.reorient(res.getFillRule() === 'nonzero', true);
		}
		return res;
	}

	function createResult(paths, simplify, path1, path2, options) {
		var result = new CompoundPath(Item.NO_INSERT);
		result.addChildren(paths, true);
		result = result.reduce({ simplify: simplify });
		if (!(options && options.insert == false)) {
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex() ? path2 : path1);
		}
		result.copyAttributes(path1, true);
		return result;
	}

	function filterIntersection(inter) {
		return inter.hasOverlap() || inter.isCrossing();
	}

	function traceBoolean(path1, path2, operation, options) {
		if (options && (options.trace == false || options.stroke) &&
				/^(subtract|intersect)$/.test(operation))
			return splitBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true),
			operator = operators[operation];
		operator[operation] = true;
		if (_path2 && (operator.subtract || operator.exclude)
				^ (_path2.isClockwise() ^ _path1.isClockwise()))
			_path2.reverse();
		var crossings = divideLocations(CurveLocation.expand(
				_path1.getIntersections(_path2, filterIntersection))),
			paths1 = getPaths(_path1),
			paths2 = _path2 && getPaths(_path2),
			segments = [],
			curves = [],
			paths;

		function collectPaths(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				Base.push(segments, path._segments);
				Base.push(curves, path.getCurves());
				path._overlapsOnly = true;
			}
		}

		function getCurves(indices) {
			var list = [];
			for (var i = 0, l = indices && indices.length; i < l; i++) {
				list.push(curves[indices[i]]);
			}
			return list;
		}

		if (crossings.length) {
			collectPaths(paths1);
			if (paths2)
				collectPaths(paths2);

			var curvesValues = new Array(curves.length);
			for (var i = 0, l = curves.length; i < l; i++) {
				curvesValues[i] = curves[i].getValues();
			}
			var curveCollisions = CollisionDetection.findCurveBoundsCollisions(
					curvesValues, curvesValues, 0, true);
			var curveCollisionsMap = {};
			for (var i = 0; i < curves.length; i++) {
				var curve = curves[i],
					id = curve._path._id,
					map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};
				map[curve.getIndex()] = {
					hor: getCurves(curveCollisions[i].hor),
					ver: getCurves(curveCollisions[i].ver)
				};
			}

			for (var i = 0, l = crossings.length; i < l; i++) {
				propagateWinding(crossings[i]._segment, _path1, _path2,
						curveCollisionsMap, operator);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i],
					inter = segment._intersection;
				if (!segment._winding) {
					propagateWinding(segment, _path1, _path2,
							curveCollisionsMap, operator);
				}
				if (!(inter && inter._overlap))
					segment._path._overlapsOnly = false;
			}
			paths = tracePaths(segments, operator);
		} else {
			paths = reorientPaths(
					paths2 ? paths1.concat(paths2) : paths1.slice(),
					function(w) {
						return !!operator[w];
					});
		}
		return createResult(paths, true, path1, path2, options);
	}

	function splitBoolean(path1, path2, operation) {
		var _path1 = preparePath(path1),
			_path2 = preparePath(path2),
			crossings = _path1.getIntersections(_path2, filterIntersection),
			subtract = operation === 'subtract',
			divide = operation === 'divide',
			added = {},
			paths = [];

		function addPath(path) {
			if (!added[path._id] && (divide ||
					_path2.contains(path.getPointAt(path.getLength() / 2))
						^ subtract)) {
				paths.unshift(path);
				return added[path._id] = true;
			}
		}

		for (var i = crossings.length - 1; i >= 0; i--) {
			var path = crossings[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return createResult(paths, false, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._previous;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._previous)
				to = to._previous;
			from._next = to;
			to._previous = from;
		}
	}

	function clearCurveHandles(curves) {
		for (var i = curves.length - 1; i >= 0; i--)
			curves[i].clearHandles();
	}

	function reorientPaths(paths, isInside, clockwise) {
		var length = paths && paths.length;
		if (length) {
			var lookup = Base.each(paths, function (path, i) {
					this[path._id] = {
						container: null,
						winding: path.isClockwise() ? 1 : -1,
						index: i
					};
				}, {}),
				sorted = paths.slice().sort(function (a, b) {
					return abs(b.getArea()) - abs(a.getArea());
				}),
				first = sorted[0];
			var collisions = CollisionDetection.findItemBoundsCollisions(sorted,
					null, Numerical.GEOMETRIC_EPSILON);
			if (clockwise == null)
				clockwise = first.isClockwise();
			for (var i = 0; i < length; i++) {
				var path1 = sorted[i],
					entry1 = lookup[path1._id],
					containerWinding = 0,
					indices = collisions[i];
				if (indices) {
					var point = null;
					for (var j = indices.length - 1; j >= 0; j--) {
						if (indices[j] < i) {
							point = point || path1.getInteriorPoint();
							var path2 = sorted[indices[j]];
							if (path2.contains(point)) {
								var entry2 = lookup[path2._id];
								containerWinding = entry2.winding;
								entry1.winding += containerWinding;
								entry1.container = entry2.exclude
									? entry2.container : path2;
								break;
							}
						}
					}
				}
				if (isInside(entry1.winding) === isInside(containerWinding)) {
					entry1.exclude = true;
					paths[entry1.index] = null;
				} else {
					var container = entry1.container;
					path1.setClockwise(
							container ? !container.isClockwise() : clockwise);
				}
			}
		}
		return paths;
	}

	function divideLocations(locations, include, clearLater) {
		var results = include && [],
			tMin = 1e-8,
			tMax = 1 - tMin,
			clearHandles = false,
			clearCurves = clearLater || [],
			clearLookup = clearLater && {},
			renormalizeLocs,
			prevCurve,
			prevTime;

		function getId(curve) {
			return curve._path._id + '.' + curve._segment1._index;
		}

		for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
			var curve = clearLater[i];
			if (curve._path)
				clearLookup[getId(curve)] = true;
		}

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				time = loc._time,
				origTime = time,
				exclude = include && !include(loc),
				curve = loc._curve,
				segment;
			if (curve) {
				if (curve !== prevCurve) {
					clearHandles = !curve.hasHandles()
							|| clearLookup && clearLookup[getId(curve)];
					renormalizeLocs = [];
					prevTime = null;
					prevCurve = curve;
				} else if (prevTime >= tMin) {
					time /= prevTime;
				}
			}
			if (exclude) {
				if (renormalizeLocs)
					renormalizeLocs.push(loc);
				continue;
			} else if (include) {
				results.unshift(loc);
			}
			prevTime = origTime;
			if (time < tMin) {
				segment = curve._segment1;
			} else if (time > tMax) {
				segment = curve._segment2;
			} else {
				var newCurve = curve.divideAtTime(time, true);
				if (clearHandles)
					clearCurves.push(curve, newCurve);
				segment = newCurve._segment1;
				for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
					var l = renormalizeLocs[j];
					l._time = (l._time - time) / (1 - time);
				}
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
		}
		if (!clearLater)
			clearCurveHandles(clearCurves);
		return results || locations;
	}

	function getWinding(point, curves, dir, closed, dontFlip) {
		var curvesList = Array.isArray(curves)
			? curves
			: curves[dir ? 'hor' : 'ver'];
		var ia = dir ? 1 : 0,
			io = ia ^ 1,
			pv = [point.x, point.y],
			pa = pv[ia],
			po = pv[io],
			windingEpsilon = 1e-9,
			qualityEpsilon = 1e-6,
			paL = pa - windingEpsilon,
			paR = pa + windingEpsilon,
			windingL = 0,
			windingR = 0,
			pathWindingL = 0,
			pathWindingR = 0,
			onPath = false,
			onAnyPath = false,
			quality = 1,
			roots = [],
			vPrev,
			vClose;

		function addWinding(v) {
			var o0 = v[io + 0],
				o3 = v[io + 6];
			if (po < min(o0, o3) || po > max(o0, o3)) {
				return;
			}
			var a0 = v[ia + 0],
				a1 = v[ia + 2],
				a2 = v[ia + 4],
				a3 = v[ia + 6];
			if (o0 === o3) {
				if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
					onPath = true;
				}
				return;
			}
			var t =   po === o0 ? 0
					: po === o3 ? 1
					: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
					? 1
					: Curve.solveCubic(v, io, po, roots, 0, 1) > 0
						? roots[0]
						: 1,
				a =   t === 0 ? a0
					: t === 1 ? a3
					: Curve.getPoint(v, t)[dir ? 'y' : 'x'],
				winding = o0 > o3 ? 1 : -1,
				windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
				a3Prev = vPrev[ia + 6];
			if (po !== o0) {
				if (a < paL) {
					pathWindingL += winding;
				} else if (a > paR) {
					pathWindingR += winding;
				} else {
					onPath = true;
				}
				if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
					quality /= 2;
			} else {
				if (winding !== windingPrev) {
					if (a0 < paL) {
						pathWindingL += winding;
					} else if (a0 > paR) {
						pathWindingR += winding;
					}
				} else if (a0 != a3Prev) {
					if (a3Prev < paR && a > paR) {
						pathWindingR += winding;
						onPath = true;
					} else if (a3Prev > paL && a < paL) {
						pathWindingL += winding;
						onPath = true;
					}
				}
				quality /= 4;
			}
			vPrev = v;
			return !dontFlip && a > paL && a < paR
					&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
					&& getWinding(point, curves, !dir, closed, true);
		}

		function handleCurve(v) {
			var o0 = v[io + 0],
				o1 = v[io + 2],
				o2 = v[io + 4],
				o3 = v[io + 6];
			if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
				var a0 = v[ia + 0],
					a1 = v[ia + 2],
					a2 = v[ia + 4],
					a3 = v[ia + 6],
					monoCurves = paL > max(a0, a1, a2, a3) ||
								 paR < min(a0, a1, a2, a3)
							? [v] : Curve.getMonoCurves(v, dir),
					res;
				for (var i = 0, l = monoCurves.length; i < l; i++) {
					if (res = addWinding(monoCurves[i]))
						return res;
				}
			}
		}

		for (var i = 0, l = curvesList.length; i < l; i++) {
			var curve = curvesList[i],
				path = curve._path,
				v = curve.getValues(),
				res;
			if (!i || curvesList[i - 1]._path !== path) {
				vPrev = null;
				if (!path._closed) {
					vClose = Curve.getValues(
							path.getLastCurve().getSegment2(),
							curve.getSegment1(),
							null, !closed);
					if (vClose[io] !== vClose[io + 6]) {
						vPrev = vClose;
					}
				}

				if (!vPrev) {
					vPrev = v;
					var prev = path.getLastCurve();
					while (prev && prev !== curve) {
						var v2 = prev.getValues();
						if (v2[io] !== v2[io + 6]) {
							vPrev = v2;
							break;
						}
						prev = prev.getPrevious();
					}
				}
			}

			if (res = handleCurve(v))
				return res;

			if (i + 1 === l || curvesList[i + 1]._path !== path) {
				if (vClose && (res = handleCurve(vClose)))
					return res;
				if (onPath && !pathWindingL && !pathWindingR) {
					pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
							? 1 : -1;
				}
				windingL += pathWindingL;
				windingR += pathWindingR;
				pathWindingL = pathWindingR = 0;
				if (onPath) {
					onAnyPath = true;
					onPath = false;
				}
				vClose = null;
			}
		}
		windingL = abs(windingL);
		windingR = abs(windingR);
		return {
			winding: max(windingL, windingR),
			windingL: windingL,
			windingR: windingR,
			quality: quality,
			onPath: onAnyPath
		};
	}

	function propagateWinding(segment, path1, path2, curveCollisionsMap,
			operator) {
		var chain = [],
			start = segment,
			totalLength = 0,
			winding;
		do {
			var curve = segment.getCurve();
			if (curve) {
				var length = curve.getLength();
				chain.push({ segment: segment, curve: curve, length: length });
				totalLength += length;
			}
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		var offsets = [0.5, 0.25, 0.75],
			winding = { winding: 0, quality: -1 },
			tMin = 1e-3,
			tMax = 1 - tMin;
		for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
			var length = totalLength * offsets[i];
			for (var j = 0, l = chain.length; j < l; j++) {
				var entry = chain[j],
					curveLength = entry.length;
				if (length <= curveLength) {
					var curve = entry.curve,
						path = curve._path,
						parent = path._parent,
						operand = parent instanceof CompoundPath ? parent : path,
						t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
						pt = curve.getPointAtTime(t),
						dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
					var wind = null;
					if (operator.subtract && path2) {
						var otherPath = operand === path1 ? path2 : path1,
							pathWinding = otherPath._getWinding(pt, dir, true);
						if (operand === path1 && pathWinding.winding ||
							operand === path2 && !pathWinding.winding) {
							if (pathWinding.quality < 1) {
								continue;
							} else {
								wind = { winding: 0, quality: 1 };
							}
						}
					}
					wind =  wind || getWinding(
							pt, curveCollisionsMap[path._id][curve.getIndex()],
							dir, true);
					if (wind.quality > winding.quality)
						winding = wind;
					break;
				}
				length -= curveLength;
			}
		}
		for (var j = chain.length - 1; j >= 0; j--) {
			chain[j].segment._winding = winding;
		}
	}

	function tracePaths(segments, operator) {
		var paths = [],
			starts;

		function isValid(seg) {
			var winding;
			return !!(seg && !seg._visited && (!operator
					|| operator[(winding = seg._winding || {}).winding]
						&& !(operator.unite && winding.winding === 2
							&& winding.windingL && winding.windingR)));
		}

		function isStart(seg) {
			if (seg) {
				for (var i = 0, l = starts.length; i < l; i++) {
					if (seg === starts[i])
						return true;
				}
			}
			return false;
		}

		function visitPath(path) {
			var segments = path._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				segments[i]._visited = true;
			}
		}

		function getCrossingSegments(segment, collectStarts) {
			var inter = segment._intersection,
				start = inter,
				crossings = [];
			if (collectStarts)
				starts = [segment];

			function collect(inter, end) {
				while (inter && inter !== end) {
					var other = inter._segment,
						path = other && other._path;
					if (path) {
						var next = other.getNext() || path.getFirstSegment(),
							nextInter = next._intersection;
						if (other !== segment && (isStart(other)
							|| isStart(next)
							|| next && (isValid(other) && (isValid(next)
								|| nextInter && isValid(nextInter._segment))))
						) {
							crossings.push(other);
						}
						if (collectStarts)
							starts.push(other);
					}
					inter = inter._next;
				}
			}

			if (inter) {
				collect(inter);
				while (inter && inter._previous)
					inter = inter._previous;
				collect(inter, start);
			}
			return crossings;
		}

		segments.sort(function(seg1, seg2) {
			var inter1 = seg1._intersection,
				inter2 = seg2._intersection,
				over1 = !!(inter1 && inter1._overlap),
				over2 = !!(inter2 && inter2._overlap),
				path1 = seg1._path,
				path2 = seg2._path;
			return over1 ^ over2
					? over1 ? 1 : -1
					: !inter1 ^ !inter2
						? inter1 ? 1 : -1
						: path1 !== path2
							? path1._id - path2._id
							: seg1._index - seg2._index;
		});

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				valid = isValid(seg),
				path = null,
				finished = false,
				closed = true,
				branches = [],
				branch,
				visited,
				handleIn;
			if (valid && seg._path._overlapsOnly) {
				var path1 = seg._path,
					path2 = seg._intersection._segment._path;
				if (path1.compare(path2)) {
					if (path1.getArea())
						paths.push(path1.clone(false));
					visitPath(path1);
					visitPath(path2);
					valid = false;
				}
			}
			while (valid) {
				var first = !path,
					crossings = getCrossingSegments(seg, first),
					other = crossings.shift(),
					finished = !first && (isStart(seg) || isStart(other)),
					cross = !finished && other;
				if (first) {
					path = new Path(Item.NO_INSERT);
					branch = null;
				}
				if (finished) {
					if (seg.isFirst() || seg.isLast())
						closed = seg._path._closed;
					seg._visited = true;
					break;
				}
				if (cross && branch) {
					branches.push(branch);
					branch = null;
				}
				if (!branch) {
					if (cross)
						crossings.push(seg);
					branch = {
						start: path._segments.length,
						crossings: crossings,
						visited: visited = [],
						handleIn: handleIn
					};
				}
				if (cross)
					seg = other;
				if (!isValid(seg)) {
					path.removeSegments(branch.start);
					for (var j = 0, k = visited.length; j < k; j++) {
						visited[j]._visited = false;
					}
					visited.length = 0;
					do {
						seg = branch && branch.crossings.shift();
						if (!seg || !seg._path) {
							seg = null;
							branch = branches.pop();
							if (branch) {
								visited = branch.visited;
								handleIn = branch.handleIn;
							}
						}
					} while (branch && !isValid(seg));
					if (!seg)
						break;
				}
				var next = seg.getNext();
				path.add(new Segment(seg._point, handleIn,
						next && seg._handleOut));
				seg._visited = true;
				visited.push(seg);
				seg = next || seg._path.getFirstSegment();
				handleIn = next && next._handleIn;
			}
			if (finished) {
				if (closed) {
					path.getFirstSegment().setHandleIn(handleIn);
					path.setClosed(closed);
				}
				if (path.getArea() !== 0) {
					paths.push(path);
				}
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, dir, closed) {
			return getWinding(point, this.getCurves(), dir, closed);
		},

		unite: function(path, options) {
			return traceBoolean(this, path, 'unite', options);
		},

		intersect: function(path, options) {
			return traceBoolean(this, path, 'intersect', options);
		},

		subtract: function(path, options) {
			return traceBoolean(this, path, 'subtract', options);
		},

		exclude: function(path, options) {
			return traceBoolean(this, path, 'exclude', options);
		},

		divide: function(path, options) {
			return options && (options.trace == false || options.stroke)
					? splitBoolean(this, path, 'divide')
					: createResult([
						this.subtract(path, options),
						this.intersect(path, options)
					], true, this, path, options);
		},

		resolveCrossings: function() {
			var children = this._children,
				paths = children || [this];

			function hasOverlap(seg, path) {
				var inter = seg && seg._intersection;
				return inter && inter._overlap && inter._path === path;
			}

			var hasOverlaps = false,
				hasCrossings = false,
				intersections = this.getIntersections(null, function(inter) {
					return inter.hasOverlap() && (hasOverlaps = true) ||
							inter.isCrossing() && (hasCrossings = true);
				}),
				clearCurves = hasOverlaps && hasCrossings && [];
			intersections = CurveLocation.expand(intersections);
			if (hasOverlaps) {
				var overlaps = divideLocations(intersections, function(inter) {
					return inter.hasOverlap();
				}, clearCurves);
				for (var i = overlaps.length - 1; i >= 0; i--) {
					var overlap = overlaps[i],
						path = overlap._path,
						seg = overlap._segment,
						prev = seg.getPrevious(),
						next = seg.getNext();
					if (hasOverlap(prev, path) && hasOverlap(next, path)) {
						seg.remove();
						prev._handleOut._set(0, 0);
						next._handleIn._set(0, 0);
						if (prev !== seg && !prev.getCurve().hasLength()) {
							next._handleIn.set(prev._handleIn);
							prev.remove();
						}
					}
				}
			}
			if (hasCrossings) {
				divideLocations(intersections, hasOverlaps && function(inter) {
					var curve1 = inter.getCurve(),
						seg1 = inter.getSegment(),
						other = inter._intersection,
						curve2 = other._curve,
						seg2 = other._segment;
					if (curve1 && curve2 && curve1._path && curve2._path)
						return true;
					if (seg1)
						seg1._intersection = null;
					if (seg2)
						seg2._intersection = null;
				}, clearCurves);
				if (clearCurves)
					clearCurveHandles(clearCurves);
				paths = tracePaths(Base.each(paths, function(path) {
					Base.push(this, path._segments);
				}, []));
			}
			var length = paths.length,
				item;
			if (length > 1 && children) {
				if (paths !== children)
					this.setChildren(paths);
				item = this;
			} else if (length === 1 && !children) {
				if (paths[0] !== this)
					this.setSegments(paths[0].removeSegments());
				item = this;
			}
			if (!item) {
				item = new CompoundPath(Item.NO_INSERT);
				item.addChildren(paths);
				item = item.reduce();
				item.copyAttributes(this);
				this.replaceWith(item);
			}
			return item;
		},

		reorient: function(nonZero, clockwise) {
			var children = this._children;
			if (children && children.length) {
				this.setChildren(reorientPaths(this.removeChildren(),
						function(w) {
							return !!(nonZero ? w : w & 1);
						},
						clockwise));
			} else if (clockwise !== undefined) {
				this.setClockwise(clockwise);
			}
			return this;
		},

		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this.getCurves(),
					y = point.y,
					intercepts = [],
					roots = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var v = curves[i].getValues(),
						o0 = v[1],
						o1 = v[3],
						o2 = v[5],
						o3 = v[7];
					if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
						var monoCurves = Curve.getMonoCurves(v);
						for (var j = 0, m = monoCurves.length; j < m; j++) {
							var mv = monoCurves[j],
								mo0 = mv[1],
								mo3 = mv[7];
							if ((mo0 !== mo3) &&
								(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
								var x = y === mo0 ? mv[0]
									: y === mo3 ? mv[6]
									: Curve.solveCubic(mv, 1, y, roots, 0, 1)
										=== 1
										? Curve.getPoint(mv, roots[0]).x
										: (mv[0] + mv[6]) / 2;
								intercepts.push(x);
							}
						}
					}
				}
				if (intercepts.length > 1) {
					intercepts.sort(function(a, b) { return a - b; });
					point.x = (intercepts[0] + intercepts[1]) / 2;
				}
			}
			return point;
		}
	};
});

var PathFlattener = Base.extend({
	_class: 'PathFlattener',

	initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minSpan = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, t1, t2) {
			if ((t2 - t1) > minSpan
					&& !(ignoreStraight && Curve.isStraight(curve))
					&& !Curve.isFlatEnough(curve, flatness || 0.25)) {
				var halves = Curve.subdivide(curve, 0.5),
					tMid = (t1 + t2) / 2;
				computeParts(halves[0], index, t1, tMid);
				computeParts(halves[1], index, tMid, t2);
			} else {
				var dx = curve[6] - curve[0],
					dy = curve[7] - curve[1],
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist > 0) {
					length += dist;
					parts.push({
						offset: length,
						curve: curve,
						index: index,
						time: t2,
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2 || segment1, segments[0]);
		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	_get: function(offset) {
		var parts = this.parts,
			length = parts.length,
			start,
			i, j = this.index;
		for (;;) {
			i = j;
			if (!j || parts[--j].offset < offset)
				break;
		}
		for (; i < length; i++) {
			var part = parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = parts[i - 1],
					prevTime = prev && prev.index === part.index ? prev.time : 0,
					prevOffset = prev ? prev.offset : 0;
				return {
					index: part.index,
					time: prevTime + (part.time - prevTime)
						* (offset - prevOffset) / (part.offset - prevOffset)
				};
			}
		}
		return {
			index: parts[length - 1].index,
			time: 1
		};
	},

	drawPart: function(ctx, from, to) {
		var start = this._get(from),
			end = this._get(to);
		for (var i = start.index, l = end.index; i <= l; i++) {
			var curve = Curve.getPart(this.curves[i],
					i === start.index ? start.time : 0,
					i === end.index ? end.time : 1);
			if (i === start.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var param = this._get(offset);
			return Curve[name](this.curves[param.index], param.time);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path) {
		var points = this.points = [],
			segments = path._segments,
			closed = path._closed;
		for (var i = 0, prev, l = segments.length; i < l; i++) {
			var point = segments[i].point;
			if (!prev || !prev.equals(point)) {
				points.push(prev = point.clone());
			}
		}
		if (closed) {
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}
		this.closed = closed;
	},

	fit: function(error) {
		var points = this.points,
			length = points.length,
			segments = null;
		if (length > 0) {
			segments = [new Segment(points[0])];
			if (length > 1) {
				this.fitCubic(segments, error, 0, length - 1,
						points[1].subtract(points[0]),
						points[length - 2].subtract(points[length - 1]));
				if (this.closed) {
					segments.shift();
					segments.pop();
				}
			}
		}
		return segments;
	},

	fitCubic: function(segments, error, first, last, tan1, tan2) {
		var points = this.points;
		if (last - first === 1) {
			var pt1 = points[first],
				pt2 = points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(error, error * error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < error && parametersInOrder) {
				this.addCurve(segments, curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var tanCenter = points[split - 1].subtract(points[split + 1]);
		this.fitCubic(segments, error, first, split, tan1, tanCenter);
		this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(segments, curve) {
		var prev = segments[segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			abs = Math.abs,
			points = this.points,
			pt1 = points[first],
			pt2 = points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1,
			alpha2;
		if (abs(detC0C1) > epsilon) {
			var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
							: abs(c1) > epsilon ? X[1] / c1
							: 0;
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1,
				pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)),
				pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsOptions: { stroke: false, handle: false },

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	copyContent: function(source) {
		this.setContent(source._content);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(521);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx, param, viewMatrix) {
		if (!this._content)
			return;
		this._setStyles(ctx, param, viewMatrix);
		var lines = this._lines,
			style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (hasFill) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(matrix, options) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var rect = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(rect, rect) : rect;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		namedColors = {
			transparent: [0, 0, 0, 0]
		},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(
				/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
			) || string.match(
				/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
			),
			type = 'rgb',
			components;
		if (match) {
			var amount = match[4] ? 4 : 3;
			components = new Array(amount);
			for (var i = 0; i < amount; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
			type = match[1];
			components = match[2].trim().split(/[,\s]+/g);
			var isHSL = type === 'hsl';
			for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
				var component = components[i];
				var value = parseFloat(component);
				if (isHSL) {
					if (i === 0) {
						var unit = component.match(/([a-z]*)$/)[1];
						value *= ({
							turn: 360,
							rad: 180 / Math.PI,
							grad: 0.9
						}[unit] || 1);
					} else if (i < 3) {
						value /= 100;
					}
				} else if (i < 3) {
					value /= /%$/.test(component) ? 100 : 255;
				}
				components[i] = value;
			}
		} else {
			var color = namedColors[string];
			if (!color) {
				if (window) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					color = namedColors[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				} else {
					color = [0, 0, 0];
				}
			}
			components = color.slice();
		}
		return [type, components];
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = type === 'gradient'
					? name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(
								Array.isArray(value)
									? value
									: arguments, 0, { readNull: true }
							);
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
					: function(value) {
						return value == null || isNaN(value) ? 0 : +value;
					};
			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var args = arguments,
				reading = this.__read,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (reading)
						read = 1;
					args = Base.slice(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (reading) {
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					}
					if (values.length > length)
						values = Base.slice(values, 0, length);
				} else if (argType === 'string') {
					var converted = fromCSS(arg);
					type = converted[0];
					components = converted[1];
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && !i && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (reading && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (reading)
				this.__read = read;
			return this;
		},

		set: '#initialize',

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner) {
				if (this._setter) {
					this._owner[this._setter](this);
				} else {
					this._owner._changed(129);
				}
			}
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this.getAlpha() === col.getAlpha()
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx, matrix) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				highlight = components[3],
				inverse = matrix && matrix.inverted(),
				canvasGradient;
			if (inverse) {
				origin = inverse._transformPoint(origin);
				destination = inverse._transformPoint(destination);
				if (highlight)
					highlight = inverse._transformPoint(highlight);
			}
			if (gradient._radial) {
				var radius = destination.getDistance(origin);
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					offset = stop._offset;
				canvasGradient.addColorStop(
						offset == null ? i / (l - 1) : offset,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			},

			_setOwner: function(color, owner, setter) {
				if (color) {
					if (color._owner && owner && color._owner !== owner) {
						color = color.clone();
					}
					if (!color._owner ^ !owner) {
						color._owner = owner || null;
						color._setter = setter || null;
					}
				}
				return color;
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && Base.isPlainObject(stops)) {
			this.set(stops);
			stops = radial = null;
		}
		if (this._stops == null) {
			this.setStops(stops || ['white', 'black']);
		}
		if (this._radial == null) {
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
		}
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
			this._owners[i]._changed();
		}
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (!this._owners.length)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++) {
			stops[i] = this._stops[i].clone();
		}
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (stops.length < 2) {
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		}
		var _stops = this._stops;
		if (_stops) {
			for (var i = 0, l = _stops.length; i < l; i++)
				_stops[i]._owner = undefined;
		}
		_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
		for (var i = 0, l = _stops.length; i < l; i++)
			_stops[i]._owner = this;
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class) {
			var stops1 = this._stops,
				stops2 = gradient._stops,
				length = stops1.length;
			if (length === stops2.length) {
				for (var i = 0; i < length; i++) {
					if (!stops1[i].equals(stops2[i]))
						return false;
				}
				return true;
			}
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		var color = arg0,
			offset = arg1;
		if (typeof arg0 === 'object' && arg1 === undefined) {
			if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
				color = arg0[0];
				offset = arg0[1];
			} else if ('color' in arg0 || 'offset' in arg0
					|| 'rampPoint' in arg0) {
				color = arg0.color;
				offset = arg0.offset || arg0.rampPoint || 0;
			}
		}
		this.setColor(color);
		this.setOffset(offset);
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._offset);
	},

	_serialize: function(options, dictionary) {
		var color = this._color,
			offset = this._offset;
		return Base.serialize(offset == null ? [color] : [color, offset],
				options, true, dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(129);
	},

	getOffset: function() {
		return this._offset;
	},

	setOffset: function(offset) {
		this._offset = offset;
		this._changed();
	},

	getRampPoint: '#getOffset',
	setRampPoint: '#setOffset',

	getColor: function() {
		return this._color;
	},

	setColor: function() {
		Color._setOwner(this._color, null);
		this._color = Color._setOwner(Color.read(arguments, 0), this,
				'setColor');
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._offset == stop._offset
				|| false;
	}
});

var Style = Base.extend(new function() {
	var itemDefaults = {
		fillColor: null,
		fillRule: 'nonzero',
		strokeColor: null,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		shadowColor: null,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: null
	},
	groupDefaults = Base.set({}, itemDefaults, {
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		leading: null,
		justification: 'left'
	}),
	textDefaults = Base.set({}, groupDefaults, {
		fillColor: new Color()
	}),
	flags = {
		strokeWidth: 193,
		strokeCap: 193,
		strokeJoin: 193,
		strokeScaling: 201,
		miterLimit: 193,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	},
	item = {
		beans: true
	},
	fields = {
		_class: 'Style',
		beans: true,

		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project
					|| paper.project;
			this._defaults = !_owner || _owner instanceof Group ? groupDefaults
					: _owner instanceof TextItem ? textDefaults
					: itemDefaults;
			if (style)
				this.set(style);
		}
	};

	Base.each(groupDefaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath);
			if (applyToChildren) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			}
			if ((key === 'selectedColor' || !applyToChildren)
					&& key in this._defaults) {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old) {
							Color._setOwner(old, null);
							old._canvasStyle = null;
						}
						if (value && value.constructor === Color) {
							value = Color._setOwner(value, owner,
									applyToChildren && set);
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 129);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath),
				value;
			if (applyToChildren && !_dontMerge) {
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (!i) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
			} else if (key in this._defaults) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone) {
						value = value.clone();
					}
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
					}
				}
			}
			if (value && isColor) {
				value = Color._setOwner(value, owner, applyToChildren && set);
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Base.each({
		Font: 'FontFamily',
		WindingRule: 'FillRule'
	}, function(value, key) {
		var get = 'get' + key,
			set = 'set' + key;
		fields[get] = item[get] = '#get' + value;
		fields[set] = item[set] = '#set' + value;
	});

	Item.inject(item);
	return fields;
}, {
	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		function compare(style1, style2, secondary) {
			var values1 = style1._values,
				values2 = style2._values,
				defaults2 = style2._defaults;
			for (var key in values1) {
				var value1 = values1[key],
					value2 = values2[key];
				if (!(secondary && key in values2) && !Base.equals(value1,
						value2 === undefined ? defaults2[key] : value2))
					return false;
			}
			return true;
		}

		return style === this || style && this._class === style._class
				&& compare(this, style)
				&& compare(style, this, true)
				|| false;
	},

	_dispose: function() {
		var color;
		color = this.getFillColor();
		if (color) color._canvasStyle = null;
		color = this.getStrokeColor();
		if (color) color._canvasStyle = null;
		color = this.getShadowColor();
		if (color) color._canvasStyle = null;
	},

	hasFill: function() {
		var color = this.getFillColor();
		return !!color && color.alpha > 0;
	},

	hasStroke: function() {
		var color = this.getStrokeColor();
		return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		var color = this.getShadowColor();
		return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
				|| !this.getShadowOffset().isZero());
	},

	getView: function() {
		return this._project._view;
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		isInserted: function(el) {
			return document.body.contains(el);
		},

		getPrefixed: function(el, name) {
			return el && handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++) {
					var name = parts[i];
					var options = (
						el === document
						&& (name === 'touchstart' || name === 'touchmove')
					) ? { passive: false } : false;
					el.addEventListener(name, func, options);
				}
			}
		}
	},

	remove: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		timer;

	function handleCallbacks() {
		var functions = callbacks;
		callbacks = [];
		for (var i = 0, l = functions.length; i < l; i++)
			functions[i]();
		requested = nativeRequest && callbacks.length;
		if (requested)
			nativeRequest(handleCallbacks);
	}

	return function(callback) {
		callbacks.push(callback);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		}

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		}

		var size;
		if (window && element) {
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'paper-view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userDrag: none,
				userSelect: none,
				touchCallout: none,
				contentZooming: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}

			size = getCanvasSize();

			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
		} else {
			size = new Size(element);
			element = null;
		}
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		if (!this._pixelRatio)
			this._pixelRatio = window && window.devicePixelRatio || 1;
		this._setElementSize(size.width, size.height);
		this._viewSize = size;
		View._views.push(this);
		View._viewsById[this._id] = this;
		(this._matrix = new Matrix())._owner = this;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
		this._itemEvents = { native: {}, virtual: {} };
		this._autoUpdate = !paper.agent.node;
		this._needsUpdate = false;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		var project = this._project;
		if (project._view === this)
			project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(
		Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
		function(name) {
			this[name] = {};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	getAutoUpdate: function() {
		return this._autoUpdate;
	},

	setAutoUpdate: function(autoUpdate) {
		this._autoUpdate = autoUpdate;
		if (autoUpdate)
			this.requestUpdate();
	},

	update: function() {
	},

	draw: function() {
		this.update();
	},

	requestUpdate: function() {
		if (!this._requested) {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (that._animate) {
					that.requestUpdate();
					var element = that._element;
					if ((!DomElement.getPrefixed(document, 'hidden')
							|| PaperScope.getAttribute(element, 'keepalive')
								=== 'true') && DomElement.isInView(element)) {
						that._handleFrame();
					}
				}
				if (that._autoUpdate)
					that.update();
			});
			this._requested = true;
		}
	},

	play: function() {
		this._animate = true;
		this.requestUpdate();
	},

	pause: function() {
		this._animate = false;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._last ? now - this._last : 0;
		this._last = now;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_changed: function() {
		this._project._changed(4097);
		this._bounds = this._decomposed = undefined;
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._setElementSize(size.width, size.height);
		this._viewSize.set(size);
		this._changed();
		this.emit('resize', { size: size, delta: delta });
		if (this._autoUpdate) {
			this.update();
		}
	},

	_setElementSize: function(width, height) {
		var element = this._element;
		if (element) {
			if (element.width !== width)
				element.width = width;
			if (element.height !== height)
				element.height = height;
		}
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	isInserted: function() {
		return DomElement.isInserted(this._element);
	},

	getPixelSize: function(size) {
		var element = this._element,
			pixels;
		if (element) {
			var parent = element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			pixels = parseFloat(pixels);
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		return 0;
	}
}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var args = arguments,
			value = (rotate ? Base : Point).read(args),
			center = Point.read(args, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getCenter(true)));
	};
}, {
	_decompose: function() {
		return this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.translate(this.getCenter().subtract(center));
	},

	getZoom: function() {
		var scaling = this._decompose().scaling;
		return (scaling.x + scaling.y) / 2;
	},

	setZoom: function(zoom) {
		this.transform(new Matrix().scale(zoom / this.getZoom(),
			this.getCenter()));
	},

	getRotation: function() {
		return this._decompose().rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			this.rotate(rotation - current);
		}
	},

	getScaling: function() {
		var scaling = this._decompose().scaling;
		return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling) {
			this.scale(scaling.x / current.x, scaling.y / current.y);
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.set.apply(matrix, arguments);
	},

	transform: function(matrix) {
		this._matrix.append(matrix);
	},

	scrollBy: function() {
		this.translate(Point.read(arguments).negate());
	}
}), {

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	getEventPoint: function(event) {
		return this.viewToProject(DomEvent.getOffset(event, this._element));
	},

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (document && typeof element === 'string')
				element = document.getElementById(element);
			var ctor = window ? CanvasView : View;
			return new ctor(project, element);
		}
	}
},
new function() {
	if (!window)
		return;
	var prevFocus,
		tempFocus,
		dragging = false,
		mouseDown = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[
				target.getAttribute('id')];
	}

	function updateFocus() {
		var view = View._focused;
		if (!view || !view.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				if ((view = View._views[i]).isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, event, point) {
		view._handleMouseEvent('mousemove', event, point);
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {},
		docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML')) {
					var offset = DomEvent.getOffset(event, view._element),
						x = offset.x,
						abs = Math.abs,
						ax = abs(x),
						max = 1 << 25,
						diff = ax - max;
					offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
					handleMouseMove(view, event, view.viewToProject(offset));
				}
			},

			scroll: updateFocus
		};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event);
		if (!dragging) {
			dragging = true;
			view._handleMouseEvent('mousedown', event);
		}
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!mouseDown) {
			var target = getView(event);
			if (target) {
				if (view !== target) {
					if (view)
						handleMouseMove(view, event);
					if (!prevFocus)
						prevFocus = view;
					view = View._focused = tempFocus = target;
				}
			} else if (tempFocus && tempFocus === view) {
				if (prevFocus && !prevFocus.isInserted())
					prevFocus = null;
				view = View._focused = prevFocus;
				prevFocus = null;
				updateFocus();
			}
		}
		if (view)
			handleMouseMove(view, event);
	};

	docEvents[mousedown] = function() {
		mouseDown = true;
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (view && dragging)
			view._handleMouseEvent('mouseup', event);
		mouseDown = dragging = false;
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var called = false,
		prevented = false,
		fallbacks = {
			doubleclick: 'click',
			mousedrag: 'mousemove'
		},
		wasInView = false,
		overView,
		downPoint,
		lastPoint,
		downItem,
		overItem,
		dragItem,
		clickItem,
		clickTime,
		dblClick;

	function emitMouseEvent(obj, target, type, event, point, prevPoint,
			stopItem) {
		var stopped = false,
			mouseEvent;

		function emit(obj, type) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point,
							target || obj,
							prevPoint ? point.subtract(prevPoint) : null);
				}
				if (obj.emit(type, mouseEvent)) {
					called = true;
					if (mouseEvent.prevented)
						prevented = true;
					if (mouseEvent.stopped)
						return stopped = true;
				}
			} else {
				var fallback = fallbacks[type];
				if (fallback)
					return emit(obj, fallback);
			}
		}

		while (obj && obj !== stopItem) {
			if (emit(obj, type))
				break;
			obj = obj._parent;
		}
		return stopped;
	}

	function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
		view._project.removeOn(type);
		prevented = called = false;
		return (dragItem && emitMouseEvent(dragItem, null, type, event,
					point, prevPoint)
			|| hitItem && hitItem !== dragItem
				&& !hitItem.isDescendant(dragItem)
				&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?
					'mousemove' : type, event, point, prevPoint, dragItem)
			|| emitMouseEvent(view, dragItem || hitItem || view, type, event,
					point, prevPoint));
	}

	var itemEventsMap = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleMouseEvent: function(type, event, point) {
			var itemEvents = this._itemEvents,
				hitItems = itemEvents.native[type],
				nativeMove = type === 'mousemove',
				tool = this._scope.tool,
				view = this;

			function responds(type) {
				return itemEvents.virtual[type] || view.responds(type)
						|| tool && tool.responds(type);
			}

			if (nativeMove && dragging && responds('mousedrag'))
				type = 'mousedrag';
			if (!point)
				point = this.getEventPoint(event);

			var inView = this.getBounds().contains(point),
				hit = hitItems && inView && view._project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				hitItem = hit && hit.item || null,
				handle = false,
				mouse = {};
			mouse[type.substr(5)] = true;

			if (hitItems && hitItem !== overItem) {
				if (overItem) {
					emitMouseEvent(overItem, null, 'mouseleave', event, point);
				}
				if (hitItem) {
					emitMouseEvent(hitItem, null, 'mouseenter', event, point);
				}
				overItem = hitItem;
			}
			if (wasInView ^ inView) {
				emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
						event, point);
				overView = inView ? this : null;
				handle = true;
			}
			if ((inView || mouse.drag) && !point.equals(lastPoint)) {
				emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
						event, point, lastPoint);
				handle = true;
			}
			wasInView = inView;
			if (mouse.down && inView || mouse.up && downPoint) {
				emitMouseEvents(this, hitItem, type, event, point, downPoint);
				if (mouse.down) {
					dblClick = hitItem === clickItem
						&& (Date.now() - clickTime < 300);
					downItem = clickItem = hitItem;
					if (!prevented && hitItem) {
						var item = hitItem;
						while (item && !item.responds('mousedrag'))
							item = item._parent;
						if (item)
							dragItem = hitItem;
					}
					downPoint = point;
				} else if (mouse.up) {
					if (!prevented && hitItem === downItem) {
						clickTime = Date.now();
						emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
								: 'click', event, point, downPoint);
						dblClick = false;
					}
					downItem = dragItem = null;
				}
				wasInView = false;
				handle = true;
			}
			lastPoint = point;
			if (handle && tool) {
				called = tool._handleMouseEvent(type, event, point, mouse)
					|| called;
			}

			if (
				event.cancelable !== false
				&& (called && !mouse.move || mouse.down && responds('mouseup'))
			) {
				event.preventDefault();
			}
		},

		_handleKeyEvent: function(type, event, key, character) {
			var scope = this._scope,
				tool = scope.tool,
				keyEvent;

			function emit(obj) {
				if (obj.responds(type)) {
					paper = scope;
					obj.emit(type, keyEvent = keyEvent
							|| new KeyEvent(type, event, key, character));
				}
			}

			if (this.isVisible()) {
				emit(this);
				if (tool && tool.responds(type))
					emit(tool);
			}
		},

		_countItemEvent: function(type, sign) {
			var itemEvents = this._itemEvents,
				native = itemEvents.native,
				virtual = itemEvents.virtual;
			for (var key in itemEventsMap) {
				native[key] = (native[key] || 0)
						+ (itemEventsMap[key][type] || 0) * sign;
			}
			virtual[type] = (virtual[type] || 0) + sign;
		},

		statics: {
			updateFocus: updateFocus,

			_resetState: function() {
				dragging = mouseDown = called = wasInView = false;
				prevFocus = tempFocus = overView = downPoint = lastPoint =
					downItem = overItem = dragItem = clickItem = clickTime =
					dblClick = null;
			}
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof window.HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ Base.slice(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		var ctx = this._context = canvas.getContext('2d');
		ctx.save();
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(ctx,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
		this._needsUpdate = true;
	},

	remove: function remove() {
		this._context.restore();
		return remove.base.call(this);
	},

	_setElementSize: function _setElementSize(width, height) {
		var pixelRatio = this._pixelRatio;
		_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
		if (pixelRatio !== 1) {
			var element = this._element,
				ctx = this._context;
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			ctx.restore();
			ctx.save();
			ctx.scale(pixelRatio, pixelRatio);
		}
	},

	getContext: function() {
		return this._context;
	},

	getPixelSize: function getPixelSize(size) {
		var agent = paper.agent,
			pixels;
		if (agent && agent.firefox) {
			pixels = getPixelSize.base.call(this, size);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		if (!this._needsUpdate)
			return false;
		var project = this._project,
			ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		if (project)
			project.draw(ctx, this._matrix, this._pixelRatio);
		this._needsUpdate = false;
		return true;
	}
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
		this.type = event && event.type;
	},

	prevented: false,
	stopped: false,

	preventDefault: function() {
		this.prevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.stopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getTimeStamp: function() {
		return this.event.timeStamp;
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(type, event, key, character) {
		this.type = type;
		this.event = event;
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	var keyLookup = {
			'\t': 'tab',
			' ': 'space',
			'\b': 'backspace',
			'\x7f': 'delete',
			'Spacebar': 'space',
			'Del': 'delete',
			'Win': 'meta',
			'Esc': 'escape'
		},

		charLookup = {
			'tab': '\t',
			'space': ' ',
			'enter': '\r'
		},

		keyMap = {},
		charMap = {},
		metaFixMap,
		downKey,

		modifiers = new Base({
			shift: false,
			control: false,
			alt: false,
			meta: false,
			capsLock: false,
			space: false
		}).inject({
			option: {
				get: function() {
					return this.alt;
				}
			},

			command: {
				get: function() {
					var agent = paper && paper.agent;
					return agent && agent.mac ? this.meta : this.control;
				}
			}
		});

	function getKey(event) {
		var key = event.key || event.keyIdentifier;
		key = /^U\+/.test(key)
				? String.fromCharCode(parseInt(key.substr(2), 16))
				: /^Arrow[A-Z]/.test(key) ? key.substr(5)
				: key === 'Unidentified'  || key === undefined
					? String.fromCharCode(event.keyCode)
					: key;
		return keyLookup[key] ||
				(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
	}

	function handleKey(down, key, character, event) {
		var type = down ? 'keydown' : 'keyup',
			view = View._focused,
			name;
		keyMap[key] = down;
		if (down) {
			charMap[key] = character;
		} else {
			delete charMap[key];
		}
		if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
			modifiers[name] = down;
			var agent = paper && paper.agent;
			if (name === 'meta' && agent && agent.mac) {
				if (down) {
					metaFixMap = {};
				} else {
					for (var k in metaFixMap) {
						if (k in charMap)
							handleKey(false, k, metaFixMap[k], event);
					}
					metaFixMap = null;
				}
			}
		} else if (down && metaFixMap) {
			metaFixMap[key] = character;
		}
		if (view) {
			view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
					character);
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var key = getKey(event),
				agent = paper && paper.agent;
			if (key.length > 1 || agent && (agent.chrome && (event.altKey
						|| agent.mac && event.metaKey
						|| !agent.mac && event.ctrlKey))) {
				handleKey(true, key,
						charLookup[key] || (key.length > 1 ? '' : key), event);
			} else {
				downKey = key;
			}
		},

		keypress: function(event) {
			if (downKey) {
				var key = getKey(event),
					code = event.charCode,
					character = code >= 32 ? String.fromCharCode(code)
						: key.length > 1 ? '' : key;
				if (key !== downKey) {
					key = character.toLowerCase();
				}
				handleKey(true, key, character, event);
				downKey = null;
			}
		},

		keyup: function(event) {
			var key = getKey(event);
			if (key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		this.type = type;
		this.event = event;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return this.tool[/^mouse(down|up)$/.test(this.type)
				? '_downCount' : '_moveCount'];
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
			'onKeyUp'],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._moveCount = -1;
		this._downCount = -1;
		this.set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_handleMouseEvent: function(type, event, point, mouse) {
		paper = this._scope;
		if (mouse.drag && !this.responds(type))
			type = 'mousemove';
		var move = mouse.move || mouse.drag,
			responds = this.responds(type),
			minDistance = this.minDistance,
			maxDistance = this.maxDistance,
			called = false,
			tool = this;
		function update(minDistance, maxDistance) {
			var pt = point,
				toolPoint = move ? tool._point : (tool._downPoint || pt);
			if (move) {
				if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
					return false;
				}
				if (toolPoint && (minDistance != null || maxDistance != null)) {
					var vector = pt.subtract(toolPoint),
						distance = vector.getLength();
					if (distance < (minDistance || 0))
						return false;
					if (maxDistance) {
						pt = toolPoint.add(vector.normalize(
								Math.min(distance, maxDistance)));
					}
				}
				tool._moveCount++;
			}
			tool._point = pt;
			tool._lastPoint = toolPoint || pt;
			if (mouse.down) {
				tool._moveCount = -1;
				tool._downPoint = pt;
				tool._downCount++;
			}
			return true;
		}

		function emit() {
			if (responds) {
				called = tool.emit(type, new ToolEvent(tool, type, event))
						|| called;
			}
		}

		if (mouse.down) {
			update();
			emit();
		} else if (mouse.up) {
			update(null, maxDistance);
			emit();
		} else if (responds) {
			while (update(minDistance, maxDistance))
				emit();
		}
		return called;
	}

});

var Tween = Base.extend(Emitter, {
	_class: 'Tween',

	statics: {
		easings: new Base({
			linear: function(t) {
				return t;
			},

			easeInQuad: function(t) {
				return t * t;
			},

			easeOutQuad: function(t) {
				return t * (2 - t);
			},

			easeInOutQuad: function(t) {
				return t < 0.5
					? 2 * t * t
					: -1 + 2 * (2 - t) * t;
			},

			easeInCubic: function(t) {
				return t * t * t;
			},

			easeOutCubic: function(t) {
				return --t * t * t + 1;
			},

			easeInOutCubic: function(t) {
				return t < 0.5
					? 4 * t * t * t
					: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
			},

			easeInQuart: function(t) {
				return t * t * t * t;
			},

			easeOutQuart: function(t) {
				return 1 - (--t) * t * t * t;
			},

			easeInOutQuart: function(t) {
				return t < 0.5
					? 8 * t * t * t * t
					: 1 - 8 * (--t) * t * t * t;
			},

			easeInQuint: function(t) {
				return t * t * t * t * t;
			},

			easeOutQuint: function(t) {
				return 1 + --t * t * t * t * t;
			},

			easeInOutQuint: function(t) {
				return t < 0.5
					? 16 * t * t * t * t * t
					: 1 + 16 * (--t) * t * t * t * t;
			}
		})
	},

	initialize: function Tween(object, from, to, duration, easing, start) {
		this.object = object;
		var type = typeof easing;
		var isFunction = type === 'function';
		this.type = isFunction
			? type
			: type === 'string'
				? easing
				: 'linear';
		this.easing = isFunction ? easing : Tween.easings[this.type];
		this.duration = duration;
		this.running = false;

		this._then = null;
		this._startTime = null;
		var state = from || to;
		this._keys = state ? Object.keys(state) : [];
		this._parsedKeys = this._parseKeys(this._keys);
		this._from = state && this._getState(from);
		this._to = state && this._getState(to);
		if (start !== false) {
			this.start();
		}
	},

	then: function(then) {
		this._then = then;
		return this;
	},

	start: function() {
		this._startTime = null;
		this.running = true;
		return this;
	},

	stop: function() {
		this.running = false;
		return this;
	},

	update: function(progress) {
		if (this.running) {
			if (progress >= 1) {
				progress = 1;
				this.running = false;
			}

			var factor = this.easing(progress),
				keys = this._keys,
				getValue = function(value) {
					return typeof value === 'function'
						? value(factor, progress)
						: value;
				};
			for (var i = 0, l = keys && keys.length; i < l; i++) {
				var key = keys[i],
					from = getValue(this._from[key]),
					to = getValue(this._to[key]),
					value = (from && to && from.__add && to.__add)
						? to.__subtract(from).__multiply(factor).__add(from)
						: ((to - from) * factor) + from;
				this._setProperty(this._parsedKeys[key], value);
			}

			if (this.responds('update')) {
				this.emit('update', new Base({
					progress: progress,
					factor: factor
				}));
			}
			if (!this.running && this._then) {
				this._then(this.object);
			}
		}
		return this;
	},

	_events: {
		onUpdate: {}
	},

	_handleFrame: function(time) {
		var startTime = this._startTime,
			progress = startTime
				? (time - startTime) / this.duration
				: 0;
		if (!startTime) {
			this._startTime = time;
		}
		this.update(progress);
	},

	_getState: function(state) {
		var keys = this._keys,
			result = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = this._parsedKeys[key],
				current = this._getProperty(path),
				value;
			if (state) {
				var resolved = this._resolveValue(current, state[key]);
				this._setProperty(path, resolved);
				value = this._getProperty(path);
				value = value && value.clone ? value.clone() : value;
				this._setProperty(path, current);
			} else {
				value = current && current.clone ? current.clone() : current;
			}
			result[key] = value;
		}
		return result;
	},

	_resolveValue: function(current, value) {
		if (value) {
			if (Array.isArray(value) && value.length === 2) {
				var operator = value[0];
				return (
					operator &&
					operator.match &&
					operator.match(/^[+\-\*\/]=/)
				)
					? this._calculate(current, operator[0], value[1])
					: value;
			} else if (typeof value === 'string') {
				var match = value.match(/^[+\-*/]=(.*)/);
				if (match) {
					var parsed = JSON.parse(match[1].replace(
						/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
						'"$2": '
					));
					return this._calculate(current, value[0], parsed);
				}
			}
		}
		return value;
	},

	_calculate: function(left, operator, right) {
		return paper.PaperScript.calculateBinary(left, operator, right);
	},

	_parseKeys: function(keys) {
		var parsed = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = key
					.replace(/\.([^.]*)/g, '/$1')
					.replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
			parsed[key] = path.split('/');
		}
		return parsed;
	},

	_getProperty: function(path, offset) {
		var obj = this.object;
		for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
			obj = obj[path[i]];
		}
		return obj;
	},

	_setProperty: function(path, value) {
		var dest = this._getProperty(path, 1);
		if (dest) {
			dest[path[path.length - 1]] = value;
		}
	}
});

var Http = {
	request: function(options) {
		var xhr = new self.XMLHttpRequest();
		xhr.open((options.method || 'get').toUpperCase(), options.url,
				Base.pick(options.async, true));
		if (options.mimeType)
			xhr.overrideMimeType(options.mimeType);
		xhr.onload = function() {
			var status = xhr.status;
			if (status === 0 || status === 200) {
				if (options.onLoad) {
					options.onLoad.call(xhr, xhr.responseText);
				}
			} else {
				xhr.onerror();
			}
		};
		xhr.onerror = function() {
			var status = xhr.status,
				message = 'Could not load "' + options.url + '" (Status: '
						+ status + ')';
			if (options.onError) {
				options.onError(message, status);
			} else {
				throw new Error(message);
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = Base.exports.CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		if (!window)
			return null;
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
			clear = false;
		}
		var ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('Canvas ' + canvas +
					' is unable to provide a 2D context.');
		}
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		var canvas = this.getCanvas(width, height);
		return canvas ? canvas.getContext('2d') : null;
	},

	release: function(obj) {
		var canvas = obj && obj.canvas ? obj.canvas : obj;
		if (canvas && canvas.getContext) {
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	if (ctx) {
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
							? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	}

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SvgElement = new function() {
	var svg = 'http://www.w3.org/2000/svg',
		xmlns = 'http://www.w3.org/2000/xmlns',
		xlink = 'http://www.w3.org/1999/xlink',
		attributeNamespace = {
			href: xlink,
			xlink: xmlns,
			xmlns: xmlns + '/',
			'xmlns:xlink': xmlns + '/'
		};

	function create(tag, attributes, formatter) {
		return set(document.createElementNS(svg, tag), attributes, formatter);
	}

	function get(node, name) {
		var namespace = attributeNamespace[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		return value === 'null' ? null : value;
	}

	function set(node, attributes, formatter) {
		for (var name in attributes) {
			var value = attributes[name],
				namespace = attributeNamespace[name];
			if (typeof value === 'number' && formatter)
				value = formatter.number(value);
			if (namespace) {
				node.setAttributeNS(namespace, name, value);
			} else {
				node.setAttribute(name, value);
			}
		}
		return node;
	}

	return {
		svg: svg,
		xmlns: xmlns,
		xlink: xlink,

		create: create,
		get: get,
		set: set
	};
};

var SvgStyles = Base.each({
	fillColor: ['fill', 'color'],
	fillRule: ['fill-rule', 'string'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'style']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

new function() {
	var formatter;

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			var point;
			if (matrix.isInvertible()) {
				matrix = matrix._shiftless();
				point = matrix._inverseTransform(trans);
				trans = null;
			} else {
				point = new Point();
			}
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling,
					skew = decomposed.skewing;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (skew.x)
					parts.push('skewX(' + formatter.number(skew.x) + ')');
				if (skew.y)
					parts.push('skewY(' + formatter.number(skew.y) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = SvgElement.create('g', attrs, formatter);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = SvgElement.create('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					SvgElement.set(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages == false && image && image.src
				|| item.toDataURL();
		return SvgElement.create('image', attrs, formatter);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			length = segments.length,
			type,
			attrs = getTransform(item._matrix);
		if (matchShapes && length >= 2 && !item.hasHandles()) {
			if (length > 2) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for (var i = 0; i < length; i++) {
					parts.push(formatter.point(segments[i]._point));
				}
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var start = segments[0]._point,
					end = segments[1]._point;
				attrs.set({
					x1: start.x,
					y1: start.y,
					x2: end.x,
					y2: end.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return SvgElement.create('path', attrs, formatter);
	}

	function exportSymbolItem(item, options) {
		var attrs = getTransform(item._matrix, true),
			definition = item._definition,
			node = getDefinition(definition, 'symbol'),
			definitionItem = definition._item,
			bounds = definitionItem.getStrokeBounds();
		if (!node) {
			node = SvgElement.create('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			node.appendChild(exportSVG(definitionItem, options));
			setDefinition(definition, node, 'symbol');
		}
		attrs.href = '#' + node.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = bounds.width;
		attrs.height = bounds.height;
		attrs.overflow = 'visible';
		return SvgElement.create('use', attrs, formatter);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin(),
				destination = color.getDestination(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
					+ 'Gradient', attrs, formatter);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha(),
					offset = stop._offset;
				attrs = {
					offset: offset == null ? i / (l - 1) : offset
				};
				if (stopColor)
					attrs['stop-color'] = stopColor.toCSS(true);
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(
						SvgElement.create('stop', attrs, formatter));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = SvgElement.create('text', getTransform(item._matrix, true),
				formatter);
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		SymbolItem: exportSymbolItem,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent(),
			style = [];

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SvgStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				if (type === 'style') {
					style.push(entry.attribute + ': ' + value);
				} else {
					attrs[entry.attribute] = value == null ? 'none'
							: type === 'color' ? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array' ? value.join(',')
							: type === 'lookup' ? entry.toSVG[value]
							: value;
				}
			}
		});

		if (style.length)
			attrs.style = style.join(';');

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return SvgElement.set(node, attrs, formatter);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-'
				+ (item._id || item.__id || (item.__id = UID.get('svg')))];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + typeId;
		definitions.svgs[type + '-' + (item._id || item.__id)] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = SvgElement.create('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(SvgElement.create('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new self.XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var children = this._children,
				view = this.getView(),
				bounds = Base.pick(options.bounds, 'view'),
				mx = options.matrix || bounds === 'view' && view._matrix,
				matrix = mx && Matrix.read([mx]),
				rect = bounds === 'view'
					? new Rectangle([0, 0], view.getViewSize())
					: bounds === 'content'
						? Item._getBounds(children, matrix, { stroke: true })
							.rect
						: Rectangle.read([bounds], 0, { readNull: true }),
				attrs = {
					version: '1.1',
					xmlns: SvgElement.svg,
					'xmlns:xlink': SvgElement.xlink,
				};
			if (rect) {
				attrs.width = rect.width;
				attrs.height = rect.height;
				if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
					attrs.viewBox = formatter.rectangle(rect);
			}
			var node = SvgElement.create('svg', attrs, formatter),
				parent = node;
			if (matrix && !matrix.isIdentity()) {
				parent = node.appendChild(SvgElement.create('g',
						getTransform(matrix), formatter));
			}
			for (var i = 0, l = children.length; i < l; i++) {
				parent.appendChild(exportSVG(children[i], options, true));
			}
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	var definitions = {},
		rootSize;

	function getValue(node, name, isString, allowNull, allowPercent,
			defaultValue) {
		var value = SvgElement.get(node, name) || defaultValue,
			res = value == null
				? allowNull
					? null
					: isString ? '' : 0
				: isString
					? value
					: parseFloat(value);
		return /%\s*$/.test(value)
			? (res / 100) * (allowPercent ? 1
				: rootSize[/x|^width/.test(name) ? 'width' : 'height'])
			: res;
	}

	function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
		x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
		y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull, allowPercent) {
		w = getValue(node, w || 'width', false, allowNull, allowPercent);
		h = getValue(node, h || 'height', false, allowNull, allowPercent);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none' ? null
				: type === 'number' ? parseFloat(value)
				: type === 'array' ?
					value ? value.split(/[\s,]+/g).map(parseFloat) : []
				: type === 'color' ? getDefinition(value) || value
				: type === 'lookup' ? lookup[value]
				: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			isDefs = type === 'defs',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip && !isDefs) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importNode(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& !/^defs$/i.test(childNode.nodeName)
					&& (child = importNode(childNode, options, false))
					&& !(child instanceof SymbolDefinition))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || isDefs) {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		return PathItem.create(node.getAttribute('d'));
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			radial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
			if (gradient._radial ^ radial) {
				gradient = gradient.clone();
				gradient._radial = radial;
			}
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, radial);
		}
		var origin, destination, highlight,
			scaleToBounds = getValue(node, 'gradientUnits', true) !==
				'userSpaceOnUse';
		if (radial) {
			origin = getPoint(node, 'cx', 'cy', false, scaleToBounds,
				'50%', '50%');
			destination = origin.add(
				getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
			highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
		} else {
			origin = getPoint(node, 'x1', 'y1', false, scaleToBounds,
				'0%', '0%');
			destination = getPoint(node, 'x2', 'y2', false, scaleToBounds,
				'100%', '0%');
		}
		var color = applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
		color._scaleToBounds = scaleToBounds;
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					return importNode(child, options, isRoot);
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node);
				this.setSize(size);
				var center = getPoint(node).add(size.divide(2));
				this._matrix.append(new Matrix().translate(center));
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new SymbolDefinition(
					importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node);
			return definition
					? definition instanceof SymbolDefinition
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(
					getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			return new Shape.Rectangle(new Rectangle(
						getPoint(node),
						getSize(node)
					), getSize(node, 'rx', 'ry'));
			},

		line: function(node) {
			return new Path.Line(
					getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node).add(
					getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		},

		switch: importGroup
	};

	function applyTransform(item, value, name, node) {
		if (item.transform) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.append(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1] || 0, v[2] || 0);
					break;
				case 'translate':
					matrix.translate(v[0], v[1] || 0);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	}

	function applyOpacity(item, value, name) {
		var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
			color = item[key] && item[key]();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SvgStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			if (item[entry.set]) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color') {
					var color = item[entry.get]();
					if (color) {
						if (color._scaleToBounds) {
							var bounds = item.getBounds();
							color.transform(new Matrix()
								.translate(bounds.getPoint())
								.scale(bounds.getSize()));
						}
					}
				}
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			if (item.setVisible)
				item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			if (item.setVisible)
				item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			if (item.setOffset) {
				var percent = value.match(/(.*)%$/);
				item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
			}
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, null, null, true),
				group,
				matrix;
			if (item instanceof Group) {
				var scale = size ? size.divide(rect.getSize()) : 1,
				matrix = new Matrix().scale(scale)
						.translate(rect.getPoint().negate());
				group = item;
			} else if (item instanceof SymbolDefinition) {
				if (size)
					rect.setSize(size);
				group = item._item;
			}
			if (group)  {
				if (getAttribute(node, 'overflow', styles) !== 'visible') {
					var clip = new Shape.Rectangle(rect);
					clip.setClipMask(true);
					group.addChild(clip);
				}
				if (matrix)
					group.transform(matrix);
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value && node.style) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value ? undefined
				: value === 'none' ? null
				: value;
	}

	function applyAttributes(item, node, isRoot) {
		var parent = node.parentNode,
			styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && !/^defs$/i.test(parent.tagName)
						&& DomElement.getStyles(parent) || {}
			};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			item = value !== undefined
					&& apply(item, value, name, node, styles) || item;
		});
		return item;
	}

	function getDefinition(value) {
		var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
			name = match && match[1],
			res = name && definitions[window
					? name.replace(window.location.href.split('#')[0] + '#', '')
					: name];
		if (res && res._scaleToBounds) {
			res = res.clone();
			res._scaleToBounds = true;
		}
		return res;
	}

	function importNode(node, options, isRoot) {
		var type = node.nodeName.toLowerCase(),
			isElement = type !== '#document',
			body = document.body,
			container,
			parent,
			next;
		if (isRoot && isElement) {
			rootSize = paper.getView().getSize();
			rootSize = getSize(node, null, null, true) || rootSize;
			container = SvgElement.create('svg', {
				style: 'stroke-width: 1px; stroke-miterlimit: 10'
			});
			parent = node.parentNode;
			next = node.nextSibling;
			container.appendChild(node);
			body.appendChild(container);
		}
		var settings = paper.settings,
			applyMatrix = settings.applyMatrix,
			insertItems = settings.insertItems;
		settings.applyMatrix = false;
		settings.insertItems = false;
		var importer = importers[type],
			item = importer && importer(node, type, options, isRoot) || null;
		settings.insertItems = insertItems;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (isElement && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport,
				data = isElement && node.getAttribute('data-paper-data');
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (container) {
			body.removeChild(container);
			if (parent) {
				if (next) {
					parent.insertBefore(node, next);
				} else {
					parent.appendChild(node);
				}
			}
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	function importSVG(source, options, owner) {
		if (!source)
			return null;
		options = typeof options === 'function' ? { onLoad: options }
				: options || {};
		var scope = paper,
			item = null;

		function onLoad(svg) {
			try {
				var node = typeof svg === 'object'
					? svg
					: new self.DOMParser().parseFromString(
						svg.trim(),
						'image/svg+xml'
					);
				if (!node.nodeName) {
					node = null;
					throw new Error('Unsupported SVG source: ' + source);
				}
				paper = scope;
				item = importNode(node, options, true);
				if (!options || options.insert !== false) {
					owner._insertItem(undefined, item);
				}
				var onLoad = options.onLoad;
				if (onLoad)
					onLoad(item, svg);
			} catch (e) {
				onError(e);
			}
		}

		function onError(message, status) {
			var onError = options.onError;
			if (onError) {
				onError(message, status);
			} else {
				throw new Error(message);
			}
		}

		if (typeof source === 'string' && !/^[\s\S]*</.test(source)) {
			var node = document.getElementById(source);
			if (node) {
				onLoad(node);
			} else {
				Http.request({
					url: source,
					async: true,
					onLoad: onLoad,
					onError: onError
				});
			}
		} else if (typeof File !== 'undefined' && source instanceof File) {
			var reader = new FileReader();
			reader.onload = function() {
				onLoad(reader.result);
			};
			reader.onerror = function() {
				onError(reader.error);
			};
			return reader.readAsText(source);
		} else {
			onLoad(source);
		}

		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return importSVG(node, options, this);
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, this);
		}
	});
};

Base.exports.PaperScript = function() {
	var global = this,
		acorn = global.acorn;
	if (!acorn && typeof require !== 'undefined') {
		try { acorn = require('acorn'); } catch(e) {}
	}
	if (!acorn) {
		var exports, module;
		acorn = exports = module = {};

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports);
  if (typeof define == "function" && define.amd) return define(["exports"], mod);
  mod(root.acorn || (root.acorn = {}));
})(this, function(exports) {
  "use strict";

  exports.version = "0.5.0";

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();
	return parseTopLevel(options.program);
  };

  var defaultOptions = exports.defaultOptions = {
	ecmaVersion: 5,
	strictSemicolons: false,
	allowTrailingCommas: true,
	forbidReserved: false,
	allowReturnOutsideFunction: false,
	locations: false,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null
  };

  function setOptions(opts) {
	options = opts || {};
	for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
	  options[opt] = defaultOptions[opt];
	sourceFile = options.sourceFile || null;
  }

  var getLineInfo = exports.getLineInfo = function(input, offset) {
	for (var line = 1, cur = 0;;) {
	  lineBreak.lastIndex = cur;
	  var match = lineBreak.exec(input);
	  if (match && match.index < offset) {
		++line;
		cur = match.index + match[0].length;
	  } else break;
	}
	return {line: line, column: offset - cur};
  };

  exports.tokenize = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();

	var t = {};
	function getToken(forceRegexp) {
	  lastEnd = tokEnd;
	  readToken(forceRegexp);
	  t.start = tokStart; t.end = tokEnd;
	  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
	  t.type = tokType; t.value = tokVal;
	  return t;
	}
	getToken.jumpTo = function(pos, reAllowed) {
	  tokPos = pos;
	  if (options.locations) {
		tokCurLine = 1;
		tokLineStart = lineBreak.lastIndex = 0;
		var match;
		while ((match = lineBreak.exec(input)) && match.index < pos) {
		  ++tokCurLine;
		  tokLineStart = match.index + match[0].length;
		}
	  }
	  tokRegexpAllowed = reAllowed;
	  skipSpace();
	};
	return getToken;
  };

  var tokPos;

  var tokStart, tokEnd;

  var tokStartLoc, tokEndLoc;

  var tokType, tokVal;

  var tokRegexpAllowed;

  var tokCurLine, tokLineStart;

  var lastStart, lastEnd, lastEndLoc;

  var inFunction, labels, strict;

  function raise(pos, message) {
	var loc = getLineInfo(input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
	throw err;
  }

  var empty = [];

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
					  "continue": _continue, "debugger": _debugger, "default": _default,
					  "do": _do, "else": _else, "finally": _finally, "for": _for,
					  "function": _function, "if": _if, "return": _return, "switch": _switch,
					  "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
					  "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
					  "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
					  "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
					  "void": {keyword: "void", prefix: true, beforeExpr: true},
					  "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _multiplyModulo = {binop: 10, beforeExpr: true};

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
					  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
					  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
					  num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  function makePredicate(words) {
	words = words.split(" ");
	var f = "", cats = [];
	out: for (var i = 0; i < words.length; ++i) {
	  for (var j = 0; j < cats.length; ++j)
		if (cats[j][0].length == words[i].length) {
		  cats[j].push(words[i]);
		  continue out;
		}
	  cats.push([words[i]]);
	}
	function compareTo(arr) {
	  if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
	  f += "switch(str){";
	  for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
	  f += "return true}return false;";
	}

	if (cats.length > 3) {
	  cats.sort(function(a, b) {return b.length - a.length;});
	  f += "switch(str.length){";
	  for (var i = 0; i < cats.length; ++i) {
		var cat = cats[i];
		f += "case " + cat[0].length + ":";
		compareTo(cat);
	  }
	  f += "}";

	} else {
	  compareTo(words);
	}
	return new Function("str", f);
  }

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  var isStrictBadIdWord = makePredicate("eval arguments");

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var newline = /[\n\r\u2028\u2029]/;

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  function line_loc_t() {
	this.line = tokCurLine;
	this.column = tokPos - tokLineStart;
  }

  function initTokenState() {
	tokCurLine = 1;
	tokPos = tokLineStart = 0;
	tokRegexpAllowed = true;
	skipSpace();
  }

  function finishToken(type, val) {
	tokEnd = tokPos;
	if (options.locations) tokEndLoc = new line_loc_t;
	tokType = type;
	skipSpace();
	tokVal = val;
	tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var start = tokPos, end = input.indexOf("*/", tokPos += 2);
	if (end === -1) raise(tokPos - 2, "Unterminated comment");
	tokPos = end + 2;
	if (options.locations) {
	  lineBreak.lastIndex = start;
	  var match;
	  while ((match = lineBreak.exec(input)) && match.index < tokPos) {
		++tokCurLine;
		tokLineStart = match.index + match[0].length;
	  }
	}
	if (options.onComment)
	  options.onComment(true, input.slice(start + 2, end), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
	var start = tokPos;
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var ch = input.charCodeAt(tokPos+=2);
	while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	  ++tokPos;
	  ch = input.charCodeAt(tokPos);
	}
	if (options.onComment)
	  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipSpace() {
	while (tokPos < inputLen) {
	  var ch = input.charCodeAt(tokPos);
	  if (ch === 32) {
		++tokPos;
	  } else if (ch === 13) {
		++tokPos;
		var next = input.charCodeAt(tokPos);
		if (next === 10) {
		  ++tokPos;
		}
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch === 10 || ch === 8232 || ch === 8233) {
		++tokPos;
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch > 8 && ch < 14) {
		++tokPos;
	  } else if (ch === 47) {
		var next = input.charCodeAt(tokPos + 1);
		if (next === 42) {
		  skipBlockComment();
		} else if (next === 47) {
		  skipLineComment();
		} else break;
	  } else if (ch === 160) {
		++tokPos;
	  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		++tokPos;
	  } else {
		break;
	  }
	}
  }

  function readToken_dot() {
	var next = input.charCodeAt(tokPos + 1);
	if (next >= 48 && next <= 57) return readNumber(true);
	++tokPos;
	return finishToken(_dot);
  }

  function readToken_slash() {
	var next = input.charCodeAt(tokPos + 1);
	if (tokRegexpAllowed) {++tokPos; return readRegexp();}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_multiplyModulo, 1);
  }

  function readToken_pipe_amp(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) {
	  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
		  newline.test(input.slice(lastEnd, tokPos))) {
		tokPos += 3;
		skipLineComment();
		skipSpace();
		return readToken();
	  }
	  return finishOp(_incDec, 2);
	}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) {
	var next = input.charCodeAt(tokPos + 1);
	var size = 1;
	if (next === code) {
	  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
	  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
	  return finishOp(_bitShift, size);
	}
	if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
		input.charCodeAt(tokPos + 3) == 45) {
	  tokPos += 4;
	  skipLineComment();
	  skipSpace();
	  return readToken();
	}
	if (next === 61)
	  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
	return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
	return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
	switch(code) {
	case 46:
	  return readToken_dot();

	case 40: ++tokPos; return finishToken(_parenL);
	case 41: ++tokPos; return finishToken(_parenR);
	case 59: ++tokPos; return finishToken(_semi);
	case 44: ++tokPos; return finishToken(_comma);
	case 91: ++tokPos; return finishToken(_bracketL);
	case 93: ++tokPos; return finishToken(_bracketR);
	case 123: ++tokPos; return finishToken(_braceL);
	case 125: ++tokPos; return finishToken(_braceR);
	case 58: ++tokPos; return finishToken(_colon);
	case 63: ++tokPos; return finishToken(_question);

	case 48:
	  var next = input.charCodeAt(tokPos + 1);
	  if (next === 120 || next === 88) return readHexNumber();
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
	  return readNumber(false);

	case 34: case 39:
	  return readString(code);

	case 47:
	  return readToken_slash(code);

	case 37: case 42:
	  return readToken_mult_modulo();

	case 124: case 38:
	  return readToken_pipe_amp(code);

	case 94:
	  return readToken_caret();

	case 43: case 45:
	  return readToken_plus_min(code);

	case 60: case 62:
	  return readToken_lt_gt(code);

	case 61: case 33:
	  return readToken_eq_excl(code);

	case 126:
	  return finishOp(_prefix, 1);
	}

	return false;
  }

  function readToken(forceRegexp) {
	if (!forceRegexp) tokStart = tokPos;
	else tokPos = tokStart + 1;
	if (options.locations) tokStartLoc = new line_loc_t;
	if (forceRegexp) return readRegexp();
	if (tokPos >= inputLen) return finishToken(_eof);

	var code = input.charCodeAt(tokPos);
	if (isIdentifierStart(code) || code === 92 ) return readWord();

	var tok = getTokenFromCode(code);

	if (tok === false) {
	  var ch = String.fromCharCode(code);
	  if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
	  raise(tokPos, "Unexpected character '" + ch + "'");
	}
	return tok;
  }

  function finishOp(type, size) {
	var str = input.slice(tokPos, tokPos + size);
	tokPos += size;
	finishToken(type, str);
  }

  function readRegexp() {
	var content = "", escaped, inClass, start = tokPos;
	for (;;) {
	  if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
	  var ch = input.charAt(tokPos);
	  if (newline.test(ch)) raise(start, "Unterminated regular expression");
	  if (!escaped) {
		if (ch === "[") inClass = true;
		else if (ch === "]" && inClass) inClass = false;
		else if (ch === "/" && !inClass) break;
		escaped = ch === "\\";
	  } else escaped = false;
	  ++tokPos;
	}
	var content = input.slice(start, tokPos);
	++tokPos;
	var mods = readWord1();
	if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
	try {
	  var value = new RegExp(content, mods);
	} catch (e) {
	  if (e instanceof SyntaxError) raise(start, e.message);
	  raise(e);
	}
	return finishToken(_regexp, value);
  }

  function readInt(radix, len) {
	var start = tokPos, total = 0;
	for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	  var code = input.charCodeAt(tokPos), val;
	  if (code >= 97) val = code - 97 + 10;
	  else if (code >= 65) val = code - 65 + 10;
	  else if (code >= 48 && code <= 57) val = code - 48;
	  else val = Infinity;
	  if (val >= radix) break;
	  ++tokPos;
	  total = total * radix + val;
	}
	if (tokPos === start || len != null && tokPos - start !== len) return null;

	return total;
  }

  function readHexNumber() {
	tokPos += 2;
	var val = readInt(16);
	if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
	return finishToken(_num, val);
  }

  function readNumber(startsWithDot) {
	var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
	if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
	if (input.charCodeAt(tokPos) === 46) {
	  ++tokPos;
	  readInt(10);
	  isFloat = true;
	}
	var next = input.charCodeAt(tokPos);
	if (next === 69 || next === 101) {
	  next = input.charCodeAt(++tokPos);
	  if (next === 43 || next === 45) ++tokPos;
	  if (readInt(10) === null) raise(start, "Invalid number");
	  isFloat = true;
	}
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

	var str = input.slice(start, tokPos), val;
	if (isFloat) val = parseFloat(str);
	else if (!octal || str.length === 1) val = parseInt(str, 10);
	else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
	else val = parseInt(str, 8);
	return finishToken(_num, val);
  }

  function readString(quote) {
	tokPos++;
	var out = "";
	for (;;) {
	  if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
	  var ch = input.charCodeAt(tokPos);
	  if (ch === quote) {
		++tokPos;
		return finishToken(_string, out);
	  }
	  if (ch === 92) {
		ch = input.charCodeAt(++tokPos);
		var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
		if (octal) octal = octal[0];
		while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
		if (octal === "0") octal = null;
		++tokPos;
		if (octal) {
		  if (strict) raise(tokPos - 2, "Octal literal in strict mode");
		  out += String.fromCharCode(parseInt(octal, 8));
		  tokPos += octal.length - 1;
		} else {
		  switch (ch) {
		  case 110: out += "\n"; break;
		  case 114: out += "\r"; break;
		  case 120: out += String.fromCharCode(readHexChar(2)); break;
		  case 117: out += String.fromCharCode(readHexChar(4)); break;
		  case 85: out += String.fromCharCode(readHexChar(8)); break;
		  case 116: out += "\t"; break;
		  case 98: out += "\b"; break;
		  case 118: out += "\u000b"; break;
		  case 102: out += "\f"; break;
		  case 48: out += "\0"; break;
		  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;
		  case 10:
			if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
			break;
		  default: out += String.fromCharCode(ch); break;
		  }
		}
	  } else {
		if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
		out += String.fromCharCode(ch);
		++tokPos;
	  }
	}
  }

  function readHexChar(len) {
	var n = readInt(16, len);
	if (n === null) raise(tokStart, "Bad character escape sequence");
	return n;
  }

  var containsEsc;

  function readWord1() {
	containsEsc = false;
	var word, first = true, start = tokPos;
	for (;;) {
	  var ch = input.charCodeAt(tokPos);
	  if (isIdentifierChar(ch)) {
		if (containsEsc) word += input.charAt(tokPos);
		++tokPos;
	  } else if (ch === 92) {
		if (!containsEsc) word = input.slice(start, tokPos);
		containsEsc = true;
		if (input.charCodeAt(++tokPos) != 117)
		  raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
		++tokPos;
		var esc = readHexChar(4);
		var escStr = String.fromCharCode(esc);
		if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
		if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
		  raise(tokPos - 4, "Invalid Unicode escape");
		word += escStr;
	  } else {
		break;
	  }
	  first = false;
	}
	return containsEsc ? word : input.slice(start, tokPos);
  }

  function readWord() {
	var word = readWord1();
	var type = _name;
	if (!containsEsc && isKeyword(word))
	  type = keywordTypes[word];
	return finishToken(type, word);
  }

  function next() {
	lastStart = tokStart;
	lastEnd = tokEnd;
	lastEndLoc = tokEndLoc;
	readToken();
  }

  function setStrict(strct) {
	strict = strct;
	tokPos = tokStart;
	if (options.locations) {
	  while (tokPos < tokLineStart) {
		tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
		--tokCurLine;
	  }
	}
	skipSpace();
	readToken();
  }

  function node_t() {
	this.type = null;
	this.start = tokStart;
	this.end = null;
  }

  function node_loc_t() {
	this.start = tokStartLoc;
	this.end = null;
	if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
	var node = new node_t();
	if (options.locations)
	  node.loc = new node_loc_t();
	if (options.directSourceFile)
	  node.sourceFile = options.directSourceFile;
	if (options.ranges)
	  node.range = [tokStart, 0];
	return node;
  }

  function startNodeFrom(other) {
	var node = new node_t();
	node.start = other.start;
	if (options.locations) {
	  node.loc = new node_loc_t();
	  node.loc.start = other.loc.start;
	}
	if (options.ranges)
	  node.range = [other.range[0], 0];

	return node;
  }

  function finishNode(node, type) {
	node.type = type;
	node.end = lastEnd;
	if (options.locations)
	  node.loc.end = lastEndLoc;
	if (options.ranges)
	  node.range[1] = lastEnd;
	return node;
  }

  function isUseStrict(stmt) {
	return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	  stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  function eat(type) {
	if (tokType === type) {
	  next();
	  return true;
	}
  }

  function canInsertSemicolon() {
	return !options.strictSemicolons &&
	  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  function semicolon() {
	if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  function expect(type) {
	if (tokType === type) next();
	else unexpected();
  }

  function unexpected() {
	raise(tokStart, "Unexpected token");
  }

  function checkLVal(expr) {
	if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
	  raise(expr.start, "Assigning to rvalue");
	if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
	  raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  function parseTopLevel(program) {
	lastStart = lastEnd = tokPos;
	if (options.locations) lastEndLoc = new line_loc_t;
	inFunction = strict = null;
	labels = [];
	readToken();

	var node = program || startNode(), first = true;
	if (!program) node.body = [];
	while (tokType !== _eof) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && isUseStrict(stmt)) setStrict(true);
	  first = false;
	}
	return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  function parseStatement() {
	if (tokType === _slash || tokType === _assign && tokVal == "/=")
	  readToken(true);

	var starttype = tokType, node = startNode();

	switch (starttype) {
	case _break: case _continue:
	  next();
	  var isBreak = starttype === _break;
	  if (eat(_semi) || canInsertSemicolon()) node.label = null;
	  else if (tokType !== _name) unexpected();
	  else {
		node.label = parseIdent();
		semicolon();
	  }

	  for (var i = 0; i < labels.length; ++i) {
		var lab = labels[i];
		if (node.label == null || lab.name === node.label.name) {
		  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
		  if (node.label && isBreak) break;
		}
	  }
	  if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
	  return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	case _debugger:
	  next();
	  semicolon();
	  return finishNode(node, "DebuggerStatement");

	case _do:
	  next();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  expect(_while);
	  node.test = parseParenExpression();
	  semicolon();
	  return finishNode(node, "DoWhileStatement");

	case _for:
	  next();
	  labels.push(loopLabel);
	  expect(_parenL);
	  if (tokType === _semi) return parseFor(node, null);
	  if (tokType === _var) {
		var init = startNode();
		next();
		parseVar(init, true);
		finishNode(init, "VariableDeclaration");
		if (init.declarations.length === 1 && eat(_in))
		  return parseForIn(node, init);
		return parseFor(node, init);
	  }
	  var init = parseExpression(false, true);
	  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
	  return parseFor(node, init);

	case _function:
	  next();
	  return parseFunction(node, true);

	case _if:
	  next();
	  node.test = parseParenExpression();
	  node.consequent = parseStatement();
	  node.alternate = eat(_else) ? parseStatement() : null;
	  return finishNode(node, "IfStatement");

	case _return:
	  if (!inFunction && !options.allowReturnOutsideFunction)
		raise(tokStart, "'return' outside of function");
	  next();

	  if (eat(_semi) || canInsertSemicolon()) node.argument = null;
	  else { node.argument = parseExpression(); semicolon(); }
	  return finishNode(node, "ReturnStatement");

	case _switch:
	  next();
	  node.discriminant = parseParenExpression();
	  node.cases = [];
	  expect(_braceL);
	  labels.push(switchLabel);

	  for (var cur, sawDefault; tokType != _braceR;) {
		if (tokType === _case || tokType === _default) {
		  var isCase = tokType === _case;
		  if (cur) finishNode(cur, "SwitchCase");
		  node.cases.push(cur = startNode());
		  cur.consequent = [];
		  next();
		  if (isCase) cur.test = parseExpression();
		  else {
			if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
			cur.test = null;
		  }
		  expect(_colon);
		} else {
		  if (!cur) unexpected();
		  cur.consequent.push(parseStatement());
		}
	  }
	  if (cur) finishNode(cur, "SwitchCase");
	  next();
	  labels.pop();
	  return finishNode(node, "SwitchStatement");

	case _throw:
	  next();
	  if (newline.test(input.slice(lastEnd, tokStart)))
		raise(lastEnd, "Illegal newline after throw");
	  node.argument = parseExpression();
	  semicolon();
	  return finishNode(node, "ThrowStatement");

	case _try:
	  next();
	  node.block = parseBlock();
	  node.handler = null;
	  if (tokType === _catch) {
		var clause = startNode();
		next();
		expect(_parenL);
		clause.param = parseIdent();
		if (strict && isStrictBadIdWord(clause.param.name))
		  raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
		expect(_parenR);
		clause.guard = null;
		clause.body = parseBlock();
		node.handler = finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = eat(_finally) ? parseBlock() : null;
	  if (!node.handler && !node.finalizer)
		raise(node.start, "Missing catch or finally clause");
	  return finishNode(node, "TryStatement");

	case _var:
	  next();
	  parseVar(node);
	  semicolon();
	  return finishNode(node, "VariableDeclaration");

	case _while:
	  next();
	  node.test = parseParenExpression();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  return finishNode(node, "WhileStatement");

	case _with:
	  if (strict) raise(tokStart, "'with' in strict mode");
	  next();
	  node.object = parseParenExpression();
	  node.body = parseStatement();
	  return finishNode(node, "WithStatement");

	case _braceL:
	  return parseBlock();

	case _semi:
	  next();
	  return finishNode(node, "EmptyStatement");

	default:
	  var maybeName = tokVal, expr = parseExpression();
	  if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
		for (var i = 0; i < labels.length; ++i)
		  if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
		var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
		labels.push({name: maybeName, kind: kind});
		node.body = parseStatement();
		labels.pop();
		node.label = expr;
		return finishNode(node, "LabeledStatement");
	  } else {
		node.expression = expr;
		semicolon();
		return finishNode(node, "ExpressionStatement");
	  }
	}
  }

  function parseParenExpression() {
	expect(_parenL);
	var val = parseExpression();
	expect(_parenR);
	return val;
  }

  function parseBlock(allowStrict) {
	var node = startNode(), first = true, strict = false, oldStrict;
	node.body = [];
	expect(_braceL);
	while (!eat(_braceR)) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && allowStrict && isUseStrict(stmt)) {
		oldStrict = strict;
		setStrict(strict = true);
	  }
	  first = false;
	}
	if (strict && !oldStrict) setStrict(false);
	return finishNode(node, "BlockStatement");
  }

  function parseFor(node, init) {
	node.init = init;
	expect(_semi);
	node.test = tokType === _semi ? null : parseExpression();
	expect(_semi);
	node.update = tokType === _parenR ? null : parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForStatement");
  }

  function parseForIn(node, init) {
	node.left = init;
	node.right = parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForInStatement");
  }

  function parseVar(node, noIn) {
	node.declarations = [];
	node.kind = "var";
	for (;;) {
	  var decl = startNode();
	  decl.id = parseIdent();
	  if (strict && isStrictBadIdWord(decl.id.name))
		raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
	  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
	  node.declarations.push(finishNode(decl, "VariableDeclarator"));
	  if (!eat(_comma)) break;
	}
	return node;
  }

  function parseExpression(noComma, noIn) {
	var expr = parseMaybeAssign(noIn);
	if (!noComma && tokType === _comma) {
	  var node = startNodeFrom(expr);
	  node.expressions = [expr];
	  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
	  return finishNode(node, "SequenceExpression");
	}
	return expr;
  }

  function parseMaybeAssign(noIn) {
	var left = parseMaybeConditional(noIn);
	if (tokType.isAssign) {
	  var node = startNodeFrom(left);
	  node.operator = tokVal;
	  node.left = left;
	  next();
	  node.right = parseMaybeAssign(noIn);
	  checkLVal(left);
	  return finishNode(node, "AssignmentExpression");
	}
	return left;
  }

  function parseMaybeConditional(noIn) {
	var expr = parseExprOps(noIn);
	if (eat(_question)) {
	  var node = startNodeFrom(expr);
	  node.test = expr;
	  node.consequent = parseExpression(true);
	  expect(_colon);
	  node.alternate = parseExpression(true, noIn);
	  return finishNode(node, "ConditionalExpression");
	}
	return expr;
  }

  function parseExprOps(noIn) {
	return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  function parseExprOp(left, minPrec, noIn) {
	var prec = tokType.binop;
	if (prec != null && (!noIn || tokType !== _in)) {
	  if (prec > minPrec) {
		var node = startNodeFrom(left);
		node.left = left;
		node.operator = tokVal;
		var op = tokType;
		next();
		node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
		var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
		return parseExprOp(exprNode, minPrec, noIn);
	  }
	}
	return left;
  }

  function parseMaybeUnary() {
	if (tokType.prefix) {
	  var node = startNode(), update = tokType.isUpdate;
	  node.operator = tokVal;
	  node.prefix = true;
	  tokRegexpAllowed = true;
	  next();
	  node.argument = parseMaybeUnary();
	  if (update) checkLVal(node.argument);
	  else if (strict && node.operator === "delete" &&
			   node.argument.type === "Identifier")
		raise(node.start, "Deleting local variable in strict mode");
	  return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	}
	var expr = parseExprSubscripts();
	while (tokType.postfix && !canInsertSemicolon()) {
	  var node = startNodeFrom(expr);
	  node.operator = tokVal;
	  node.prefix = false;
	  node.argument = expr;
	  checkLVal(expr);
	  next();
	  expr = finishNode(node, "UpdateExpression");
	}
	return expr;
  }

  function parseExprSubscripts() {
	return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
	if (eat(_dot)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseIdent(true);
	  node.computed = false;
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (eat(_bracketL)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseExpression();
	  node.computed = true;
	  expect(_bracketR);
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (!noCalls && eat(_parenL)) {
	  var node = startNodeFrom(base);
	  node.callee = base;
	  node.arguments = parseExprList(_parenR, false);
	  return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
	} else return base;
  }

  function parseExprAtom() {
	switch (tokType) {
	case _this:
	  var node = startNode();
	  next();
	  return finishNode(node, "ThisExpression");
	case _name:
	  return parseIdent();
	case _num: case _string: case _regexp:
	  var node = startNode();
	  node.value = tokVal;
	  node.raw = input.slice(tokStart, tokEnd);
	  next();
	  return finishNode(node, "Literal");

	case _null: case _true: case _false:
	  var node = startNode();
	  node.value = tokType.atomValue;
	  node.raw = tokType.keyword;
	  next();
	  return finishNode(node, "Literal");

	case _parenL:
	  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
	  next();
	  var val = parseExpression();
	  val.start = tokStart1;
	  val.end = tokEnd;
	  if (options.locations) {
		val.loc.start = tokStartLoc1;
		val.loc.end = tokEndLoc;
	  }
	  if (options.ranges)
		val.range = [tokStart1, tokEnd];
	  expect(_parenR);
	  return val;

	case _bracketL:
	  var node = startNode();
	  next();
	  node.elements = parseExprList(_bracketR, true, true);
	  return finishNode(node, "ArrayExpression");

	case _braceL:
	  return parseObj();

	case _function:
	  var node = startNode();
	  next();
	  return parseFunction(node, false);

	case _new:
	  return parseNew();

	default:
	  unexpected();
	}
  }

  function parseNew() {
	var node = startNode();
	next();
	node.callee = parseSubscripts(parseExprAtom(), true);
	if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
	else node.arguments = empty;
	return finishNode(node, "NewExpression");
  }

  function parseObj() {
	var node = startNode(), first = true, sawGetSet = false;
	node.properties = [];
	next();
	while (!eat(_braceR)) {
	  if (!first) {
		expect(_comma);
		if (options.allowTrailingCommas && eat(_braceR)) break;
	  } else first = false;

	  var prop = {key: parsePropertyName()}, isGetSet = false, kind;
	  if (eat(_colon)) {
		prop.value = parseExpression(true);
		kind = prop.kind = "init";
	  } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
				 (prop.key.name === "get" || prop.key.name === "set")) {
		isGetSet = sawGetSet = true;
		kind = prop.kind = prop.key.name;
		prop.key = parsePropertyName();
		if (tokType !== _parenL) unexpected();
		prop.value = parseFunction(startNode(), false);
	  } else unexpected();

	  if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
		for (var i = 0; i < node.properties.length; ++i) {
		  var other = node.properties[i];
		  if (other.key.name === prop.key.name) {
			var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
			  kind === "init" && (other.kind === "get" || other.kind === "set");
			if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
			if (conflict) raise(prop.key.start, "Redefinition of property");
		  }
		}
	  }
	  node.properties.push(prop);
	}
	return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
	if (tokType === _num || tokType === _string) return parseExprAtom();
	return parseIdent(true);
  }

  function parseFunction(node, isStatement) {
	if (tokType === _name) node.id = parseIdent();
	else if (isStatement) unexpected();
	else node.id = null;
	node.params = [];
	var first = true;
	expect(_parenL);
	while (!eat(_parenR)) {
	  if (!first) expect(_comma); else first = false;
	  node.params.push(parseIdent());
	}

	var oldInFunc = inFunction, oldLabels = labels;
	inFunction = true; labels = [];
	node.body = parseBlock(true);
	inFunction = oldInFunc; labels = oldLabels;

	if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
	  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
		var id = i < 0 ? node.id : node.params[i];
		if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
		  raise(id.start, "Defining '" + id.name + "' in strict mode");
		if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
		  raise(id.start, "Argument name clash in strict mode");
	  }
	}

	return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  function parseExprList(close, allowTrailingComma, allowEmpty) {
	var elts = [], first = true;
	while (!eat(close)) {
	  if (!first) {
		expect(_comma);
		if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
	  } else first = false;

	  if (allowEmpty && tokType === _comma) elts.push(null);
	  else elts.push(parseExpression(true));
	}
	return elts;
  }

  function parseIdent(liberal) {
	var node = startNode();
	if (liberal && options.forbidReserved == "everywhere") liberal = false;
	if (tokType === _name) {
	  if (!liberal &&
		  (options.forbidReserved &&
		   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
		   strict && isStrictReservedWord(tokVal)) &&
		  input.slice(tokStart, tokEnd).indexOf("\\") == -1)
		raise(tokStart, "The keyword '" + tokVal + "' is reserved");
	  node.name = tokVal;
	} else if (liberal && tokType.keyword) {
	  node.name = tokType.keyword;
	} else {
	  unexpected();
	}
	tokRegexpAllowed = false;
	next();
	return finishNode(node, "Identifier");
  }

});

		if (!acorn.version)
			acorn = null;
	}

	function parse(code, options) {
		return (global.acorn || acorn).parse(code, options);
	}

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': '__equals',
		'!=': '__equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': '__self'
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{
			__self: function() {
				return this;
			}
		}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code, options) {
		if (!code)
			return '';
		options = options || {};

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function handleOverloading(node, parent) {
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (node.prefix) {
							str = '(' + str + ')';
						} else if (
							parentType === 'AssignmentExpression' ||
							parentType === 'VariableDeclarator' ||
							parentType === 'BinaryExpression'
						) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right),
								exp = left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')';
							replaceCode(node, /^\(.*\)$/.test(getCode(node))
									? '(' + exp + ')' : exp);
						}
					}
				}
				break;
			}
		}

		function handleExports(node) {
			switch (node.type) {
			case 'ExportDefaultDeclaration':
				replaceCode({
					range: [node.start, node.declaration.start]
				}, 'module.exports = ');
				break;
			case 'ExportNamedDeclaration':
				var declaration = node.declaration;
				var specifiers = node.specifiers;
				if (declaration) {
					var declarations = declaration.declarations;
					if (declarations) {
						declarations.forEach(function(dec) {
							replaceCode(dec, 'module.exports.' + getCode(dec));
						});
						replaceCode({
							range: [
								node.start,
								declaration.start + declaration.kind.length
							]
						}, '');
					}
				} else if (specifiers) {
					var exports = specifiers.map(function(specifier) {
						var name = getCode(specifier);
						return 'module.exports.' + name + ' = ' + name + '; ';
					}).join('');
					if (exports) {
						replaceCode(node, exports);
					}
				}
				break;
			}
		}

		function walkAST(node, parent, paperFeatures) {
			if (node) {
				for (var key in node) {
					if (key !== 'range' && key !== 'loc') {
						var value = node[key];
						if (Array.isArray(value)) {
							for (var i = 0, l = value.length; i < l; i++) {
								walkAST(value[i], node, paperFeatures);
							}
						} else if (value && typeof value === 'object') {
							walkAST(value, node, paperFeatures);
						}
					}
				}
				if (paperFeatures.operatorOverloading !== false) {
					handleOverloading(node, parent);
				}
				if (paperFeatures.moduleExports !== false) {
					handleExports(node);
				}
			}
		}

		function encodeVLQ(value) {
			var res = '',
				base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
			value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
			while (value || !res) {
				var next = value & (32 - 1);
				value >>= 5;
				if (value)
					next |= 32;
				res += base64[next];
			}
			return res;
		}

		var url = options.url || '',
			sourceMaps = options.sourceMaps,
			paperFeatures = options.paperFeatures || {},
			source = options.source || code,
			offset = options.offset || 0,
			agent = paper.agent,
			version = agent.versionNumber,
			offsetCode = false,
			lineBreaks = /\r\n|\n|\r/mg,
			map;
		if (sourceMaps && (agent.chrome && version >= 30
				|| agent.webkit && version >= 537.76
				|| agent.firefox && version >= 23
				|| agent.node)) {
			if (agent.node) {
				offset -= 2;
			} else if (window && url && !window.location.href.indexOf(url)) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			offsetCode = offset > 0 && !(
					agent.chrome && version >= 36 ||
					agent.safari && version >= 600 ||
					agent.firefox && version >= 40 ||
					agent.node);
			var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
			mappings.length = (code.match(lineBreaks) || []).length + 1
					+ (offsetCode ? offset : 0);
			map = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url],
				sourcesContent: [source]
			};
		}
		if (
			paperFeatures.operatorOverloading !== false ||
			paperFeatures.moduleExports !== false
		) {
			walkAST(parse(code, {
				ranges: true,
				preserveParens: true,
				sourceType: 'module'
			}), null, paperFeatures);
		}
		if (map) {
			if (offsetCode) {
				code = new Array(offset + 1).join('\n') + code;
			}
			if (/^(inline|both)$/.test(sourceMaps)) {
				code += "\n//# sourceMappingURL=data:application/json;base64,"
						+ self.btoa(unescape(encodeURIComponent(
							JSON.stringify(map))));
			}
			code += "\n//# sourceURL=" + (url || 'paperscript');
		}
		return {
			url: url,
			source: source,
			code: code,
			map: map
		};
	}

	function execute(code, scope, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/
					.test(code) && !/\bnew\s+Tool\b/.test(code)
						? new Tool() : null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func,
			compiled = typeof code === 'object' ? code : compile(code, options);
		code = compiled.code;
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, tool: tool },
				true);
		expose(scope);
		code = 'var module = { exports: {} }; ' + code;
		var exports = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push('module.exports.' + key + ' = ' + key + ';');
			}
		}, []).join('\n');
		if (exports) {
			code += '\n' + exports;
		}
		code += '\nreturn module.exports;';
		var agent = paper.agent;
		if (document && (agent.chrome
				|| agent.firefox && agent.versionNumber < 40)) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (agent.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'document.__paperscript__ = function(' + params + ') {' +
					code +
				'\n}'
			));
			head.appendChild(script);
			func = document.__paperscript__;
			delete document.__paperscript__;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var exports = func && func.apply(scope, args);
		var obj = exports || {};
		Base.each(toolHandlers, function(key) {
			var value = obj[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (obj.onResize)
				view.setOnResize(obj.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (obj.onFrame)
				view.setOnFrame(obj.onFrame);
			view.requestUpdate();
		}
		return exports;
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request({
					url: src,
					async: async,
					mimeType: 'text/plain',
					onLoad: function(code) {
						execute(code, scope, src);
					}
				});
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document && document.getElementsByTagName('script'),
				loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (window) {
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse,
		calculateBinary: __$__,
		calculateUnary: $__
	};

}.call(this);

var paper = new (PaperScope.inject(Base.exports, {
	Base: Base,
	Numerical: Numerical,
	Key: Key,
	DomEvent: DomEvent,
	DomElement: DomElement,
	document: document,
	window: window,
	Symbol: SymbolDefinition,
	PlacedSymbol: SymbolItem
}))();

if (paper.agent.node) {
	require('./node/extend.js')(paper);
}

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
}.call(this, typeof self === 'object' ? self : null);

},{"./node/extend.js":3,"./node/self.js":3,"acorn":2}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AniBase = void 0;
var paper_1 = __importDefault(require("paper"));
var AniBase = /** @class */ (function () {
    function AniBase(element) {
        this._element = element;
        this._canvas = document.createElement('canvas');
        this._element.appendChild(this._canvas);
        this._project = new paper_1.default.Project(this._canvas);
        this.InitializeCanvas();
    }
    Object.defineProperty(AniBase.prototype, "Width", {
        get: function () {
            return this._canvas.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AniBase.prototype, "Height", {
        get: function () {
            return this._canvas.height;
        },
        enumerable: false,
        configurable: true
    });
    AniBase.prototype.InitializeCanvas = function () {
        this._canvas.width = this._element.clientWidth;
        this._canvas.height = this._element.clientHeight;
    };
    return AniBase;
}());
exports.AniBase = AniBase;
},{"paper":4}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcentricAni = void 0;
var ani_base_1 = require("./abstractions/ani-base");
var paper_1 = __importDefault(require("paper"));
var ani_helpers_1 = require("./helpers/ani-helpers");
var ConcentricAni = /** @class */ (function (_super) {
    __extends(ConcentricAni, _super);
    function ConcentricAni(element) {
        var _this = _super.call(this, element) || this;
        _this._circles = [];
        _this.StartAni();
        return _this;
    }
    ConcentricAni.prototype.CreateElements = function () {
        var maxRadius = this.Height >= this.Width ? (this.Height - 10) / 2 : (this.Width - 10) / 2;
        var currentRadius = maxRadius;
        var strokeColor = new paper_1.default.Color('black');
        for (var i = 0; i < 4; i++) {
            var center = ani_helpers_1.AniHelpers.GetCenterFromElement(this._element);
            var point = new paper_1.default.Point(center[0], center[1]);
            var circle = new paper_1.default.Path.Circle(point, currentRadius);
            circle.strokeWidth = 1;
            circle.strokeColor = strokeColor;
            this._circles.push(circle);
            currentRadius -= maxRadius / 4;
        }
        this._project.view.viewSize = new paper_1.default.Size(this.Width, this.Height);
    };
    ConcentricAni.prototype.StartAni = function () {
        if (this._circles.length === 0)
            this.CreateElements();
        this.DoAnimation(0);
    };
    ConcentricAni.prototype.DoAnimation = function (index) {
        var _this = this;
        var direction = 'up';
        var interval = window.setInterval(function () {
            console.log("Animating: " + index + " | " + direction + " | " + _this._circles[index].strokeWidth);
            if (direction === 'up') {
                _this._circles[index].strokeWidth += 0.5;
                if (_this._circles[index].strokeWidth === 4) {
                    direction = 'down';
                }
            }
            else {
                _this._circles[index].strokeWidth -= 0.5;
                if (_this._circles[index].strokeWidth === 1) {
                    clearInterval(interval);
                    _this.DoAnimation(index === 3 ? 0 : ++index);
                }
            }
        }, 16);
    };
    return ConcentricAni;
}(ani_base_1.AniBase));
exports.ConcentricAni = ConcentricAni;
},{"./abstractions/ani-base":5,"./helpers/ani-helpers":7,"paper":4}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AniHelpers = void 0;
var AniHelpers = /** @class */ (function () {
    function AniHelpers() {
    }
    AniHelpers.GetCenterFromElement = function (element) {
        var result = [element.clientWidth / 2, element.clientHeight / 2];
        return result;
    };
    return AniHelpers;
}());
exports.AniHelpers = AniHelpers;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluLnRzIiwibm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4uanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsInNyYy9hYnN0cmFjdGlvbnMvYW5pLWJhc2UudHMiLCJzcmMvY29uY2VudHJpYy1hbmkudHMiLCJzcmMvaGVscGVycy9hbmktaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsdURBQXFEO0FBRXJELElBQU0sT0FBTyxHQUE2QixRQUFRLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFFdkYsSUFBTSxhQUFhLEdBQUcsSUFBSSw4QkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQ0pqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGtLQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbGppQkEsZ0RBQTBCO0FBRTFCO0lBY0UsaUJBQVksT0FBb0I7UUFDOUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZUFBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDMUIsQ0FBQztJQWRELHNCQUFjLDBCQUFLO2FBQW5CO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUM1QixDQUFDOzs7T0FBQTtJQUVELHNCQUFjLDJCQUFNO2FBQXBCO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUM3QixDQUFDOzs7T0FBQTtJQVVPLGtDQUFnQixHQUF4QjtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQy9DLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO0lBQ25ELENBQUM7SUFLSCxjQUFDO0FBQUQsQ0E5QkEsQUE4QkMsSUFBQTtBQTlCcUIsMEJBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSDdCLG9EQUFrRDtBQUNsRCxnREFBMEI7QUFDMUIscURBQW1EO0FBR25EO0lBQW1DLGlDQUFPO0lBR3hDLHVCQUFZLE9BQW9CO1FBQWhDLFlBQ0Usa0JBQU0sT0FBTyxDQUFDLFNBRWY7UUFMZ0IsY0FBUSxHQUF3QixFQUFFLENBQUM7UUFJbEQsS0FBSSxDQUFDLFFBQVEsRUFBRSxDQUFDOztJQUNsQixDQUFDO0lBRU8sc0NBQWMsR0FBdEI7UUFDRSxJQUFNLFNBQVMsR0FBVyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFckcsSUFBSSxhQUFhLEdBQVcsU0FBUyxDQUFDO1FBQ3RDLElBQU0sV0FBVyxHQUFnQixJQUFJLGVBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFMUQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxJQUFNLE1BQU0sR0FBMkIsd0JBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdEYsSUFBTSxLQUFLLEdBQWdCLElBQUksZUFBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakUsSUFBTSxNQUFNLEdBQXNCLElBQUksZUFBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQzlFLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1lBRWpDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTNCLGFBQWEsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZUFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRVMsZ0NBQVEsR0FBbEI7UUFDRSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUM7WUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRU8sbUNBQVcsR0FBbkIsVUFBb0IsS0FBYTtRQUFqQyxpQkFvQkM7UUFuQkMsSUFBSSxTQUFTLEdBQWtCLElBQUksQ0FBQztRQUVwQyxJQUFNLFFBQVEsR0FBVyxNQUFNLENBQUMsV0FBVyxDQUFDO1lBRTFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWMsS0FBSyxXQUFNLFNBQVMsV0FBTSxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQWEsQ0FBQyxDQUFDO1lBRXhGLElBQUksU0FBUyxLQUFLLElBQUksRUFBRTtnQkFDdEIsS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDO2dCQUN4QyxJQUFJLEtBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxLQUFLLENBQUMsRUFBRTtvQkFDMUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztpQkFDcEI7YUFDRjtpQkFBTTtnQkFDTCxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsSUFBSSxHQUFHLENBQUM7Z0JBQ3hDLElBQUksS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEtBQUssQ0FBQyxFQUFFO29CQUMxQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ3hCLEtBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUM3QzthQUNGO1FBQ0gsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUNILG9CQUFDO0FBQUQsQ0F2REEsQUF1REMsQ0F2RGtDLGtCQUFPLEdBdUR6QztBQXZEWSxzQ0FBYTs7Ozs7QUNMMUI7SUFBQTtJQUtBLENBQUM7SUFKZSwrQkFBb0IsR0FBbEMsVUFBbUMsT0FBb0I7UUFDckQsSUFBTSxNQUFNLEdBQTJCLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzRixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQUxBLEFBS0MsSUFBQTtBQUxZLGdDQUFVIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IHsgQ29uY2VudHJpY0FuaSB9IGZyb20gXCIuL3NyYy9jb25jZW50cmljLWFuaVwiO1xyXG5cclxuY29uc3QgZWxlbWVudDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb25jZW50cmljQ2lyY2xlc1wiKTtcclxuXHJcbmNvbnN0IGNvbmNlbnRyaWNBbmkgPSBuZXcgQ29uY2VudHJpY0FuaShlbGVtZW50KTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYWNvcm4gPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cbiAgLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICAgIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG4gIH07XG5cbiAgdmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuICAvLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGM3XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHU5ZmZjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3Y2FcXHVhN2Y1LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NS1cXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmZcXHUxYWMwXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODJjXFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuICAvLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuICAvLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4gIC8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS4gVGhleSB3ZXJlXG4gIC8vIGdlbmVyYXRlZCBieSBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsMzQ5LDQxLDcsMSw3OSwyOCwxMSwwLDksMjEsMTA3LDIwLDI4LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMywwLDksMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMiwzMSw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiw3LDMsMCwzLDcsMiwxLDIsMjMsMTYsMCwyLDAsOTUsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDE5MCwwLDgwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSwxMjM3LDQzLDgsODk1MiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxNywzNSw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MSwxNTA3LDQ5MzhdO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LDAsMjI3LDAsMTUwLDQsMjk0LDksMTM2OCwyLDIsMSw2LDMsNDEsMiw1LDAsMTY2LDEsNTc0LDMsOSw5LDM3MCwxLDE1NCwxMCwxNzYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDYsMSw0NSwwLDEzLDIsNDksMTMsOSwzLDIsMTEsODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSw3MSw1LDIsMSwzLDMsMiwwLDIsMSwxMyw5LDEyMCw2LDMsNiw0LDAsMjksOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTkzMDYsOSwxMzUsNCw2MCw2LDI2LDksMTAxNCwwLDIsNTQsOCwzLDgyLDAsMTIsMSwxOTYyOCwxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDI2Miw2LDEwLDksNDE5LDEzLDE0OTUsNiwxMTAsNiw2LDksNDc1OSw5LDc4NzcxOSwyMzldO1xuXG4gIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAvLyByYXJlLlxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBwb3MgKz0gc2V0W2ldO1xuICAgICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuICAvLyAjIyBUb2tlbiB0eXBlc1xuXG4gIC8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4gIC8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuICAvLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuICAvLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbiAgLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbiAgLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuICAvLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuICAvL1xuICAvLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuICAvLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4gIC8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4gIC8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuICAvL1xuICAvLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbiAgLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRzJDEgPSB7fTtcblxuICAvLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG4gIGZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgdHlwZXMgPSB7XG4gICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICAgIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICAgIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgcXVlc3Rpb25Eb3Q6IG5ldyBUb2tlblR5cGUoXCI/LlwiKSxcbiAgICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICAgIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gICAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICAgIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICAgIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gICAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAgIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gICAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAgIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAgIC8vXG4gICAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gICAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gICAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gICAgLy9cbiAgICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAgIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAgIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gICAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICAgIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICAgIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gICAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gICAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICAgIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICAgIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBjb2FsZXNjZTogYmlub3AoXCI/P1wiLCAxKSxcblxuICAgIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gICAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICAgIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICAgIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gICAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pZjoga3coXCJpZlwiKSxcbiAgICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gICAgX3RyeToga3coXCJ0cnlcIiksXG4gICAgX3Zhcjoga3coXCJ2YXJcIiksXG4gICAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICAgIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gICAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICAgIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gICAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gICAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxuICB9O1xuXG4gIC8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbiAgLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbiAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xuICB2YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGlzTmV3TGluZShjb2RlLCBlY21hMjAxOVN0cmluZykge1xuICAgIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCAoIWVjbWEyMDE5U3RyaW5nICYmIChjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5KSlcbiAgfVxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbiAgdmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbiAgdmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG4gIC8vIENoZWNrcyBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG5cbiAgZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbiAgKTsgfSk7XG5cbiAgZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxuICB9XG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4gIC8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbiAgdmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbiAgfTtcblxuICB2YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbiAgfTtcblxuICAvLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4gIC8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4gIC8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gIC8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbiAgLy8gaW50by5cblxuICBmdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gICAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWMoaW5wdXQpO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbiAgLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0IGJlXG4gICAgLy8gZWl0aGVyIDMsIDUsIDYgKDIwMTUpLCA3ICgyMDE2KSwgOCAoMjAxNyksIDkgKDIwMTgpLCBvciAxMFxuICAgIC8vICgyMDE5KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnQgZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mXG4gICAgLy8gcmVzZXJ2ZWQgd29yZHMsIGFuZCBzdXBwb3J0IGZvciBuZXcgc3ludGF4IGZlYXR1cmVzLiBUaGUgZGVmYXVsdFxuICAgIC8vIGlzIDEwLlxuICAgIGVjbWFWZXJzaW9uOiAxMCxcbiAgICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gICAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gICAgLy8gc3RyaWN0IG1vZGUgYW5kIHBhcnNpbmcgb2YgYGltcG9ydGAgYW5kIGBleHBvcnRgIGRlY2xhcmF0aW9ucy5cbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gICAgLy8gd2hlbiBhIHNlbWljb2xvbiBpcyBhdXRvbWF0aWNhbGx5IGluc2VydGVkLiBJdCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAgIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gICAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAgIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gICAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAgIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAgIC8vIGVycm9yLlxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAgIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgaGFzaGJhbmcgZGlyZWN0aXZlIGluIHRoZSBiZWdpbm5pbmcgb2YgZmlsZVxuICAgIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gICAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgYGxvY2AgcHJvcGVydGllcyBob2xkaW5nIG9iamVjdHMgd2l0aFxuICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gICAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgICAvLyBub2Rlcy5cbiAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggb2JqZWN0IGluIHRoZSBzYW1lXG4gICAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAgIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgICAvLyBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICBvblRva2VuOiBudWxsLFxuICAgIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKGJsb2NrLCB0ZXh0LCBzdGFydCxcbiAgICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gICAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gICAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gICAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAgIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gICAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gICAgLy8gdGhlIGBsb2NgIG9iamVjdCwgd2hpY2ggaG9sZHMgbGluZS9jb2x1bW4gZGF0YS4gVG8gYWxzbyBhZGQgYVxuICAgIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gICAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAgIC8vIGB0cnVlYC5cbiAgICAvL1xuICAgIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgICAvLyBgcHJvZ3JhbWAgb3B0aW9uIGluIHN1YnNlcXVlbnQgcGFyc2VzLiBUaGlzIHdpbGwgYWRkIHRoZVxuICAgIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICAgIHByb2dyYW06IG51bGwsXG4gICAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gICAgc291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gICAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gICAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgICBwcmVzZXJ2ZVBhcmVuczogZmFsc2VcbiAgfTtcblxuICAvLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICAgIHsgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5OyB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICAgIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xuICB2YXJcbiAgICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTixcbiAgICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgICBTQ09QRV9BUlJPVyA9IDE2LFxuICAgICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgICAgU0NPUEVfRElSRUNUX1NVUEVSID0gMTI4O1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbiAgfVxuXG4gIC8vIFVzZWQgaW4gY2hlY2tMVmFsIGFuZCBkZWNsYXJlTmFtZSB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBiaW5kaW5nXG4gIHZhclxuICAgICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgICAgQklORF9WQVIgPSAxLCAvLyBWYXItc3R5bGUgYmluZGluZ1xuICAgICAgQklORF9MRVhJQ0FMID0gMiwgLy8gTGV0LSBvciBjb25zdC1zdHlsZSBiaW5kaW5nXG4gICAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgLy8gU2ltcGxlIChpZGVudGlmaWVyIHBhdHRlcm4pIGNhdGNoIGJpbmRpbmdcbiAgICAgIEJJTkRfT1VUU0lERSA9IDU7IC8vIFNwZWNpYWwgY2FzZSBmb3IgZnVuY3Rpb24gbmFtZXMgYXMgYm91bmQgaW5zaWRlIHRoZSBmdW5jdGlvblxuXG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICAgIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gICAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gICAgfVxuICAgIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICAgIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gICAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gICAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gICAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gICAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAgIC8vIEl0cyB0eXBlXG4gICAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAgIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICAvLyBBbmQsIGlmIGxvY2F0aW9ucyBhcmUgdXNlZCwgdGhlIHtsaW5lLCBjb2x1bW59IG9iamVjdFxuICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIC8vIFBvc2l0aW9uIGluZm9ybWF0aW9uIGZvciB0aGUgcHJldmlvdXMgdG9rZW5cbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAgIC8vIFRoZSBjb250ZXh0IHN0YWNrIGlzIHVzZWQgdG8gc3VwZXJmaWNpYWxseSB0cmFjayBzeW50YWN0aWNcbiAgICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgICB0aGlzLmluTW9kdWxlID0gb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiO1xuICAgIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG5cbiAgICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0ge307XG5cbiAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAgIC8vIFNjb3BlIHRyYWNraW5nIGZvciBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMgKHNlZSBzY29wZS5qcylcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmVudGVyU2NvcGUoU0NPUEVfVE9QKTtcblxuICAgIC8vIEZvciBSZWdFeHAgdmFsaWRhdGlvblxuICAgIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGluRnVuY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5HZW5lcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5Bc3luYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd1N1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93RGlyZWN0U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdHJlYXRGdW5jdGlvbnNBc1ZhcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5Bc3luYy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0FTWU5DKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpIH07XG5cbiAgLy8gU3dpdGNoIHRvIGEgZ2V0dGVyIGZvciA3LjAuMC5cbiAgUGFyc2VyLnByb3RvdHlwZS5pbk5vbkFycm93RnVuY3Rpb24gPSBmdW5jdGlvbiBpbk5vbkFycm93RnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgY2xzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gICAgcmV0dXJuIGNsc1xuICB9O1xuXG4gIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxuICB9O1xuXG4gIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICAgIHBhcnNlci5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG4gIH07XG5cbiAgUGFyc2VyLnRva2VuaXplciA9IGZ1bmN0aW9uIHRva2VuaXplciAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBhcnNlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4gIHZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ1xcXFxdKSo/KSd8XCIoKD86XFxcXC58W15cIlxcXFxdKSo/KVwiKS87XG4gIHBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgc3RyaW5nIGxpdGVyYWwuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpLCBlbmQgPSBzcGFjZUFmdGVyLmluZGV4ICsgc3BhY2VBZnRlclswXS5sZW5ndGg7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQXQoZW5kKTtcbiAgICAgICAgcmV0dXJuIG5leHQgPT09IFwiO1wiIHx8IG5leHQgPT09IFwifVwiIHx8XG4gICAgICAgICAgKGxpbmVCcmVhay50ZXN0KHNwYWNlQWZ0ZXJbMF0pICYmXG4gICAgICAgICAgICEoL1soYC5bK1xcLS8qJTw+PSw/XiZdLy50ZXN0KG5leHQpIHx8IG5leHQgPT09IFwiIVwiICYmIHRoaXMuaW5wdXQuY2hhckF0KGVuZCArIDEpID09PSBcIj1cIikpXG4gICAgICB9XG4gICAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgICAgeyBzdGFydCsrOyB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4gIC8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbiAgcHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2NcbiAgfTtcblxuICAvLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbiAgcHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBwcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICBwcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuICAvLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxuICBwcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgICAgaWYgKCFub3ROZXh0KVxuICAgICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4gIC8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xuICB9O1xuXG4gIC8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gICAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICAgIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgICAgLTE7XG4gIH1cblxuICBwcC5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICAgIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICAgIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICB9O1xuXG4gIHBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxuICB9O1xuXG4gIHZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgcHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfSB9XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbiAgfTtcblxuICB2YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbiAgcHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gICAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICAgIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IC8vICd7J1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4gIC8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuICAvLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxuICBwcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbiAgLy9cbiAgLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbiAgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2VcbiAgLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuICAvLyBkb2VzIG5vdCBoZWxwLlxuXG4gIHBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICAgIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG5cbiAgICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAgIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAgIC8vIGNvbXBsZXhpdHkuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICAgIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgICAvLyBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cbiAgICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcy5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKHRydWUsIG5vZGUpXG4gICAgY2FzZSB0eXBlcy5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2ggPT09IDQwIHx8IG5leHRDaCA9PT0gNDYpIC8vICcoJyBvciAnLidcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gICAgLy8gY29udGludWUgdG8uXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKVxuICAgIH1cbiAgICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgICAvLyBub2Rlcy4gYGN1cmAgaXMgdXNlZCB0byBrZWVwIHRoZSBub2RlIHRoYXQgd2UgYXJlIGN1cnJlbnRseVxuICAgIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gICAgdmFyIGN1cjtcbiAgICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlLCBleGl0U3RyaWN0KSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4gIC8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuICAvLyBleHByZXNzaW9uLlxuXG4gIHBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4gIC8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxuICBwcCQxLnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbjtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChcbiAgICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgICAgKFxuICAgICAgICAhaXNGb3JJbiB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICAgIHRoaXMuc3RyaWN0IHx8XG4gICAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5yYWlzZShcbiAgICAgICAgaW5pdC5zdGFydCxcbiAgICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpbml0LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3BcIik7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGluaXQ7XG4gICAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbiAgcHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIHBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgICBkZWNsLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG4gIH07XG5cbiAgdmFyIEZVTkNfU1RBVEVNRU5UID0gMSwgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCA9IDIsIEZVTkNfTlVMTEFCTEVfSUQgPSA0O1xuXG4gIC8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuICAvLyBSZW1vdmUgYGFsbG93RXhwcmVzc2lvbkJvZHlgIGZvciA3LjAuMCwgYXMgaXQgaXMgb25seSBjYWxsZWQgd2l0aCBmYWxzZVxuICBwcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIgJiYgKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgICAgLy8gbW9kZSBkZXBlbmRzIG9uIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgc2NvcGUgKHNlZVxuICAgICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gICAgfVxuXG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICAgIGlmICghKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSlcbiAgICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgZmFsc2UpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgfTtcblxuICAvLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbiAgLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG4gIHBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBlY21hLTI2MiAxNC42IENsYXNzIERlZmluaXRpb25zXG4gICAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgICB0aGlzLnN0cmljdCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgeyB0aGlzLnJhaXNlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgICAgaWYgKCBub0xpbmVCcmVhayA9PT0gdm9pZCAwICkgbm9MaW5lQnJlYWsgPSBmYWxzZTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICh0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmICghbm9MaW5lQnJlYWsgfHwgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0LCBzdGFydExvYyk7XG4gICAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfTtcblxuICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICBtZXRob2Quc3RhdGljID0gdHJ5Q29udGV4dHVhbChcInN0YXRpY1wiKTtcbiAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgIGlmICghaXNHZW5lcmF0b3IpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgIHZhciBhbGxvd3NEaXJlY3RTdXBlciA9IGZhbHNlO1xuICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICByZXR1cm4gbWV0aG9kXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG4gIHBwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgICB2YXIgaXNBc3luYztcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2xhc3MpIHtcbiAgICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi5cbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQubmFtZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5zdGFydCk7IH1cbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7IC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGtleXdvcmRzIHVzZWQgYXMgbG9jYWwgbmFtZXNcbiAgICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgICAgICAvLyBjaGVjayBpZiBleHBvcnQgaXMgZGVmaW5lZFxuICAgICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gICAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgcHAkMS5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICAgIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQubmFtZSwgcGF0LnN0YXJ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxuICB9O1xuXG4gIHBwJDEuY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxuICBwcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50KHRydWUpIDogbm9kZS5sb2NhbDtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCBub2RlLmV4cG9ydGVkLnN0YXJ0KTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzXG4gIH07XG5cbiAgLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxuICBwcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIC8vIGltcG9ydCAnLi4uJ1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZykge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHk7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG4gIHBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIC8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxuICBwcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aCAmJiB0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKHN0YXRlbWVudHNbaV0pOyArK2kpIHtcbiAgICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gICAgfVxuICB9O1xuICBwcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN0YXRlbWVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJlxuICAgICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgLy8gUmVqZWN0IHBhcmVudGhlc2l6ZWQgc3RyaW5ncy5cbiAgICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gICAgKVxuICB9O1xuXG4gIHZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbiAgLy8gaWYgcG9zc2libGUuXG5cbiAgcHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIC8vIEVhcmx5IGVycm9yOlxuICAgICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJlxuICAgICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmFyZ3VtZW50LnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gQXNzaWdubWVudFBhdHRlcm5cblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZVwiKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuICAvLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbiAgcHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQyLnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZXMgbHZhbHVlIChhc3NpZ25hYmxlKSBhdG9tLlxuXG4gIHBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH07XG5cbiAgLy8gUGFyc2VzIGFzc2lnbm1lbnQgcGF0dGVybiBhcm91bmQgZ2l2ZW4gYXRvbSBpZiBwb3NzaWJsZS5cblxuICBwcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gIH07XG5cbiAgLy8gVmVyaWZ5IHRoYXQgYSBub2RlIGlzIGFuIGx2YWwg4oCUIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZFxuICAvLyB0by5cbiAgLy8gYmluZGluZ1R5cGUgY2FuIGJlIGVpdGhlcjpcbiAgLy8gJ3ZhcicgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSAndmFyJyBiaW5kaW5nXG4gIC8vICdsZXQnIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgbGV4aWNhbCAoJ2xldCcgb3IgJ2NvbnN0JykgYmluZGluZ1xuICAvLyAnbm9uZScgaW5kaWNhdGluZyB0aGF0IHRoZSBiaW5kaW5nIHNob3VsZCBiZSBjaGVja2VkIGZvciBpbGxlZ2FsIGlkZW50aWZpZXJzLCBidXQgbm90IGZvciBkdXBsaWNhdGUgcmVmZXJlbmNlc1xuXG4gIHBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICAgIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcImxldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWVcIik7IH1cbiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpOyB9XG4gICAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FICYmIGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChiaW5kaW5nVHlwZSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQSByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgb3BlcmF0ZXMgYnkgZGVmaW5pbmcgZnVuY3Rpb25zIGZvciBhbGxcblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbiAgLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuICAvLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4gIC8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbiAgcHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgICB7IHJldHVybiB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgdmFyIG5hbWU7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuICAgIHZhciBraW5kID0gcHJvcC5raW5kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMClcbiAgICAgICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGtsdWRnZS4gQ2FuIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjBcbiAgICAgICAgICB9IGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgICBpZiAob3RoZXIpIHtcbiAgICAgIHZhciByZWRlZmluaXRpb247XG4gICAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgICAgaW5pdDogZmFsc2UsXG4gICAgICAgIGdldDogZmFsc2UsXG4gICAgICAgIHNldDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIG90aGVyW2tpbmRdID0gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbiAgLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4gIC8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4gIC8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuICAvLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuICAvLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbiAgLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbiAgLy8gZm9yYmlkIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucylcbiAgLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4gIC8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuICAvLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4gIC8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG4gIHBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2ZcbiAgLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxuICBwcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAgIC8vIFRoZSB0b2tlbml6ZXIgd2lsbCBhc3N1bWUgYW4gZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGFmdGVyXG4gICAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgICB9XG5cbiAgICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTE7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID49IG5vZGUubGVmdC5zdGFydClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyB9IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG4gIHBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG4gIH07XG5cbiAgLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbiAgLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbiAgLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4gIC8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbiAgLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG4gIHBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICAgIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgICB2YXIgY29hbGVzY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmNvYWxlc2NlO1xuICAgICAgICBpZiAoY29hbGVzY2UpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHByZWNlZGVuY2Ugb2YgYHR0LmNvYWxlc2NlYCBhcyBlcXVhbCB0byB0aGUgcmFuZ2Ugb2YgbG9naWNhbCBleHByZXNzaW9ucy5cbiAgICAgICAgICAvLyBJbiBvdGhlciB3b3JkcywgYG5vZGUucmlnaHRgIHNob3VsZG4ndCBjb250YWluIGxvZ2ljYWwgZXhwcmVzc2lvbnMgaW4gb3JkZXIgdG8gY2hlY2sgdGhlIG1peGVkIGVycm9yLlxuICAgICAgICAgIHByZWMgPSB0eXBlcy5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIG5vSW4pO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCB8fCBjb2FsZXNjZSk7XG4gICAgICAgIGlmICgobG9naWNhbCAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbEFORCkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiTG9naWNhbCBleHByZXNzaW9ucyBhbmQgY29hbGVzY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIG1peGVkLiBXcmFwIGVpdGhlciBieSBwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBwcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgICAgc2F3VW5hcnkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZXhwciB9XG4gIH07XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgYmFzZS5lbmQgLSBiYXNlLnN0YXJ0ID09PSA1ICYmXG4gICAgICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gYmFzZS5zdGFydDtcbiAgICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93LCBvcHRpb25hbENoYWluZWQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgICBpZiAoZWxlbWVudCA9PT0gYmFzZSB8fCBlbGVtZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAob3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBjaGFpbk5vZGUuZXhwcmVzc2lvbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuZmluaXNoTm9kZShjaGFpbk5vZGUsIFwiQ2hhaW5FeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgICB9XG5cbiAgICAgIGJhc2UgPSBlbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCkge1xuICAgIHZhciBvcHRpb25hbFN1cHBvcnRlZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgb3B0aW9uYWwgPSBvcHRpb25hbFN1cHBvcnRlZCAmJiB0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbkRvdCk7XG4gICAgaWYgKG5vQ2FsbHMgJiYgb3B0aW9uYWwpIHsgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zXCIpOyB9XG5cbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gICAgaWYgKGNvbXB1dGVkIHx8IChvcHRpb25hbCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJhY2tRdW90ZSkgfHwgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIW9wdGlvbmFsICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgICAgbm9kZSQxLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICBpZiAob3B0aW9uYWwgfHwgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSB0YWcgb2YgdGFnZ2VkIHRlbXBsYXRlIGV4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBwcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgLy8gSWYgYSBkaXZpc2lvbiBvcGVyYXRvciBhcHBlYXJzIGluIGFuIGV4cHJlc3Npb24gcG9zaXRpb24sIHRoZVxuICAgIC8vIHRva2VuaXplciBnb3QgY29uZnVzZWQsIGFuZCB3ZSBmb3JjZSBpdCB0byByZWFkIGEgcmVnZXhwIGluc3RlYWQuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2xhc2gpIHsgdGhpcy5yZWFkUmVnZXhwKCk7IH1cblxuICAgIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgIXRoaXMuYWxsb3dEaXJlY3RTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgICAgLy8gVGhlIGBzdXBlcmAga2V5d29yZCBjYW4gYXBwZWFyIGF0IGJlbG93OlxuICAgICAgLy8gU3VwZXJQcm9wZXJ0eTpcbiAgICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgICAgLy8gICAgIHN1cGVyIC4gSWRlbnRpZmllck5hbWVcbiAgICAgIC8vIFN1cGVyQ2FsbDpcbiAgICAgIC8vICAgICBzdXBlciAoIEFyZ3VtZW50cyApXG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgICBjYXNlIHR5cGVzLl90aGlzOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gICAgY2FzZSB0eXBlcy5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuX2Z1bmN0aW9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgMCwgZmFsc2UsIHRydWUpIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIGZhbHNlKSB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmICFjb250YWluc0VzYykge1xuICAgICAgICAgIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkXG5cbiAgICBjYXNlIHR5cGVzLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMubnVtOiBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKVxuXG4gICAgY2FzZSB0eXBlcy5fbnVsbDogY2FzZSB0eXBlcy5fdHJ1ZTogY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3RydWU7XG4gICAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gICAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LCBleHByID0gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBzdGFydDsgfVxuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcblxuICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgMClcblxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMuX25ldzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICAgIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG5cbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZUV4cHJJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICAvLyBDb25zdW1lIGBpbXBvcnRgIGFzIGFuIGlkZW50aWZpZXIgZm9yIGBpbXBvcnQubWV0YWAuXG4gICAgLy8gQmVjYXVzZSBgdGhpcy5wYXJzZUlkZW50KHRydWUpYCBkb2Vzbid0IGNoZWNrIGVzY2FwZSBzZXF1ZW5jZXMsIGl0IG5lZWRzIHRoZSBjaGVjayBvZiBgdGhpcy5jb250YWluc0VzY2AuXG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgaW1wb3J0XCIpOyB9XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEeW5hbWljSW1wb3J0KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5kb3Q6XG4gICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgKGBcblxuICAgIC8vIFBhcnNlIG5vZGUuc291cmNlLlxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG5cbiAgICAvLyBWZXJpZnkgZW5kaW5nLlxuICAgIGlmICghdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgdmFyIGVycm9yUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5SKSkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXJyb3JQb3MsIFwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoZXJyb3JQb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUltcG9ydE1ldGEgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYC5gXG5cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcIm1ldGFcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIidpbXBvcnQubWV0YScgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIpOyB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL18vZywgXCJcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWUsIGxhc3RJc0NvbW1hID0gZmFsc2U7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCwgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICAgIH1cblxuICAgICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIHBhci5leHByZXNzaW9uID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QpXG4gIH07XG5cbiAgLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4gIC8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbiAgLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbiAgLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4gIC8vIGFyZ3VtZW50IGxpc3QuXG5cbiAgdmFyIGVtcHR5JDEgPSBbXTtcblxuICBwcCQzLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgbmV3XCIpOyB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyAnbmV3LnRhcmdldCdcIik7IH1cbiAgICAgIGlmIChjb250YWluc0VzYylcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk5vbkFycm93RnVuY3Rpb24oKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBpc0ltcG9ydCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2ltcG9ydDtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICAgIGlmIChpc0ltcG9ydCAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5yYWlzZShzdGFydFBvcywgXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCgpXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSk7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eSQxOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG4gIHBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICAgIH1cbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgICAgY29va2VkOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkMy5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQgfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhcikpICYmXG4gICAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxuICBwcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIH1cbiAgICAgIC8vIFRvIGRpc2FsbG93IHBhcmVudGhlc2l6ZWQgaWRlbnRpZmllciB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMCkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gRmluaXNoXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTsgfVxuICAgIH1cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICAgIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb2xvbilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5lcSkpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxuICBwcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbiAgfTtcblxuICAvLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG4gIHBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG4gIHBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMpIHtcbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgcHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QpIHtcbiAgICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgICAgfVxuICAgICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gIH07XG5cbiAgcHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4gIC8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG4gIHBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbiAgLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbiAgLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuICAvLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbiAgLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxuICBwcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAvLyBpZGVudGlmaWVycy5cblxuICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCghIWxpYmVyYWwpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4gIC8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4gIC8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuICAvLyBtZXNzYWdlLlxuXG4gIHBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgICB0aHJvdyBlcnJcbiAgfTtcblxuICBwcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG4gIHBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gICAgfVxuICB9O1xuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLnZhciA9IFtdO1xuICAgIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMubGV4aWNhbCA9IFtdO1xuICAgIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgfTtcblxuICAvLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbiAgcHAkNS5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgU2NvcGUoZmxhZ3MpKTtcbiAgfTtcblxuICBwcCQ1LmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgfTtcblxuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyA+IEF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmdW5jdGlvbiwgb3Igc2NyaXB0LCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlXG4gIC8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbiAgcHAkNS50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB8fCAhdGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApXG4gIH07XG5cbiAgcHAkNS5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgICB2YXIgcmVkZWNsYXJlZCA9IGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgcmVkZWNsYXJlZCA9IHNjb3BlLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUudmFyLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBzY29wZSQxLmxleGljYWwucHVzaChuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBpZiAodGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyKVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUkMi52YXIuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgICAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSQzKSAmJiBzY29wZSQzLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbiAgfTtcblxuICBwcCQ1LmNoZWNrTG9jYWxFeHBvcnQgPSBmdW5jdGlvbihpZCkge1xuICAgIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gICAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICAgIHRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICAgIH1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG4gIH07XG5cbiAgcHAkNS5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbiAgcHAkNS5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgICB7IHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbiAgfTtcblxuICAvLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG4gIHZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBwcCQ2LnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxuICB9O1xuXG4gIHBwJDYuc3RhcnROb2RlQXQgPSBmdW5jdGlvbihwb3MsIGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbiAgfTtcblxuICAvLyBGaW5pc2ggYW4gQVNUIG5vZGUsIGFkZGluZyBgdHlwZWAgYW5kIGBlbmRgIHByb3BlcnRpZXMuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IHBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbiAgfTtcblxuICAvLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG4gIHBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgcG9zLCBsb2MpXG4gIH07XG5cbiAgLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuXG4gIHZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gICAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xuICB9O1xuXG4gIHZhciB0eXBlcyQxID0ge1xuICAgIGJfc3RhdDogbmV3IFRva0NvbnRleHQoXCJ7XCIsIGZhbHNlKSxcbiAgICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICAgIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgICBmX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UpLFxuICAgIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgICBmX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSwgZmFsc2UsIG51bGwsIHRydWUpXG4gIH07XG5cbiAgdmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDcuaW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDcuYnJhY2VJc0Jsb2NrID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgICAvLyBUaGUgY2hlY2sgZm9yIGB0dC5uYW1lICYmIGV4cHJBbGxvd2VkYCBkZXRlY3RzIHdoZXRoZXIgd2UgYXJlXG4gICAgLy8gYWZ0ZXIgYSBgeWllbGRgIG9yIGBvZmAgY29uc3RydWN0LiBTZWUgdGhlIGB1cGRhdGVDb250ZXh0YCBmb3JcbiAgICAvLyBgdHQubmFtZWAuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgICB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTClcbiAgICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxuICB9O1xuXG4gIHBwJDcuaW5HZW5lcmF0b3JDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcy5kb3QpXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG4gIH07XG5cbiAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gIHR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICBpZiAob3V0ID09PSB0eXBlcyQxLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbiAgfTtcblxuICB0eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMkMS5iX3N0YXQgOiB0eXBlcyQxLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucF9zdGF0IDogdHlwZXMkMS5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG4gIH07XG5cbiAgdHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmJfc3RhdCkpXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2luZGV4XSA9PT0gdHlwZXMkMS5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZ2VuOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgcHJldlR5cGUgIT09IHR5cGVzLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG4gIC8vIFRoaXMgZmlsZSBjb250YWlucyBVbmljb2RlIHByb3BlcnRpZXMgZXh0cmFjdGVkIGZyb20gdGhlIEVDTUFTY3JpcHRcbiAgLy8gc3BlY2lmaWNhdGlvbi4gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbiAgLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4gIC8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXG4gIHZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xuICB2YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xuICB2YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG4gIHZhciB1bmljb2RlQmluYXJ5UHJvcGVydGllcyA9IHtcbiAgICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gICAgMTE6IGVjbWExMUJpbmFyeVByb3BlcnRpZXNcbiAgfTtcblxuICAvLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xuICB2YXIgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyA9IFwiQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdVwiO1xuXG4gIC8vICN0YWJsZS11bmljb2RlLXNjcmlwdC12YWx1ZXNcbiAgdmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xuICB2YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xuICB2YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG4gIHZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICAgIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAgIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gICAgMTE6IGVjbWExMVNjcmlwdFZhbHVlc1xuICB9O1xuXG4gIHZhciBkYXRhID0ge307XG4gIGZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgbm9uQmluYXJ5OiB7XG4gICAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgICAgfVxuICAgIH07XG4gICAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gICAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gICAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG4gIH1cbiAgYnVpbGRVbmljb2RlRGF0YSg5KTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMCk7XG4gIGJ1aWxkVW5pY29kZURhdGEoMTEpO1xuXG4gIHZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpO1xuICAgIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExID8gMTEgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICAgIHRoaXMuc3dpdGNoTiA9IGZhbHNlO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHRoaXMubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gICAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICAgIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gICAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG4gIH07XG5cbiAgLy8gSWYgdSBmbGFnIGlzIGdpdmVuLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGluZGV4IChpdCBjb21iaW5lcyBhIHN1cnJvZ2F0ZSBwYWlyKS5cbiAgLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICAgIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gbFxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgICBpZiAoIShmb3JjZVUgfHwgdGhpcy5zd2l0Y2hVKSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIGkgKyAxXG4gICAgfVxuICAgIHJldHVybiBpICsgMlxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MsIGZvcmNlVSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKSwgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gsIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudChmb3JjZVUpID09PSBjaCkge1xuICAgICAgdGhpcy5hZHZhbmNlKGZvcmNlVSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICAgIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgICBjaCAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcCQ4LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gVGhlIGdvYWwgc3ltYm9sIGZvciB0aGUgcGFyc2UgaXMgfFBhdHRlcm5bflUsIH5OXXwuIElmIHRoZSByZXN1bHQgb2ZcbiAgICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAgIC8vIGV4Y2VwdGlvbiBpZiBfUF8gZGlkIG5vdCBjb25mb3JtIHRvIHRoZSBncmFtbWFyLCBpZiBhbnkgZWxlbWVudHMgb2YgX1BfXG4gICAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICAgIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbiAgcHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBdICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxuICBwcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG4gIHBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICAgIHsgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG4gIHBwJDgucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxuICBwcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAgIC8vIF4sICRcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gXFxiIFxcQlxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG4gIHBwJDgucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxuICBwcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG4gIHBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxuICBwcCQ4LnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuICAvLyBCdXQgZWF0IGVhZ2VyLlxuICBwcCQ4LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICAgICkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gR3JvdXBTcGVjaWZpZXIgOjpcbiAgLy8gICBbZW1wdHldXG4gIC8vICAgYD9gIEdyb3VwTmFtZVxuICBwcCQ4LnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR3JvdXBOYW1lIDo6XG4gIC8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lIGA+YFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkOC5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllck5hbWUgOjpcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZSBSZWdFeHBJZGVudGlmaWVyUGFydFxuICAvLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJTdGFydCA6OlxuICAvLyAgIFVuaWNvZGVJRFN0YXJ0XG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbK1VdXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbiAgfVxuXG4gIC8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0IDo6XG4gIC8vICAgVW5pY29kZUlEQ29udGludWVcbiAgLy8gICBgJGBcbiAgLy8gICBgX2BcbiAgLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbiAgLy8gICA8WldOSj5cbiAgLy8gICA8WldKPlxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG4gIHBwJDgucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICAgIClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBzd2l0Y2hVID0gZm9yY2VVIHx8IHN0YXRlLnN3aXRjaFU7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBzd2l0Y2hVICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxuICBwcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgICAgKGNoID09PSAweDUwIC8qIFAgKi8gfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgICApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgICApXG4gIH1cblxuICAvLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAvLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAgIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWhhcyhzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbiAgfTtcbiAgcHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICB9O1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbiAgLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxuICB9XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG4gIHBwJDgucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICAgIHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgICAgdGhpcy5yZWdleHBfY2xhc3NSYW5nZXMoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIF0gKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICAvLyBVbnJlYWNoYWJsZSBzaW5jZSBpdCB0aHJldyBcInVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiBlcnJvciBiZWZvcmUuXG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzUmFuZ2VzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICBwcCQ4LnJlZ2V4cF9jbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pICYmIHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbU5vRGFzaFxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IC8qIC0gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbiAgcHAkOC5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NzggLyogeCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xuICBwcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRzXG4gIHBwJDgucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHx8XG4gICAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLylcbiAgICApXG4gIH1cbiAgZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSAvKiBBICovKVxuICAgIH1cbiAgICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSAvKiBhICovKVxuICAgIH1cbiAgICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1MZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlXG4gIC8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxuICBwcCQ4LnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG4gIHBwJDgucmVnZXhwX2VhdE9jdGFsRGlnaXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggLSAweDMwOyAvKiAwICovXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4NERpZ2l0c1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuICAvLyBBbmQgSGV4RGlnaXQgSGV4RGlnaXQgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbiAgcHAkOC5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyBPYmplY3QgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCB0b2tlbnMuIE5vdGUgdGhhdCBub3JtYWxseSwgdG9rZW5zXG4gIC8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbiAgLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbiAgdmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICAgIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgICB0aGlzLmVuZCA9IHAuZW5kO1xuICAgIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbiAgfTtcblxuICAvLyAjIyBUb2tlbml6ZXJcblxuICB2YXIgcHAkOSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG4gIHBwJDkubmV4dCA9IGZ1bmN0aW9uKGlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkKSB7XG4gICAgaWYgKCFpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCAmJiB0aGlzLnR5cGUua2V5d29yZCAmJiB0aGlzLmNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIHBwJDkuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG4gIH07XG5cbiAgLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgeyBwcCQ5W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IH1cblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICBwcCQ5LmN1ckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxuICB9O1xuXG4gIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAvLyBwcm9wZXJ0aWVzLlxuXG4gIHBwJDkubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAgIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG4gIH07XG5cbiAgcHAkOS5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbiAgfTtcblxuICBwcCQ5LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxuICB9O1xuXG4gIHBwJDkuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZShjaCkpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuICAvLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG4gIHBwJDkuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuICAvLyByaWdodCBwb3NpdGlvbi5cblxuICBwcCQ5LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICB9O1xuXG4gIC8vICMjIyBUb2tlbiByZWFkaW5nXG5cbiAgLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uIEl0XG4gIC8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuICAvLyB0aGFuIGNoYXJhY3RlcnMsIGFuZCBiZWNhdXNlIG9wZXJhdG9yIHBhcnNpbmcgaGFzIGJlZW4gaW5saW5lZFxuICAvLyBpbnRvIGl0LlxuICAvL1xuICAvLyBBbGwgaW4gdGhlIG5hbWUgb2Ygc3BlZWQuXG4gIC8vXG4gIHBwJDkucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzLnN0YXIgOiB0eXBlcy5tb2R1bG87XG5cbiAgICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICArK3NpemU7XG4gICAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAzKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9xdWVzdGlvbiA9IGZ1bmN0aW9uKCkgeyAvLyAnPydcbiAgICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gICAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICBpZiAobmV4dDIgPCA0OCB8fCBuZXh0MiA+IDU3KSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnF1ZXN0aW9uRG90LCAyKSB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dCA9PT0gNjMpIHtcbiAgICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgICAgdmFyIG5leHQyJDEgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgICBpZiAobmV4dDIkMSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAzKSB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuY29hbGVzY2UsIDIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnF1ZXN0aW9uLCAxKVxuICB9O1xuXG4gIHBwJDkuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6IC8vICcuJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gICAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKVxuICAgIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuUilcbiAgICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zZW1pKVxuICAgIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKVxuICAgIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRMKVxuICAgIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRSKVxuICAgIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpXG4gICAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlUilcbiAgICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb2xvbilcblxuICAgIGNhc2UgOTY6IC8vICdgJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcblxuICAgIGNhc2UgNDg6IC8vICcwJ1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gICAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gICAgY2FzZSA5NDogLy8gJ14nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gICAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICAgIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgICBjYXNlIDYzOiAvLyAnPydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpXG5cbiAgICBjYXNlIDEyNjogLy8gJ34nXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wcmVmaXgsIDEpXG4gICAgfVxuXG4gICAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwJDkuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG4gIH07XG5cbiAgcHAkOS5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICBpZiAoY2ggPT09IFwiW1wiKSB7IGluQ2xhc3MgPSB0cnVlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSB7IGluQ2xhc3MgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgfSBlbHNlIHsgZXNjYXBlZCA9IGZhbHNlOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAgIC8vIFZhbGlkYXRlIHBhdHRlcm5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gICAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAgIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gRVNUcmVlIHJlcXVpcmVzIG51bGwgaWYgaXQgZmFpbGVkIHRvIGluc3RhbnRpYXRlIFJlZ0V4cCBvYmplY3QuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG4gIH07XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbiAgLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbiAgcHAkOS5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbiwgbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgLy8gYGxlbmAgaXMgdXNlZCBmb3IgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMuIEluIHRoYXQgY2FzZSwgZGlzYWxsb3cgc2VwYXJhdG9ycy5cbiAgICB2YXIgYWxsb3dTZXBhcmF0b3JzID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyICYmIGxlbiA9PT0gdW5kZWZpbmVkO1xuXG4gICAgLy8gYG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbGAgaXMgdHJ1ZSBpZiBpdCBkb2Vzbid0IGhhdmUgcHJlZml4ICgweCwwbywwYilcbiAgICAvLyBhbmQgaXNuJ3QgZnJhY3Rpb24gcGFydCBub3IgZXhwb25lbnQgcGFydC4gSW4gdGhhdCBjYXNlLCBpZiB0aGUgZmlyc3QgZGlnaXRcbiAgICAvLyBpcyB6ZXJvIHRoZW4gZGlzYWxsb3cgc2VwYXJhdG9ycy5cbiAgICB2YXIgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsID0gbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDQ4O1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMCwgbGFzdENvZGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSwgKyt0aGlzLnBvcykge1xuICAgICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcblxuICAgICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBjb2RlID09PSA5NSkge1xuICAgICAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBpbiBsZWdhY3kgb2N0YWwgbnVtZXJpYyBsaXRlcmFsc1wiKTsgfVxuICAgICAgICBpZiAobGFzdENvZGUgPT09IDk1KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBtdXN0IGJlIGV4YWN0bHkgb25lIHVuZGVyc2NvcmVcIik7IH1cbiAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBmaXJzdCBvZiBkaWdpdHNcIik7IH1cbiAgICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IC8vIEFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgeyB2YWwgPSBjb2RlIC0gNDg7IH0gLy8gMC05XG4gICAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICAgIGlmICh2YWwgPj0gcmFkaXgpIHsgYnJlYWsgfVxuICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1NlcGFyYXRvcnMgJiYgbGFzdENvZGUgPT09IDk1KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcyAtIDEsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGxhc3Qgb2YgZGlnaXRzXCIpOyB9XG4gICAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgcmV0dXJuIHRvdGFsXG4gIH07XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXIoc3RyLCBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCA4KVxuICAgIH1cblxuICAgIC8vIGBwYXJzZUZsb2F0KHZhbHVlKWAgc3RvcHMgcGFyc2luZyBhdCB0aGUgZmlyc3QgbnVtZXJpYyBzZXBhcmF0b3IgdGhlbiByZXR1cm5zIGEgd3JvbmcgdmFsdWUuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0JpZ0ludChzdHIpIHtcbiAgICBpZiAodHlwZW9mIEJpZ0ludCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIGBCaWdJbnQodmFsdWUpYCB0aHJvd3Mgc3ludGF4IGVycm9yIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgbnVtZXJpYyBzZXBhcmF0b3JzLlxuICAgIHJldHVybiBCaWdJbnQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG4gIH1cblxuICBwcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuICAvLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxuICBwcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCwgdW5kZWZpbmVkLCB0cnVlKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICAgIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgICAgdmFyIHZhbCQxID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbCQxKVxuICAgIH1cbiAgICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHsgLy8gJ2VFJ1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICAgIGlmICh0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gICAgdmFyIHZhbCA9IHN0cmluZ1RvTnVtYmVyKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSwgb2N0YWwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBwcCQ5LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gICAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpIHtcbiAgICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG4gIH1cblxuICBwcCQ5LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcCQ5LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xuICBwcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiJFwiOlxuICAgICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcImBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxuICBwcCQ5LnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICAgIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgLy8gJ3gnXG4gICAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyQxKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gICAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zIC0gMTtcblxuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICBjb2RlUG9zLFxuICAgICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgY2ggPT09IDU2IHx8IGNoID09PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgICAgfVxuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgLy8gVW5pY29kZSBuZXcgbGluZSBjaGFyYWN0ZXJzIGFmdGVyIFxcIGdldCByZW1vdmVkIGZyb20gb3V0cHV0IGluIGJvdGhcbiAgICAgICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgYW5kIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG4gIHBwJDkucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgICByZXR1cm4gblxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2BcbiAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gIC8vXG4gIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgcHAkOS5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICAgIHRoaXMuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmckMShlc2MpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuICAvLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxuICBwcCQ5LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbiAgfTtcblxuICAvLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuXG4gIHZhciB2ZXJzaW9uID0gXCI3LjQuMVwiO1xuXG4gIFBhcnNlci5hY29ybiA9IHtcbiAgICBQYXJzZXI6IFBhcnNlcixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgU291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuICAgIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgICBOb2RlOiBOb2RlLFxuICAgIFRva2VuVHlwZTogVG9rZW5UeXBlLFxuICAgIHRva1R5cGVzOiB0eXBlcyxcbiAgICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzJDEsXG4gICAgVG9rQ29udGV4dDogVG9rQ29udGV4dCxcbiAgICB0b2tDb250ZXh0czogdHlwZXMkMSxcbiAgICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICBUb2tlbjogVG9rZW4sXG4gICAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gICAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gICAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxuICB9O1xuXG4gIC8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4gIC8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kXG4gIC8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuICAvLyBBUEldW2FwaV0uXG4gIC8vXG4gIC8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uIGF0IGEgZ2l2ZW5cbiAgLy8gb2Zmc2V0IGluIGEgc3RyaW5nLiBVc2VmdWwgZm9yIHBhcnNpbmcgbWl4ZWQtbGFuZ3VhZ2UgZm9ybWF0c1xuICAvLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbiAgfVxuXG4gIC8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4gIC8vIFRoZSBgdG9rZW5pemVyYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICBleHBvcnRzLk5vZGUgPSBOb2RlO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuICBleHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG4gIGV4cG9ydHMuVG9rQ29udGV4dCA9IFRva0NvbnRleHQ7XG4gIGV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiAgZXhwb3J0cy5Ub2tlblR5cGUgPSBUb2tlblR5cGU7XG4gIGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGdldExpbmVJbmZvO1xuICBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuICBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gIGV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuICBleHBvcnRzLmtleXdvcmRUeXBlcyA9IGtleXdvcmRzJDE7XG4gIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuICBleHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcyQxO1xuICBleHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG4gIGV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIiLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjEyLjE1IC0gVGhlIFN3aXNzIEFybXkgS25pZmUgb2YgVmVjdG9yIEdyYXBoaWNzIFNjcmlwdGluZy5cbiAqIGh0dHA6Ly9wYXBlcmpzLm9yZy9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgLSAyMDIwLCBKw7xyZyBMZWhuaSAmIEpvbmF0aGFuIFB1Y2tleVxuICogaHR0cDovL2p1ZXJnbGVobmkuY29tLyAmIGh0dHBzOi8vcHVja2V5LnN0dWRpby9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBXZWQgTWFyIDE3IDEwOjQ5OjQ4IDIwMjEgKzAxMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAyMCBKw7xyZyBMZWhuaVxuICogaHR0cDovL2p1ZXJnbGVobmkuY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKioqXG4gKlxuICogQWNvcm4uanNcbiAqIGh0dHBzOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBmdW5jdGlvbihzZWxmLCB1bmRlZmluZWQpIHtcblxuc2VsZiA9IHNlbGYgfHwgcmVxdWlyZSgnLi9ub2RlL3NlbGYuanMnKTtcbnZhciB3aW5kb3cgPSBzZWxmLndpbmRvdyxcblx0ZG9jdW1lbnQgPSBzZWxmLmRvY3VtZW50O1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblx0XHRhcnJheSA9IFtdLFxuXHRcdHNsaWNlID0gYXJyYXkuc2xpY2UsXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG5cdFx0ZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuXG5cdFx0Zm9yRWFjaCA9IGFycmF5LmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZvckluID0gZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihkc3QpIHtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG5cdFx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdFx0XHRcdFx0ZHN0W2tleV0gPSBzcmNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRzdDtcblx0XHR9LFxuXG5cdFx0ZWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlciwgYmluZCkge1xuXHRcdFx0aWYgKG9iaikge1xuXHRcdFx0XHR2YXIgZGVzYyA9IGRlc2NyaWJlKG9iaiwgJ2xlbmd0aCcpO1xuXHRcdFx0XHQoZGVzYyAmJiB0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ251bWJlcicgPyBmb3JFYWNoIDogZm9ySW4pXG5cdFx0XHRcdFx0LmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJpbmQ7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmMgJiYgIXZhbC5iYXNlXG5cdFx0XHRcdFx0XHQ/ICh2YWwgJiYgdmFsLmdldCA/IG5hbWUgaW4gZGVzdCA6IGRlc3RbbmFtZV0pXG5cdFx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHRcdGJlYW47XG5cdFx0XHRpZiAoIXByZXNlcnZlIHx8ICFwcmV2KSB7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgcHJldilcblx0XHRcdFx0XHR2YWwuYmFzZSA9IHByZXY7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgYmVhbnMgIT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiAoYmVhbiA9IG5hbWUubWF0Y2goL14oW2dzXWV0fGlzKSgoW0EtWl0pKC4qKSkkLykpKVxuXHRcdFx0XHRcdGJlYW5zTmFtZXNbYmVhblszXS50b0xvd2VyQ2FzZSgpICsgYmVhbls0XV0gPSBiZWFuWzJdO1xuXHRcdFx0XHRpZiAoIXJlcyB8fCBpc0Z1bmMgfHwgIXJlcy5nZXQgfHwgdHlwZW9mIHJlcy5nZXQgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdHx8ICFCYXNlLmlzUGxhaW5PYmplY3QocmVzKSkge1xuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGUgIT0gbnVsbCA/IGVudW1lcmFibGUgOiAhYmVhbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZpbmUoZGVzdCwgbmFtZSwgcmVzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhaGlkZGVuLnRlc3QobmFtZSkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGJlYW5zTmFtZXMpIHtcblx0XHRcdFx0dmFyIHBhcnQgPSBiZWFuc05hbWVzW25hbWVdLFxuXHRcdFx0XHRcdHNldCA9IGRlc3RbJ3NldCcgKyBwYXJ0XSxcblx0XHRcdFx0XHRnZXQgPSBkZXN0WydnZXQnICsgcGFydF0gfHwgc2V0ICYmIGRlc3RbJ2lzJyArIHBhcnRdO1xuXHRcdFx0XHRpZiAoZ2V0ICYmIChiZWFucyA9PT0gdHJ1ZSB8fCBnZXQubGVuZ3RoID09PSAwKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lLCB7IGdldDogZ2V0LCBzZXQ6IHNldCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRlc3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChzcmMpXG5cdFx0XHRcdHNldCh0aGlzLCBzcmMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJldHVybiBpbmplY3QoQmFzZSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCBudWxsLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3IsXG5cdFx0XHRcdHByb3RvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG9iaiwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRcdFx0aSA8IGwgJiYgIShjdG9yICYmIHByb3RvKTsgaSsrKSB7XG5cdFx0XHRcdG9iaiA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Y3RvciA9IGN0b3IgfHwgb2JqLmluaXRpYWxpemU7XG5cdFx0XHRcdHByb3RvID0gcHJvdG8gfHwgb2JqLnByb3RvdHlwZTtcblx0XHRcdH1cblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjdG9yLnByb3RvdHlwZSA9IHByb3RvIHx8IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRkZWZpbmUocHJvdG8sICdjb25zdHJ1Y3RvcicsXG5cdFx0XHRcdFx0eyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdGluamVjdChjdG9yLCB0aGlzKTtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdHJldHVybiBjdG9yO1xuXHRcdH1cblx0fSkuaW5qZWN0KHtcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblxuXHRcdGluaXRpYWxpemU6IEJhc2UsXG5cblx0XHRzZXQ6IEJhc2UsXG5cblx0XHRpbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0ZWFjaDogZWFjaCxcblx0XHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdFx0ZGVmaW5lOiBkZWZpbmUsXG5cdFx0XHRkZXNjcmliZTogZGVzY3JpYmUsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhICE9PSB1bmRlZmluZWQgPyBhIDogYjtcblx0XHRcdH0sXG5cblx0XHRcdHNsaWNlOiBmdW5jdGlvbihsaXN0LCBiZWdpbiwgZW5kKSB7XG5cdFx0XHRcdHJldHVybiBzbGljZS5jYWxsKGxpc3QsIGJlZ2luLCBlbmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSkge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdEJhc2UuZmlsdGVyKHRoaXMsIHByb3BzLCBleGNsdWRlLCB0aGlzLl9wcmlvcml0aXplKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSwge1xuXG5iZWFuczogZmFsc2UsXG5zdGF0aWNzOiB7XG5cdGV4cG9ydHM6IHt9LFxuXG5cdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0bmFtZSA9IHJlcy5wcm90b3R5cGUuX2NsYXNzO1xuXHRcdGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pXG5cdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMilcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0cmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xuXHRcdGlmIChvYmoyICYmIG9iajIuZXF1YWxzKVxuXHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdGlmIChvYmoxICYmIG9iajJcblx0XHRcdFx0JiYgdHlwZW9mIG9iajEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gb2JqMS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyhvYmoxW2xlbmd0aF0sIG9iajJbbGVuZ3RoXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG5cdFx0XHRcdFx0bGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKG9iajFba2V5XSwgb2JqMltrZXldKSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuXHRcdGlmICh0aGlzID09PSBCYXNlKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0cmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcblx0XHRcdGJlZ2luID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwLFxuXHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGgsXG5cdFx0XHRvYmogPSBsaXN0W2JlZ2luXTtcblx0XHRhbW91bnQgPSBhbW91bnQgfHwgbGVuZ3RoIC0gYmVnaW47XG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBhbW91bnQgPD0gMSkge1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gYmVnaW4gKyAxO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvcHRpb25zICYmIG9wdGlvbnMuY2xvbmUgPyBvYmouY2xvbmUoKSA6IG9iajtcblx0XHR9XG5cdFx0b2JqID0gQmFzZS5jcmVhdGUocHJvdG8pO1xuXHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGJlZ2luID4gMCB8fCBiZWdpbiArIGFtb3VudCA8IGxlbmd0aFxuXHRcdFx0XHQ/IEJhc2Uuc2xpY2UobGlzdCwgYmVnaW4sIGJlZ2luICsgYW1vdW50KVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRsaXN0Ll9faW5kZXggPSBiZWdpbiArIG9iai5fX3JlYWQ7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBvYmouX19maWx0ZXJlZDtcblx0XHRcdGlmIChmaWx0ZXJlZCkge1xuXHRcdFx0XHRsaXN0Ll9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcblx0XHRcdFx0b2JqLl9fZmlsdGVyZWQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIGxpc3RbbGlzdC5fX2luZGV4ID0gc3RhcnQgfHwgbGlzdC5fX2luZGV4IHx8IDBdO1xuXHR9LFxuXG5cdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdHJldHVybiBsaXN0Lmxlbmd0aCAtIChsaXN0Ll9faW5kZXggfHwgMCk7XG5cdH0sXG5cblx0cmVhZExpc3Q6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcblx0XHR2YXIgcmVzID0gW10sXG5cdFx0XHRlbnRyeSxcblx0XHRcdGJlZ2luID0gc3RhcnQgfHwgMCxcblx0XHRcdGVuZCA9IGFtb3VudCA/IGJlZ2luICsgYW1vdW50IDogbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdD8gdGhpcy5yZWFkKGVudHJ5LCAwLCBvcHRpb25zKVxuXHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuXHRcdFx0aGFzVmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNWYWx1ZSkge1xuXHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkO1xuXHRcdFx0aWYgKCFmaWx0ZXJlZCkge1xuXHRcdFx0XHR2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UobGlzdCk7XG5cdFx0XHRcdGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUoc291cmNlKTtcblx0XHRcdFx0ZmlsdGVyZWQuX191bmZpbHRlcmVkID0gc291cmNlO1xuXHRcdFx0fVxuXHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnJlYWQoaGFzVmFsdWUgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCk7XG5cdH0sXG5cblx0cmVhZFN1cHBvcnRlZDogZnVuY3Rpb24obGlzdCwgZGVzdCkge1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZShsaXN0KSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVhZCA9IGZhbHNlO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0aWYgKGtleSBpbiBkZXN0KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdC5yZWFkTmFtZWQobGlzdCwga2V5KTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0ZGVzdFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlYWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlYWQ7XG5cdH0sXG5cblx0Z2V0U291cmNlOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0dmFyIHNvdXJjZSA9IGxpc3QuX19zb3VyY2U7XG5cdFx0aWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgYXJnID0gbGlzdC5sZW5ndGggPT09IDEgJiYgbGlzdFswXTtcblx0XHRcdHNvdXJjZSA9IGxpc3QuX19zb3VyY2UgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0PyBhcmcgOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGxpc3QpO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiBuYW1lID8gc291cmNlW25hbWVdIDogbGlzdC5fX2ZpbHRlcmVkIHx8IHNvdXJjZTtcblx0XHR9XG5cdH0sXG5cblx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24oZGVzdCwgc291cmNlLCBleGNsdWRlLCBwcmlvcml0aXplKSB7XG5cdFx0dmFyIHByb2Nlc3NlZDtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUtleShrZXkpIHtcblx0XHRcdGlmICghKGV4Y2x1ZGUgJiYga2V5IGluIGV4Y2x1ZGUpICYmXG5cdFx0XHRcdCEocHJvY2Vzc2VkICYmIGtleSBpbiBwcm9jZXNzZWQpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRkZXN0W2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocHJpb3JpdGl6ZSkge1xuXHRcdFx0dmFyIGtleXMgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXksIGwgPSBwcmlvcml0aXplLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoKGtleSA9IHByaW9yaXRpemVbaV0pIGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdGhhbmRsZUtleShrZXkpO1xuXHRcdFx0XHRcdGtleXNba2V5XSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByb2Nlc3NlZCA9IGtleXM7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMoc291cmNlLl9fdW5maWx0ZXJlZCB8fCBzb3VyY2UpLmZvckVhY2goaGFuZGxlS2V5KTtcblx0XHRyZXR1cm4gZGVzdDtcblx0fSxcblxuXHRpc1BsYWluVmFsdWU6IGZ1bmN0aW9uKG9iaiwgYXNTdHJpbmcpIHtcblx0XHRyZXR1cm4gQmFzZS5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG5cdFx0XHRcdHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgaXNSb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRyZXM7XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdGxlbmd0aDogMCxcblx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0YWRkOiBmdW5jdGlvbihpdGVtLCBjcmVhdGUpIHtcblx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0aWYgKCFyZWYpIHtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBpdGVtLl9jbGFzcztcblx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluaXRpb25zW2lkXSA9IHJlcztcblx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdHZhciBuYW1lID0gb2JqLl9jbGFzcztcblx0XHRcdGlmIChuYW1lICYmICFvYmouX2NvbXBhY3RTZXJpYWxpemUgJiYgKGlzUm9vdCB8fCAhY29tcGFjdClcblx0XHRcdFx0XHQmJiByZXNbMF0gIT09IG5hbWUpIHtcblx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpO1xuXHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpba2V5XSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzID0gb2JqO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNSb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHQ/IFtbJ2RpY3Rpb25hcnknLCBkaWN0aW9uYXJ5LmRlZmluaXRpb25zXSwgcmVzXVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRkZXNlcmlhbGl6ZTogZnVuY3Rpb24oanNvbiwgY3JlYXRlLCBfZGF0YSwgX3NldERpY3Rpb25hcnksIF9pc1Jvb3QpIHtcblx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdGlzRmlyc3QgPSAhX2RhdGEsXG5cdFx0XHRoYXNEaWN0aW9uYXJ5ID0gaXNGaXJzdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoXG5cdFx0XHRcdCYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHR2YXIgdHlwZSA9IGpzb25bMF0sXG5cdFx0XHRcdGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRcdGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdH1cblx0XHRcdHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG5cdFx0XHRyZXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsXG5cdFx0XHRcdFx0XHRpc0RpY3Rpb25hcnksIGhhc0RpY3Rpb25hcnkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0cmVzID0gY3JlYXRlKHR5cGUsIGFyZ3MsIGlzRmlyc3QgfHwgX2lzUm9vdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzID0gbmV3IHR5cGUoYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChqc29uKSkge1xuXHRcdFx0cmVzID0ge307XG5cdFx0XHRpZiAoX3NldERpY3Rpb25hcnkpXG5cdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4ganNvbilcblx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNEaWN0aW9uYXJ5ID8gcmVzWzFdIDogcmVzO1xuXHR9LFxuXG5cdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdHZhciBqc29uID0gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09IGZhbHNlXG5cdFx0XHRcdD8ganNvblxuXHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24sIHRhcmdldCkge1xuXHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHR0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbixcblx0XHRcdFx0ZnVuY3Rpb24oY3RvciwgYXJncywgaXNSb290KSB7XG5cdFx0XHRcdFx0dmFyIHVzZVRhcmdldCA9IGlzUm9vdCAmJiB0YXJnZXRcblx0XHRcdFx0XHRcdFx0JiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSBjdG9yLFxuXHRcdFx0XHRcdFx0b2JqID0gdXNlVGFyZ2V0ID8gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdDogQmFzZS5jcmVhdGUoY3Rvci5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdCYmICh1c2VUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuXHRcdFx0XHRcdFx0XHRhcmcuaW5zZXJ0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VUYXJnZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJncy5jb25jYXQoW3sgaW5zZXJ0OiB0cnVlIH1dKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQodXNlVGFyZ2V0ID8gb2JqLnNldCA6IGN0b3IpLmFwcGx5KG9iaiwgYXJncyk7XG5cdFx0XHRcdFx0aWYgKHVzZVRhcmdldClcblx0XHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fSk7XG5cdH0sXG5cblx0cHVzaDogZnVuY3Rpb24obGlzdCwgaXRlbXMpIHtcblx0XHR2YXIgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cdFx0aWYgKGl0ZW1zTGVuZ3RoIDwgNDA5Nikge1xuXHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHN0YXJ0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRsaXN0Lmxlbmd0aCArPSBpdGVtc0xlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsaXN0W3N0YXJ0TGVuZ3RoICsgaV0gPSBpdGVtc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH0sXG5cblx0c3BsaWNlOiBmdW5jdGlvbihsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuXHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PT0gdW5kZWZpbmVkO1xuXHRcdGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcblx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdGluZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcblx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRCYXNlLnB1c2gobGlzdCwgaXRlbXMpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcblx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0QmFzZS5wdXNoKGFyZ3MsIGl0ZW1zKTtcblx0XHRcdHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRyZW1vdmVkW2ldLl9pbmRleCA9IHVuZGVmaW5lZDtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHR9XG5cdH0sXG5cblx0Y2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtYXRjaCwgY2hyKSB7XG5cdFx0XHRyZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHlwaGVuYXRlOiBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdH1cbn19KTtcblxudmFyIEVtaXR0ZXIgPSB7XG5cdG9uOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vbihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdGlmIChoYW5kbGVycy5pbmRleE9mKGZ1bmMpID09PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuXHRcdFx0XHRcdCYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b25jZTogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZih0eXBlLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fSxcblxuXHRlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IEJhc2Uuc2xpY2UoYXJndW1lbnRzLCAxKSxcblx0XHRcdHNldFRhcmdldCA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiAhZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKCk7XG5cdFx0aWYgKHNldFRhcmdldClcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT0gZmFsc2UpIHtcblx0XHRcdFx0aWYgKGV2ZW50ICYmIGV2ZW50LnN0b3ApXG5cdFx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHQgICB9XG5cdFx0fVxuXHRcdGlmIChzZXRUYXJnZXQpXG5cdFx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZXNwb25kczogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiAhISh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdKTtcblx0fSxcblxuXHRhdHRhY2g6ICcjb24nLFxuXHRkZXRhY2g6ICcjb2ZmJyxcblx0ZmlyZTogJyNlbWl0JyxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24oaW5zdGFsbCkge1xuXHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyxcblx0XHRcdGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblx0XHRpZiAodHlwZXMpIHtcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgZW50cnkgPSB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRcdGZ1bmMgPSBlbnRyeSAmJiBlbnRyeVtrZXldO1xuXHRcdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChzcmMpIHtcblx0XHRcdHZhciBldmVudHMgPSBzcmMuX2V2ZW50cztcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0dmFyIHR5cGVzID0ge307XG5cdFx0XHRcdEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0XHRcdFx0XHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnLFxuXHRcdFx0XHRcdFx0bmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRcdFx0dHlwZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG5cdFx0XHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0XHRcdFx0c3JjWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0c3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJldiA9IHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0XHRpZiAocHJldilcblx0XHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgcHJldik7XG5cdFx0XHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRcdFx0dGhpcy5vbih0eXBlLCBmdW5jKTtcblx0XHRcdFx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBuZXcgQmFzZSh7XG5cdFx0XHRhcHBseU1hdHJpeDogdHJ1ZSxcblx0XHRcdGluc2VydEl0ZW1zOiB0cnVlLFxuXHRcdFx0aGFuZGxlU2l6ZTogNCxcblx0XHRcdGhpdFRvbGVyYW5jZTogMFxuXHRcdH0pO1xuXHRcdHRoaXMucHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5wcm9qZWN0cyA9IFtdO1xuXHRcdHRoaXMudG9vbHMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpIHx8IHt9O1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuYWdlbnQpIHtcblx0XHRcdHZhciB1c2VyID0gc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdG9zID0gKC8oZGFyd2lufHdpbnxtYWN8bGludXh8ZnJlZWJzZHxzdW5vcykvLmV4ZWModXNlcil8fFtdKVswXSxcblx0XHRcdFx0cGxhdGZvcm0gPSBvcyA9PT0gJ2RhcndpbicgPyAnbWFjJyA6IG9zLFxuXHRcdFx0XHRhZ2VudCA9IHByb3RvLmFnZW50ID0gcHJvdG8uYnJvd3NlciA9IHsgcGxhdGZvcm06IHBsYXRmb3JtIH07XG5cdFx0XHRpZiAocGxhdGZvcm0pXG5cdFx0XHRcdGFnZW50W3BsYXRmb3JtXSA9IHRydWU7XG5cdFx0XHR1c2VyLnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbXxub2RlfGpzZG9tKVxcLz9cXHMqKFsuXFxkXSspKD86Lip2ZXJzaW9uXFwvKFsuXFxkXSspKT8oPzouKnJ2XFw6dj8oWy5cXGRdKykpPy9nLFxuXHRcdFx0XHRmdW5jdGlvbihtYXRjaCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYWdlbnQuY2hyb21lKSB7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IG4gPT09ICdvcGVyYScgPyB2MiA6XG5cdFx0XHRcdFx0XHRcdFx0L14obm9kZXx0cmlkZW50KSQvLnRlc3QobikgPyBydiA6IHYxO1xuXHRcdFx0XHRcdFx0YWdlbnQudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRhZ2VudC52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcblx0XHRcdFx0XHRcdG4gPSB7IHRyaWRlbnQ6ICdtc2llJywganNkb206ICdub2RlJyB9W25dIHx8IG47XG5cdFx0XHRcdFx0XHRhZ2VudC5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGFnZW50W25dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRpZiAoYWdlbnQuY2hyb21lKVxuXHRcdFx0XHRkZWxldGUgYWdlbnQud2Via2l0O1xuXHRcdFx0aWYgKGFnZW50LmF0b20pXG5cdFx0XHRcdGRlbGV0ZSBhZ2VudC5jaHJvbWU7XG5cdFx0fVxuXHR9LFxuXG5cdHZlcnNpb246IFwiMC4xMi4xNVwiLFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0O1xuXHRcdHJldHVybiBwcm9qZWN0ICYmIHByb2plY3QuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBleHBvcnRzID0gcGFwZXIuUGFwZXJTY3JpcHQuZXhlY3V0ZShjb2RlLCB0aGlzLCBvcHRpb25zKTtcblx0XHRcdFZpZXcudXBkYXRlRm9jdXMoKTtcblx0XHRcdHJldHVybiBleHBvcnRzO1xuXHR9LFxuXG5cdGluc3RhbGw6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0QmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXRba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpXG5cdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcblx0XHRcdFx0c2NvcGVba2V5XSA9IHRoaXNba2V5XTtcblx0fSxcblxuXHRzZXR1cDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChlbGVtZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjcmVhdGVDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcm9qZWN0cyA9IHRoaXMucHJvamVjdHMsXG5cdFx0XHR0b29scyA9IHRoaXMudG9vbHM7XG5cdFx0Zm9yICh2YXIgaSA9IHByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0cHJvamVjdHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRvb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dG9vbHNbaV0ucmVtb3ZlKCk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0ZGVsZXRlIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF07XG5cdH0sXG5cblx0c3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRuYW1lICs9ICdBdHRyaWJ1dGUnO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRfc2NvcGVzOiB7fSxcblx0XHRcdF9pZDogMCxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2NvcGVzW2lkXSB8fCBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2dldCcpLFxuXHRcdFx0aGFzQXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2hhcycpXG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBQYXBlclNjb3BlSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihhY3RpdmF0ZSkge1xuXHRcdHRoaXMuX3Njb3BlID0gcGFwZXI7XG5cdFx0dGhpcy5faW5kZXggPSB0aGlzLl9zY29wZVt0aGlzLl9saXN0XS5wdXNoKHRoaXMpIC0gMTtcblx0XHRpZiAoYWN0aXZhdGUgfHwgIXRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0pXG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fc2NvcGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHByZXYgPSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdO1xuXHRcdGlmIChwcmV2ICYmIHByZXYgIT09IHRoaXMpXG5cdFx0XHRwcmV2LmVtaXQoJ2RlYWN0aXZhdGUnKTtcblx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gdGhpcztcblx0XHR0aGlzLmVtaXQoJ2FjdGl2YXRlJywgcHJldik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09PSB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2luZGV4ID09IG51bGwpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0QmFzZS5zcGxpY2UodGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRpZiAodGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PSB0aGlzKVxuXHRcdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IG51bGw7XG5cdFx0dGhpcy5fc2NvcGUgPSBudWxsO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5nZXRWaWV3KCk7XG5cdH1cbn0pO1xuXG52YXIgQ29sbGlzaW9uRGV0ZWN0aW9uID0ge1xuXHRmaW5kSXRlbUJvdW5kc0NvbGxpc2lvbnM6IGZ1bmN0aW9uKGl0ZW1zMSwgaXRlbXMyLCB0b2xlcmFuY2UpIHtcblx0XHRmdW5jdGlvbiBnZXRCb3VuZHMoaXRlbXMpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBpdGVtc1tpXS5nZXRCb3VuZHMoKTtcblx0XHRcdFx0Ym91bmRzW2ldID0gW3JlY3QubGVmdCwgcmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fVxuXG5cdFx0dmFyIGJvdW5kczEgPSBnZXRCb3VuZHMoaXRlbXMxKSxcblx0XHRcdGJvdW5kczIgPSAhaXRlbXMyIHx8IGl0ZW1zMiA9PT0gaXRlbXMxXG5cdFx0XHRcdD8gYm91bmRzMVxuXHRcdFx0XHQ6IGdldEJvdW5kcyhpdGVtczIpO1xuXHRcdHJldHVybiB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwKTtcblx0fSxcblxuXHRmaW5kQ3VydmVCb3VuZHNDb2xsaXNpb25zOiBmdW5jdGlvbihjdXJ2ZXMxLCBjdXJ2ZXMyLCB0b2xlcmFuY2UsIGJvdGhBeGlzKSB7XG5cdFx0ZnVuY3Rpb24gZ2V0Qm91bmRzKGN1cnZlcykge1xuXHRcdFx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdFx0XHRtYXggPSBNYXRoLm1heCxcblx0XHRcdFx0Ym91bmRzID0gbmV3IEFycmF5KGN1cnZlcy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHYgPSBjdXJ2ZXNbaV07XG5cdFx0XHRcdGJvdW5kc1tpXSA9IFtcblx0XHRcdFx0XHRtaW4odlswXSwgdlsyXSwgdls0XSwgdls2XSksXG5cdFx0XHRcdFx0bWluKHZbMV0sIHZbM10sIHZbNV0sIHZbN10pLFxuXHRcdFx0XHRcdG1heCh2WzBdLCB2WzJdLCB2WzRdLCB2WzZdKSxcblx0XHRcdFx0XHRtYXgodlsxXSwgdlszXSwgdls1XSwgdls3XSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fVxuXG5cdFx0dmFyIGJvdW5kczEgPSBnZXRCb3VuZHMoY3VydmVzMSksXG5cdFx0XHRib3VuZHMyID0gIWN1cnZlczIgfHwgY3VydmVzMiA9PT0gY3VydmVzMVxuXHRcdFx0XHQ/IGJvdW5kczFcblx0XHRcdFx0OiBnZXRCb3VuZHMoY3VydmVzMik7XG5cdFx0aWYgKGJvdGhBeGlzKSB7XG5cdFx0XHR2YXIgaG9yID0gdGhpcy5maW5kQm91bmRzQ29sbGlzaW9ucyhcblx0XHRcdFx0XHRib3VuZHMxLCBib3VuZHMyLCB0b2xlcmFuY2UgfHwgMCwgZmFsc2UsIHRydWUpLFxuXHRcdFx0XHR2ZXIgPSB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKFxuXHRcdFx0XHRcdGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwLCB0cnVlLCB0cnVlKSxcblx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBob3IubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxpc3RbaV0gPSB7IGhvcjogaG9yW2ldLCB2ZXI6IHZlcltpXSB9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZpbmRCb3VuZHNDb2xsaXNpb25zKGJvdW5kczEsIGJvdW5kczIsIHRvbGVyYW5jZSB8fCAwKTtcblx0fSxcblxuXHRmaW5kQm91bmRzQ29sbGlzaW9uczogZnVuY3Rpb24oYm91bmRzQSwgYm91bmRzQiwgdG9sZXJhbmNlLFxuXHRcdHN3ZWVwVmVydGljYWwsIG9ubHlTd2VlcEF4aXNDb2xsaXNpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSAhYm91bmRzQiB8fCBib3VuZHNBID09PSBib3VuZHNCLFxuXHRcdFx0YWxsQm91bmRzID0gc2VsZiA/IGJvdW5kc0EgOiBib3VuZHNBLmNvbmNhdChib3VuZHNCKSxcblx0XHRcdGxlbmd0aEEgPSBib3VuZHNBLmxlbmd0aCxcblx0XHRcdGxlbmd0aEFsbCA9IGFsbEJvdW5kcy5sZW5ndGg7XG5cblx0XHRmdW5jdGlvbiBiaW5hcnlTZWFyY2goaW5kaWNlcywgY29vcmQsIHZhbHVlKSB7XG5cdFx0XHR2YXIgbG8gPSAwLFxuXHRcdFx0XHRoaSA9IGluZGljZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGxvIDwgaGkpIHtcblx0XHRcdFx0dmFyIG1pZCA9IChoaSArIGxvKSA+Pj4gMTtcblx0XHRcdFx0aWYgKGFsbEJvdW5kc1tpbmRpY2VzW21pZF1dW2Nvb3JkXSA8IHZhbHVlKSB7XG5cdFx0XHRcdFx0bG8gPSBtaWQgKyAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpID0gbWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbG8gLSAxO1xuXHRcdH1cblxuXHRcdHZhciBwcmkwID0gc3dlZXBWZXJ0aWNhbCA/IDEgOiAwLFxuXHRcdFx0cHJpMSA9IHByaTAgKyAyLFxuXHRcdFx0c2VjMCA9IHN3ZWVwVmVydGljYWwgPyAwIDogMSxcblx0XHRcdHNlYzEgPSBzZWMwICsgMjtcblx0XHR2YXIgYWxsSW5kaWNlc0J5UHJpMCA9IG5ldyBBcnJheShsZW5ndGhBbGwpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoQWxsOyBpKyspIHtcblx0XHRcdGFsbEluZGljZXNCeVByaTBbaV0gPSBpO1xuXHRcdH1cblx0XHRhbGxJbmRpY2VzQnlQcmkwLnNvcnQoZnVuY3Rpb24oaTEsIGkyKSB7XG5cdFx0XHRyZXR1cm4gYWxsQm91bmRzW2kxXVtwcmkwXSAtIGFsbEJvdW5kc1tpMl1bcHJpMF07XG5cdFx0fSk7XG5cdFx0dmFyIGFjdGl2ZUluZGljZXNCeVByaTEgPSBbXSxcblx0XHRcdGFsbENvbGxpc2lvbnMgPSBuZXcgQXJyYXkobGVuZ3RoQSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhBbGw7IGkrKykge1xuXHRcdFx0dmFyIGN1ckluZGV4ID0gYWxsSW5kaWNlc0J5UHJpMFtpXSxcblx0XHRcdFx0Y3VyQm91bmRzID0gYWxsQm91bmRzW2N1ckluZGV4XSxcblx0XHRcdFx0b3JpZ0luZGV4ID0gc2VsZiA/IGN1ckluZGV4IDogY3VySW5kZXggLSBsZW5ndGhBLFxuXHRcdFx0XHRpc0N1cnJlbnRBID0gY3VySW5kZXggPCBsZW5ndGhBLFxuXHRcdFx0XHRpc0N1cnJlbnRCID0gc2VsZiB8fCAhaXNDdXJyZW50QSxcblx0XHRcdFx0Y3VyQ29sbGlzaW9ucyA9IGlzQ3VycmVudEEgPyBbXSA6IG51bGw7XG5cdFx0XHRpZiAoYWN0aXZlSW5kaWNlc0J5UHJpMS5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIHBydW5lQ291bnQgPSBiaW5hcnlTZWFyY2goYWN0aXZlSW5kaWNlc0J5UHJpMSwgcHJpMSxcblx0XHRcdFx0XHRcdGN1ckJvdW5kc1twcmkwXSAtIHRvbGVyYW5jZSkgKyAxO1xuXHRcdFx0XHRhY3RpdmVJbmRpY2VzQnlQcmkxLnNwbGljZSgwLCBwcnVuZUNvdW50KTtcblx0XHRcdFx0aWYgKHNlbGYgJiYgb25seVN3ZWVwQXhpc0NvbGxpc2lvbnMpIHtcblx0XHRcdFx0XHRjdXJDb2xsaXNpb25zID0gY3VyQ29sbGlzaW9ucy5jb25jYXQoYWN0aXZlSW5kaWNlc0J5UHJpMSk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRpY2VzQnlQcmkxW2pdO1xuXHRcdFx0XHRcdFx0YWxsQ29sbGlzaW9uc1thY3RpdmVJbmRleF0ucHVzaChvcmlnSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3VyU2VjMSA9IGN1ckJvdW5kc1tzZWMxXSxcblx0XHRcdFx0XHRcdGN1clNlYzAgPSBjdXJCb3VuZHNbc2VjMF07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRpY2VzQnlQcmkxW2pdLFxuXHRcdFx0XHRcdFx0XHRhY3RpdmVCb3VuZHMgPSBhbGxCb3VuZHNbYWN0aXZlSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRpc0FjdGl2ZUEgPSBhY3RpdmVJbmRleCA8IGxlbmd0aEEsXG5cdFx0XHRcdFx0XHRcdGlzQWN0aXZlQiA9IHNlbGYgfHwgYWN0aXZlSW5kZXggPj0gbGVuZ3RoQTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRvbmx5U3dlZXBBeGlzQ29sbGlzaW9ucyB8fFxuXHRcdFx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHRcdFx0aXNDdXJyZW50QSAmJiBpc0FjdGl2ZUIgfHxcblx0XHRcdFx0XHRcdFx0XHRpc0N1cnJlbnRCICYmIGlzQWN0aXZlQVxuXHRcdFx0XHRcdFx0XHQpICYmIChcblx0XHRcdFx0XHRcdFx0XHRjdXJTZWMxID49IGFjdGl2ZUJvdW5kc1tzZWMwXSAtIHRvbGVyYW5jZSAmJlxuXHRcdFx0XHRcdFx0XHRcdGN1clNlYzAgPD0gYWN0aXZlQm91bmRzW3NlYzFdICsgdG9sZXJhbmNlXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNDdXJyZW50QSAmJiBpc0FjdGl2ZUIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJDb2xsaXNpb25zLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxmID8gYWN0aXZlSW5kZXggOiBhY3RpdmVJbmRleCAtIGxlbmd0aEEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChpc0N1cnJlbnRCICYmIGlzQWN0aXZlQSkge1xuXHRcdFx0XHRcdFx0XHRcdGFsbENvbGxpc2lvbnNbYWN0aXZlSW5kZXhdLnB1c2gob3JpZ0luZGV4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQ3VycmVudEEpIHtcblx0XHRcdFx0aWYgKGJvdW5kc0EgPT09IGJvdW5kc0IpIHtcblx0XHRcdFx0XHRjdXJDb2xsaXNpb25zLnB1c2goY3VySW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFsbENvbGxpc2lvbnNbY3VySW5kZXhdID0gY3VyQ29sbGlzaW9ucztcblx0XHRcdH1cblx0XHRcdGlmIChhY3RpdmVJbmRpY2VzQnlQcmkxLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgY3VyUHJpMSA9IGN1ckJvdW5kc1twcmkxXSxcblx0XHRcdFx0XHRpbmRleCA9IGJpbmFyeVNlYXJjaChhY3RpdmVJbmRpY2VzQnlQcmkxLCBwcmkxLCBjdXJQcmkxKTtcblx0XHRcdFx0YWN0aXZlSW5kaWNlc0J5UHJpMS5zcGxpY2UoaW5kZXggKyAxLCAwLCBjdXJJbmRleCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhY3RpdmVJbmRpY2VzQnlQcmkxLnB1c2goY3VySW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFsbENvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjb2xsaXNpb25zID0gYWxsQ29sbGlzaW9uc1tpXTtcblx0XHRcdGlmIChjb2xsaXNpb25zKSB7XG5cdFx0XHRcdGNvbGxpc2lvbnMuc29ydChmdW5jdGlvbihpMSwgaTIpIHsgcmV0dXJuIGkxIC0gaTI7IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYWxsQ29sbGlzaW9ucztcblx0fVxufTtcblxudmFyIEZvcm1hdHRlciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBCYXNlLnBpY2socHJlY2lzaW9uLCA1KTtcblx0XHR0aGlzLm11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgdGhpcy5wcmVjaXNpb24pO1xuXHR9LFxuXG5cdG51bWJlcjogZnVuY3Rpb24odmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlY2lzaW9uIDwgMTZcblx0XHRcdFx0PyBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXIgOiB2YWw7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdGxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cyRTtcblx0XHR9LFxuXHRcdEVQU0lMT04gPSAxZS0xMixcblx0XHRNQUNISU5FX0VQU0lMT04gPSAxLjEyZS0xNjtcblxuXHRmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcblx0XHRyZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpIHtcblx0XHRmdW5jdGlvbiBzcGxpdCh2KSB7XG5cdFx0XHR2YXIgeCA9IHYgKiAxMzQyMTc3MjksXG5cdFx0XHRcdHkgPSB2IC0geCxcblx0XHRcdFx0aGkgPSB5ICsgeCxcblx0XHRcdFx0bG8gPSB2IC0gaGk7XG5cdFx0XHRyZXR1cm4gW2hpLCBsb107XG5cdFx0fVxuXG5cdFx0dmFyIEQgPSBiICogYiAtIGEgKiBjLFxuXHRcdFx0RSA9IGIgKiBiICsgYSAqIGM7XG5cdFx0aWYgKGFicyhEKSAqIDMgPCBFKSB7XG5cdFx0XHR2YXIgYWQgPSBzcGxpdChhKSxcblx0XHRcdFx0YmQgPSBzcGxpdChiKSxcblx0XHRcdFx0Y2QgPSBzcGxpdChjKSxcblx0XHRcdFx0cCA9IGIgKiBiLFxuXHRcdFx0XHRkcCA9IChiZFswXSAqIGJkWzBdIC0gcCArIDIgKiBiZFswXSAqIGJkWzFdKSArIGJkWzFdICogYmRbMV0sXG5cdFx0XHRcdHEgPSBhICogYyxcblx0XHRcdFx0ZHEgPSAoYWRbMF0gKiBjZFswXSAtIHEgKyBhZFswXSAqIGNkWzFdICsgYWRbMV0gKiBjZFswXSlcblx0XHRcdFx0XHRcdCsgYWRbMV0gKiBjZFsxXTtcblx0XHRcdEQgPSAocCAtIHEpICsgKGRwIC0gZHEpO1xuXHRcdH1cblx0XHRyZXR1cm4gRDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25GYWN0b3IoKSB7XG5cdFx0dmFyIG5vcm0gPSBNYXRoLm1heC5hcHBseShNYXRoLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBub3JtICYmIChub3JtIDwgMWUtOCB8fCBub3JtID4gMWU4KVxuXHRcdFx0XHQ/IHBvdygyLCAtTWF0aC5yb3VuZChsb2cyKG5vcm0pKSlcblx0XHRcdFx0OiAwO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRFUFNJTE9OOiBFUFNJTE9OLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTjogTUFDSElORV9FUFNJTE9OLFxuXHRcdENVUlZFVElNRV9FUFNJTE9OOiAxZS04LFxuXHRcdEdFT01FVFJJQ19FUFNJTE9OOiAxZS03LFxuXHRcdFRSSUdPTk9NRVRSSUNfRVBTSUxPTjogMWUtOCxcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiB2YWwgPj0gLUVQU0lMT04gJiYgdmFsIDw9IEVQU0lMT047XG5cdFx0fSxcblxuXHRcdGlzTWFjaGluZVplcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbCA+PSAtTUFDSElORV9FUFNJTE9OICYmIHZhbCA8PSBNQUNISU5FX0VQU0lMT047XG5cdFx0fSxcblxuXHRcdGNsYW1wOiBjbGFtcCxcblxuXHRcdGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xuXHRcdFx0dmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuXHRcdFx0XHR3ID0gd2VpZ2h0c1tuIC0gMl0sXG5cdFx0XHRcdEEgPSAoYiAtIGEpICogMC41LFxuXHRcdFx0XHRCID0gQSArIGEsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRtID0gKG4gKyAxKSA+PiAxLFxuXHRcdFx0XHRzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwO1xuXHRcdFx0d2hpbGUgKGkgPCBtKSB7XG5cdFx0XHRcdHZhciBBeCA9IEEgKiB4W2ldO1xuXHRcdFx0XHRzdW0gKz0gd1tpKytdICogKGYoQiArIEF4KSArIGYoQiAtIEF4KSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQSAqIHN1bTtcblx0XHR9LFxuXG5cdFx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGYsIGRmLCB4LCBhLCBiLCBuLCB0b2xlcmFuY2UpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBmeCA9IGYoeCksXG5cdFx0XHRcdFx0ZHggPSBmeCAvIGRmKHgpLFxuXHRcdFx0XHRcdG54ID0geCAtIGR4O1xuXHRcdFx0XHRpZiAoYWJzKGR4KSA8IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSBueDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjbGFtcCh4LCBhLCBiKTtcblx0XHR9LFxuXG5cdFx0c29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIHgxLCB4MiA9IEluZmluaXR5O1xuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhiKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7XG5cdFx0XHRcdHgxID0gLWMgLyBiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YiAqPSAtMC41O1xuXHRcdFx0XHR2YXIgRCA9IGdldERpc2NyaW1pbmFudChhLCBiLCBjKTtcblx0XHRcdFx0aWYgKEQgJiYgYWJzKEQpIDwgTUFDSElORV9FUFNJTE9OKSB7XG5cdFx0XHRcdFx0dmFyIGYgPSBnZXROb3JtYWxpemF0aW9uRmFjdG9yKGFicyhhKSwgYWJzKGIpLCBhYnMoYykpO1xuXHRcdFx0XHRcdGlmIChmKSB7XG5cdFx0XHRcdFx0XHRhICo9IGY7XG5cdFx0XHRcdFx0XHRiICo9IGY7XG5cdFx0XHRcdFx0XHRjICo9IGY7XG5cdFx0XHRcdFx0XHREID0gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoRCA+PSAtTUFDSElORV9FUFNJTE9OKSB7XG5cdFx0XHRcdFx0dmFyIFEgPSBEIDwgMCA/IDAgOiBzcXJ0KEQpLFxuXHRcdFx0XHRcdFx0UiA9IGIgKyAoYiA8IDAgPyAtUSA6IFEpO1xuXHRcdFx0XHRcdGlmIChSID09PSAwKSB7XG5cdFx0XHRcdFx0XHR4MSA9IGMgLyBhO1xuXHRcdFx0XHRcdFx0eDIgPSAteDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHgxID0gUiAvIGE7XG5cdFx0XHRcdFx0XHR4MiA9IGMgLyBSO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNvdW50ID0gMCxcblx0XHRcdFx0Ym91bmRsZXNzID0gbWluID09IG51bGwsXG5cdFx0XHRcdG1pbkIgPSBtaW4gLSBFUFNJTE9OLFxuXHRcdFx0XHRtYXhCID0gbWF4ICsgRVBTSUxPTjtcblx0XHRcdGlmIChpc0Zpbml0ZSh4MSkgJiYgKGJvdW5kbGVzcyB8fCB4MSA+IG1pbkIgJiYgeDEgPCBtYXhCKSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4MSA6IGNsYW1wKHgxLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoeDIgIT09IHgxXG5cdFx0XHRcdFx0JiYgaXNGaW5pdGUoeDIpICYmIChib3VuZGxlc3MgfHwgeDIgPiBtaW5CICYmIHgyIDwgbWF4QikpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geDIgOiBjbGFtcCh4MiwgbWluLCBtYXgpO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBmID0gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcihhYnMoYSksIGFicyhiKSwgYWJzKGMpLCBhYnMoZCkpLFxuXHRcdFx0XHR4LCBiMSwgYzIsIHFkLCBxO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0YSAqPSBmO1xuXHRcdFx0XHRiICo9IGY7XG5cdFx0XHRcdGMgKj0gZjtcblx0XHRcdFx0ZCAqPSBmO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBldmFsdWF0ZSh4MCkge1xuXHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdHZhciB0bXAgPSBhICogeDtcblx0XHRcdFx0YjEgPSB0bXAgKyBiO1xuXHRcdFx0XHRjMiA9IGIxICogeCArIGM7XG5cdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMjtcblx0XHRcdFx0cSA9IGMyICogeCArIGQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRiMSA9IGM7XG5cdFx0XHRcdGMyID0gZDtcblx0XHRcdFx0eCA9IEluZmluaXR5O1xuXHRcdFx0fSBlbHNlIGlmIChhYnMoZCkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGIxID0gYjtcblx0XHRcdFx0YzIgPSBjO1xuXHRcdFx0XHR4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2YWx1YXRlKC0oYiAvIGEpIC8gMyk7XG5cdFx0XHRcdHZhciB0ID0gcSAvIGEsXG5cdFx0XHRcdFx0ciA9IHBvdyhhYnModCksIDEvMyksXG5cdFx0XHRcdFx0cyA9IHQgPCAwID8gLTEgOiAxLFxuXHRcdFx0XHRcdHRkID0gLXFkIC8gYSxcblx0XHRcdFx0XHRyZCA9IHRkID4gMCA/IDEuMzI0NzE3OTU3MjQ0NzQ2ICogTWF0aC5tYXgociwgc3FydCh0ZCkpIDogcixcblx0XHRcdFx0XHR4MCA9IHggLSBzICogcmQ7XG5cdFx0XHRcdGlmICh4MCAhPT0geCkge1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdGV2YWx1YXRlKHgwKTtcblx0XHRcdFx0XHRcdHgwID0gcWQgPT09IDAgPyB4IDogeCAtIHEgLyBxZCAvICgxICsgTUFDSElORV9FUFNJTE9OKTtcblx0XHRcdFx0XHR9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cdFx0XHRcdFx0aWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuXHRcdFx0XHRcdFx0YzIgPSAtZCAvIHg7XG5cdFx0XHRcdFx0XHRiMSA9IChjMiAtIGMpIC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCksXG5cdFx0XHRcdGJvdW5kbGVzcyA9IG1pbiA9PSBudWxsO1xuXHRcdFx0aWYgKGlzRmluaXRlKHgpICYmIChjb3VudCA9PT0gMFxuXHRcdFx0XHRcdHx8IGNvdW50ID4gMCAmJiB4ICE9PSByb290c1swXSAmJiB4ICE9PSByb290c1sxXSlcblx0XHRcdFx0XHQmJiAoYm91bmRsZXNzIHx8IHggPiBtaW4gLSBFUFNJTE9OICYmIHggPCBtYXggKyBFUFNJTE9OKSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4IDogY2xhbXAoeCwgbWluLCBtYXgpO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBVSUQgPSB7XG5cdF9pZDogMSxcblx0X3Bvb2xzOiB7fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZiAobmFtZSkge1xuXHRcdFx0dmFyIHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXTtcblx0XHRcdGlmICghcG9vbClcblx0XHRcdFx0cG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdID0geyBfaWQ6IDEgfTtcblx0XHRcdHJldHVybiBwb29sLl9pZCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faWQrKztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnQnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZGluZyA9IHRoaXMuX19yZWFkLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMuX3NldChhcmcwLCBoYXNZID8gYXJnMSA6IGFyZzApO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHJlYWQgPSBoYXNZID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9zZXQoMCwgMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG9iaiA9IHR5cGUgPT09ICdzdHJpbmcnID8gYXJnMC5zcGxpdCgvW1xccyxdKy8pIHx8IFtdIDogYXJnMDtcblx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHR0aGlzLl9zZXQoK29ialswXSwgKyhvYmoubGVuZ3RoID4gMSA/IG9ialsxXSA6IG9ialswXSkpO1xuXHRcdFx0fSBlbHNlIGlmICgneCcgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoueCB8fCAwLCBvYmoueSB8fCAwKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3dpZHRoJyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai53aWR0aCB8fCAwLCBvYmouaGVpZ2h0IHx8IDApO1xuXHRcdFx0fSBlbHNlIGlmICgnYW5nbGUnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLmxlbmd0aCB8fCAwLCAwKTtcblx0XHRcdFx0dGhpcy5zZXRBbmdsZShvYmouYW5nbGUgfHwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZXQoMCwgMCk7XG5cdFx0XHRcdHJlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocmVhZGluZylcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXQ6ICcjaW5pdGlhbGl6ZScsXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50XG5cdFx0XHRcdCYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG5cdFx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShwb2ludClcblx0XHRcdFx0XHRcdCYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXHRcdFx0dGhpcy5fc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSlcblx0XHRcdFx0dGhpcy5nZXRBbmdsZSgpO1xuXHRcdFx0dGhpcy5fc2V0KFxuXHRcdFx0XHR0aGlzLnggKiBzY2FsZSxcblx0XHRcdFx0dGhpcy55ICogc2NhbGVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXHRnZXRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QW5nbGVJblJhZGlhbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0c2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0dGhpcy5zZXRBbmdsZUluUmFkaWFucy5jYWxsKHRoaXMsIGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7XG5cdH0sXG5cblx0Z2V0QW5nbGVJbkRlZ3JlZXM6ICcjZ2V0QW5nbGUnLFxuXHRzZXRBbmdsZUluRGVncmVlczogJyNzZXRBbmdsZScsXG5cblx0Z2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2FuZ2xlIHx8IDBcblx0XHRcdFx0XHQ6IHRoaXMuX2FuZ2xlID0gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0ZGl2ID0gdGhpcy5nZXRMZW5ndGgoKSAqIHBvaW50LmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZGl2KSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSB0aGlzLmRvdChwb2ludCkgLyBkaXY7XG5cdFx0XHRcdHJldHVybiBNYXRoLmFjb3MoYSA8IC0xID8gLTEgOiBhID4gMSA/IDEgOiBhKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdFx0dGhpcy5fYW5nbGUgPSBhbmdsZTtcblx0XHRpZiAoIXRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0dGhpcy5fc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdHggPSBwb2ludC54IC0gdGhpcy54LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLnksXG5cdFx0XHRkID0geCAqIHggKyB5ICogeSxcblx0XHRcdHNxdWFyZWQgPSBCYXNlLnJlYWQoYXJncyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHBvaW50ID0gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIGNvcyAtIHBvaW50LnkgKiBzaW4sXG5cdFx0XHRwb2ludC54ICogc2luICsgcG9pbnQueSAqIGNvc1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0dG9sZXJhbmNlID0gQmFzZS5yZWFkKGFyZ3MpO1xuXHRcdHJldHVybiB0aGlzLmdldERpc3RhbmNlKHBvaW50KSA8PSB0b2xlcmFuY2U7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6ICcjaXNDb2xsaW5lYXInLFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIGlzWmVybyh0aGlzLngpICYmIGlzWmVybyh0aGlzLnkpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy54KSB8fCBpc05hTih0aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5RdWFkcmFudDogZnVuY3Rpb24ocSkge1xuXHRcdHJldHVybiB0aGlzLnggKiAocSA+IDEgJiYgcSA8IDQgPyAtMSA6IDEpID49IDBcblx0XHRcdCYmIHRoaXMueSAqIChxID4gMiA/IC0xIDogMSkgPj0gMDtcblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueCArIHRoaXMueSAqIHBvaW50Lnk7XG5cdH0sXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueSAtIHRoaXMueSAqIHBvaW50Lng7XG5cdH0sXG5cblx0cHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0c2NhbGUgPSBwb2ludC5pc1plcm8oKSA/IDAgOiB0aGlzLmRvdChwb2ludCkgLyBwb2ludC5kb3QocG9pbnQpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRwb2ludC55ICogc2NhbGVcblx0XHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHBvaW50MSA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJncyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHBvaW50MSA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJncyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9LFxuXG5cdFx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB5MiAtIHkxICogeDIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS04O1xuXHRcdH0sXG5cblx0XHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB4MiArIHkxICogeTIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS04O1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBvcCA9IE1hdGhba2V5XTtcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgdGhpcy5fZ2V0U2VsZWN0aW9uKCkpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VTZWxlY3Rpb24odGhpcy5fZ2V0U2VsZWN0aW9uKCksIHNlbGVjdGVkKTtcblx0fSxcblxuXHRfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0dGVyID09PSAnc2V0UG9zaXRpb24nID8gNCA6IDA7XG5cdH1cbn0pO1xuXG52YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2l6ZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMuX3NldChhcmcwLCBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGhhc0hlaWdodCA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fc2V0KDAsIDApO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvYmogPSB0eXBlID09PSAnc3RyaW5nJyA/IGFyZzAuc3BsaXQoL1tcXHMsXSsvKSB8fCBbXSA6IGFyZzA7XG5cdFx0XHRyZWFkID0gMTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0dGhpcy5fc2V0KCtvYmpbMF0sICsob2JqLmxlbmd0aCA+IDEgPyBvYmpbMV0gOiBvYmpbMF0pKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3dpZHRoJyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai53aWR0aCB8fCAwLCBvYmouaGVpZ2h0IHx8IDApO1xuXHRcdFx0fSBlbHNlIGlmICgneCcgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoueCB8fCAwLCBvYmoueSB8fCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdFx0cmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIGlzWmVybyh0aGlzLndpZHRoKSAmJiBpc1plcm8odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBvcCA9IE1hdGhba2V5XTtcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl93aWR0aDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgUmVjdGFuZ2xlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSZWN0YW5nbGUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0dHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMuX3NldChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcblx0XHRcdHJlYWQgPSA0O1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fc2V0KDAsIDAsIDAsIDApO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLl9zZXQuYXBwbHkodGhpcywgYXJnMCk7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzAueCB8fCAwLCBhcmcwLnkgfHwgMCxcblx0XHRcdFx0XHRcdGFyZzAud2lkdGggfHwgMCwgYXJnMC5oZWlnaHQgfHwgMCk7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc2V0KDAsIDAsIDAsIDApO1xuXHRcdFx0XHRpZiAoQmFzZS5yZWFkU3VwcG9ydGVkKGFyZ3MsIHRoaXMpKSB7XG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHJlYWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIGZybSA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3MpLFxuXHRcdFx0XHR4ID0gZnJtLngsXG5cdFx0XHRcdHkgPSBmcm0ueSxcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodDtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJncywgJ3RvJykpIHtcblx0XHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0bycpO1xuXHRcdFx0XHR3aWR0aCA9IHRvLnggLSB4O1xuXHRcdFx0XHRoZWlnaHQgPSB0by55IC0geTtcblx0XHRcdFx0aWYgKHdpZHRoIDwgMCkge1xuXHRcdFx0XHRcdHggPSB0by54O1xuXHRcdFx0XHRcdHdpZHRoID0gLXdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0eSA9IHRvLnk7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gLWhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJncyk7XG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRyZWFkID0gYXJncy5fX2luZGV4O1xuXHRcdH1cblx0XHR2YXIgZmlsdGVyZWQgPSBhcmdzLl9fZmlsdGVyZWQ7XG5cdFx0aWYgKGZpbHRlcmVkKVxuXHRcdFx0dGhpcy5fX2ZpbHRlcmVkID0gZmlsdGVyZWQ7XG5cdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuXHRcdFx0XHQ/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0OiByZWN0O1xuXHRcdHJldHVybiBydCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55XG5cdFx0XHRcdFx0JiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpXG5cdFx0XHRcdCsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcblx0XHRcdFx0KyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpXG5cdFx0XHRcdCsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMueSksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRfZnc6IDEsXG5cdF9maDogMSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0c3ggPSB0aGlzLl9zeCxcblx0XHRcdHN5ID0gdGhpcy5fc3ksXG5cdFx0XHR3ID0gc2l6ZS53aWR0aCxcblx0XHRcdGggPSBzaXplLmhlaWdodDtcblx0XHRpZiAoc3gpIHtcblx0XHRcdHRoaXMueCArPSAodGhpcy53aWR0aCAtIHcpICogc3g7XG5cdFx0fVxuXHRcdGlmIChzeSkge1xuXHRcdFx0dGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIGgpICogc3k7XG5cdFx0fVxuXHRcdHRoaXMud2lkdGggPSB3O1xuXHRcdHRoaXMuaGVpZ2h0ID0gaDtcblx0XHR0aGlzLl9mdyA9IHRoaXMuX2ZoID0gMTtcblx0fSxcblxuXHRnZXRMZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9LFxuXG5cdHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcblx0XHRpZiAoIXRoaXMuX2Z3KSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gbGVmdCAtIHRoaXMueDtcblx0XHRcdHRoaXMud2lkdGggLT0gdGhpcy5fc3ggPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG5cdFx0fVxuXHRcdHRoaXMueCA9IGxlZnQ7XG5cdFx0dGhpcy5fc3ggPSB0aGlzLl9mdyA9IDA7XG5cdH0sXG5cblx0Z2V0VG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55O1xuXHR9LFxuXG5cdHNldFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0aWYgKCF0aGlzLl9maCkge1xuXHRcdFx0dmFyIGFtb3VudCA9IHRvcCAtIHRoaXMueTtcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRoaXMuX3N5ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuXHRcdH1cblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fc3kgPSB0aGlzLl9maCA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICghdGhpcy5fZncpIHtcblx0XHRcdHZhciBhbW91bnQgPSByaWdodCAtIHRoaXMueDtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLl9zeCA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdHRoaXMuX3N4ID0gMTtcblx0XHR0aGlzLl9mdyA9IDA7XG5cdH0sXG5cblx0Z2V0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0c2V0Qm90dG9tOiBmdW5jdGlvbihib3R0b20pIHtcblx0XHRpZiAoIXRoaXMuX2ZoKSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gYm90dG9tIC0gdGhpcy55O1xuXHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLl9zeSA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0dGhpcy5fc3kgPSAxO1xuXHRcdHRoaXMuX2ZoID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXJYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdGlmICh0aGlzLl9mdyB8fCB0aGlzLl9zeCA9PT0gMC41KSB7XG5cdFx0XHR0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLl9zeCkge1xuXHRcdFx0XHR0aGlzLnggKz0gKHggLSB0aGlzLngpICogMiAqIHRoaXMuX3N4O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy53aWR0aCA9ICh4IC0gdGhpcy54KSAqIDI7XG5cdFx0fVxuXHRcdHRoaXMuX3N4ID0gMC41O1xuXHRcdHRoaXMuX2Z3ID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXJZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHRpZiAodGhpcy5fZmggfHwgdGhpcy5fc3kgPT09IDAuNSkge1xuXHRcdFx0dGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX3N5KSB7XG5cdFx0XHRcdHRoaXMueSArPSAoeSAtIHRoaXMueSkgKiAyICogdGhpcy5fc3k7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhlaWdodCA9ICh5IC0gdGhpcy55KSAqIDI7XG5cdFx0fVxuXHRcdHRoaXMuX3N5ID0gMC41O1xuXHRcdHRoaXMuX2ZoID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQ/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHRcdDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeCA9IHJlY3QueCxcblx0XHRcdHkgPSByZWN0Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGVwc2lsb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSB8fCAwO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54IC0gZXBzaWxvblxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueSAtIGVwc2lsb25cblx0XHRcdFx0JiYgcmVjdC54IDwgdGhpcy54ICsgdGhpcy53aWR0aCArIGVwc2lsb25cblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQgKyBlcHNpbG9uO1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyksXG5cdFx0XHR4Rmlyc3QgPSAvXltSTF0vLnRlc3QocGFydCk7XG5cdFx0aWYgKGluZGV4ID49IDQpXG5cdFx0XHRwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG5cdFx0dmFyIHggPSBwYXJ0c1t4Rmlyc3QgPyAwIDogMV0sXG5cdFx0XHR5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuXHRcdFx0Z2V0WCA9ICdnZXQnICsgeCxcblx0XHRcdGdldFkgPSAnZ2V0JyArIHksXG5cdFx0XHRzZXRYID0gJ3NldCcgKyB4LFxuXHRcdFx0c2V0WSA9ICdzZXQnICsgeSxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydCxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydDtcblx0XHR0aGlzW2dldF0gPSBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcblx0XHR9O1xuXHRcdHRoaXNbc2V0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpc1tzZXRYXShwb2ludC54KTtcblx0XHRcdHRoaXNbc2V0WV0ocG9pbnQueSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH1cbikpO1xuXG52YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGludGVybmFsID0gJ18nICsga2V5O1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuXHRcdH07XG5cblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpc1tpbnRlcm5hbF0gPSB2YWx1ZTtcblx0XHRcdGlmICghdGhpcy5fZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHR9O1xuXHR9LCBCYXNlLmVhY2goWydQb2ludCcsICdTaXplJywgJ0NlbnRlcicsXG5cdFx0XHQnTGVmdCcsICdUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0NlbnRlclgnLCAnQ2VudGVyWScsXG5cdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXSxcblx0XHRmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciBuYW1lID0gJ3NldCcgKyBrZXk7XG5cdFx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSB0cnVlO1xuXHRcdFx0XHRwcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIDIpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdFx0XHRpZiAob3duZXIuX2NoYW5nZVNlbGVjdGlvbikge1xuXHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VTZWxlY3Rpb24oMiwgc2VsZWN0ZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0KTtcbn0pO1xuXG52YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdNYXRyaXgnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRjb3VudCA9IGFyZ3MubGVuZ3RoLFxuXHRcdFx0b2sgPSB0cnVlO1xuXHRcdGlmIChjb3VudCA+PSA2KSB7XG5cdFx0XHR0aGlzLl9zZXQuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSB8fCBjb3VudCA9PT0gMikge1xuXHRcdFx0aWYgKGFyZyBpbnN0YW5jZW9mIE1hdHJpeCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnLl9hLCBhcmcuX2IsIGFyZy5fYywgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5LFxuXHRcdFx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0dGhpcy5fc2V0LmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRfZG9udE5vdGlmeSA/IGFyZy5jb25jYXQoW19kb250Tm90aWZ5XSkgOiBhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFjb3VudCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIW9rKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fYyA9IGM7XG5cdFx0dGhpcy5fZCA9IGQ7XG5cdFx0dGhpcy5fdHggPSB0eDtcblx0XHR0aGlzLl90eSA9IHR5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG93bmVyLl9jaGFuZ2VkKDI1KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsXG5cdFx0XHRcdHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYlxuXHRcdFx0XHQmJiB0aGlzLl9jID09PSBteC5fYyAmJiB0aGlzLl9kID09PSBteC5fZFxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gbXguX3R4ICYmIHRoaXMuX3R5ID09PSBteC5fdHk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9jKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eCldLmpvaW4oJywgJykgKyAnXSwgWydcblx0XHRcdFx0KyBbZi5udW1iZXIodGhpcy5fYiksIGYubnVtYmVyKHRoaXMuX2QpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R5KV0uam9pbignLCAnKSArICddXSc7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuXHRcdHRoaXMuX2IgPSB0aGlzLl9jID0gdGhpcy5fdHggPSB0aGlzLl90eSA9IDA7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBseTogZnVuY3Rpb24ocmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIEJhc2UucGljayhyZWN1cnNpdmVseSwgdHJ1ZSksIF9zZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0dGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYztcblx0XHR0aGlzLl90eSArPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRzY2FsZSA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dGhpcy5fYSAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2IgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9jICo9IHNjYWxlLnk7XG5cdFx0dGhpcy5fZCAqPSBzY2FsZS55O1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcblx0XHRcdHggPSBjZW50ZXIueCxcblx0XHRcdHkgPSBjZW50ZXIueSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuXHRcdFx0dHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG5cdFx0XHRhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGM7XG5cdFx0dGhpcy5fYiA9IGNvcyAqIGIgKyBzaW4gKiBkO1xuXHRcdHRoaXMuX2MgPSAtc2luICogYSArIGNvcyAqIGM7XG5cdFx0dGhpcy5fZCA9IC1zaW4gKiBiICsgY29zICogZDtcblx0XHR0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGM7XG5cdFx0dGhpcy5fdHkgKz0gdHggKiBiICsgdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRzaGVhciA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2I7XG5cdFx0dGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYztcblx0XHR0aGlzLl9iICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2MgKz0gc2hlYXIueCAqIGE7XG5cdFx0dGhpcy5fZCArPSBzaGVhci54ICogYjtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2tldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRza2V3ID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJncywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuXHRcdFx0XHRNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcblx0XHRyZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKG14LCBfZG9udE5vdGlmeSkge1xuXHRcdGlmIChteCkge1xuXHRcdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdFx0YjIgPSBteC5fYyxcblx0XHRcdFx0YzIgPSBteC5fYixcblx0XHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYzE7XG5cdFx0XHR0aGlzLl9jID0gYjIgKiBhMSArIGQyICogYzE7XG5cdFx0XHR0aGlzLl9iID0gYTIgKiBiMSArIGMyICogZDE7XG5cdFx0XHR0aGlzLl9kID0gYjIgKiBiMSArIGQyICogZDE7XG5cdFx0XHR0aGlzLl90eCArPSB0eDIgKiBhMSArIHR5MiAqIGMxO1xuXHRcdFx0dGhpcy5fdHkgKz0gdHgyICogYjEgKyB0eTIgKiBkMTtcblx0XHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24obXgsIF9kb250Tm90aWZ5KSB7XG5cdFx0aWYgKG14KSB7XG5cdFx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdFx0dHkxID0gdGhpcy5fdHksXG5cdFx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRcdGIyID0gbXguX2MsXG5cdFx0XHRcdGMyID0gbXguX2IsXG5cdFx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdFx0dGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGIxO1xuXHRcdFx0dGhpcy5fYyA9IGEyICogYzEgKyBiMiAqIGQxO1xuXHRcdFx0dGhpcy5fYiA9IGMyICogYTEgKyBkMiAqIGIxO1xuXHRcdFx0dGhpcy5fZCA9IGMyICogYzEgKyBkMiAqIGQxO1xuXHRcdFx0dGhpcy5fdHggPSBhMiAqIHR4MSArIGIyICogdHkxICsgdHgyO1xuXHRcdFx0dGhpcy5fdHkgPSBjMiAqIHR4MSArIGQyICogdHkxICsgdHkyO1xuXHRcdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBlbmRlZDogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmFwcGVuZChteCk7XG5cdH0sXG5cblx0cHJlcGVuZGVkOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkucHJlcGVuZChteCk7XG5cdH0sXG5cblx0aW52ZXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2QsXG5cdFx0XHR0eCA9IHRoaXMuX3R4LFxuXHRcdFx0dHkgPSB0aGlzLl90eSxcblx0XHRcdGRldCA9IGEgKiBkIC0gYiAqIGMsXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChkZXQgJiYgIWlzTmFOKGRldCkgJiYgaXNGaW5pdGUodHgpICYmIGlzRmluaXRlKHR5KSkge1xuXHRcdFx0dGhpcy5fYSA9IGQgLyBkZXQ7XG5cdFx0XHR0aGlzLl9iID0gLWIgLyBkZXQ7XG5cdFx0XHR0aGlzLl9jID0gLWMgLyBkZXQ7XG5cdFx0XHR0aGlzLl9kID0gYSAvIGRldDtcblx0XHRcdHRoaXMuX3R4ID0gKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXQ7XG5cdFx0XHR0aGlzLl90eSA9IChiICogdHggLSBhICogdHkpIC8gZGV0O1xuXHRcdFx0cmVzID0gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRpbnZlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnQoKTtcblx0fSxcblxuXHRjb25jYXRlbmF0ZTogJyNhcHBlbmQnLFxuXHRwcmVDb25jYXRlbmF0ZTogJyNwcmVwZW5kJyxcblx0Y2hhaW46ICcjYXBwZW5kZWQnLFxuXG5cdF9zaGlmdGxlc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIDAsIDApO1xuXHR9LFxuXG5cdF9vck51bGxJZklkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCkgPyBudWxsIDogdGhpcztcblx0fSxcblxuXHRpc0lkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9iID09PSAwICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fZCA9PT0gMVxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gMCAmJiB0aGlzLl90eSA9PT0gMDtcblx0fSxcblxuXHRpc0ludmVydGlibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9hICogdGhpcy5fZCAtIHRoaXMuX2MgKiB0aGlzLl9iO1xuXHRcdHJldHVybiBkZXQgJiYgIWlzTmFOKGRldCkgJiYgaXNGaW5pdGUodGhpcy5fdHgpICYmIGlzRmluaXRlKHRoaXMuX3R5KTtcblx0fSxcblxuXHRpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuaXNJbnZlcnRpYmxlKCk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbiggc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzXG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5fc2V0KFxuXHRcdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jICsgdGhpcy5fdHgsXG5cdFx0XHRcdHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24oc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG1heCA9IDIgKiBjb3VudDsgaSA8IG1heDsgaSArPSAyKSB7XG5cdFx0XHR2YXIgeCA9IHNyY1tpXSxcblx0XHRcdFx0eSA9IHNyY1tpICsgMV07XG5cdFx0XHRkc3RbaV0gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaSArIDFdID0geCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5O1xuXHRcdH1cblx0XHRyZXR1cm4gZHN0O1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db3JuZXJzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LFxuXHRcdFx0eTEgPSByZWN0LnksXG5cdFx0XHR4MiA9IHgxICsgcmVjdC53aWR0aCxcblx0XHRcdHkyID0geTEgKyByZWN0LmhlaWdodCxcblx0XHRcdGNvb3JkcyA9IFsgeDEsIHkxLCB4MiwgeTEsIHgyLCB5MiwgeDEsIHkyIF07XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCA0KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQm91bmRzOiBmdW5jdGlvbihib3VuZHMsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuX3RyYW5zZm9ybUNvcm5lcnMoYm91bmRzKSxcblx0XHRcdG1pbiA9IGNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG5cdFx0XHR2YXIgdmFsID0gY29vcmRzW2ldLFxuXHRcdFx0XHRqID0gaSAmIDE7XG5cdFx0XHRpZiAodmFsIDwgbWluW2pdKSB7XG5cdFx0XHRcdG1pbltqXSA9IHZhbDtcblx0XHRcdH0gZWxzZSBpZiAodmFsID4gbWF4W2pdKSB7XG5cdFx0XHRcdG1heFtqXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBSZWN0YW5nbGUoKTtcblx0XHRyZXR1cm4gZGVzdC5fc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2ludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZCxcblx0XHRcdHR4ID0gdGhpcy5fdHgsXG5cdFx0XHR0eSA9IHRoaXMuX3R5LFxuXHRcdFx0ZGV0ID0gYSAqIGQgLSBiICogYyxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG5cdFx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLl90eCxcblx0XHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRcdGlmICghZGVzdClcblx0XHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdFx0cmVzID0gZGVzdC5fc2V0KFxuXHRcdFx0XHRcdCh4ICogZCAtIHkgKiBjKSAvIGRldCxcblx0XHRcdFx0XHQoeSAqIGEgLSB4ICogYikgLyBkZXQsXG5cdFx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kLFxuXHRcdFx0ZGV0ID0gYSAqIGQgLSBiICogYyxcblx0XHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0XHRhdGFuMiA9IE1hdGguYXRhbjIsXG5cdFx0XHRkZWdyZWVzID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdHJvdGF0ZSxcblx0XHRcdHNjYWxlLFxuXHRcdFx0c2tldztcblx0XHRpZiAoYSAhPT0gMCB8fCBiICE9PSAwKSB7XG5cdFx0XHR2YXIgciA9IHNxcnQoYSAqIGEgKyBiICogYik7XG5cdFx0XHRyb3RhdGUgPSBNYXRoLmFjb3MoYSAvIHIpICogKGIgPiAwID8gMSA6IC0xKTtcblx0XHRcdHNjYWxlID0gW3IsIGRldCAvIHJdO1xuXHRcdFx0c2tldyA9IFthdGFuMihhICogYyArIGIgKiBkLCByICogciksIDBdO1xuXHRcdH0gZWxzZSBpZiAoYyAhPT0gMCB8fCBkICE9PSAwKSB7XG5cdFx0XHR2YXIgcyA9IHNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0XHRyb3RhdGUgPSBNYXRoLmFzaW4oYyAvIHMpICAqIChkID4gMCA/IDEgOiAtMSk7XG5cdFx0XHRzY2FsZSA9IFtkZXQgLyBzLCBzXTtcblx0XHRcdHNrZXcgPSBbMCwgYXRhbjIoYSAqIGMgKyBiICogZCwgcyAqIHMpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cm90YXRlID0gMDtcblx0XHRcdHNrZXcgPSBzY2FsZSA9IFswLCAwXTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRyYW5zbGF0aW9uOiB0aGlzLmdldFRyYW5zbGF0aW9uKCksXG5cdFx0XHRyb3RhdGlvbjogcm90YXRlICogZGVncmVlcyxcblx0XHRcdHNjYWxpbmc6IG5ldyBQb2ludChzY2FsZSksXG5cdFx0XHRza2V3aW5nOiBuZXcgUG9pbnQoc2tld1swXSAqIGRlZ3JlZXMsIHNrZXdbMV0gKiBkZWdyZWVzKVxuXHRcdH07XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyB0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkgXTtcblx0fSxcblxuXHRnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRlY29tcG9zZSgpLnJvdGF0aW9uO1xuXHR9LFxuXG5cdGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuaXNJZGVudGl0eSgpKSB7XG5cdFx0XHRjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsXG5cdFx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2EnLCAnYicsICdjJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0cHJvcCA9ICdfJyArIGtleTtcblx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF07XG5cdH07XG5cdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdMaW5lJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcblx0XHR2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzE7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzI7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzM7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMC54O1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcwLnk7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzEueDtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMS55O1xuXHRcdFx0YXNWZWN0b3IgPSBhcmcyO1xuXHRcdH1cblx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHR0aGlzLl92eCAtPSB0aGlzLl9weDtcblx0XHRcdHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuXHR9LFxuXG5cdGdldFZlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0bGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksXG5cdFx0XHRcdHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldFNpZGU6IGZ1bmN0aW9uKHBvaW50LCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lkZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNpZ25lZERpc3RhbmNlKHBvaW50KSk7XG5cdH0sXG5cblx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UodGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihsaW5lKSB7XG5cdFx0cmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihwMXgsIHAxeSwgdjF4LCB2MXksIHAyeCwgcDJ5LCB2MngsIHYyeSwgYXNWZWN0b3IsXG5cdFx0XHRcdGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0djF4IC09IHAxeDtcblx0XHRcdFx0djF5IC09IHAxeTtcblx0XHRcdFx0djJ4IC09IHAyeDtcblx0XHRcdFx0djJ5IC09IHAyeTtcblx0XHRcdH1cblx0XHRcdHZhciBjcm9zcyA9IHYxeCAqIHYyeSAtIHYxeSAqIHYyeDtcblx0XHRcdGlmICghTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IHAxeCAtIHAyeCxcblx0XHRcdFx0XHRkeSA9IHAxeSAtIHAyeSxcblx0XHRcdFx0XHR1MSA9ICh2MnggKiBkeSAtIHYyeSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHUyID0gKHYxeCAqIGR5IC0gdjF5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0XHRcdHVNaW4gPSAtZXBzaWxvbixcblx0XHRcdFx0XHR1TWF4ID0gMSArIGVwc2lsb247XG5cdFx0XHRcdGlmIChpc0luZmluaXRlXG5cdFx0XHRcdFx0XHR8fCB1TWluIDwgdTEgJiYgdTEgPCB1TWF4ICYmIHVNaW4gPCB1MiAmJiB1MiA8IHVNYXgpIHtcblx0XHRcdFx0XHRpZiAoIWlzSW5maW5pdGUpIHtcblx0XHRcdFx0XHRcdHUxID0gdTEgPD0gMCA/IDAgOiB1MSA+PSAxID8gMSA6IHUxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRwMXggKyB1MSAqIHYxeCxcblx0XHRcdFx0XHRcdFx0cDF5ICsgdTEgKiB2MXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFNpZGU6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvciwgaXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdjJ4ID0geCAtIHB4LFxuXHRcdFx0XHR2MnkgPSB5IC0gcHksXG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cdFx0XHRpZiAoIWlzSW5maW5pdGUgJiYgTnVtZXJpY2FsLmlzTWFjaGluZVplcm8oY2N3KSkge1xuXHRcdFx0XHRjY3cgPSAodjJ4ICogdnggKyB2MnggKiB2eCkgLyAodnggKiB2eCArIHZ5ICogdnkpO1xuXHRcdFx0XHRpZiAoY2N3ID49IDAgJiYgY2N3IDw9IDEpXG5cdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG5cdFx0fSxcblxuXHRcdGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0ICByZXR1cm4gIHZ4ID09PSAwID8gKHZ5ID4gMCA/IHggLSBweCA6IHB4IC0geClcblx0XHRcdFx0XHQ6IHZ5ID09PSAwID8gKHZ4IDwgMCA/IHkgLSBweSA6IHB5IC0geSlcblx0XHRcdFx0XHQ6ICgoeCAtIHB4KSAqIHZ5IC0gKHkgLSBweSkgKiB2eCkgLyAoXG5cdFx0XHRcdFx0XHR2eSA+IHZ4XG5cdFx0XHRcdFx0XHRcdD8gdnkgKiBNYXRoLnNxcnQoMSArICh2eCAqIHZ4KSAvICh2eSAqIHZ5KSlcblx0XHRcdFx0XHRcdFx0OiB2eCAqIE1hdGguc3FydCgxICsgKHZ5ICogdnkpIC8gKHZ4ICogdngpKVxuXHRcdFx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyhcblx0XHRcdFx0XHRMaW5lLmdldFNpZ25lZERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvcikpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBQcm9qZWN0ID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUHJvamVjdCcsXG5cdF9saXN0OiAncHJvamVjdHMnLFxuXHRfcmVmZXJlbmNlOiAncHJvamVjdCcsXG5cdF9jb21wYWN0U2VyaWFsaXplOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFByb2plY3QoZWxlbWVudCkge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGlvbkl0ZW1zID0ge307XG5cdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQgPSAwO1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSAwO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5fY2hpbGRyZW4sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncywgaXRlbSkge1xuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhpcy5fdmlldztcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHZpZXcuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCF2aWV3Ll9yZXF1ZXN0ZWQgJiYgdmlldy5fYXV0b1VwZGF0ZSlcblx0XHRcdFx0XHR2aWV3LnJlcXVlc3RVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzO1xuXHRcdGlmIChjaGFuZ2VzICYmIGl0ZW0pIHtcblx0XHRcdHZhciBjaGFuZ2VzQnlJZCA9IHRoaXMuX2NoYW5nZXNCeUlkLFxuXHRcdFx0XHRpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0XHRlbnRyeSA9IGNoYW5nZXNCeUlkW2lkXTtcblx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYW5nZXMucHVzaChjaGFuZ2VzQnlJZFtpZF0gPSB7IGl0ZW06IGl0ZW0sIGZsYWdzOiBmbGFncyB9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdGNoaWxkcmVuW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdGlmICghcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5fdmlldylcblx0XHRcdHRoaXMuX3ZpZXcucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudFN0eWxlO1xuXHR9LFxuXG5cdHNldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR0aGlzLl9jdXJyZW50U3R5bGUuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMsIGluc2VydDogdHJ1ZSB9KTtcblx0fSxcblxuXHRnZXRTeW1ib2xEZWZpbml0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlZmluaXRpb25zID0gW10sXG5cdFx0XHRpZHMgPSB7fTtcblx0XHR0aGlzLmdldEl0ZW1zKHtcblx0XHRcdGNsYXNzOiBTeW1ib2xJdGVtLFxuXHRcdFx0bWF0Y2g6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuXHRcdFx0XHRcdGlkID0gZGVmaW5pdGlvbi5faWQ7XG5cdFx0XHRcdGlmICghaWRzW2lkXSkge1xuXHRcdFx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBkZWZpbml0aW9ucztcblx0fSxcblxuXHRnZXRTeW1ib2xzOiAnZ2V0U3ltYm9sRGVmaW5pdGlvbnMnLFxuXG5cdGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zLFxuXHRcdFx0aXRlbXMgPSBbXTtcblx0XHRmb3IgKHZhciBpZCBpbiBzZWxlY3Rpb25JdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzZWxlY3Rpb25JdGVtc1tpZF0sXG5cdFx0XHRcdHNlbGVjdGlvbiA9IGl0ZW0uX3NlbGVjdGlvbjtcblx0XHRcdGlmICgoc2VsZWN0aW9uICYgMSkgJiYgaXRlbS5pc0luc2VydGVkKCkpIHtcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoIXNlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zO1xuXHRcdGlmIChpdGVtLl9zZWxlY3Rpb24pIHtcblx0XHRcdGlmIChzZWxlY3Rpb25JdGVtc1tpZF0gIT09IGl0ZW0pIHtcblx0XHRcdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQrKztcblx0XHRcdFx0c2VsZWN0aW9uSXRlbXNbaWRdID0gaXRlbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGlvbkl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3Rpb25JdGVtc1tpZF07XG5cdFx0fVxuXHR9LFxuXG5cdHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGRlc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGlvbkl0ZW1zKVxuXHRcdFx0c2VsZWN0aW9uSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG5cdH0sXG5cblx0YWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0TGF5ZXIodW5kZWZpbmVkLCBsYXllcik7XG5cdH0sXG5cblx0aW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uKGluZGV4LCBsYXllcikge1xuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG5cdFx0XHRsYXllci5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBbbGF5ZXJdLCBpbmRleCwgMCk7XG5cdFx0XHRsYXllci5fc2V0UHJvamVjdCh0aGlzLCB0cnVlKTtcblx0XHRcdHZhciBuYW1lID0gbGF5ZXIuX25hbWU7XG5cdFx0XHRpZiAobmFtZSlcblx0XHRcdFx0bGF5ZXIuc2V0TmFtZShuYW1lKTtcblx0XHRcdGlmICh0aGlzLl9jaGFuZ2VzKVxuXHRcdFx0XHRsYXllci5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gbGF5ZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGxheWVyO1xuXHR9LFxuXG5cdF9pbnNlcnRJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX2NyZWF0ZWQpIHtcblx0XHRpdGVtID0gdGhpcy5pbnNlcnRMYXllcihpbmRleCwgaXRlbSlcblx0XHRcdFx0fHwgKHRoaXMuX2FjdGl2ZUxheWVyIHx8IHRoaXMuX2luc2VydEl0ZW0odW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0bmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSwgdHJ1ZSkpXG5cdFx0XHRcdFx0XHQuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0pO1xuXHRcdGlmIChfY3JlYXRlZCAmJiBpdGVtLmFjdGl2YXRlKVxuXHRcdFx0aXRlbS5hY3RpdmF0ZSgpO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgbnVsbCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2FjdGl2ZUxheWVyO1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgbGF5ZXIgJiYgbGF5ZXIuaXNFbXB0eSgpICYmIGxheWVyKTtcblx0fSxcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBzZXRzID0gdGhpcy5fcmVtb3ZlU2V0cztcblx0XHRpZiAoc2V0cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXVwJylcblx0XHRcdFx0c2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuXHRcdFx0dmFyIHNldCA9IHNldHNbdHlwZV07XG5cdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHNldCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gc2V0W2lkXTtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyID0gc2V0c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyICYmIG90aGVyICE9IHNldClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRzW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uKys7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0XHRvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcblx0XHRcdFx0cGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcblx0XHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRcdG1hdHJpY2VzOiBbbmV3IE1hdHJpeCgpXSxcblx0XHRcdFx0dXBkYXRlTWF0cml4OiB0cnVlXG5cdFx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3Rpb25Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXMsXG5cdFx0XHRcdHNpemUgPSB0aGlzLl9zY29wZS5zZXR0aW5ncy5oYW5kbGVTaXplLFxuXHRcdFx0XHR2ZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbjtcblx0XHRcdGZvciAodmFyIGlkIGluIGl0ZW1zKSB7XG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0c3RhdGljczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuXHRcdFx0aWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKVxuXHRcdFx0XHRzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IEJhc2Uuc2V0KHt9LFxuXHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9uYW1lOiBudWxsLFxuXHRfYXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhblNjYWxlU3Ryb2tlOiBmYWxzZSxcblx0X3Bpdm90OiBudWxsLFxuXHRfdmlzaWJsZTogdHJ1ZSxcblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cdF9vcGFjaXR5OiAxLFxuXHRfbG9ja2VkOiBmYWxzZSxcblx0X2d1aWRlOiBmYWxzZSxcblx0X2NsaXBNYXNrOiBmYWxzZSxcblx0X3NlbGVjdGlvbjogMCxcblx0X3NlbGVjdEJvdW5kczogdHJ1ZSxcblx0X3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdG5hbWU6IG51bGwsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0bWF0cml4OiBuZXcgTWF0cml4KCksXG5cdFx0cGl2b3Q6IG51bGwsXG5cdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0bG9ja2VkOiBmYWxzZSxcblx0XHRndWlkZTogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRkYXRhOiB7fVxuXHR9LFxuXHRfcHJpb3JpdGl6ZTogWydhcHBseU1hdHJpeCddXG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGFuZGxlcnMgPSBbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChoYW5kbGVycyxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0gPSB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fY291bnRJdGVtRXZlbnQodHlwZSwgMSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2NvdW50SXRlbUV2ZW50KHR5cGUsIC0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRfZXZlbnRzOiB7XG5cdFx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uTG9hZDoge30sXG5cdFx0XHRcdG9uRXJyb3I6IHt9XG5cdFx0XHR9LFxuXHRcdFx0c3RhdGljczoge1xuXHRcdFx0XHRfaXRlbUhhbmRsZXJzOiBoYW5kbGVyc1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sIHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcblx0XHRcdGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0LFxuXHRcdFx0c2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncztcblx0XHR0aGlzLl9pZCA9IGludGVybmFsID8gbnVsbCA6IFVJRC5nZXQoKTtcblx0XHR0aGlzLl9wYXJlbnQgPSB0aGlzLl9pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmIChpbnRlcm5hbCB8fCBoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2Vcblx0XHRcdHx8ICFzZXR0aW5ncy5pbnNlcnRJdGVtcyAmJiAhKGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gdHJ1ZSkpIHtcblx0XHRcdHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQgfHwgcHJvamVjdClcblx0XHRcdFx0XHQuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzLCB0cnVlKTtcblx0XHR9XG5cdFx0aWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVCkge1xuXHRcdFx0dGhpcy5zZXQocHJvcHMsIHtcblx0XHRcdFx0aW50ZXJuYWw6IHRydWUsIGluc2VydDogdHJ1ZSwgcHJvamVjdDogdHJ1ZSwgcGFyZW50OiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc1Byb3BzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9zeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDE2KSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjYWNoZVBhcmVudFxuXHRcdFx0XHQmJiAoZmxhZ3MgJiA3MikpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAyKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAocHJvamVjdClcblx0XHRcdHByb2plY3QuX2NoYW5nZWQoZmxhZ3MsIHRoaXMpO1xuXHRcdGlmIChzeW1ib2wpXG5cdFx0XHRzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdGdldElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdH0sXG5cblx0c2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0aWYgKG5hbWUgJiYgb3duZXIpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0aWYgKCEobmFtZSBpbiBjaGlsZHJlbikpXG5cdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjU2KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRrZXkgPSAnXycgKyBuYW1lLFxuXHRcdFx0ZmxhZ3MgPSB7XG5cdFx0XHRcdGxvY2tlZDogMjU2LFxuXHRcdFx0XHR2aXNpYmxlOiAyNjVcblx0XHRcdH07XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1trZXldO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW2tleV0pIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoZmxhZ3NbbmFtZV0gfHwgMjU3KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXHRcdGlmIChzZWxlY3Rpb24gIT09IHRoaXMuX3NlbGVjdGlvbikge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdFx0cHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDI1Nyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uKGZsYWcsIHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcblx0XHR0aGlzLnNldFNlbGVjdGlvbihzZWxlY3RlZCA/IHNlbGVjdGlvbiB8IGZsYWcgOiBzZWxlY3Rpb24gJiB+ZmxhZyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHNlbGVjdGVkID0gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdFx0aWYgKGNoaWxkcmVuICYmIHNlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMjU3KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgyMDQ4KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uIHx8XG5cdFx0XHQodGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZyb21Cb3VuZHMoKSk7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHRoaXMsICdzZXRQb3NpdGlvbicpO1xuXHR9LFxuXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9LFxuXG5cdF9nZXRQb3NpdGlvbkZyb21Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLl9waXZvdFxuXHRcdFx0XHQ/IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcy5fcGl2b3QpXG5cdFx0XHRcdDogKGJvdW5kcyB8fCB0aGlzLmdldEJvdW5kcygpKS5nZXRDZW50ZXIodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdHJldHVybiBwaXZvdFxuXHRcdFx0XHQ/IG5ldyBMaW5rZWRQb2ludChwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUsIHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9XG59LCBCYXNlLmVhY2goe1xuXHRcdGdldFN0cm9rZUJvdW5kczogeyBzdHJva2U6IHRydWUgfSxcblx0XHRnZXRIYW5kbGVCb3VuZHM6IHsgaGFuZGxlOiB0cnVlIH0sXG5cdFx0Z2V0SW50ZXJuYWxCb3VuZHM6IHsgaW50ZXJuYWw6IHRydWUgfVxuXHR9LFxuXHRmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcblx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGhhc01hdHJpeCA9IG9wdGlvbnMgfHwgbWF0cml4IGluc3RhbmNlb2YgTWF0cml4LFxuXHRcdFx0b3B0cyA9IEJhc2Uuc2V0KHt9LCBoYXNNYXRyaXggPyBvcHRpb25zIDogbWF0cml4LFxuXHRcdFx0XHRcdHRoaXMuX2JvdW5kc09wdGlvbnMpO1xuXHRcdGlmICghb3B0cy5zdHJva2UgfHwgdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkpXG5cdFx0XHRvcHRzLmNhY2hlSXRlbSA9IHRoaXM7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMoaGFzTWF0cml4ICYmIG1hdHJpeCwgb3B0cykucmVjdDtcblx0XHRyZXR1cm4gIWFyZ3VtZW50cy5sZW5ndGhcblx0XHRcdFx0PyBuZXcgTGlua2VkUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCxcblx0XHRcdFx0XHR0aGlzLCAnc2V0Qm91bmRzJylcblx0XHRcdFx0OiByZWN0O1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0aWYgKCFfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG5cdFx0XHRcdF9tYXRyaXguc2V0KF9tYXRyaXguX2JhY2t1cFxuXHRcdFx0XHRcdFx0fHwgbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShfbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHRcdH1cblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT09IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMCxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9PSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMCk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcywgb3B0aW9ucy5jYWNoZUl0ZW0pO1xuXHRcdHJldHVybiBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2dldEJvdW5kc0NhY2hlS2V5OiBmdW5jdGlvbihvcHRpb25zLCBpbnRlcm5hbCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRvcHRpb25zLnN0cm9rZSA/IDEgOiAwLFxuXHRcdFx0b3B0aW9ucy5oYW5kbGUgPyAxIDogMCxcblx0XHRcdGludGVybmFsID8gMSA6IDBcblx0XHRdLmpvaW4oJycpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucywgbm9JbnRlcm5hbCkge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgaW50ZXJuYWwgPSBvcHRpb25zLmludGVybmFsICYmICFub0ludGVybmFsLFxuXHRcdFx0Y2FjaGVJdGVtID0gb3B0aW9ucy5jYWNoZUl0ZW0sXG5cdFx0XHRfbWF0cml4ID0gaW50ZXJuYWwgPyBudWxsIDogdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZUtleSA9IGNhY2hlSXRlbSAmJiAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKVxuXHRcdFx0XHQmJiB0aGlzLl9nZXRCb3VuZHNDYWNoZUtleShvcHRpb25zLCBpbnRlcm5hbCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGVLZXkgJiYgYm91bmRzICYmIGNhY2hlS2V5IGluIGJvdW5kcykge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGJvdW5kc1tjYWNoZUtleV07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZWN0OiBjYWNoZWQucmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBjYWNoZWQubm9uc2NhbGluZ1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2dldEJvdW5kcyhtYXRyaXggfHwgX21hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRyZWN0ID0gcmVzLnJlY3QgfHwgcmVzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdG5vbnNjYWxpbmcgPSByZXMubm9uc2NhbGluZyB8fCBzdHlsZS5oYXNTdHJva2UoKVxuXHRcdFx0XHQmJiAhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpO1xuXHRcdGlmIChjYWNoZUtleSkge1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XSA9IHtcblx0XHRcdFx0cmVjdDogcmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nLFxuXHRcdFx0XHRpbnRlcm5hbDogaW50ZXJuYWxcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0bm9uc2NhbGluZzogbm9uc2NhbGluZ1xuXHRcdH07XG5cdH0sXG5cblx0X2dldFN0cm9rZU1hdHJpeDogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbFxuXHRcdFx0XHQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcm5hbCA/IHRoaXNcblx0XHRcdFx0XHQ6IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9zeW1ib2wgJiYgdGhpcy5fc3ltYm9sLl9pdGVtLFxuXHRcdFx0bXggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Vmlld01hdHJpeCgpLmludmVydCgpIDogbWF0cml4O1xuXHRcdHJldHVybiBteCAmJiBteC5fc2hpZnRsZXNzKCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF91cGRhdGVCb3VuZHNDYWNoZTogZnVuY3Rpb24ocGFyZW50LCBpdGVtKSB7XG5cdFx0XHRpZiAocGFyZW50ICYmIGl0ZW0pIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2dldEJvdW5kczogZnVuY3Rpb24oaXRlbXMsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHgxID0gSW5maW5pdHksXG5cdFx0XHRcdHgyID0gLXgxLFxuXHRcdFx0XHR5MSA9IHgxLFxuXHRcdFx0XHR5MiA9IHgyLFxuXHRcdFx0XHRub25zY2FsaW5nID0gZmFsc2U7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGlmIChpdGVtLl92aXNpYmxlICYmICFpdGVtLmlzRW1wdHkodHJ1ZSkpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gaXRlbS5fZ2V0Q2FjaGVkQm91bmRzKFxuXHRcdFx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChpdGVtLl9tYXRyaXgpLCBvcHRpb25zLCB0cnVlKSxcblx0XHRcdFx0XHRcdHJlY3QgPSBib3VuZHMucmVjdDtcblx0XHRcdFx0XHR4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuXHRcdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdFx0eDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG5cdFx0XHRcdFx0eTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuXHRcdFx0XHRcdGlmIChib3VuZHMubm9uc2NhbGluZylcblx0XHRcdFx0XHRcdG5vbnNjYWxpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZWN0OiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXHRcdFx0XHRcdDogbmV3IFJlY3RhbmdsZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG59KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXhcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCA/IGRlY29tcG9zZWQucm90YXRpb24gOiAwO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlKCksXG5cdFx0XHRzID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChzID8gcy54IDogMSwgcyA/IHMueSA6IDEsIHRoaXMsICdzZXRTY2FsaW5nJyk7XG5cdH0sXG5cblx0c2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKSxcblx0XHRcdHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSwgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGN1cnJlbnQgJiYgc2NhbGluZyAmJiAhY3VycmVudC5lcXVhbHMoc2NhbGluZykpIHtcblx0XHRcdHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQsXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdFx0aXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRcdGlmIChpc1plcm8oY3VycmVudC54KSB8fCBpc1plcm8oY3VycmVudC55KSkge1xuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKGRlY29tcG9zZWQudHJhbnNsYXRpb24pO1xuXHRcdFx0XHRpZiAocm90YXRpb24pIHtcblx0XHRcdFx0XHRtYXRyaXgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXRyaXguc2NhbGUoc2NhbGluZy54LCBzY2FsaW5nLnkpO1xuXHRcdFx0XHR0aGlzLl9tYXRyaXguc2V0KG1hdHJpeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKTtcblx0XHRcdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0XHRpZiAocm90YXRpb24pXG5cdFx0XHRcdFx0bWF0cml4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRcdG1hdHJpeC5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG5cdFx0XHRcdGlmIChyb3RhdGlvbilcblx0XHRcdFx0XHRtYXRyaXgucm90YXRlKC1yb3RhdGlvbik7XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm0obWF0cml4KTtcblx0XHRcdH1cblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG5cdFx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH0sXG5cblx0c2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdG1hdHJpeC5zZXQuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGdldEdsb2JhbE1hdHJpeDogZnVuY3Rpb24oX2RvbnRDbG9uZSkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXg7XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdHZhciBwYXJlbnRzID0gW107XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGlmICghcGFyZW50Ll9nbG9iYWxNYXRyaXgpIHtcblx0XHRcdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdHBhcmVudHNbaV0uX2dsb2JhbE1hdHJpeCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudHMucHVzaChwYXJlbnQpO1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFtYXRyaXgpIHtcblx0XHRcdG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdGlmIChwYXJlbnQpXG5cdFx0XHRcdG1hdHJpeC5wcmVwZW5kKHBhcmVudC5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldFZpZXdNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcblx0fSxcblxuXHRzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oYXBwbHkpIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIWFwcGx5KVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuXHRcdF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuXHR9LFxuXG5cdGdldExheWVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcilcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHR9LFxuXG5cdHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdF9nZXRPd25lcjogJyNnZXRQYXJlbnQnLFxuXG5cdGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0c2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuXHR9LFxuXG5cdGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciAmJiBvd25lci5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPT09IHRoaXMgfHwgaXRlbSAmJiB0aGlzLl9jbGFzcyA9PT0gaXRlbS5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3R5bGUuZXF1YWxzKGl0ZW0uX3N0eWxlKVxuXHRcdFx0XHQmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeClcblx0XHRcdFx0JiYgdGhpcy5fbG9ja2VkID09PSBpdGVtLl9sb2NrZWRcblx0XHRcdFx0JiYgdGhpcy5fdmlzaWJsZSA9PT0gaXRlbS5fdmlzaWJsZVxuXHRcdFx0XHQmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZVxuXHRcdFx0XHQmJiB0aGlzLl9vcGFjaXR5ID09PSBpdGVtLl9vcGFjaXR5XG5cdFx0XHRcdCYmIHRoaXMuX2NsaXBNYXNrID09PSBpdGVtLl9jbGlwTWFza1xuXHRcdFx0XHQmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGVcblx0XHRcdFx0JiYgdGhpcy5fZXF1YWxzKGl0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0Y2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGluc2VydCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5pbnNlcnQgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0b3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IHRydWUpLFxuXHRcdFx0ZGVlcCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5kZWVwIDogdW5kZWZpbmVkLCB0cnVlKTtcblx0XHRpZiAoY2hpbGRyZW4pXG5cdFx0XHRjb3B5LmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgZGVlcClcblx0XHRcdGNvcHkuY29weUNvbnRlbnQodGhpcyk7XG5cdFx0aWYgKCFjaGlsZHJlbilcblx0XHRcdGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0aWYgKGluc2VydClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0aWYgKG5hbWUgIT09IG9yaWcpXG5cdFx0XHRcdGNvcHkuc2V0TmFtZShuYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHNvdXJjZS5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0uY2xvbmUoZmFsc2UpLCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Y29weUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZXhjbHVkZU1hdHJpeCkge1xuXHRcdHRoaXMuc2V0U3R5bGUoc291cmNlLl9zdHlsZSk7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdHRoaXNba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0XHRpZiAoIWV4Y2x1ZGVNYXRyaXgpXG5cdFx0XHR0aGlzLl9tYXRyaXguc2V0KHNvdXJjZS5fbWF0cml4LCB0cnVlKTtcblx0XHR0aGlzLnNldEFwcGx5TWF0cml4KHNvdXJjZS5fYXBwbHlNYXRyaXgpO1xuXHRcdHRoaXMuc2V0UGl2b3Qoc291cmNlLl9waXZvdCk7XG5cdFx0dGhpcy5zZXRTZWxlY3Rpb24oc291cmNlLl9zZWxlY3Rpb24pO1xuXHRcdHZhciBkYXRhID0gc291cmNlLl9kYXRhLFxuXHRcdFx0bmFtZSA9IHNvdXJjZS5fbmFtZTtcblx0XHR0aGlzLl9kYXRhID0gZGF0YSA/IEJhc2UuY2xvbmUoZGF0YSkgOiBudWxsO1xuXHRcdGlmIChuYW1lKVxuXHRcdFx0dGhpcy5zZXROYW1lKG5hbWUpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuXHRcdHZhciByZXNvbHV0aW9uLFxuXHRcdFx0aW5zZXJ0LFxuXHRcdFx0cmFzdGVyO1xuXHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnMCkpIHtcblx0XHRcdHJlc29sdXRpb24gPSBhcmcwLnJlc29sdXRpb247XG5cdFx0XHRpbnNlcnQgPSBhcmcwLmluc2VydDtcblx0XHRcdHJhc3RlciA9IGFyZzAucmFzdGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXNvbHV0aW9uID0gYXJnMDtcblx0XHRcdGluc2VydCA9IGFyZzE7XG5cdFx0fVxuXHRcdGlmIChyYXN0ZXIpIHtcblx0XHRcdHJhc3Rlci5tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcblx0XHRcdHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuXHRcdFx0dG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcblx0XHRcdGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuXHRcdFx0Ym91bmRzU2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcblx0XHRcdHJhc3RlclNpemUgPSBib3VuZHNTaXplLm11bHRpcGx5KHNjYWxlKTtcblx0XHRyYXN0ZXIuc2V0U2l6ZShyYXN0ZXJTaXplLCB0cnVlKTtcblxuXHRcdGlmICghcmFzdGVyU2l6ZS5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGN0eCA9IHJhc3Rlci5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZSh0b3BMZWZ0Lm5lZ2F0ZSgpKTtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRcdHRoaXMuZHJhdyhjdHgsIG5ldyBCYXNlKHsgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHRcdHJhc3Rlci50cmFuc2Zvcm0oXG5cdFx0XHRuZXcgTWF0cml4KClcblx0XHRcdFx0LnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChib3VuZHNTaXplLmRpdmlkZSgyKSkpXG5cdFx0XHRcdC5zY2FsZSgxIC8gc2NhbGUpXG5cdFx0KTtcblx0XHRpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KSB7XG5cdFx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cdFx0cmV0dXJuIChcblx0XHRcdG1hdHJpeC5pc0ludmVydGlibGUoKSAmJlxuXHRcdFx0ISF0aGlzLl9jb250YWlucyhtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSlcblx0XHQpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcy5nZXRCb3VuZHMoKSk7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0cmVjdGFuZ2xlOiB0aGlzLmdldEludGVybmFsQm91bmRzKCksXG5cdFx0XHRtYXRyaXg6IHRoaXMuX21hdHJpeCxcblx0XHRcdGluc2VydDogZmFsc2UsXG5cdFx0fSk7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oaXRlbSwgX21hdHJpeCkge1xuXHRcdGlmICghKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fYXNQYXRoSXRlbSgpLmdldEludGVyc2VjdGlvbnMoaXRlbS5fYXNQYXRoSXRlbSgpLCBudWxsLFxuXHRcdFx0XHRfbWF0cml4LCB0cnVlKS5sZW5ndGggPiAwO1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBoaXRUZXN0KCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdHJldHVybiB0aGlzLl9oaXRUZXN0KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRIaXRSZXN1bHQuZ2V0T3B0aW9ucyhhcmdzKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBoaXRUZXN0QWxsKCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3MpLFxuXHRcdFx0YWxsID0gW107XG5cdFx0dGhpcy5faGl0VGVzdChwb2ludCwgbmV3IEJhc2UoeyBhbGw6IGFsbCB9LCBvcHRpb25zKSk7XG5cdFx0cmV0dXJuIGFsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGhpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgX2V4Y2x1ZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0dmFyIHJlcyA9IGNoaWxkICE9PSBfZXhjbHVkZSAmJiBjaGlsZC5faGl0VGVzdChwb2ludCwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRpZiAocmVzICYmICFvcHRpb25zLmFsbClcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRoaXRUZXN0OiBoaXRUZXN0LFxuXHRcdGhpdFRlc3RBbGw6IGhpdFRlc3RBbGwsXG5cdFx0X2hpdFRlc3Q6IGhpdFRlc3RDaGlsZHJlblxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdGhpdFRlc3Q6IGhpdFRlc3QsXG5cdFx0aGl0VGVzdEFsbDogaGl0VGVzdEFsbCxcblx0XHRfaGl0VGVzdENoaWxkcmVuOiBoaXRUZXN0Q2hpbGRyZW4sXG5cdH07XG59LCB7XG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zLCBwYXJlbnRWaWV3TWF0cml4KSB7XG5cdFx0aWYgKHRoaXMuX2xvY2tlZCB8fCAhdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9ndWlkZSAmJiAhb3B0aW9ucy5ndWlkZXNcblx0XHRcdFx0fHwgdGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyZW50Vmlld01hdHJpeFxuXHRcdFx0XHRcdD8gcGFyZW50Vmlld01hdHJpeC5hcHBlbmRlZChtYXRyaXgpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCksXG5cdFx0XHR0b2xlcmFuY2UgPSBNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMWUtMTIpLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcgPSBuZXcgU2l6ZShcblx0XHRcdFx0XHRQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHRvbGVyYW5jZSxcblx0XHRcdFx0XHRcdG1hdHJpeC5fc2hpZnRsZXNzKCkuaW52ZXJ0KCkpKTtcblx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cdFx0aWYgKCFwb2ludCB8fCAhdGhpcy5fY2hpbGRyZW4gJiZcblx0XHRcdCF0aGlzLmdldEJvdW5kcyh7IGludGVybmFsOiB0cnVlLCBzdHJva2U6IHRydWUsIGhhbmRsZTogdHJ1ZSB9KVxuXHRcdFx0XHQuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlXG5cdFx0XHRcdHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHR8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcblx0XHRcdG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0Ym91bmRzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyKGhpdCkge1xuXHRcdFx0aWYgKGhpdCAmJiBtYXRjaCAmJiAhbWF0Y2goaGl0KSlcblx0XHRcdFx0aGl0ID0gbnVsbDtcblx0XHRcdGlmIChoaXQgJiYgb3B0aW9ucy5hbGwpXG5cdFx0XHRcdG9wdGlvbnMuYWxsLnB1c2goaGl0KTtcblx0XHRcdHJldHVybiBoaXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tQb2ludCh0eXBlLCBwYXJ0KSB7XG5cdFx0XHR2YXIgcHQgPSBwYXJ0ID8gYm91bmRzWydnZXQnICsgcGFydF0oKSA6IHRoYXQuZ2V0UG9zaXRpb24oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KHR5cGUsIHRoYXQsIHtcblx0XHRcdFx0XHRuYW1lOiBwYXJ0ID8gQmFzZS5oeXBoZW5hdGUocGFydCkgOiB0eXBlLFxuXHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hlY2tQb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24sXG5cdFx0XHRjaGVja0NlbnRlciA9IG9wdGlvbnMuY2VudGVyLFxuXHRcdFx0Y2hlY2tCb3VuZHMgPSBvcHRpb25zLmJvdW5kcztcblx0XHRpZiAoY2hlY2tTZWxmICYmIHRoaXMuX3BhcmVudFxuXHRcdFx0XHQmJiAoY2hlY2tQb3NpdGlvbiB8fCBjaGVja0NlbnRlciB8fCBjaGVja0JvdW5kcykpIHtcblx0XHRcdGlmIChjaGVja0NlbnRlciB8fCBjaGVja0JvdW5kcykge1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXMgPSBjaGVja1Bvc2l0aW9uICYmIGNoZWNrUG9pbnQoJ3Bvc2l0aW9uJykgfHxcblx0XHRcdFx0XHRjaGVja0NlbnRlciAmJiBjaGVja1BvaW50KCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBjaGVja0JvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspIHtcblx0XHRcdFx0XHRyZXMgPSBjaGVja1BvaW50KCdib3VuZHMnLCBwb2ludHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXMgPSBmaWx0ZXIocmVzKTtcblx0XHR9XG5cblx0XHRpZiAoIXJlcykge1xuXHRcdFx0cmVzID0gdGhpcy5faGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KVxuXHRcdFx0XHR8fCBjaGVja1NlbGZcblx0XHRcdFx0XHQmJiBmaWx0ZXIodGhpcy5faGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsXG5cdFx0XHRcdFx0XHR0aGlzLmdldFN0cm9rZVNjYWxpbmcoKSA/IG51bGxcblx0XHRcdFx0XHRcdFx0OiB2aWV3TWF0cml4Ll9zaGlmdGxlc3MoKS5pbnZlcnQoKSkpXG5cdFx0XHRcdHx8IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyZXMgJiYgcmVzLnBvaW50KSB7XG5cdFx0XHRyZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcblx0fSxcblxuXHRtYXRjaGVzOiBmdW5jdGlvbihuYW1lLCBjb21wYXJlKSB7XG5cdFx0ZnVuY3Rpb24gbWF0Y2hPYmplY3Qob2JqMSwgb2JqMikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dmFyIHZhbDEgPSBvYmoxW2ldLFxuXHRcdFx0XHRcdFx0dmFsMiA9IG9iajJbaV07XG5cdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciB0eXBlID0gdHlwZW9mIG5hbWU7XG5cdFx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuXHRcdFx0XHRpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF0aGlzLm1hdGNoZXMoa2V5LCBuYW1lW2tleV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG5hbWUodGhpcyk7XG5cdFx0fSBlbHNlIGlmIChuYW1lID09PSAnbWF0Y2gnKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZSh0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHZhbHVlID0gL14oZW1wdHl8ZWRpdGFibGUpJC8udGVzdChuYW1lKVxuXHRcdFx0XHRcdD8gdGhpc1snaXMnICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSgpXG5cdFx0XHRcdFx0OiBuYW1lID09PSAndHlwZSdcblx0XHRcdFx0XHRcdD8gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdFx0XHQ6IHRoaXNbbmFtZV07XG5cdFx0XHRpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBjb21wYXJlO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2NsYXNzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiAhIWNvbXBhcmUodmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb21wYXJlKSB7XG5cdFx0XHRcdGlmIChjb21wYXJlLnRlc3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGFyZS50ZXN0KHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoY29tcGFyZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQmFzZS5lcXVhbHModmFsdWUsIGNvbXBhcmUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCB0aGlzLl9tYXRyaXgpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgdGhpcy5fbWF0cml4LCBudWxsLCB0cnVlKVswXVxuXHRcdFx0XHR8fCBudWxsO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhpdGVtLCBvcHRpb25zLCBtYXRyaXgsIHBhcmFtLCBmaXJzdE9ubHkpIHtcblx0XHRcdGlmICghcGFyYW0pIHtcblx0XHRcdFx0dmFyIG9iaiA9IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLFxuXHRcdFx0XHRcdG92ZXJsYXBwaW5nID0gb2JqICYmIG9iai5vdmVybGFwcGluZyxcblx0XHRcdFx0XHRpbnNpZGUgPSBvYmogJiYgb2JqLmluc2lkZSxcblx0XHRcdFx0XHRib3VuZHMgPSBvdmVybGFwcGluZyB8fCBpbnNpZGUsXG5cdFx0XHRcdFx0cmVjdCA9IGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG5cdFx0XHRcdHBhcmFtID0ge1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0XHRyZWN1cnNpdmU6IG9iaiAmJiBvYmoucmVjdXJzaXZlICE9PSBmYWxzZSxcblx0XHRcdFx0XHRpbnNpZGU6ICEhaW5zaWRlLFxuXHRcdFx0XHRcdG92ZXJsYXBwaW5nOiAhIW92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdHJlY3Q6IHJlY3QsXG5cdFx0XHRcdFx0cGF0aDogb3ZlcmxhcHBpbmcgJiYgbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdFx0XHRcdHJlY3RhbmdsZTogcmVjdCxcblx0XHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAob2JqKSB7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IEJhc2UuZmlsdGVyKHt9LCBvcHRpb25zLCB7XG5cdFx0XHRcdFx0XHRyZWN1cnNpdmU6IHRydWUsIGluc2lkZTogdHJ1ZSwgb3ZlcmxhcHBpbmc6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW4sXG5cdFx0XHRcdGl0ZW1zID0gcGFyYW0uaXRlbXMsXG5cdFx0XHRcdHJlY3QgPSBwYXJhbS5yZWN0O1xuXHRcdFx0bWF0cml4ID0gcmVjdCAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguYXBwZW5kZWQoY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHJlY3QpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoIXJlY3QuaW50ZXJzZWN0cyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKCEocmVjdC5jb250YWlucyhib3VuZHMpXG5cdFx0XHRcdFx0XHRcdHx8IHBhcmFtLm92ZXJsYXBwaW5nICYmIChib3VuZHMuY29udGFpbnMocmVjdClcblx0XHRcdFx0XHRcdFx0XHR8fCBwYXJhbS5wYXRoLmludGVyc2VjdHMoY2hpbGQsIGNoaWxkTWF0cml4KSkpKVxuXHRcdFx0XHRcdFx0YWRkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG9wdGlvbnMpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0aWYgKGZpcnN0T25seSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXJhbS5yZWN1cnNpdmUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0X2dldEl0ZW1zKGNoaWxkLCBvcHRpb25zLCBjaGlsZE1hdHJpeCwgcGFyYW0sIGZpcnN0T25seSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZpcnN0T25seSAmJiBpdGVtcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufSwge1xuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR2YXIgcmVzID0gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuXHRcdHJldHVybiByZXMgIT09IHRoaXMgPyB0aGlzLmFkZENoaWxkKHJlcykgOiByZXM7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0pO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuXHRcdHZhciByZXMgPSBpdGVtID8gdGhpcy5pbnNlcnRDaGlsZHJlbihpbmRleCwgW2l0ZW1dKSA6IG51bGw7XG5cdFx0cmV0dXJuIHJlcyAmJiByZXNbMF07XG5cdH0sXG5cblx0YWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcyk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uKGluZGV4LCBpdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpdGVtcyA9IEJhc2Uuc2xpY2UoaXRlbXMpO1xuXHRcdFx0dmFyIGluc2VydGVkID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXSxcblx0XHRcdFx0XHRpZCA9IGl0ZW0gJiYgaXRlbS5faWQ7XG5cdFx0XHRcdGlmICghaXRlbSB8fCBpbnNlcnRlZFtpZF0pIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0XHRpbnNlcnRlZFtpZF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0bm90aWZ5U2VsZiA9IHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldLFxuXHRcdFx0XHRcdG5hbWUgPSBpdGVtLl9uYW1lO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHByb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAobmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUobmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdGl0ZW0uX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydEl0ZW06ICcjaW5zZXJ0Q2hpbGQnLFxuXG5cdF9pbnNlcnRBdDogZnVuY3Rpb24oaXRlbSwgb2Zmc2V0KSB7XG5cdFx0dmFyIG93bmVyID0gaXRlbSAmJiBpdGVtLl9nZXRPd25lcigpLFxuXHRcdFx0cmVzID0gaXRlbSAhPT0gdGhpcyAmJiBvd25lciA/IHRoaXMgOiBudWxsO1xuXHRcdGlmIChyZXMpIHtcblx0XHRcdHJlcy5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdG93bmVyLl9pbnNlcnRJdGVtKGl0ZW0uX2luZGV4ICsgb2Zmc2V0LCByZXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc2VydEF0KGl0ZW0sIDEpO1xuXHR9LFxuXG5cdGluc2VydEJlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc2VydEF0KGl0ZW0sIDApO1xuXHR9LFxuXG5cdHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyID8gb3duZXIuX2luc2VydEl0ZW0oMCwgdGhpcykgOiBudWxsO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRyZXR1cm4gb3duZXIgPyBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMpIDogbnVsbDtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRhZGRUbzogZnVuY3Rpb24ob3duZXIpIHtcblx0XHRyZXR1cm4gb3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzKTtcblx0fSxcblxuXHRjb3B5VG86IGZ1bmN0aW9uKG93bmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoZmFsc2UpLmFkZFRvKG93bmVyKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlblswXS5yZWR1Y2Uob3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KSB7XG5cdFx0XHRcdGNoaWxkLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9yZW1vdmVOYW1lZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRuYW1lID0gdGhpcy5fbmFtZSxcblx0XHRcdFx0bmFtZWRBcnJheSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0sXG5cdFx0XHRcdGluZGV4ID0gbmFtZWRBcnJheSA/IG5hbWVkQXJyYXkuaW5kZXhPZih0aGlzKSA6IC0xO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5bbmFtZV0gPT0gdGhpcylcblx0XHRcdFx0XHRkZWxldGUgY2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdG5hbWVkQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0aWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSBuYW1lZEFycmF5WzBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCksXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXg7XG5cdFx0aWYgKHRoaXMuX3N0eWxlKVxuXHRcdFx0dGhpcy5fc3R5bGUuX2Rpc3Bvc2UoKTtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdFx0aWYgKGluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHByb2plY3QuX2FjdGl2ZUxheWVyID09PSB0aGlzKVxuXHRcdFx0XHRcdHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0XHRcdHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cdFx0XHRcdEJhc2Uuc3BsaWNlKG93bmVyLl9jaGlsZHJlbiwgbnVsbCwgaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZiAmJiBwcm9qZWN0Ll9jaGFuZ2VzKVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0aWYgKG5vdGlmeVBhcmVudClcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoMTEsIHRoaXMpO1xuXHRcdFx0dGhpcy5fcGFyZW50ID0gbnVsbDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVtb3ZlKHRydWUsIHRydWUpO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIG9rID0gaXRlbSAmJiBpdGVtLmluc2VydEJlbG93KHRoaXMpO1xuXHRcdGlmIChvaylcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIG9rO1xuXHR9LFxuXG5cdHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0XHRlbmQgPSBCYXNlLnBpY2soZW5kLCB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpO1xuXHRcdHZhciByZW1vdmVkID0gQmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIG51bGwsIHN0YXJ0LCBlbmQgLSBzdGFydCk7XG5cdFx0Zm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHJlbW92ZWRbaV0uX3JlbW92ZSh0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVDaGlsZHJlbicsXG5cblx0cmV2ZXJzZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdHRoaXMuX2NoaWxkcmVuLnJldmVyc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5faW5kZXggPSBpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKHJlY3Vyc2l2ZWx5KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0dmFyIG51bUNoaWxkcmVuID0gY2hpbGRyZW4gPyBjaGlsZHJlbi5sZW5ndGggOiAwO1xuXHRcdGlmIChyZWN1cnNpdmVseSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGlsZHJlbjsgaSsrKSB7XG5cdFx0XHRcdGlmICghY2hpbGRyZW5baV0uaXNFbXB0eShyZWN1cnNpdmVseSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gIW51bUNoaWxkcmVuO1xuXHR9LFxuXG5cdGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtID0gdGhpcztcblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcblx0fSxcblxuXHRfZ2V0T3JkZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcblx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpc3QudW5zaGlmdChpdGVtKTtcblx0XHRcdH0gd2hpbGUgKGl0ZW0gPSBpdGVtLl9wYXJlbnQpO1xuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHRcdHZhciBsaXN0MSA9IGdldExpc3QodGhpcyksXG5cdFx0XHRsaXN0MiA9IGdldExpc3QoaXRlbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihsaXN0MS5sZW5ndGgsIGxpc3QyLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChsaXN0MVtpXSAhPSBsaXN0MltpXSkge1xuXHRcdFx0XHRyZXR1cm4gbGlzdDFbaV0uX2luZGV4IDwgbGlzdDJbaV0uX2luZGV4ID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcblx0fSxcblxuXHRpc0Fib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcblx0fSxcblxuXHRpc0JlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuXHR9LFxuXG5cdGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcblx0fSxcblxuXHRpc0NoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuXHR9LFxuXG5cdGlzRGVzY2VuZGFudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCA9PT0gaXRlbSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0FuY2VzdG9yOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPyBpdGVtLmlzRGVzY2VuZGFudCh0aGlzKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzU2libGluZzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW0uX3BhcmVudDtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cbn0sIEJhc2UuZWFjaChbJ3JvdGF0ZScsICdzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgcm90YXRlID0ga2V5ID09PSAncm90YXRlJztcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHR2YWx1ZSA9IChyb3RhdGUgPyBCYXNlIDogUG9pbnQpLnJlYWQoYXJncyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3MsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtrZXldKHZhbHVlLFxuXHRcdFx0XHRjZW50ZXIgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9O1xufSwge1xuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0dHJhbnNmb3JtTWF0cml4ID0gbWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpLFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoXG5cdFx0XHRcdF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeCB8fFxuXHRcdFx0XHR0aGlzLl9hcHBseU1hdHJpeCAmJiAoXG5cdFx0XHRcdFx0dHJhbnNmb3JtTWF0cml4IHx8ICFfbWF0cml4LmlzSWRlbnRpdHkoKSB8fFxuXHRcdFx0XHRcdF9hcHBseVJlY3Vyc2l2ZWx5ICYmIHRoaXMuX2NoaWxkcmVuXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0aWYgKCF0cmFuc2Zvcm1NYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKHRyYW5zZm9ybU1hdHJpeCkge1xuXHRcdFx0aWYgKCFtYXRyaXguaXNJbnZlcnRpYmxlKCkgJiYgX21hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdFx0X21hdHJpeC5fYmFja3VwID0gX21hdHJpeC5nZXRWYWx1ZXMoKTtcblx0XHRcdF9tYXRyaXgucHJlcGVuZChtYXRyaXgsIHRydWUpO1xuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcih0cnVlKSxcblx0XHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcblx0XHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRcdGZpbGxDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcblx0XHRcdGlmIChzdHJva2VDb2xvcilcblx0XHRcdFx0c3Ryb2tlQ29sb3IudHJhbnNmb3JtKG1hdHJpeCk7XG5cdFx0fVxuXG5cdFx0aWYgKGFwcGx5TWF0cml4ICYmIChhcHBseU1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoXG5cdFx0XHRcdF9tYXRyaXgsIF9hcHBseVJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpKSkge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdFx0aWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeClcblx0XHRcdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHRpZiAodHJhbnNmb3JtTWF0cml4IHx8IGFwcGx5TWF0cml4KSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHR9XG5cdFx0dmFyIGRlY29tcCA9IHRyYW5zZm9ybU1hdHJpeCAmJiBib3VuZHMgJiYgbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdGlmIChkZWNvbXAgJiYgZGVjb21wLnNrZXdpbmcuaXNaZXJvKCkgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIGNhY2hlID0gYm91bmRzW2tleV07XG5cdFx0XHRcdGlmIChjYWNoZS5ub25zY2FsaW5nKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGJvdW5kc1trZXldO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFwcGx5TWF0cml4IHx8ICFjYWNoZS5pbnRlcm5hbCkge1xuXHRcdFx0XHRcdHZhciByZWN0ID0gY2FjaGUucmVjdDtcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdFx0dmFyIGNhY2hlZCA9IGJvdW5kc1t0aGlzLl9nZXRCb3VuZHNDYWNoZUtleShcblx0XHRcdFx0dGhpcy5fYm91bmRzT3B0aW9ucyB8fCB7fSldO1xuXHRcdFx0aWYgKGNhY2hlZCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRnJvbUJvdW5kcyhjYWNoZWQucmVjdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm1NYXRyaXggJiYgcG9zaXRpb24gJiYgdGhpcy5fcGl2b3QpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y2hpbGRyZW5baV0udHJhbnNmb3JtKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGZpdEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBmaWxsKSB7XG5cdFx0cmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG5cdFx0XHRyZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuXHRcdFx0c2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbylcblx0XHRcdFx0XHQ/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG5cdFx0XHRuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuXHRcdFx0XHRcdG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcblx0XHRuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG5cdFx0dGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcblx0fVxufSksIHtcblxuXHRfc2V0U3R5bGVzOiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGxDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4LCBtYXRyaXgpO1xuXHRcdH1cblx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCkudG9DYW52YXNTdHlsZShjdHgsIG1hdHJpeCk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcblx0XHRcdHZhciBzdHJva2VKb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0XHRzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHJva2VKb2luKVxuXHRcdFx0XHRjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuXHRcdFx0aWYgKHN0cm9rZUNhcClcblx0XHRcdFx0Y3R4LmxpbmVDYXAgPSBzdHJva2VDYXA7XG5cdFx0XHRpZiAobWl0ZXJMaW1pdClcblx0XHRcdFx0Y3R4Lm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdFx0aWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuXHRcdFx0XHR2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdFx0ZGFzaE9mZnNldCA9IHN0eWxlLmdldERhc2hPZmZzZXQoKTtcblx0XHRcdFx0aWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcblx0XHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuXHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3R5bGUuaGFzU2hhZG93KCkpIHtcblx0XHRcdHZhciBwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRteCA9IHZpZXdNYXRyaXguX3NoaWZ0bGVzcygpLnByZXBlbmQoXG5cdFx0XHRcdFx0bmV3IE1hdHJpeCgpLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pKSxcblx0XHRcdFx0Ymx1ciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoc3R5bGUuZ2V0U2hhZG93Qmx1cigpLCAwKSksXG5cdFx0XHRcdG9mZnNldCA9IG14LnRyYW5zZm9ybSh0aGlzLmdldFNoYWRvd09mZnNldCgpKTtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCkudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0Y3R4LnNoYWRvd0JsdXIgPSBibHVyLmdldExlbmd0aCgpO1xuXHRcdFx0Y3R4LnNoYWRvd09mZnNldFggPSBvZmZzZXQueDtcblx0XHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmFwcGVuZGVkKG1hdHJpeCk7XG5cdFx0aWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2aWV3TWF0cml4ID0gdmlld01hdHJpeCA/IHZpZXdNYXRyaXguYXBwZW5kZWQoZ2xvYmFsTWF0cml4KVxuXHRcdFx0XHQ6IGdsb2JhbE1hdHJpeDtcblxuXHRcdG1hdHJpY2VzLnB1c2goZ2xvYmFsTWF0cml4KTtcblx0XHRpZiAocGFyYW0udXBkYXRlTWF0cml4KSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSBOdW1lcmljYWwuY2xhbXAodGhpcy5fb3BhY2l0eSwgMCwgMSksXG5cdFx0XHRub3JtYWxCbGVuZCA9IGJsZW5kTW9kZSA9PT0gJ25vcm1hbCcsXG5cdFx0XHRuYXRpdmVCbGVuZCA9IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1tibGVuZE1vZGVdLFxuXHRcdFx0ZGlyZWN0ID0gbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA9PT0gMVxuXHRcdFx0XHRcdHx8IHBhcmFtLmRvbnRTdGFydFxuXHRcdFx0XHRcdHx8IHBhcmFtLmNsaXBcblx0XHRcdFx0XHR8fCAobmF0aXZlQmxlbmQgfHwgbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA8IDEpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLl9jYW5Db21wb3NpdGUoKSxcblx0XHRcdHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRtYWluQ3R4LCBpdGVtT2Zmc2V0LCBwcmV2T2Zmc2V0O1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHModmlld01hdHJpeCk7XG5cdFx0XHRpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodCkge1xuXHRcdFx0XHRtYXRyaWNlcy5wb3AoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG5cdFx0XHRtYWluQ3R4ID0gY3R4O1xuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSlcblx0XHRcdFx0XHQubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4XG5cdFx0XHRcdD8gcGFyZW50U3Ryb2tlTWF0cml4LmFwcGVuZGVkKG1hdHJpeClcblx0XHRcdFx0OiB0aGlzLl9jYW5TY2FsZVN0cm9rZSAmJiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpXG5cdFx0XHRcdFx0JiYgdmlld01hdHJpeCxcblx0XHRcdGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuXHRcdFx0dHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cdFx0XHRpZiAobmF0aXZlQmxlbmQpXG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdChkaXJlY3QgPyBtYXRyaXggOiB2aWV3TWF0cml4KS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdH1cblx0XHRpZiAoc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGlmIChvZmZzZXQpXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuXHRcdH1cblx0XHR0aGlzLl9kcmF3KGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRtYXRyaWNlcy5wb3AoKTtcblx0XHRpZiAocGFyYW0uY2xpcCAmJiAhcGFyYW0uZG9udEZpbmlzaCkge1xuXHRcdFx0Y3R4LmNsaXAodGhpcy5nZXRGaWxsUnVsZSgpKTtcblx0XHR9XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LFxuXHRcdFx0XHRcdGl0ZW1PZmZzZXQuc3VidHJhY3QocHJldk9mZnNldCkubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0cGFyYW0ub2Zmc2V0ID0gcHJldk9mZnNldDtcblx0XHR9XG5cdH0sXG5cblx0X2lzVXBkYXRlZDogZnVuY3Rpb24odXBkYXRlVmVyc2lvbikge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdHJldHVybiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKTtcblx0XHR2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPT09IHVwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF1cGRhdGVkICYmIHBhcmVudCAmJiBwYXJlbnQuX3Zpc2libGVcblx0XHRcdFx0JiYgcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB1cGRhdGVkO1xuXHR9LFxuXG5cdF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgc2VsZWN0aW9uSXRlbXMsIHVwZGF0ZVZlcnNpb24pIHtcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuXHRcdFx0aXRlbVNlbGVjdGVkID0gc2VsZWN0aW9uICYgMSxcblx0XHRcdGJvdW5kc1NlbGVjdGVkID0gc2VsZWN0aW9uICYgMlxuXHRcdFx0XHRcdHx8IGl0ZW1TZWxlY3RlZCAmJiB0aGlzLl9zZWxlY3RCb3VuZHMsXG5cdFx0XHRwb3NpdGlvblNlbGVjdGVkID0gc2VsZWN0aW9uICYgNDtcblx0XHRpZiAoIXRoaXMuX2RyYXdTZWxlY3RlZClcblx0XHRcdGl0ZW1TZWxlY3RlZCA9IGZhbHNlO1xuXHRcdGlmICgoaXRlbVNlbGVjdGVkIHx8IGJvdW5kc1NlbGVjdGVkIHx8IHBvc2l0aW9uU2VsZWN0ZWQpXG5cdFx0XHRcdCYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dmFyIGxheWVyLFxuXHRcdFx0XHRjb2xvciA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSB8fCAobGF5ZXIgPSB0aGlzLmdldExheWVyKCkpXG5cdFx0XHRcdFx0JiYgbGF5ZXIuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSxcblx0XHRcdFx0bXggPSBtYXRyaXguYXBwZW5kZWQodGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpLFxuXHRcdFx0XHRoYWxmID0gc2l6ZSAvIDI7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3Jcblx0XHRcdFx0XHQ/IGNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KSA6ICcjMDA5ZGVjJztcblx0XHRcdGlmIChpdGVtU2VsZWN0ZWQpXG5cdFx0XHRcdHRoaXMuX2RyYXdTZWxlY3RlZChjdHgsIG14LCBzZWxlY3Rpb25JdGVtcyk7XG5cdFx0XHRpZiAocG9zaXRpb25TZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcblx0XHRcdFx0XHRwYXJlbnQgPSB0aGlzLl9wYXJlbnQsXG5cdFx0XHRcdFx0cG9pbnQgPSBwYXJlbnQgPyBwYXJlbnQubG9jYWxUb0dsb2JhbChwb3MpIDogcG9zLFxuXHRcdFx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0XHRcdHkgPSBwb2ludC55O1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoeCwgeSwgaGFsZiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdHZhciBkZWx0YXMgPSBbWzAsIC0xXSwgWzEsIDBdLCBbMCwgMV0sIFstMSwgMF1dLFxuXHRcdFx0XHRcdHN0YXJ0ID0gaGFsZixcblx0XHRcdFx0XHRlbmQgPSBzaXplICsgMTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgZGVsdGEgPSBkZWx0YXNbaV0sXG5cdFx0XHRcdFx0XHRkeCA9IGRlbHRhWzBdLFxuXHRcdFx0XHRcdFx0ZHkgPSBkZWx0YVsxXTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKHggKyBkeCAqIHN0YXJ0LCB5ICsgZHkgKiBzdGFydCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4ICsgZHggKiBlbmQsIHkgKyBkeSAqIGVuZCk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYm91bmRzU2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG14Ll90cmFuc2Zvcm1Db3JuZXJzKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcdFx0XHRjdHhbIWkgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjb29yZHNbaV0sIGNvb3Jkc1srK2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29vcmRzW2ldIC0gaGFsZiwgY29vcmRzWysraV0gLSBoYWxmLFxuXHRcdFx0XHRcdFx0XHRzaXplLCBzaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2Rvd24nLCAnZHJhZycsICd1cCcsICdtb3ZlJ10sIGZ1bmN0aW9uKGtleSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUoa2V5KV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdGhhc2hba2V5XSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlT24oaGFzaCk7XG5cdH07XG59LCB7XG5cblx0cmVtb3ZlT246IGZ1bmN0aW9uKG9iaikge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqW25hbWVdKSB7XG5cdFx0XHRcdHZhciBrZXkgPSAnbW91c2UnICsgbmFtZSxcblx0XHRcdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0XHRzZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgfHwge307XG5cdFx0XHRcdHNldHNba2V5XSA9IHNldHNba2V5XSB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KSwge1xuXHR0d2VlbjogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB0bztcblx0XHRcdHRvID0gZnJvbTtcblx0XHRcdGZyb20gPSBudWxsO1xuXHRcdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0bztcblx0XHRcdFx0dG8gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgZWFzaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmVhc2luZyxcblx0XHRcdHN0YXJ0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zICE9IG51bGwgJiYgKFxuXHRcdFx0XHR0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgPyBvcHRpb25zIDogb3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KSxcblx0XHRcdHR3ZWVuID0gbmV3IFR3ZWVuKHRoaXMsIGZyb20sIHRvLCBkdXJhdGlvbiwgZWFzaW5nLCBzdGFydCk7XG5cdFx0ZnVuY3Rpb24gb25GcmFtZShldmVudCkge1xuXHRcdFx0dHdlZW4uX2hhbmRsZUZyYW1lKGV2ZW50LnRpbWUgKiAxMDAwKTtcblx0XHRcdGlmICghdHdlZW4ucnVubmluZykge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCBvbkZyYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLm9uKCdmcmFtZScsIG9uRnJhbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHdlZW47XG5cdH0sXG5cblx0dHdlZW5UbzogZnVuY3Rpb24odG8sIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy50d2VlbihudWxsLCB0bywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dHdlZW5Gcm9tOiBmdW5jdGlvbihmcm9tLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRoaXMudHdlZW4oZnJvbSwgbnVsbCwgb3B0aW9ucyk7XG5cdH1cbn0pO1xuXG52YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyb3VwJyxcblx0X3NlbGVjdEJvdW5kczogZmFsc2UsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMjA1MCkge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2ldLl9jbGlwTWFzaykge1xuXHRcdFx0XHRcdGNsaXBJdGVtID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gY2xpcEl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBjbGlwSXRlbTtcblx0fSxcblxuXHRpc0NsaXBwZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldENsaXBJdGVtKCk7XG5cdH0sXG5cblx0c2V0Q2xpcHBlZDogZnVuY3Rpb24oY2xpcHBlZCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdGlmIChjaGlsZClcblx0XHRcdGNoaWxkLnNldENsaXBNYXNrKGNsaXBwZWQpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uIF9nZXRCb3VuZHMobWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0XHRyZXR1cm4gY2xpcEl0ZW1cblx0XHRcdD8gY2xpcEl0ZW0uX2dldENhY2hlZEJvdW5kcyhjbGlwSXRlbS5fbWF0cml4LnByZXBlbmRlZChtYXRyaXgpLFxuXHRcdFx0XHRCYXNlLnNldCh7fSwgb3B0aW9ucywgeyBzdHJva2U6IGZhbHNlIH0pKVxuXHRcdFx0OiBfZ2V0Qm91bmRzLmJhc2UuY2FsbCh0aGlzLCBtYXRyaXgsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9oaXRUZXN0Q2hpbGRyZW46IGZ1bmN0aW9uIF9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHRcdHJldHVybiAoIWNsaXBJdGVtIHx8IGNsaXBJdGVtLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0JiYgX2hpdFRlc3RDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgcG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsXG5cdFx0XHRcdFx0Y2xpcEl0ZW0pO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dmFyIGNsaXAgPSBwYXJhbS5jbGlwLFxuXHRcdFx0Y2xpcEl0ZW0gPSAhY2xpcCAmJiB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgY2xpcEl0ZW06IGNsaXBJdGVtLCBjbGlwOiBmYWxzZSB9KTtcblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0cGFyYW0uZG9udFN0YXJ0ID0gcGFyYW0uZG9udEZpbmlzaCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChjbGlwSXRlbSkge1xuXHRcdFx0Y2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdH1cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChpdGVtICE9PSBjbGlwSXRlbSlcblx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBMYXllciA9IEdyb3VwLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xheWVyJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMYXllcigpIHtcblx0XHRHcm91cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9nZXRPd25lcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLl9pbmRleCAhPSBudWxsICYmIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gaXNJbnNlcnRlZC5iYXNlLmNhbGwodGhpcykgOiB0aGlzLl9pbmRleCAhPSBudWxsO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXM7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbigpIHtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuU2NhbGVTdHJva2U6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMsIHBvaW50KSB7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShwcm9wcywgcG9pbnQpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZVxuXHRcdFx0JiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSlcblx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcblx0fSxcblxuXHRjb3B5Q29udGVudDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dGhpcy5zZXRUeXBlKHNvdXJjZS5fdHlwZSk7XG5cdFx0dGhpcy5zZXRTaXplKHNvdXJjZS5fc2l6ZSk7XG5cdFx0dGhpcy5zZXRSYWRpdXMoc291cmNlLl9yYWRpdXMpO1xuXHR9LFxuXG5cdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9LFxuXG5cdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0fSxcblxuXHRnZXRTaGFwZTogJyNnZXRUeXBlJyxcblx0c2V0U2hhcGU6ICcjc2V0VHlwZScsXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLl9zaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQoU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKS5hYnMoKSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHR3aWR0aCA9IGhlaWdodCA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSB3aWR0aCAvIDI7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuX3NldCh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2l6ZS5fc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLl9zZXQoc2l6ZSwgc2l6ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCF0aGlzLl9yYWRpdXMpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzLmNsb25lKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fcmFkaXVzLmVxdWFscyhyYWRpdXMpKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChyYWRpdXMpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUubWF4KHRoaXMuX3NpemUsIHJhZGl1cy5tdWx0aXBseSgyKSk7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQoc2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5fc2V0KHJhZGl1cy53aWR0aCAqIDIsIHJhZGl1cy5oZWlnaHQgKiAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0b1BhdGg6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGhbQmFzZS5jYXBpdGFsaXplKHRoaXMuX3R5cGUpXSh7XG5cdFx0XHRjZW50ZXI6IG5ldyBQb2ludCgpLFxuXHRcdFx0c2l6ZTogdGhpcy5fc2l6ZSxcblx0XHRcdHJhZGl1czogdGhpcy5fcmFkaXVzLFxuXHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdH0pO1xuXHRcdHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0aWYgKHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4KVxuXHRcdFx0cGF0aC5zZXRBcHBseU1hdHJpeCh0cnVlKTtcblx0XHRpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KVxuXHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHR0b1NoYXBlOiAnI2Nsb25lJyxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9QYXRoKGZhbHNlKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdGFuZ2xlJyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHkgPSBoZWlnaHQgLyAyLFxuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhLFxuXHRcdFx0XHRcdFx0YyA9IFtcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIHksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSByeVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRpZiAoc3Ryb2tlTWF0cml4KVxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuXHRcdFx0XHRcdGlmICh5ICE9PSByeSlcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9XG5cdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRzdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpXG5cdFx0XHRcdFx0JiYgc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0cmVjdCA9IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpO1xuXHRcdHJldHVybiBzdHJva2VXaWR0aFxuXHRcdFx0XHQ/IHJlY3QuZXhwYW5kKFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0dGhpcy5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucykpKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldENvcm5lckNlbnRlcih0aGF0LCBwb2ludCwgZXhwYW5kKSB7XG5cdFx0dmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcblx0XHRpZiAoIXJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGhhbGZTaXplID0gdGhhdC5fc2l6ZS5kaXZpZGUoMik7XG5cdFx0XHRmb3IgKHZhciBxID0gMTsgcSA8PSA0OyBxKyspIHtcblx0XHRcdFx0dmFyIGRpciA9IG5ldyBQb2ludChxID4gMSAmJiBxIDwgNCA/IC0xIDogMSwgcSA+IDIgPyAtMSA6IDEpLFxuXHRcdFx0XHRcdGNvcm5lciA9IGRpci5tdWx0aXBseShoYWxmU2l6ZSksXG5cdFx0XHRcdFx0Y2VudGVyID0gY29ybmVyLnN1YnRyYWN0KGRpci5tdWx0aXBseShyYWRpdXMpKSxcblx0XHRcdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZShcblx0XHRcdFx0XHRcdFx0ZXhwYW5kID8gY29ybmVyLmFkZChkaXIubXVsdGlwbHkoZXhwYW5kKSkgOiBjb3JuZXIsXG5cdFx0XHRcdFx0XHRcdGNlbnRlcik7XG5cdFx0XHRcdGlmIChyZWN0LmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4geyBwb2ludDogY2VudGVyLCBxdWFkcmFudDogcSB9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LCByYWRpdXMsIHBhZGRpbmcsIHF1YWRyYW50KSB7XG5cdFx0dmFyIHZlY3RvciA9IHBvaW50LmRpdmlkZShyYWRpdXMpO1xuXHRcdHJldHVybiAoIXF1YWRyYW50IHx8IHZlY3Rvci5pc0luUXVhZHJhbnQocXVhZHJhbnQpKSAmJlxuXHRcdFx0XHR2ZWN0b3Iuc3VidHJhY3QodmVjdG9yLm5vcm1hbGl6ZSgpKS5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHRcdFx0LmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIucG9pbnQpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsXG5cdFx0XHRcdHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0dmFyIGhpdCA9IGZhbHNlLFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCk7XG5cdFx0XHRpZiAoaGl0U3Ryb2tlIHx8IGhpdEZpbGwpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0XHRzdHJva2VSYWRpdXMgPSBoaXRTdHJva2UgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG5cdFx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcuYWRkKFxuXHRcdFx0XHRcdFx0UGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdCFzdHlsZS5nZXRTdHJva2VTY2FsaW5nKCkgJiYgc3Ryb2tlTWF0cml4KSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBwYWRkaW5nID0gc3Ryb2tlUGFkZGluZy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRcdGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCwgcGFkZGluZyk7XG5cdFx0XHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRcdFx0aGl0ID0gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQuc3VidHJhY3QoY2VudGVyLnBvaW50KSxcblx0XHRcdFx0XHRcdFx0XHRyYWRpdXMsIHN0cm9rZVBhZGRpbmcsIGNlbnRlci5xdWFkcmFudCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRcdFx0XHRcdG91dGVyID0gcmVjdC5leHBhbmQocGFkZGluZyksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQocGFkZGluZy5uZWdhdGUoKSk7XG5cdFx0XHRcdFx0XHRoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcblx0XHRcdFx0XHRcdFx0XHQmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoaXQgPSBpc09uRWxsaXBzZVN0cm9rZShwb2ludCwgcmFkaXVzLCBzdHJva2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhpdCA/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBCYXNlLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUpO1xuXHRcdGl0ZW0uX3R5cGUgPSB0eXBlO1xuXHRcdGl0ZW0uX3NpemUgPSBzaXplO1xuXHRcdGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcblx0XHRpdGVtLl9pbml0aWFsaXplKEJhc2UuZ2V0TmFtZWQoYXJncyksIHBvaW50KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cyxcblx0XHRcdFx0XHRhcmdzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKSxcblx0XHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSxcblx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJncyk7XG5cdFx0fSxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJncyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBjZW50ZXIsXG5cdFx0XHRcdHJhZGl1cztcblx0XHRcdGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuXHRcdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdFx0cmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmFzdGVyJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc09wdGlvbnM6IHsgc3Ryb2tlOiBmYWxzZSwgaGFuZGxlOiBmYWxzZSB9LFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cdF9wcmlvcml0aXplOiBbJ2Nyb3NzT3JpZ2luJ10sXG5cdF9zbW9vdGhpbmc6ICdsb3cnLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSYXN0ZXIoc291cmNlLCBwb3NpdGlvbikge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShzb3VyY2UsXG5cdFx0XHRcdHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKSkge1xuXHRcdFx0dmFyIGltYWdlLFxuXHRcdFx0XHR0eXBlID0gdHlwZW9mIHNvdXJjZSxcblx0XHRcdFx0b2JqZWN0ID0gdHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHQ/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSlcblx0XHRcdFx0XHQ6IHR5cGUgID09PSAnb2JqZWN0J1xuXHRcdFx0XHRcdFx0PyBzb3VyY2Vcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdGlmIChvYmplY3QgJiYgb2JqZWN0ICE9PSBJdGVtLk5PX0lOU0VSVCkge1xuXHRcdFx0XHRpZiAob2JqZWN0LmdldENvbnRleHQgfHwgb2JqZWN0Lm5hdHVyYWxIZWlnaHQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGltYWdlID0gb2JqZWN0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iamVjdCkge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0aWYgKCFzaXplLmlzWmVybygpKSB7XG5cdFx0XHRcdFx0XHRpbWFnZSA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpbWFnZSkge1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKGltYWdlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKCk7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgpID09PSBpdGVtLmdldFNvdXJjZSgpO1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW1hZ2UgPSBzb3VyY2UuX2ltYWdlLFxuXHRcdFx0Y2FudmFzID0gc291cmNlLl9jYW52YXM7XG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHR0aGlzLl9zZXRJbWFnZShpbWFnZSk7XG5cdFx0fSBlbHNlIGlmIChjYW52YXMpIHtcblx0XHRcdHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNvdXJjZS5fc2l6ZSk7XG5cdFx0XHRjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHR0aGlzLl9zZXRJbWFnZShjb3B5Q2FudmFzKTtcblx0XHR9XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBzb3VyY2UuX2Nyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLFxuXHRcdFx0XHR0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKF9zaXplLCBfY2xlYXIpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghc2l6ZS5lcXVhbHModGhpcy5fc2l6ZSkpIHtcblx0XHRcdGlmIChzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDApIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSAhX2NsZWFyICYmIHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0XHR0aGlzLl9zZXRJbWFnZShDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSkpO1xuXHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKF9jbGVhcikge1xuXHRcdFx0dGhpcy5jbGVhcigpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLndpZHRoIDogMDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLnNldFNpemUod2lkdGgsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUgPyB0aGlzLl9zaXplLmhlaWdodCA6IDA7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLnNldFNpemUodGhpcy5nZXRXaWR0aCgpLCBoZWlnaHQpO1xuXHR9LFxuXG5cdGdldExvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuICFzaXplIHx8IHNpemUud2lkdGggPT09IDAgJiYgc2l6ZS5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdG9yaWcgPSBuZXcgUG9pbnQoMCwgMCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHR1ID0gbmV3IFBvaW50KDEsIDApLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpLFxuXHRcdFx0diA9IG5ldyBQb2ludCgwLCAxKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKTtcblx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHQ3MiAvIHUuZ2V0TGVuZ3RoKCksXG5cdFx0XHQ3MiAvIHYuZ2V0TGVuZ3RoKClcblx0XHQpO1xuXHR9LFxuXG5cdGdldFBwaTogJyNnZXRSZXNvbHV0aW9uJyxcblxuXHRnZXRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xuXHR9LFxuXG5cdHNldEltYWdlOiBmdW5jdGlvbihpbWFnZSkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhhdC5nZXRWaWV3KCksXG5cdFx0XHRcdHR5cGUgPSBldmVudCAmJiBldmVudC50eXBlIHx8ICdsb2FkJztcblx0XHRcdGlmICh2aWV3ICYmIHRoYXQucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0cGFwZXIgPSB2aWV3Ll9zY29wZTtcblx0XHRcdFx0dGhhdC5lbWl0KHR5cGUsIG5ldyBFdmVudChldmVudCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldEltYWdlKGltYWdlKTtcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRzZXRUaW1lb3V0KGVtaXQsIDApO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2UpIHtcblx0XHRcdERvbUV2ZW50LmFkZChpbWFnZSwge1xuXHRcdFx0XHRsb2FkOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdHRoYXQuX3NldEltYWdlKGltYWdlKTtcblx0XHRcdFx0XHRlbWl0KGV2ZW50KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGVtaXRcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0SW1hZ2U6IGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRpZiAoaW1hZ2UgJiYgaW1hZ2UuZ2V0Q29udGV4dCkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gbnVsbDtcblx0XHRcdHRoaXMuX2xvYWRlZCA9ICEhKGltYWdlICYmIGltYWdlLnNyYyAmJiBpbWFnZS5jb21wbGV0ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCgxMDMzKTtcblx0fSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzO1xuXHR9LFxuXG5cdHNldENhbnZhczogJyNzZXRJbWFnZScsXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24oX2NoYW5nZSkge1xuXHRcdGlmICghdGhpcy5fY29udGV4dClcblx0XHRcdHRoaXMuX2NvbnRleHQgPSB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKF9jaGFuZ2UpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTAyNSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuXHRcdHJldHVybiBpbWFnZSAmJiBpbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcblx0fSxcblxuXHRzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciBpbWFnZSA9IG5ldyBzZWxmLkltYWdlKCksXG5cdFx0XHRjcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdGlmIChjcm9zc09yaWdpbilcblx0XHRcdGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0aWYgKHNyYylcblx0XHRcdGltYWdlLnNyYyA9IHNyYztcblx0XHR0aGlzLnNldEltYWdlKGltYWdlKTtcblx0fSxcblxuXHRnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG5cdFx0cmV0dXJuIGltYWdlICYmIGltYWdlLmNyb3NzT3JpZ2luIHx8IHRoaXMuX2Nyb3NzT3JpZ2luIHx8ICcnO1xuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbihjcm9zc09yaWdpbikge1xuXHRcdHRoaXMuX2Nyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG5cdFx0aWYgKGltYWdlKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0fSxcblxuXHRnZXRTbW9vdGhpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zbW9vdGhpbmc7XG5cdH0sXG5cblx0c2V0U21vb3RoaW5nOiBmdW5jdGlvbihzbW9vdGhpbmcpIHtcblx0XHR0aGlzLl9zbW9vdGhpbmcgPSB0eXBlb2Ygc21vb3RoaW5nID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBzbW9vdGhpbmdcblx0XHRcdDogc21vb3RoaW5nID8gJ2xvdycgOiAnb2ZmJztcblx0XHR0aGlzLl9jaGFuZ2VkKDI1Nyk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9sb2FkZWQgJiYgdGhpcy5faW1hZ2U7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldFN1YkNhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChyZWN0LmdldFNpemUoKSk7XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmdldENhbnZhcygpLCByZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3R4LmNhbnZhcztcblx0fSxcblxuXHRnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5fc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVwZW5kKHRoaXMuX21hdHJpeCk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0dG9EYXRhVVJMOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcblx0XHRcdHNyYyA9IGltYWdlICYmIGltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cykgOiBudWxsO1xuXHR9LFxuXG5cdGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2UgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEF2ZXJhZ2VDb2xvcjogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0dmFyIGJvdW5kcywgcGF0aDtcblx0XHRpZiAoIW9iamVjdCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFBhdGhJdGVtKSB7XG5cdFx0XHRwYXRoID0gb2JqZWN0O1xuXHRcdFx0Ym91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICgnd2lkdGgnIGluIG9iamVjdCkge1xuXHRcdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKCd4JyBpbiBvYmplY3QpIHtcblx0XHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWJvdW5kcylcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRjdHguZHJhd0ltYWdlKGVsZW1lbnQsIC1zaXplLndpZHRoIC8gMiwgLXNpemUuaGVpZ2h0IC8gMik7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLjUsIDAuNSwgTWF0aC5jZWlsKHdpZHRoKSxcblx0XHRcdFx0TWF0aC5jZWlsKGhlaWdodCkpLmRhdGEsXG5cdFx0XHRjaGFubmVscyA9IFswLCAwLCAwXSxcblx0XHRcdHRvdGFsID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBpeGVscy5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdHZhciBhbHBoYSA9IHBpeGVsc1tpICsgM107XG5cdFx0XHR0b3RhbCArPSBhbHBoYTtcblx0XHRcdGFscGhhIC89IDI1NTtcblx0XHRcdGNoYW5uZWxzWzBdICs9IHBpeGVsc1tpXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMV0gKz0gcGl4ZWxzW2kgKyAxXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMl0gKz0gcGl4ZWxzW2kgKyAyXSAqIGFscGhhO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKylcblx0XHRcdGNoYW5uZWxzW2ldIC89IHRvdGFsO1xuXHRcdHJldHVybiB0b3RhbCA/IENvbG9yLnJlYWQoY2hhbm5lbHMpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHBvaW50LngsIHBvaW50LnksIDEsIDEpLmRhdGE7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigncmdiJywgW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdLFxuXHRcdFx0XHRkYXRhWzNdIC8gMjU1KTtcblx0fSxcblxuXHRzZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJncyksXG5cdFx0XHRjb21wb25lbnRzID0gY29sb3IuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0YWxwaGEgPSBjb2xvci5fYWxwaGEsXG5cdFx0XHRjdHggPSB0aGlzLmdldENvbnRleHQodHJ1ZSksXG5cdFx0XHRpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDEsIDEpLFxuXHRcdFx0ZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdGRhdGFbMF0gPSBjb21wb25lbnRzWzBdICogMjU1O1xuXHRcdGRhdGFbMV0gPSBjb21wb25lbnRzWzFdICogMjU1O1xuXHRcdGRhdGFbMl0gPSBjb21wb25lbnRzWzJdICogMjU1O1xuXHRcdGRhdGFbM10gPSBhbHBoYSAhPSBudWxsID8gYWxwaGEgKiAyNTUgOiAyNTU7XG5cdFx0Y3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsZW1lbnQgJiYgZWxlbWVudC53aWR0aCA+IDAgJiYgZWxlbWVudC5oZWlnaHQgPiAwKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBOdW1lcmljYWwuY2xhbXAodGhpcy5fb3BhY2l0eSwgMCwgMSk7XG5cblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblxuXHRcdFx0dmFyIHNtb290aGluZyA9IHRoaXMuX3Ntb290aGluZyxcblx0XHRcdFx0ZGlzYWJsZWQgPSBzbW9vdGhpbmcgPT09ICdvZmYnO1xuXHRcdFx0RG9tRWxlbWVudC5zZXRQcmVmaXhlZChcblx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRkaXNhYmxlZCA/ICdpbWFnZVNtb290aGluZ0VuYWJsZWQnIDogJ2ltYWdlU21vb3RoaW5nUXVhbGl0eScsXG5cdFx0XHRcdGRpc2FibGVkID8gZmFsc2UgOiBzbW9vdGhpbmdcblx0XHRcdCk7XG5cblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBTeW1ib2xJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2xJdGVtJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc09wdGlvbnM6IHsgc3Ryb2tlOiB0cnVlIH0sXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2xJdGVtKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnMCxcblx0XHRcdFx0YXJnMSAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpXG5cdFx0XHR0aGlzLnNldERlZmluaXRpb24oYXJnMCBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24gP1xuXHRcdFx0XHRcdGFyZzAgOiBuZXcgU3ltYm9sRGVmaW5pdGlvbihhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uID09PSBpdGVtLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldERlZmluaXRpb24oc291cmNlLl9kZWZpbml0aW9uKTtcblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihkZWZpbml0aW9uKSB7XG5cdFx0dGhpcy5fZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRnZXRTeW1ib2w6ICcjZ2V0RGVmaW5pdGlvbicsXG5cdHNldFN5bWJvbDogJyNzZXREZWZpbml0aW9uJyxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl9kZWZpbml0aW9uLl9pdGVtO1xuXHRcdHJldHVybiBpdGVtLl9nZXRDYWNoZWRCb3VuZHMoaXRlbS5fbWF0cml4LnByZXBlbmRlZChtYXRyaXgpLCBvcHRpb25zKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG5cdFx0dmFyIG9wdHMgPSBvcHRpb25zLmV4dGVuZCh7IGFsbDogZmFsc2UgfSk7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uX2hpdFRlc3QocG9pbnQsIG9wdHMsIHZpZXdNYXRyaXgpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIFN5bWJvbERlZmluaXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbERlZmluaXRpb24nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbERlZmluaXRpb24oaXRlbSwgZG9udENlbnRlcikge1xuXHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKGl0ZW0pXG5cdFx0XHR0aGlzLnNldEl0ZW0oaXRlbSwgZG9udENlbnRlcik7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY2xhc3MsIHRoaXMuX2l0ZW1dLFxuXHRcdFx0XHRcdG9wdGlvbnMsIGZhbHNlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiA4KVxuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHRpZiAoZmxhZ3MgJiAxKVxuXHRcdFx0dGhpcy5wcm9qZWN0Ll9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9zeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9pdGVtKVxuXHRcdFx0dGhpcy5faXRlbS5fc3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9zeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0Z2V0RGVmaW5pdGlvbjogJyNnZXRJdGVtJyxcblx0c2V0RGVmaW5pdGlvbjogJyNzZXRJdGVtJyxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbEl0ZW0odGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbERlZmluaXRpb24odGhpcy5faXRlbS5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0cmV0dXJuIHN5bWJvbCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBzeW1ib2wgJiYgdGhpcy5faXRlbS5lcXVhbHMoc3ltYm9sLl9pdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKVxuXHRcdFx0dGhpcy5pbmplY3QodmFsdWVzKTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmdzICYmIEJhc2UucmVhZChhcmdzKTtcblx0XHRcdHJldHVybiBuZXcgQmFzZSh7XG5cdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdHRvbGVyYW5jZTogcGFwZXIuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuXHRcdFx0XHRmaWxsOiAhb3B0aW9ucyxcblx0XHRcdFx0c3Ryb2tlOiAhb3B0aW9ucyxcblx0XHRcdFx0c2VnbWVudHM6ICFvcHRpb25zLFxuXHRcdFx0XHRoYW5kbGVzOiBmYWxzZSxcblx0XHRcdFx0ZW5kczogZmFsc2UsXG5cdFx0XHRcdHBvc2l0aW9uOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXHRfc2VsZWN0aW9uOiAwLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dCwgc2VsZWN0aW9uO1xuXHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdGlmIChhcmcwID09IG51bGwgfHwgdHlwZW9mIGFyZzAgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChjb3VudCA9PT0gMSAmJiBhcmcwICYmICdwb2ludCcgaW4gYXJnMCkge1xuXHRcdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gYXJnMC5zZWxlY3Rpb247XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0XHRcdGhhbmRsZUluID0gYXJnMTtcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IGFyZzM7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gWyBhcmcwLCBhcmcxIF07XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmc0ICE9PSB1bmRlZmluZWQgPyBbIGFyZzQsIGFyZzUgXSA6IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG5ldyBTZWdtZW50UG9pbnQocG9pbnQsIHRoaXMsICdfcG9pbnQnKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZUluLCB0aGlzLCAnX2hhbmRsZUluJyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG5cdFx0aWYgKHNlbGVjdGlvbilcblx0XHRcdHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0c2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuXHRcdFx0b2JqID0gc2VsZWN0aW9uIHx8IHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdFx0PyBbcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdXG5cdFx0XHRcdFx0OiBwb2ludDtcblx0XHRpZiAoc2VsZWN0aW9uKVxuXHRcdFx0b2JqLnB1c2goc2VsZWN0aW9uKTtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCg0MSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRpc1Ntb290aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQ7XG5cdFx0cmV0dXJuICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdCYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCk7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXHR9LFxuXG5cdGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXHRcdHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRwYXRoID0gdGhpcy5fcGF0aDtcblx0XHR0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgMDtcblx0XHRpZiAocGF0aCAmJiBzZWxlY3Rpb24gIT09IG9sZFNlbGVjdGlvbikge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFNlbGVjdGlvbiwgc2VsZWN0aW9uKTtcblx0XHRcdHBhdGguX2NoYW5nZWQoMjU3KTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZVNlbGVjdGlvbjogZnVuY3Rpb24oZmxhZywgc2VsZWN0ZWQpIHtcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuXHRcdHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGVkID8gc2VsZWN0aW9uIHwgZmxhZyA6IHNlbGVjdGlvbiAmIH5mbGFnKTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgNyk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fY2hhbmdlU2VsZWN0aW9uKDcsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9pbmRleCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgbnVsbDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0aWYgKGluZGV4ID4gMCAmJiAhcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0JiYgaW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdGluZGV4LS07XG5cdFx0XHRyZXR1cm4gcGF0aC5nZXRDdXJ2ZXMoKVtpbmRleF0gfHwgbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmVcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGhpcyA9PT0gY3VydmUuX3NlZ21lbnQxID8gMCA6IDEpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuXHRcdHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0c21vb3RoOiBmdW5jdGlvbihvcHRpb25zLCBfZmlyc3QsIF9sYXN0KSB7XG5cdFx0dmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9LFxuXHRcdFx0dHlwZSA9IG9wdHMudHlwZSxcblx0XHRcdGZhY3RvciA9IG9wdHMuZmFjdG9yLFxuXHRcdFx0cHJldiA9IHRoaXMuZ2V0UHJldmlvdXMoKSxcblx0XHRcdG5leHQgPSB0aGlzLmdldE5leHQoKSxcblx0XHRcdHAwID0gKHByZXYgfHwgdGhpcykuX3BvaW50LFxuXHRcdFx0cDEgPSB0aGlzLl9wb2ludCxcblx0XHRcdHAyID0gKG5leHQgfHwgdGhpcykuX3BvaW50LFxuXHRcdFx0ZDEgPSBwMC5nZXREaXN0YW5jZShwMSksXG5cdFx0XHRkMiA9IHAxLmdldERpc3RhbmNlKHAyKTtcblx0XHRpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ2NhdG11bGwtcm9tJykge1xuXHRcdFx0dmFyIGEgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGZhY3Rvcixcblx0XHRcdFx0ZDFfYSA9IE1hdGgucG93KGQxLCBhKSxcblx0XHRcdFx0ZDFfMmEgPSBkMV9hICogZDFfYSxcblx0XHRcdFx0ZDJfYSA9IE1hdGgucG93KGQyLCBhKSxcblx0XHRcdFx0ZDJfMmEgPSBkMl9hICogZDJfYTtcblx0XHRcdGlmICghX2ZpcnN0ICYmIHByZXYpIHtcblx0XHRcdFx0dmFyIEEgPSAyICogZDJfMmEgKyAzICogZDJfYSAqIGQxX2EgKyBkMV8yYSxcblx0XHRcdFx0XHROID0gMyAqIGQyX2EgKiAoZDJfYSArIGQxX2EpO1xuXHRcdFx0XHR0aGlzLnNldEhhbmRsZUluKE4gIT09IDBcblx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdChkMl8yYSAqIHAwLl94ICsgQSAqIHAxLl94IC0gZDFfMmEgKiBwMi5feCkgLyBOIC0gcDEuX3gsXG5cdFx0XHRcdFx0XHQoZDJfMmEgKiBwMC5feSArIEEgKiBwMS5feSAtIGQxXzJhICogcDIuX3kpIC8gTiAtIHAxLl95KVxuXHRcdFx0XHRcdDogbmV3IFBvaW50KCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFfbGFzdCAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciBBID0gMiAqIGQxXzJhICsgMyAqIGQxX2EgKiBkMl9hICsgZDJfMmEsXG5cdFx0XHRcdFx0TiA9IDMgKiBkMV9hICogKGQxX2EgKyBkMl9hKTtcblx0XHRcdFx0dGhpcy5zZXRIYW5kbGVPdXQoTiAhPT0gMFxuXHRcdFx0XHRcdD8gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0KGQxXzJhICogcDIuX3ggKyBBICogcDEuX3ggLSBkMl8yYSAqIHAwLl94KSAvIE4gLSBwMS5feCxcblx0XHRcdFx0XHRcdChkMV8yYSAqIHAyLl95ICsgQSAqIHAxLl95IC0gZDJfMmEgKiBwMC5feSkgLyBOIC0gcDEuX3kpXG5cdFx0XHRcdFx0OiBuZXcgUG9pbnQoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZ2VvbWV0cmljJykge1xuXHRcdFx0aWYgKHByZXYgJiYgbmV4dCkge1xuXHRcdFx0XHR2YXIgdmVjdG9yID0gcDAuc3VidHJhY3QocDIpLFxuXHRcdFx0XHRcdHQgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNCA6IGZhY3Rvcixcblx0XHRcdFx0XHRrID0gdCAqIGQxIC8gKGQxICsgZDIpO1xuXHRcdFx0XHRpZiAoIV9maXJzdClcblx0XHRcdFx0XHR0aGlzLnNldEhhbmRsZUluKHZlY3Rvci5tdWx0aXBseShrKSk7XG5cdFx0XHRcdGlmICghX2xhc3QpXG5cdFx0XHRcdFx0dGhpcy5zZXRIYW5kbGVPdXQodmVjdG9yLm11bHRpcGx5KGsgLSB0KSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU21vb3RoaW5nIG1ldGhvZCBcXCcnICsgdHlwZSArICdcXCcgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc0ZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX2luZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxIHx8IGZhbHNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVJbiA9IHRoaXMuX2hhbmRsZUluLFxuXHRcdFx0aGFuZGxlT3V0ID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0dG1wID0gaGFuZGxlSW4uY2xvbmUoKTtcblx0XHRoYW5kbGVJbi5zZXQoaGFuZGxlT3V0KTtcblx0XHRoYW5kbGVPdXQuc2V0KHRtcCk7XG5cdH0sXG5cblx0cmV2ZXJzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG5cdFx0dmFyIHUgPSAxIC0gZmFjdG9yLFxuXHRcdFx0diA9IGZhY3Rvcixcblx0XHRcdHBvaW50MSA9IGZyb20uX3BvaW50LFxuXHRcdFx0cG9pbnQyID0gdG8uX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4xID0gZnJvbS5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVJbjIgPSB0by5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQyID0gdG8uX2hhbmRsZU91dCxcblx0XHRcdGhhbmRsZU91dDEgPSBmcm9tLl9oYW5kbGVPdXQ7XG5cdFx0dGhpcy5fcG9pbnQuX3NldChcblx0XHRcdFx0dSAqIHBvaW50MS5feCArIHYgKiBwb2ludDIuX3gsXG5cdFx0XHRcdHUgKiBwb2ludDEuX3kgKyB2ICogcG9pbnQyLl95LCB0cnVlKTtcblx0XHR0aGlzLl9oYW5kbGVJbi5fc2V0KFxuXHRcdFx0XHR1ICogaGFuZGxlSW4xLl94ICsgdiAqIGhhbmRsZUluMi5feCxcblx0XHRcdFx0dSAqIGhhbmRsZUluMS5feSArIHYgKiBoYW5kbGVJbjIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5fc2V0KFxuXHRcdFx0XHR1ICogaGFuZGxlT3V0MS5feCArIHYgKiBoYW5kbGVPdXQyLl94LFxuXHRcdFx0XHR1ICogaGFuZGxlT3V0MS5feSArIHYgKiBoYW5kbGVPdXQyLl95LCB0cnVlKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihtYXRyaXgsIGNvb3JkcywgY2hhbmdlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG5cdFx0XHRoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG5cdFx0XHR4ID0gcG9pbnQuX3gsXG5cdFx0XHR5ID0gcG9pbnQuX3ksXG5cdFx0XHRpID0gMjtcblx0XHRjb29yZHNbMF0gPSB4O1xuXHRcdGNvb3Jkc1sxXSA9IHk7XG5cdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcblx0XHRcdHggPSBjb29yZHNbMF07XG5cdFx0XHR5ID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRwb2ludC5feCA9IHg7XG5cdFx0XHRcdHBvaW50Ll95ID0geTtcblx0XHRcdFx0aSA9IDI7XG5cdFx0XHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0XHRcdGhhbmRsZUluLl94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZUluLl95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWhhbmRsZUluKSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxufSk7XG5cbnZhciBTZWdtZW50UG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50UG9pbnQocG9pbnQsIG93bmVyLCBrZXkpIHtcblx0XHR2YXIgeCwgeSxcblx0XHRcdHNlbGVjdGVkO1xuXHRcdGlmICghcG9pbnQpIHtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHkgPSBwb2ludFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQ7XG5cdFx0XHRpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR4ID0gcHQueDtcblx0XHRcdH1cblx0XHRcdHkgPSBwdC55O1xuXHRcdFx0c2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcblx0XHR9XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHRvd25lcltrZXldID0gdGhpcztcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIGlzWmVybyh0aGlzLl94KSAmJiBpc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiB0aGlzLl9nZXRTZWxlY3Rpb24oKSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZVNlbGVjdGlvbih0aGlzLl9nZXRTZWxlY3Rpb24oKSwgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdHJldHVybiB0aGlzID09PSBvd25lci5fcG9pbnQgPyAxXG5cdFx0XHQ6IHRoaXMgPT09IG93bmVyLl9oYW5kbGVJbiA/IDJcblx0XHRcdDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZU91dCA/IDRcblx0XHRcdDogMDtcblx0fVxufSk7XG5cbnZhciBDdXJ2ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmUnLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHNlZzEsIHNlZzIsXG5cdFx0XHRwb2ludDEsIHBvaW50Mixcblx0XHRcdGhhbmRsZTEsIGhhbmRsZTI7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHNlZzEgPSBhcmcxO1xuXHRcdFx0c2VnMiA9IGFyZzI7XG5cdFx0fSBlbHNlIGlmICghY291bnQpIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudCgpO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKCdzZWdtZW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRzZWcxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG5cdFx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQyKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3BvaW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwLnBvaW50MTtcblx0XHRcdFx0aGFuZGxlMSA9IGFyZzAuaGFuZGxlMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzAuaGFuZGxlMjtcblx0XHRcdFx0cG9pbnQyID0gYXJnMC5wb2ludDI7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0cG9pbnQxID0gW2FyZzBbMF0sIGFyZzBbMV1dO1xuXHRcdFx0XHRwb2ludDIgPSBbYXJnMFs2XSwgYXJnMFs3XV07XG5cdFx0XHRcdGhhbmRsZTEgPSBbYXJnMFsyXSAtIGFyZzBbMF0sIGFyZzBbM10gLSBhcmcwWzFdXTtcblx0XHRcdFx0aGFuZGxlMiA9IFthcmcwWzRdIC0gYXJnMFs2XSwgYXJnMFs1XSAtIGFyZzBbN11dO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcxKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG5cdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0aGFuZGxlMSA9IGFyZzE7XG5cdFx0XHRoYW5kbGUyID0gYXJnMjtcblx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuXHRcdFx0cG9pbnQxID0gW2FyZzAsIGFyZzFdO1xuXHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0aGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuXHRcdFx0aGFuZGxlMiA9IFthcmc0IC0gYXJnNiwgYXJnNSAtIGFyZzddO1xuXHRcdH1cblx0XHR0aGlzLl9zZWdtZW50MSA9IHNlZzEgfHwgbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZzIgfHwgbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdD8gW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0SGFuZGxlMSgpLCB0aGlzLmdldEhhbmRsZTIoKSxcblx0XHRcdFx0XHR0aGlzLmdldFBvaW50MigpXVxuXHRcdFx0XHQ6IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldFBvaW50MigpXSxcblx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcblx0XHRwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Y2xhc3NpZnk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5jbGFzc2lmeSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dCk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGdldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX3NlZ21lbnQxLl9pbmRleCA9PT0gcGF0aC5fY3VydmVzLmxlbmd0aCAtIDFcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5nZXRQb2ludDEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldFBvaW50MigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRWYWx1ZXModGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyLCBtYXRyaXgpO1xuXHR9LFxuXG5cdGdldFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pKTtcblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9XG59LCB7XG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKVxuXHRcdFx0dGhpcy5fbGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBMaW5lKHRoaXMuX3NlZ21lbnQxLl9wb2ludCwgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgQ3VydmUoQ3VydmUuZ2V0UGFydCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0bykpO1xuXHR9LFxuXG5cdGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0byk7XG5cdH0sXG5cblx0ZGl2aWRlQXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKGxvY2F0aW9uICYmIGxvY2F0aW9uLmN1cnZlID09PSB0aGlzXG5cdFx0XHRcdD8gbG9jYXRpb24udGltZSA6IHRoaXMuZ2V0VGltZUF0KGxvY2F0aW9uKSk7XG5cdH0sXG5cblx0ZGl2aWRlQXRUaW1lOiBmdW5jdGlvbih0aW1lLCBfc2V0SGFuZGxlcykge1xuXHRcdHZhciB0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKHRpbWUgPj0gdE1pbiAmJiB0aW1lIDw9IHRNYXgpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCB0aW1lKSxcblx0XHRcdFx0bGVmdCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRyaWdodCA9IHBhcnRzWzFdLFxuXHRcdFx0XHRzZXRIYW5kbGVzID0gX3NldEhhbmRsZXMgfHwgdGhpcy5oYXNIYW5kbGVzKCksXG5cdFx0XHRcdHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdFx0c2VnMiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRcdGlmIChzZXRIYW5kbGVzKSB7XG5cdFx0XHRcdHNlZzEuX2hhbmRsZU91dC5fc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLCBsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHNlZzIuX2hhbmRsZUluLl9zZXQocmlnaHRbNF0gLSByaWdodFs2XSxyaWdodFs1XSAtIHJpZ2h0WzddKTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0c2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQocmlnaHRbMl0gLSB4LCByaWdodFszXSAtIHkpKTtcblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdHBhdGguaW5zZXJ0KHNlZzEuX2luZGV4ICsgMSwgc2VnbWVudCk7XG5cdFx0XHRcdHJlcyA9IHRoaXMuZ2V0TmV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHRcdHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBzZWcyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdEF0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRyZXR1cm4gcGF0aCA/IHBhdGguc3BsaXRBdChsb2NhdGlvbikgOiBudWxsO1xuXHR9LFxuXG5cdHNwbGl0QXRUaW1lOiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3BsaXRBdCh0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRpbWUpKTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNUaW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMC41IDogaXNUaW1lID8gb2Zmc2V0XG5cdFx0XHRcdDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNUaW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3BsaXRBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXRcblx0XHRcdFx0OiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlZCgpLCB0aGlzLl9zZWdtZW50MS5yZXZlcnNlZCgpKTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuX3NldCgwLCAwKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uX3NldCgwLCAwKTtcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4LCBzdHJhaWdodCkge1xuXHRcdHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcblx0XHRcdGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuXHRcdFx0cDIgPSBzZWdtZW50Mi5fcG9pbnQsXG5cdFx0XHR4MSA9IHAxLngsIHkxID0gcDEueSxcblx0XHRcdHgyID0gcDIueCwgeTIgPSBwMi55LFxuXHRcdFx0dmFsdWVzID0gc3RyYWlnaHRcblx0XHRcdFx0PyBbIHgxLCB5MSwgeDEsIHkxLCB4MiwgeTIsIHgyLCB5MiBdXG5cdFx0XHRcdDogW1xuXHRcdFx0XHRcdHgxLCB5MSxcblx0XHRcdFx0XHR4MSArIGgxLl94LCB5MSArIGgxLl95LFxuXHRcdFx0XHRcdHgyICsgaDIuX3gsIHkyICsgaDIuX3ksXG5cdFx0XHRcdFx0eDIsIHkyXG5cdFx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0eDEgPSB2WzJdLCB5MSA9IHZbM10sXG5cdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddO1xuXHRcdGlmICh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHR0ID0gMC41O1xuXHRcdHZhciB1ID0gMSAtIHQsXG5cdFx0XHR4NCA9IHUgKiB4MCArIHQgKiB4MSwgeTQgPSB1ICogeTAgKyB0ICogeTEsXG5cdFx0XHR4NSA9IHUgKiB4MSArIHQgKiB4MiwgeTUgPSB1ICogeTEgKyB0ICogeTIsXG5cdFx0XHR4NiA9IHUgKiB4MiArIHQgKiB4MywgeTYgPSB1ICogeTIgKyB0ICogeTMsXG5cdFx0XHR4NyA9IHUgKiB4NCArIHQgKiB4NSwgeTcgPSB1ICogeTQgKyB0ICogeTUsXG5cdFx0XHR4OCA9IHUgKiB4NSArIHQgKiB4NiwgeTggPSB1ICogeTUgKyB0ICogeTYsXG5cdFx0XHR4OSA9IHUgKiB4NyArIHQgKiB4OCwgeTkgPSB1ICogeTcgKyB0ICogeTg7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFt4MCwgeTAsIHg0LCB5NCwgeDcsIHk3LCB4OSwgeTldLFxuXHRcdFx0W3g5LCB5OSwgeDgsIHk4LCB4NiwgeTYsIHgzLCB5M11cblx0XHRdO1xuXHR9LFxuXG5cdGdldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKHYsIGRpcikge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdGlvID0gZGlyID8gMCA6IDEsXG5cdFx0XHRvMCA9IHZbaW8gKyAwXSxcblx0XHRcdG8xID0gdltpbyArIDJdLFxuXHRcdFx0bzIgPSB2W2lvICsgNF0sXG5cdFx0XHRvMyA9IHZbaW8gKyA2XTtcblx0XHRpZiAoKG8wID49IG8xKSA9PT0gKG8xID49IG8yKSAmJiAobzEgPj0gbzIpID09PSAobzIgPj0gbzMpXG5cdFx0XHRcdHx8IEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdGN1cnZlcy5wdXNoKHYpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYSA9IDMgKiAobzEgLSBvMikgLSBvMCArIG8zLFxuXHRcdFx0XHRiID0gMiAqIChvMCArIG8yKSAtIDQgKiBvMSxcblx0XHRcdFx0YyA9IG8xIC0gbzAsXG5cdFx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRcdG4gPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMsIHRNaW4sIHRNYXgpO1xuXHRcdFx0aWYgKCFuKSB7XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYsIHQpO1xuXHRcdFx0XHRjdXJ2ZXMucHVzaChwYXJ0c1swXSk7XG5cdFx0XHRcdGlmIChuID4gMSkge1xuXHRcdFx0XHRcdHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG5cdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUocGFydHNbMV0sIHQpO1xuXHRcdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJ2ZXMucHVzaChwYXJ0c1sxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0c29sdmVDdWJpYzogZnVuY3Rpb24gKHYsIGNvb3JkLCB2YWwsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciB2MCA9IHZbY29vcmRdLFxuXHRcdFx0djEgPSB2W2Nvb3JkICsgMl0sXG5cdFx0XHR2MiA9IHZbY29vcmQgKyA0XSxcblx0XHRcdHYzID0gdltjb29yZCArIDZdLFxuXHRcdFx0cmVzID0gMDtcblx0XHRpZiAoICAhKHYwIDwgdmFsICYmIHYzIDwgdmFsICYmIHYxIDwgdmFsICYmIHYyIDwgdmFsIHx8XG5cdFx0XHRcdHYwID4gdmFsICYmIHYzID4gdmFsICYmIHYxID4gdmFsICYmIHYyID4gdmFsKSkge1xuXHRcdFx0dmFyIGMgPSAzICogKHYxIC0gdjApLFxuXHRcdFx0XHRiID0gMyAqICh2MiAtIHYxKSAtIGMsXG5cdFx0XHRcdGEgPSB2MyAtIHYwIC0gYyAtIGI7XG5cdFx0XHRyZXMgPSBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCB2MCAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRnZXRUaW1lT2Y6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0dmFyIHAwID0gbmV3IFBvaW50KHZbMF0sIHZbMV0pLFxuXHRcdFx0cDMgPSBuZXcgUG9pbnQodls2XSwgdls3XSksXG5cdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRnZW9tRXBzaWxvbiA9IDFlLTcsXG5cdFx0XHR0ID0gcG9pbnQuaXNDbG9zZShwMCwgZXBzaWxvbikgPyAwXG5cdFx0XHQgIDogcG9pbnQuaXNDbG9zZShwMywgZXBzaWxvbikgPyAxXG5cdFx0XHQgIDogbnVsbDtcblx0XHRpZiAodCA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGNvb3JkcyA9IFtwb2ludC54LCBwb2ludC55XSxcblx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYysrKSB7XG5cdFx0XHRcdHZhciBjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgYywgY29vcmRzW2NdLCByb290cywgMCwgMSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciB1ID0gcm9vdHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmlzQ2xvc2UoQ3VydmUuZ2V0UG9pbnQodiwgdSksIGdlb21FcHNpbG9uKSlcblx0XHRcdFx0XHRcdHJldHVybiB1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0Nsb3NlKHAwLCBnZW9tRXBzaWxvbikgPyAwXG5cdFx0XHQgOiBwb2ludC5pc0Nsb3NlKHAzLCBnZW9tRXBzaWxvbikgPyAxXG5cdFx0XHQgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RUaW1lOiBmdW5jdGlvbih2LCBwb2ludCkge1xuXHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0XHR2eCA9IHgzIC0geDAsIHZ5ID0geTMgLSB5MCxcblx0XHRcdFx0ZGV0ID0gdnggKiB2eCArIHZ5ICogdnk7XG5cdFx0XHRpZiAoZGV0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdHZhciB1ID0gKChwb2ludC54IC0geDApICogdnggKyAocG9pbnQueSAtIHkwKSAqIHZ5KSAvIGRldDtcblx0XHRcdHJldHVybiB1IDwgMWUtMTIgPyAwXG5cdFx0XHRcdCA6IHUgPiAwLjk5OTk5OTk5OTk5OSA/IDFcblx0XHRcdFx0IDogQ3VydmUuZ2V0VGltZU9mKHYsXG5cdFx0XHRcdFx0bmV3IFBvaW50KHgwICsgdSAqIHZ4LCB5MCArIHUgKiB2eSkpO1xuXHRcdH1cblxuXHRcdHZhciBjb3VudCA9IDEwMCxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pblQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lKHQpIHtcblx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG5cdFx0XHRcdHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoQ3VydmUuZ2V0UG9pbnQodiwgdCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gMWUtOCkge1xuXHRcdFx0aWYgKCFyZWZpbmUobWluVCAtIHN0ZXApICYmICFyZWZpbmUobWluVCArIHN0ZXApKVxuXHRcdFx0XHRzdGVwIC89IDI7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5UO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0dmFyIGZsaXAgPSBmcm9tID4gdG87XG5cdFx0aWYgKGZsaXApIHtcblx0XHRcdHZhciB0bXAgPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IHRvO1xuXHRcdFx0dG8gPSB0bXA7XG5cdFx0fVxuXHRcdGlmIChmcm9tID4gMClcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07XG5cdFx0aWYgKHRvIDwgMSlcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTtcblx0XHRyZXR1cm4gZmxpcFxuXHRcdFx0XHQ/IFt2WzZdLCB2WzddLCB2WzRdLCB2WzVdLCB2WzJdLCB2WzNdLCB2WzBdLCB2WzFdXVxuXHRcdFx0XHQ6IHY7XG5cdH0sXG5cblx0aXNGbGF0RW5vdWdoOiBmdW5jdGlvbih2LCBmbGF0bmVzcykge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdHV4ID0gMyAqIHgxIC0gMiAqIHgwIC0geDMsXG5cdFx0XHR1eSA9IDMgKiB5MSAtIDIgKiB5MCAtIHkzLFxuXHRcdFx0dnggPSAzICogeDIgLSAyICogeDMgLSB4MCxcblx0XHRcdHZ5ID0gMyAqIHkyIC0gMiAqIHkzIC0geTA7XG5cdFx0cmV0dXJuIE1hdGgubWF4KHV4ICogdXgsIHZ4ICogdngpICsgTWF0aC5tYXgodXkgKiB1eSwgdnkgKiB2eSlcblx0XHRcdFx0PD0gMTYgKiBmbGF0bmVzcyAqIGZsYXRuZXNzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN107XG5cdFx0cmV0dXJuIDMgKiAoKHkzIC0geTApICogKHgxICsgeDIpIC0gKHgzIC0geDApICogKHkxICsgeTIpXG5cdFx0XHRcdCsgeTEgKiAoeDAgLSB4MikgLSB4MSAqICh5MCAtIHkyKVxuXHRcdFx0XHQrIHkzICogKHgyICsgeDAgLyAzKSAtIHgzICogKHkyICsgeTAgLyAzKSkgLyAyMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgbWluID0gdi5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBbMCwgMF07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspXG5cdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sXG5cdFx0XHRcdFx0aSwgMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdF9hZGRCb3VuZHM6IGZ1bmN0aW9uKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG5cdFx0ZnVuY3Rpb24gYWRkKHZhbHVlLCBwYWRkaW5nKSB7XG5cdFx0XHR2YXIgbGVmdCA9IHZhbHVlIC0gcGFkZGluZyxcblx0XHRcdFx0cmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG5cdFx0XHRpZiAobGVmdCA8IG1pbltjb29yZF0pXG5cdFx0XHRcdG1pbltjb29yZF0gPSBsZWZ0O1xuXHRcdFx0aWYgKHJpZ2h0ID4gbWF4W2Nvb3JkXSlcblx0XHRcdFx0bWF4W2Nvb3JkXSA9IHJpZ2h0O1xuXHRcdH1cblxuXHRcdHBhZGRpbmcgLz0gMjtcblx0XHR2YXIgbWluUGFkID0gbWluW2Nvb3JkXSArIHBhZGRpbmcsXG5cdFx0XHRtYXhQYWQgPSBtYXhbY29vcmRdIC0gcGFkZGluZztcblx0XHRpZiAoICAgIHYwIDwgbWluUGFkIHx8IHYxIDwgbWluUGFkIHx8IHYyIDwgbWluUGFkIHx8IHYzIDwgbWluUGFkIHx8XG5cdFx0XHRcdHYwID4gbWF4UGFkIHx8IHYxID4gbWF4UGFkIHx8IHYyID4gbWF4UGFkIHx8IHYzID4gbWF4UGFkKSB7XG5cdFx0XHRpZiAodjEgPCB2MCAhPSB2MSA8IHYzICYmIHYyIDwgdjAgIT0gdjIgPCB2Mykge1xuXHRcdFx0XHRhZGQodjAsIDApO1xuXHRcdFx0XHRhZGQodjMsIDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdFx0XHRiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcblx0XHRcdFx0XHRjID0gdjEgLSB2MCxcblx0XHRcdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdFx0XHRhZGQodjMsIDApO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzW2ldLFxuXHRcdFx0XHRcdFx0dSA9IDEgLSB0O1xuXHRcdFx0XHRcdGlmICh0TWluIDw9IHQgJiYgdCA8PSB0TWF4KVxuXHRcdFx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0XHRcdCsgMyAqIHUgKiB1ICogdCAqIHYxXG5cdFx0XHRcdFx0XHRcdCsgMyAqIHUgKiB0ICogdCAqIHYyXG5cdFx0XHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFxuXHRbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShcblx0XHRcdFx0XHRcdFt0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDJdLCBmYWxzZSwgdGhpcy5fcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm91bmRzLmNsb25lKCk7XG5cdFx0fTtcblx0fSxcbntcblxufSksIEJhc2UuZWFjaCh7XG5cdGlzU3RyYWlnaHQ6IGZ1bmN0aW9uKHAxLCBoMSwgaDIsIHAyKSB7XG5cdFx0aWYgKGgxLmlzWmVybygpICYmIGgyLmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHYgPSBwMi5zdWJ0cmFjdChwMSk7XG5cdFx0XHRpZiAodi5pc1plcm8oKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKHYuaXNDb2xsaW5lYXIoaDEpICYmIHYuaXNDb2xsaW5lYXIoaDIpKSB7XG5cdFx0XHRcdHZhciBsID0gbmV3IExpbmUocDEsIHAyKSxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtNztcblx0XHRcdFx0aWYgKGwuZ2V0RGlzdGFuY2UocDEuYWRkKGgxKSkgPCBlcHNpbG9uICYmXG5cdFx0XHRcdFx0bC5nZXREaXN0YW5jZShwMi5hZGQoaDIpKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHR2YXIgZGl2ID0gdi5kb3QodiksXG5cdFx0XHRcdFx0XHRzMSA9IHYuZG90KGgxKSAvIGRpdixcblx0XHRcdFx0XHRcdHMyID0gdi5kb3QoaDIpIC8gZGl2O1xuXHRcdFx0XHRcdHJldHVybiBzMSA+PSAwICYmIHMxIDw9IDEgJiYgczIgPD0gMCAmJiBzMiA+PSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKHAxLCBoMSwgaDIsIHAyKSB7XG5cdFx0dmFyIHRoaXJkID0gcDIuc3VidHJhY3QocDEpLmRpdmlkZSgzKTtcblx0XHRyZXR1cm4gaDEuZXF1YWxzKHRoaXJkKSAmJiBoMi5uZWdhdGUoKS5lcXVhbHModGhpcmQpO1xuXHR9XG59LCBmdW5jdGlvbih0ZXN0LCBuYW1lKSB7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihlcHNpbG9uKSB7XG5cdFx0dmFyIHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdHNlZzIgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRyZXR1cm4gdGVzdChzZWcxLl9wb2ludCwgc2VnMS5faGFuZGxlT3V0LCBzZWcyLl9oYW5kbGVJbiwgc2VnMi5fcG9pbnQsXG5cdFx0XHRcdGVwc2lsb24pO1xuXHR9O1xuXG5cdHRoaXMuc3RhdGljc1tuYW1lXSA9IGZ1bmN0aW9uKHYsIGVwc2lsb24pIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XTtcblx0XHRyZXR1cm4gdGVzdChcblx0XHRcdFx0bmV3IFBvaW50KHgwLCB5MCksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzJdIC0geDAsIHZbM10gLSB5MCksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzRdIC0geDMsIHZbNV0gLSB5MyksXG5cdFx0XHRcdG5ldyBQb2ludCh4MywgeTMpLCBlcHNpbG9uKTtcblx0fTtcbn0sIHtcblx0c3RhdGljczoge30sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdHx8ICF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG5cdH0sXG5cblx0aGFzTGVuZ3RoOiBmdW5jdGlvbihlcHNpbG9uKSB7XG5cdFx0cmV0dXJuICghdGhpcy5nZXRQb2ludDEoKS5lcXVhbHModGhpcy5nZXRQb2ludDIoKSkgfHwgdGhpcy5oYXNIYW5kbGVzKCkpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0TGVuZ3RoKCkgPiAoZXBzaWxvbiB8fCAwKTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGhpcy5pc1N0cmFpZ2h0KCkgJiYgY3VydmUuaXNTdHJhaWdodCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0TGluZSgpLmlzQ29sbGluZWFyKGN1cnZlLmdldExpbmUoKSk7XG5cdH0sXG5cblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXRUaW1lKDAuNSkueSlcblx0XHRcdFx0PCAxZS04O1xuXHR9LFxuXG5cdGlzVmVydGljYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS54KVxuXHRcdFx0XHQ8IDFlLTg7XG5cdH1cbn0pLCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIF9pc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0VGltZShcblx0XHRcdFx0X2lzVGltZSA/IG9mZnNldCA6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXRUaW1lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgIT0gbnVsbCAmJiB0ID49IDAgJiYgdCA8PSAxXG5cdFx0XHRcdD8gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdClcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldFRpbWVBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRUaW1lQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyQXQ6ICcjZ2V0VGltZUF0JyxcblxuXHRnZXRUaW1lc1dpdGhUYW5nZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRhbmdlbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRhbmdlbnQuaXNaZXJvKClcblx0XHRcdFx0PyBbXVxuXHRcdFx0XHQ6IEN1cnZlLmdldFRpbWVzV2l0aFRhbmdlbnQodGhpcy5nZXRWYWx1ZXMoKSwgdGFuZ2VudCk7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0QXRUaW1lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGFydExlbmd0aCgwLCB0KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0VGltZSh0aGlzLmdldFRpbWVPZihQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldFRpbWVPZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFRpbWVPZih0aGlzLmdldFZhbHVlcygpLCBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlck9mOiAnI2dldFRpbWVPZicsXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0dCA9IEN1cnZlLmdldE5lYXJlc3RUaW1lKHZhbHVlcywgcG9pbnQpLFxuXHRcdFx0cHQgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpO1xuXHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0LCBwdCwgbnVsbCwgcG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0UG9pbnQoKSA6IGxvYztcblx0fVxuXG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWV0aG9kcyA9IFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0V2VpZ2h0ZWRUYW5nZW50Jyxcblx0XHQnZ2V0V2VpZ2h0ZWROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ107XG5cdHJldHVybiBCYXNlLmVhY2gobWV0aG9kcyxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKGxvY2F0aW9uLCBfaXNUaW1lKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odmFsdWVzLCBfaXNUaW1lID8gbG9jYXRpb25cblx0XHRcdFx0XHRcdDogQ3VydmUuZ2V0VGltZUF0KHZhbHVlcywgbG9jYXRpb24pKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbbmFtZSArICdBdFRpbWUnXSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuZ2V0VmFsdWVzKCksIHRpbWUpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRzdGF0aWNzOiB7XG5cdFx0XHRcdF9ldmFsdWF0ZU1ldGhvZHM6IG1ldGhvZHNcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG5cdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0eDEgPSB2WzJdLCB5MSA9IHZbM10sXG5cdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXG5cdFx0XHRheCA9IDkgKiAoeDEgLSB4MikgKyAzICogKHgzIC0geDApLFxuXHRcdFx0YnggPSA2ICogKHgwICsgeDIpIC0gMTIgKiB4MSxcblx0XHRcdGN4ID0gMyAqICh4MSAtIHgwKSxcblxuXHRcdFx0YXkgPSA5ICogKHkxIC0geTIpICsgMyAqICh5MyAtIHkwKSxcblx0XHRcdGJ5ID0gNiAqICh5MCArIHkyKSAtIDEyICogeTEsXG5cdFx0XHRjeSA9IDMgKiAoeTEgLSB5MCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcblx0XHRcdFx0ZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEl0ZXJhdGlvbnMoYSwgYikge1xuXHRcdHJldHVybiBNYXRoLm1heCgyLCBNYXRoLm1pbigxNiwgTWF0aC5jZWlsKE1hdGguYWJzKGIgLSBhKSAqIDMyKSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXZhbHVhdGUodiwgdCwgdHlwZSwgbm9ybWFsaXplZCkge1xuXHRcdGlmICh0ID09IG51bGwgfHwgdCA8IDAgfHwgdCA+IDEpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdGlmIChpc1plcm8oeDEgLSB4MCkgJiYgaXNaZXJvKHkxIC0geTApKSB7XG5cdFx0XHR4MSA9IHgwO1xuXHRcdFx0eTEgPSB5MDtcblx0XHR9XG5cdFx0aWYgKGlzWmVybyh4MiAtIHgzKSAmJiBpc1plcm8oeTIgLSB5MykpIHtcblx0XHRcdHgyID0geDM7XG5cdFx0XHR5MiA9IHkzO1xuXHRcdH1cblx0XHR2YXIgY3ggPSAzICogKHgxIC0geDApLFxuXHRcdFx0YnggPSAzICogKHgyIC0geDEpIC0gY3gsXG5cdFx0XHRheCA9IHgzIC0geDAgLSBjeCAtIGJ4LFxuXHRcdFx0Y3kgPSAzICogKHkxIC0geTApLFxuXHRcdFx0YnkgPSAzICogKHkyIC0geTEpIC0gY3ksXG5cdFx0XHRheSA9IHkzIC0geTAgLSBjeSAtIGJ5LFxuXHRcdFx0eCwgeTtcblx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0eCA9IHQgPT09IDAgPyB4MCA6IHQgPT09IDEgPyB4M1xuXHRcdFx0XHRcdDogKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHgwO1xuXHRcdFx0eSA9IHQgPT09IDAgPyB5MCA6IHQgPT09IDEgPyB5M1xuXHRcdFx0XHRcdDogKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdCArIHkwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdE1pbiA9IDFlLTgsXG5cdFx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRcdGlmICh0IDwgdE1pbikge1xuXHRcdFx0XHR4ID0gY3g7XG5cdFx0XHRcdHkgPSBjeTtcblx0XHRcdH0gZWxzZSBpZiAodCA+IHRNYXgpIHtcblx0XHRcdFx0eCA9IDMgKiAoeDMgLSB4Mik7XG5cdFx0XHRcdHkgPSAzICogKHkzIC0geTIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0eSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcblx0XHRcdH1cblx0XHRcdGlmIChub3JtYWxpemVkKSB7XG5cdFx0XHRcdGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgKHQgPCB0TWluIHx8IHQgPiB0TWF4KSkge1xuXHRcdFx0XHRcdHggPSB4MiAtIHgxO1xuXHRcdFx0XHRcdHkgPSB5MiAtIHkxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdGlmIChsZW4pIHtcblx0XHRcdFx0XHR4IC89IGxlbjtcblx0XHRcdFx0XHR5IC89IGxlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHR5MiA9IDYgKiBheSAqIHQgKyAyICogYnksXG5cdFx0XHRcdFx0ZCA9IE1hdGgucG93KHggKiB4ICsgeSAqIHksIDMgLyAyKTtcblx0XHRcdFx0eCA9IGQgIT09IDAgPyAoeCAqIHkyIC0geSAqIHgyKSAvIGQgOiAwO1xuXHRcdFx0XHR5ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHR5cGUgPT09IDIgPyBuZXcgUG9pbnQoeSwgLXgpIDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXG5cdFx0Y2xhc3NpZnk6IGZ1bmN0aW9uKHYpIHtcblxuXHRcdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0XHRhMSA9IHgwICogKHkzIC0geTIpICsgeTAgKiAoeDIgLSB4MykgKyB4MyAqIHkyIC0geTMgKiB4Mixcblx0XHRcdFx0YTIgPSB4MSAqICh5MCAtIHkzKSArIHkxICogKHgzIC0geDApICsgeDAgKiB5MyAtIHkwICogeDMsXG5cdFx0XHRcdGEzID0geDIgKiAoeTEgLSB5MCkgKyB5MiAqICh4MCAtIHgxKSArIHgxICogeTAgLSB5MSAqIHgwLFxuXHRcdFx0XHRkMyA9IDMgKiBhMyxcblx0XHRcdFx0ZDIgPSBkMyAtIGEyLFxuXHRcdFx0XHRkMSA9IGQyIC0gYTIgKyBhMSxcblx0XHRcdFx0bCA9IE1hdGguc3FydChkMSAqIGQxICsgZDIgKiBkMiArIGQzICogZDMpLFxuXHRcdFx0XHRzID0gbCAhPT0gMCA/IDEgLyBsIDogMCxcblx0XHRcdFx0aXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybyxcblx0XHRcdFx0c2VycGVudGluZSA9ICdzZXJwZW50aW5lJztcblx0XHRcdGQxICo9IHM7XG5cdFx0XHRkMiAqPSBzO1xuXHRcdFx0ZDMgKj0gcztcblxuXHRcdFx0ZnVuY3Rpb24gdHlwZSh0eXBlLCB0MSwgdDIpIHtcblx0XHRcdFx0dmFyIGhhc1Jvb3RzID0gdDEgIT09IHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0MU9rID0gaGFzUm9vdHMgJiYgdDEgPiAwICYmIHQxIDwgMSxcblx0XHRcdFx0XHR0Mk9rID0gaGFzUm9vdHMgJiYgdDIgPiAwICYmIHQyIDwgMTtcblx0XHRcdFx0aWYgKGhhc1Jvb3RzICYmICghKHQxT2sgfHwgdDJPaylcblx0XHRcdFx0XHRcdHx8IHR5cGUgPT09ICdsb29wJyAmJiAhKHQxT2sgJiYgdDJPaykpKSB7XG5cdFx0XHRcdFx0dHlwZSA9ICdhcmNoJztcblx0XHRcdFx0XHR0MU9rID0gdDJPayA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRyb290czogdDFPayB8fCB0Mk9rXG5cdFx0XHRcdFx0XHRcdD8gdDFPayAmJiB0Mk9rXG5cdFx0XHRcdFx0XHRcdFx0PyB0MSA8IHQyID8gW3QxLCB0Ml0gOiBbdDIsIHQxXVxuXHRcdFx0XHRcdFx0XHRcdDogW3QxT2sgPyB0MSA6IHQyXVxuXHRcdFx0XHRcdFx0XHQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzWmVybyhkMSkpIHtcblx0XHRcdFx0cmV0dXJuIGlzWmVybyhkMilcblx0XHRcdFx0XHRcdD8gdHlwZShpc1plcm8oZDMpID8gJ2xpbmUnIDogJ3F1YWRyYXRpYycpXG5cdFx0XHRcdFx0XHQ6IHR5cGUoc2VycGVudGluZSwgZDMgLyAoMyAqIGQyKSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZCA9IDMgKiBkMiAqIGQyIC0gNCAqIGQxICogZDM7XG5cdFx0XHRpZiAoaXNaZXJvKGQpKSB7XG5cdFx0XHRcdHJldHVybiB0eXBlKCdjdXNwJywgZDIgLyAoMiAqIGQxKSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZjEgPSBkID4gMCA/IE1hdGguc3FydChkIC8gMykgOiBNYXRoLnNxcnQoLWQpLFxuXHRcdFx0XHRmMiA9IDIgKiBkMTtcblx0XHRcdHJldHVybiB0eXBlKGQgPiAwID8gc2VycGVudGluZSA6ICdsb29wJyxcblx0XHRcdFx0XHQoZDIgKyBmMSkgLyBmMixcblx0XHRcdFx0XHQoZDIgLSBmMSkgLyBmMik7XG5cdFx0fSxcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYiwgZHMpIHtcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGEgPSAwO1xuXHRcdFx0aWYgKGIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YiA9IDE7XG5cdFx0XHRpZiAoQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0XHR2YXIgYyA9IHY7XG5cdFx0XHRcdGlmIChiIDwgMSkge1xuXHRcdFx0XHRcdGMgPSBDdXJ2ZS5zdWJkaXZpZGUoYywgYilbMF07XG5cdFx0XHRcdFx0YSAvPSBiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhID4gMCkge1xuXHRcdFx0XHRcdGMgPSBDdXJ2ZS5zdWJkaXZpZGUoYywgYSlbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGR4ID0gY1s2XSAtIGNbMF0sXG5cdFx0XHRcdFx0ZHkgPSBjWzddIC0gY1sxXTtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcyB8fCBnZXRMZW5ndGhJbnRlZ3JhbmQodiksIGEsIGIsXG5cdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0fSxcblxuXHRcdGdldFRpbWVBdDogZnVuY3Rpb24odiwgb2Zmc2V0LCBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHN0YXJ0ID0gb2Zmc2V0IDwgMCA/IDEgOiAwO1xuXHRcdFx0aWYgKG9mZnNldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdGZvcndhcmQgPSBvZmZzZXQgPiAwLFxuXHRcdFx0XHRhID0gZm9yd2FyZCA/IHN0YXJ0IDogMCxcblx0XHRcdFx0YiA9IGZvcndhcmQgPyAxIDogc3RhcnQsXG5cdFx0XHRcdGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpLFxuXHRcdFx0XHRyYW5nZUxlbmd0aCA9IEN1cnZlLmdldExlbmd0aCh2LCBhLCBiLCBkcyksXG5cdFx0XHRcdGRpZmYgPSBhYnMob2Zmc2V0KSAtIHJhbmdlTGVuZ3RoO1xuXHRcdFx0aWYgKGFicyhkaWZmKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdH0gZWxzZSBpZiAoZGlmZiA+IGVwc2lsb24pIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZ1bmN0aW9uIGYodCkge1xuXHRcdFx0XHRsZW5ndGggKz0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgc3RhcnQsIHQsXG5cdFx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKHN0YXJ0LCB0KSk7XG5cdFx0XHRcdHN0YXJ0ID0gdDtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aCAtIG9mZnNldDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuZmluZFJvb3QoZiwgZHMsIHN0YXJ0ICsgZ3Vlc3MsIGEsIGIsIDMyLFxuXHRcdFx0XHRcdDFlLTEyKTtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAwLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWRUYW5nZW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldEN1cnZhdHVyZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDMsIGZhbHNlKS54O1xuXHRcdH0sXG5cblx0XHRnZXRQZWFrczogZnVuY3Rpb24odikge1xuXHRcdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0XHRheCA9ICAgICAteDAgKyAzICogeDEgLSAzICogeDIgKyB4Myxcblx0XHRcdFx0YnggPSAgMyAqIHgwIC0gNiAqIHgxICsgMyAqIHgyLFxuXHRcdFx0XHRjeCA9IC0zICogeDAgKyAzICogeDEsXG5cdFx0XHRcdGF5ID0gICAgIC15MCArIDMgKiB5MSAtIDMgKiB5MiArIHkzLFxuXHRcdFx0XHRieSA9ICAzICogeTAgLSA2ICogeTEgKyAzICogeTIsXG5cdFx0XHRcdGN5ID0gLTMgKiB5MCArIDMgKiB5MSxcblx0XHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdE51bWVyaWNhbC5zb2x2ZUN1YmljKFxuXHRcdFx0XHRcdDkgKiAoYXggKiBheCArIGF5ICogYXkpLFxuXHRcdFx0XHRcdDkgKiAoYXggKiBieCArIGJ5ICogYXkpLFxuXHRcdFx0XHRcdDIgKiAoYnggKiBieCArIGJ5ICogYnkpICsgMyAqIChjeCAqIGF4ICsgY3kgKiBheSksXG5cdFx0XHRcdFx0KGN4ICogYnggKyBieSAqIGN5KSxcblx0XHRcdFx0XHRyb290cywgdE1pbiwgdE1heCk7XG5cdFx0XHRyZXR1cm4gcm9vdHMuc29ydCgpO1xuXHRcdH1cblx0fX07XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIHQxLCBjMiwgdDIsIG92ZXJsYXApIHtcblx0XHR2YXIgZXhjbHVkZVN0YXJ0ID0gIW92ZXJsYXAgJiYgYzEuZ2V0UHJldmlvdXMoKSA9PT0gYzIsXG5cdFx0XHRleGNsdWRlRW5kID0gIW92ZXJsYXAgJiYgYzEgIT09IGMyICYmIGMxLmdldE5leHQoKSA9PT0gYzIsXG5cdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAodDEgIT09IG51bGwgJiYgdDEgPj0gKGV4Y2x1ZGVTdGFydCA/IHRNaW4gOiAwKSAmJlxuXHRcdFx0dDEgPD0gKGV4Y2x1ZGVFbmQgPyB0TWF4IDogMSkpIHtcblx0XHRcdGlmICh0MiAhPT0gbnVsbCAmJiB0MiA+PSAoZXhjbHVkZUVuZCA/IHRNaW4gOiAwKSAmJlxuXHRcdFx0XHR0MiA8PSAoZXhjbHVkZVN0YXJ0ID8gdE1heCA6IDEpKSB7XG5cdFx0XHRcdHZhciBsb2MxID0gbmV3IEN1cnZlTG9jYXRpb24oYzEsIHQxLCBudWxsLCBvdmVybGFwKSxcblx0XHRcdFx0XHRsb2MyID0gbmV3IEN1cnZlTG9jYXRpb24oYzIsIHQyLCBudWxsLCBvdmVybGFwKTtcblx0XHRcdFx0bG9jMS5faW50ZXJzZWN0aW9uID0gbG9jMjtcblx0XHRcdFx0bG9jMi5faW50ZXJzZWN0aW9uID0gbG9jMTtcblx0XHRcdFx0aWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jMSkpIHtcblx0XHRcdFx0XHRDdXJ2ZUxvY2F0aW9uLmluc2VydChsb2NhdGlvbnMsIGxvYzEsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsXG5cdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB0TWluLCB0TWF4LCB1TWluLCB1TWF4KSB7XG5cdFx0aWYgKCsrY2FsbHMgPj0gNDA5NiB8fCArK3JlY3Vyc2lvbiA+PSA0MClcblx0XHRcdHJldHVybiBjYWxscztcblx0XHR2YXIgZmF0TGluZUVwc2lsb24gPSAxZS05LFxuXHRcdFx0cTB4ID0gdjJbMF0sIHEweSA9IHYyWzFdLCBxM3ggPSB2Mls2XSwgcTN5ID0gdjJbN10sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSxcblx0XHRcdGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pLFxuXHRcdFx0ZmFjdG9yID0gZDEgKiBkMiA+IDAgPyAzIC8gNCA6IDQgLyA5LFxuXHRcdFx0ZE1pbiA9IGZhY3RvciAqIE1hdGgubWluKDAsIGQxLCBkMiksXG5cdFx0XHRkTWF4ID0gZmFjdG9yICogTWF0aC5tYXgoMCwgZDEsIGQyKSxcblx0XHRcdGRwMCA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMF0sIHYxWzFdKSxcblx0XHRcdGRwMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMl0sIHYxWzNdKSxcblx0XHRcdGRwMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNF0sIHYxWzVdKSxcblx0XHRcdGRwMyA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNl0sIHYxWzddKSxcblx0XHRcdGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHR0b3AgPSBodWxsWzBdLFxuXHRcdFx0Ym90dG9tID0gaHVsbFsxXSxcblx0XHRcdHRNaW5DbGlwLFxuXHRcdFx0dE1heENsaXA7XG5cdFx0aWYgKGQxID09PSAwICYmIGQyID09PSAwXG5cdFx0XHRcdCYmIGRwMCA9PT0gMCAmJiBkcDEgPT09IDAgJiYgZHAyID09PSAwICYmIGRwMyA9PT0gMFxuXHRcdFx0fHwgKHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpKSA9PSBudWxsXG5cdFx0XHR8fCAodE1heENsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AucmV2ZXJzZSgpLCBib3R0b20ucmV2ZXJzZSgpLFxuXHRcdFx0XHRkTWluLCBkTWF4KSkgPT0gbnVsbClcblx0XHRcdHJldHVybiBjYWxscztcblx0XHR2YXIgdE1pbk5ldyA9IHRNaW4gKyAodE1heCAtIHRNaW4pICogdE1pbkNsaXAsXG5cdFx0XHR0TWF4TmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWF4Q2xpcDtcblx0XHRpZiAoTWF0aC5tYXgodU1heCAtIHVNaW4sIHRNYXhOZXcgLSB0TWluTmV3KSA8IGZhdExpbmVFcHNpbG9uKSB7XG5cdFx0XHR2YXIgdCA9ICh0TWluTmV3ICsgdE1heE5ldykgLyAyLFxuXHRcdFx0XHR1ID0gKHVNaW4gKyB1TWF4KSAvIDI7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0ZmxpcCA/IGMyIDogYzEsIGZsaXAgPyB1IDogdCxcblx0XHRcdFx0XHRmbGlwID8gYzEgOiBjMiwgZmxpcCA/IHQgOiB1KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0djEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCB0TWluQ2xpcCwgdE1heENsaXApO1xuXHRcdFx0dmFyIHVEaWZmID0gdU1heCAtIHVNaW47XG5cdFx0XHRpZiAodE1heENsaXAgLSB0TWluQ2xpcCA+IDAuOCkge1xuXHRcdFx0XHRpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1RGlmZikge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHRcdHQgPSAodE1pbk5ldyArIHRNYXhOZXcpIC8gMjtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQpO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdCwgdE1heE5ldyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdFx0dSA9ICh1TWluICsgdU1heCkgLyAyO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdSwgdE1pbk5ldywgdE1heE5ldyk7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHBhcnRzWzFdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHVEaWZmID09PSAwIHx8IHVEaWZmID49IGZhdExpbmVFcHNpbG9uKSB7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHYyLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdE1pbk5ldywgdE1heE5ldywgdU1pbiwgdU1heCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbGxzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRkaXN0MSA9IGRxMSAtICgyICogZHEwICsgZHEzKSAvIDMsXG5cdFx0XHRkaXN0MiA9IGRxMiAtIChkcTAgKyAyICogZHEzKSAvIDMsXG5cdFx0XHRodWxsO1xuXHRcdGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuXHRcdFx0aHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0UmF0aW8gPSBkaXN0MSAvIGRpc3QyO1xuXHRcdFx0aHVsbCA9IFtcblx0XHRcdFx0ZGlzdFJhdGlvID49IDIgPyBbcDAsIHAxLCBwM11cblx0XHRcdFx0OiBkaXN0UmF0aW8gPD0gMC41ID8gW3AwLCBwMiwgcDNdXG5cdFx0XHRcdDogW3AwLCBwMSwgcDIsIHAzXSxcblx0XHRcdFx0W3AwLCBwM11cblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiAoZGlzdDEgfHwgZGlzdDIpIDwgMCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG5cdFx0fSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBodWxsVG9wWzBdWzBdO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuXHRcdHZhciBweCA9IHBhcnRbMF1bMF0sXG5cdFx0XHRweSA9IHBhcnRbMF1bMV07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHF4ID0gcGFydFtpXVswXSxcblx0XHRcdFx0cXkgPSBwYXJ0W2ldWzFdO1xuXHRcdFx0aWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gcXkgPT09IHRocmVzaG9sZCA/IHF4XG5cdFx0XHRcdFx0XHQ6IHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH1cblx0XHRcdHB4ID0gcXg7XG5cdFx0XHRweSA9IHF5O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModiwgcHgsIHB5LCB2eCwgdnkpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRpZiAoaXNaZXJvKHZ4KSAmJiBpc1plcm8odnkpKSB7XG5cdFx0XHR2YXIgdCA9IEN1cnZlLmdldFRpbWVPZih2LCBuZXcgUG9pbnQocHgsIHB5KSk7XG5cdFx0XHRyZXR1cm4gdCA9PT0gbnVsbCA/IFtdIDogW3RdO1xuXHRcdH1cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKC12eSwgdngpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cnYgPSBbXSxcblx0XHRcdHJvb3RzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdltpXSAtIHB4LFxuXHRcdFx0XHR5ID0gdltpICsgMV0gLSBweTtcblx0XHRcdHJ2LnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR4ICogc2luICsgeSAqIGNvcyk7XG5cdFx0fVxuXHRcdEN1cnZlLnNvbHZlQ3ViaWMocnYsIDEsIDAsIHJvb3RzLCAwLCAxKTtcblx0XHRyZXR1cm4gcm9vdHM7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRmbGlwKSB7XG5cdFx0dmFyIHgxID0gdjJbMF0sIHkxID0gdjJbMV0sXG5cdFx0XHR4MiA9IHYyWzZdLCB5MiA9IHYyWzddLFxuXHRcdFx0cm9vdHMgPSBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdDEgPSByb290c1tpXSxcblx0XHRcdFx0cDEgPSBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFRpbWVPZih2MiwgcDEpO1xuXHRcdFx0aWYgKHQyICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gdDIgOiB0MSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdDEgOiB0Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHB0ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHB0KSB7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0YzEsIEN1cnZlLmdldFRpbWVPZih2MSwgcHQpLFxuXHRcdFx0XHRcdGMyLCBDdXJ2ZS5nZXRUaW1lT2YodjIsIHB0KSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0bWluID0gTWF0aC5taW4sXG5cdFx0XHRtYXggPSBNYXRoLm1heDtcblxuXHRcdGlmIChtYXgodjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtaW4odjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtYXgodjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pICYmXG5cdFx0XHRtaW4odjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pKSB7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdGMxLCBvdmVybGFwWzBdLFxuXHRcdFx0XHRcdFx0XHRjMiwgb3ZlcmxhcFsxXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdFx0XHRzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcblx0XHRcdFx0XHRzdHJhaWdodCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG5cdFx0XHRcdFx0ZmxpcCA9IHN0cmFpZ2h0MSAmJiAhc3RyYWlnaHQyLFxuXHRcdFx0XHRcdGJlZm9yZSA9IGxvY2F0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdChzdHJhaWdodFxuXHRcdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHRcdDogc3RyYWlnaHQxIHx8IHN0cmFpZ2h0MlxuXHRcdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHRcdGZsaXAgPyB2MiA6IHYxLCBmbGlwID8gdjEgOiB2Mixcblx0XHRcdFx0XHRcdFx0ZmxpcCA/IGMyIDogYzEsIGZsaXAgPyBjMSA6IGMyLFxuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsXG5cdFx0XHRcdFx0XHRcdDAsIDAsIDAsIDEsIDAsIDEpO1xuXHRcdFx0XHRpZiAoIXN0cmFpZ2h0IHx8IGxvY2F0aW9ucy5sZW5ndGggPT09IGJlZm9yZSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdDEgPSBpID4+IDEsXG5cdFx0XHRcdFx0XHRcdHQyID0gaSAmIDEsXG5cdFx0XHRcdFx0XHRcdGkxID0gdDEgKiA2LFxuXHRcdFx0XHRcdFx0XHRpMiA9IHQyICogNixcblx0XHRcdFx0XHRcdFx0cDEgPSBuZXcgUG9pbnQodjFbaTFdLCB2MVtpMSArIDFdKSxcblx0XHRcdFx0XHRcdFx0cDIgPSBuZXcgUG9pbnQodjJbaTJdLCB2MltpMiArIDFdKTtcblx0XHRcdFx0XHRcdGlmIChwMS5pc0Nsb3NlKHAyLCBlcHNpbG9uKSkge1xuXHRcdFx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMSwgdDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMiwgdDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBpbmZvID0gQ3VydmUuY2xhc3NpZnkodjEpO1xuXHRcdGlmIChpbmZvLnR5cGUgPT09ICdsb29wJykge1xuXHRcdFx0dmFyIHJvb3RzID0gaW5mby5yb290cztcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjMSwgcm9vdHNbMF0sXG5cdFx0XHRcdFx0YzEsIHJvb3RzWzFdKTtcblx0XHR9XG5cdCAgcmV0dXJuIGxvY2F0aW9ucztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoY3VydmVzMSwgY3VydmVzMiwgaW5jbHVkZSwgbWF0cml4MSwgbWF0cml4Mixcblx0XHRcdF9yZXR1cm5GaXJzdCkge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtNyxcblx0XHRcdHNlbGYgPSAhY3VydmVzMjtcblx0XHRpZiAoc2VsZilcblx0XHRcdGN1cnZlczIgPSBjdXJ2ZXMxO1xuXHRcdHZhciBsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gY3VydmVzMi5sZW5ndGgsXG5cdFx0XHR2YWx1ZXMxID0gbmV3IEFycmF5KGxlbmd0aDEpLFxuXHRcdFx0dmFsdWVzMiA9IHNlbGYgPyB2YWx1ZXMxIDogbmV3IEFycmF5KGxlbmd0aDIpLFxuXHRcdFx0bG9jYXRpb25zID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuXHRcdFx0dmFsdWVzMVtpXSA9IGN1cnZlczFbaV0uZ2V0VmFsdWVzKG1hdHJpeDEpO1xuXHRcdH1cblx0XHRpZiAoIXNlbGYpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG5cdFx0XHRcdHZhbHVlczJbaV0gPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcyhtYXRyaXgyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGJvdW5kc0NvbGxpc2lvbnMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEN1cnZlQm91bmRzQ29sbGlzaW9ucyhcblx0XHRcdFx0dmFsdWVzMSwgdmFsdWVzMiwgZXBzaWxvbik7XG5cdFx0Zm9yICh2YXIgaW5kZXgxID0gMDsgaW5kZXgxIDwgbGVuZ3RoMTsgaW5kZXgxKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2luZGV4MV0sXG5cdFx0XHRcdHYxID0gdmFsdWVzMVtpbmRleDFdO1xuXHRcdFx0aWYgKHNlbGYpIHtcblx0XHRcdFx0Z2V0U2VsZkludGVyc2VjdGlvbih2MSwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNvbGxpc2lvbnMxID0gYm91bmRzQ29sbGlzaW9uc1tpbmRleDFdO1xuXHRcdFx0aWYgKGNvbGxpc2lvbnMxKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgY29sbGlzaW9uczEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRpZiAoX3JldHVybkZpcnN0ICYmIGxvY2F0aW9ucy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0XHRcdHZhciBpbmRleDIgPSBjb2xsaXNpb25zMVtqXTtcblx0XHRcdFx0XHRpZiAoIXNlbGYgfHwgaW5kZXgyID4gaW5kZXgxKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VydmUyID0gY3VydmVzMltpbmRleDJdLFxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlczJbaW5kZXgyXTtcblx0XHRcdFx0XHRcdGdldEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0XHR2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0T3ZlcmxhcHModjEsIHYyKSB7XG5cblx0XHRmdW5jdGlvbiBnZXRTcXVhcmVkTGluZUxlbmd0aCh2KSB7XG5cdFx0XHR2YXIgeCA9IHZbNl0gLSB2WzBdLFxuXHRcdFx0XHR5ID0gdls3XSAtIHZbMV07XG5cdFx0XHRyZXR1cm4geCAqIHggKyB5ICogeTtcblx0XHR9XG5cblx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRnZXREaXN0YW5jZSA9IExpbmUuZ2V0RGlzdGFuY2UsXG5cdFx0XHR0aW1lRXBzaWxvbiA9IDFlLTgsXG5cdFx0XHRnZW9tRXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuXHRcdFx0c3RyYWlnaHRCb3RoID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0Mixcblx0XHRcdGZsaXAgPSBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MSkgPCBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MiksXG5cdFx0XHRsMSA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0bDIgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdHB4ID0gbDFbMF0sIHB5ID0gbDFbMV0sXG5cdFx0XHR2eCA9IGwxWzZdIC0gcHgsIHZ5ID0gbDFbN10gLSBweTtcblx0XHRpZiAoZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzBdLCBsMlsxXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzZdLCBsMls3XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuXHRcdFx0aWYgKCFzdHJhaWdodEJvdGggJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwxWzJdLCBsMVszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbNF0sIGwxWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRcdGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMlsyXSwgbDJbM10sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzRdLCBsMls1XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuXHRcdFx0XHRzdHJhaWdodDEgPSBzdHJhaWdodDIgPSBzdHJhaWdodEJvdGggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc3RyYWlnaHRCb3RoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHN0cmFpZ2h0MSBeIHN0cmFpZ2h0Mikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHYgPSBbdjEsIHYyXSxcblx0XHRcdHBhaXJzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHBhaXJzLmxlbmd0aCA8IDI7IGkrKykge1xuXHRcdFx0dmFyIGkxID0gaSAmIDEsXG5cdFx0XHRcdGkyID0gaTEgXiAxLFxuXHRcdFx0XHR0MSA9IGkgPj4gMSxcblx0XHRcdFx0dDIgPSBDdXJ2ZS5nZXRUaW1lT2YodltpMV0sIG5ldyBQb2ludChcblx0XHRcdFx0XHR2W2kyXVt0MSA/IDYgOiAwXSxcblx0XHRcdFx0XHR2W2kyXVt0MSA/IDcgOiAxXSkpO1xuXHRcdFx0aWYgKHQyICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIHBhaXIgPSBpMSA/IFt0MSwgdDJdIDogW3QyLCB0MV07XG5cdFx0XHRcdGlmICghcGFpcnMubGVuZ3RoIHx8XG5cdFx0XHRcdFx0YWJzKHBhaXJbMF0gLSBwYWlyc1swXVswXSkgPiB0aW1lRXBzaWxvbiAmJlxuXHRcdFx0XHRcdGFicyhwYWlyWzFdIC0gcGFpcnNbMF1bMV0pID4gdGltZUVwc2lsb24pIHtcblx0XHRcdFx0XHRwYWlycy5wdXNoKHBhaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaSA+IDIgJiYgIXBhaXJzLmxlbmd0aClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChwYWlycy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHBhaXJzID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKCFzdHJhaWdodEJvdGgpIHtcblx0XHRcdHZhciBvMSA9IEN1cnZlLmdldFBhcnQodjEsIHBhaXJzWzBdWzBdLCBwYWlyc1sxXVswXSksXG5cdFx0XHRcdG8yID0gQ3VydmUuZ2V0UGFydCh2MiwgcGFpcnNbMF1bMV0sIHBhaXJzWzFdWzFdKTtcblx0XHRcdGlmIChhYnMobzJbMl0gLSBvMVsyXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbM10gLSBvMVszXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbNF0gLSBvMVs0XSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbNV0gLSBvMVs1XSkgPiBnZW9tRXBzaWxvbilcblx0XHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFpcnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUaW1lc1dpdGhUYW5nZW50KHYsIHRhbmdlbnQpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRub3JtYWxpemVkID0gdGFuZ2VudC5ub3JtYWxpemUoKSxcblx0XHRcdHR4ID0gbm9ybWFsaXplZC54LFxuXHRcdFx0dHkgPSBub3JtYWxpemVkLnksXG5cdFx0XHRheCA9IDMgKiB4MyAtIDkgKiB4MiArIDkgKiB4MSAtIDMgKiB4MCxcblx0XHRcdGF5ID0gMyAqIHkzIC0gOSAqIHkyICsgOSAqIHkxIC0gMyAqIHkwLFxuXHRcdFx0YnggPSA2ICogeDIgLSAxMiAqIHgxICsgNiAqIHgwLFxuXHRcdFx0YnkgPSA2ICogeTIgLSAxMiAqIHkxICsgNiAqIHkwLFxuXHRcdFx0Y3ggPSAzICogeDEgLSAzICogeDAsXG5cdFx0XHRjeSA9IDMgKiB5MSAtIDMgKiB5MCxcblx0XHRcdGRlbiA9IDIgKiBheCAqIHR5IC0gMiAqIGF5ICogdHgsXG5cdFx0XHR0aW1lcyA9IFtdO1xuXHRcdGlmIChNYXRoLmFicyhkZW4pIDwgTnVtZXJpY2FsLkNVUlZFVElNRV9FUFNJTE9OKSB7XG5cdFx0XHR2YXIgbnVtID0gYXggKiBjeSAtIGF5ICogY3gsXG5cdFx0XHRcdGRlbiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXHRcdFx0aWYgKGRlbiAhPSAwKSB7XG5cdFx0XHRcdHZhciB0ID0gLW51bSAvIGRlbjtcblx0XHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHRpbWVzLnB1c2godCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkZWx0YSA9IChieCAqIGJ4IC0gNCAqIGF4ICogY3gpICogdHkgKiB0eSArXG5cdFx0XHRcdCgtMiAqIGJ4ICogYnkgKyA0ICogYXkgKiBjeCArIDQgKiBheCAqIGN5KSAqIHR4ICogdHkgK1xuXHRcdFx0XHQoYnkgKiBieSAtIDQgKiBheSAqIGN5KSAqIHR4ICogdHgsXG5cdFx0XHRcdGsgPSBieCAqIHR5IC0gYnkgKiB0eDtcblx0XHRcdGlmIChkZWx0YSA+PSAwICYmIGRlbiAhPSAwKSB7XG5cdFx0XHRcdHZhciBkID0gTWF0aC5zcXJ0KGRlbHRhKSxcblx0XHRcdFx0XHR0MCA9IC0oayArIGQpIC8gZGVuLFxuXHRcdFx0XHRcdHQxID0gKC1rICsgZCkgLyBkZW47XG5cdFx0XHRcdGlmICh0MCA+PSAwICYmIHQwIDw9IDEpIHRpbWVzLnB1c2godDApO1xuXHRcdFx0XHRpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB0aW1lcy5wdXNoKHQxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRpbWVzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdFx0dmFyIHYxID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0djIgPSBjdXJ2ZSAmJiBjdXJ2ZSAhPT0gdGhpcyAmJiBjdXJ2ZS5nZXRWYWx1ZXMoKTtcblx0XHRcdHJldHVybiB2MiA/IGdldEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIHRoaXMsIGN1cnZlLCBbXSlcblx0XHRcdFx0XHQgIDogZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgdGhpcywgW10pO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRnZXRPdmVybGFwczogZ2V0T3ZlcmxhcHMsXG5cdFx0XHRnZXRJbnRlcnNlY3Rpb25zOiBnZXRJbnRlcnNlY3Rpb25zLFxuXHRcdFx0Z2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9uczogZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyxcblx0XHRcdGdldFRpbWVzV2l0aFRhbmdlbnQ6IGdldFRpbWVzV2l0aFRhbmdlbnRcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHRpbWUsIHBvaW50LCBfb3ZlcmxhcCwgX2Rpc3RhbmNlKSB7XG5cdFx0aWYgKHRpbWUgPj0gMC45OTk5OTk5OSkge1xuXHRcdFx0dmFyIG5leHQgPSBjdXJ2ZS5nZXROZXh0KCk7XG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0Y3VydmUgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0dGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludCB8fCBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0aW1lKTtcblx0XHR0aGlzLl9vdmVybGFwID0gX292ZXJsYXA7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHRoaXMuX3BhdGggPSBwYXRoO1xuXHRcdHRoaXMuX3ZlcnNpb24gPSBwYXRoID8gcGF0aC5fdmVyc2lvbiA6IDA7XG5cdH0sXG5cblx0X3NldEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHRoaXMuX3NldFBhdGgoY3VydmUuX3BhdGgpO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudCA9IG51bGw7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdH0sXG5cblx0X3NldFNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHR2YXIgY3VydmUgPSBzZWdtZW50LmdldEN1cnZlKCk7XG5cdFx0aWYgKGN1cnZlKSB7XG5cdFx0XHR0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldFBhdGgoc2VnbWVudC5fcGF0aCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IHNlZ21lbnQ7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdHRoaXMuX3RpbWUgPSBzZWdtZW50ID09PSB0aGlzLl9zZWdtZW50MSA/IDAgOiAxO1xuXHRcdHRoaXMuX3BvaW50ID0gc2VnbWVudC5fcG9pbnQuY2xvbmUoKTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnQ7XG5cdFx0aWYgKCFzZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdGlmICh0aW1lID09PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPT09IDEpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAodGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHRpbWUsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmIChwYXRoICYmIHBhdGguX3ZlcnNpb24gIT09IHRoaXMuX3ZlcnNpb24pIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9vZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldCA9IHRoaXMuX2N1cnZlID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cnlTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQgJiYgc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKGN1cnZlICYmICh0aGF0Ll90aW1lID0gY3VydmUuZ2V0VGltZU9mKHRoYXQuX3BvaW50KSkgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGF0Ll9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fY3VydmVcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudClcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDEpXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkpO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcblx0fSxcblxuXHRnZXRUaW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGltZSA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhpcy5fcG9pbnQpXG5cdFx0XHQ6IHRpbWU7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiAnI2dldFRpbWUnLFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXHRcdGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCksXG5cdFx0XHRcdGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdFx0aWYgKHBhdGggJiYgaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY3VydmVzID0gcGF0aC5nZXRDdXJ2ZXMoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuXHRcdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKz0gdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fY3VydmVPZmZzZXQ7XG5cdFx0aWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdHRoaXMuX2N1cnZlT2Zmc2V0ID0gb2Zmc2V0ID0gdGltZSAhPSBudWxsICYmIGN1cnZlXG5cdFx0XHRcdFx0JiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0aW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXN0YW5jZTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHJlcyA9IGN1cnZlICYmIGN1cnZlLmRpdmlkZUF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0dGhpcy5fc2V0U2VnbWVudChyZXMuX3NlZ21lbnQxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGF0aCA9IGN1cnZlLl9wYXRoLFxuXHRcdFx0cmVzID0gY3VydmUgJiYgY3VydmUuc3BsaXRBdFRpbWUodGhpcy5nZXRUaW1lKCkpO1xuXHRcdGlmIChyZXMpIHtcblx0XHRcdHRoaXMuX3NldFNlZ21lbnQocGF0aC5nZXRMYXN0U2VnbWVudCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuICByZXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MsIF9pZ25vcmVPdGhlcikge1xuXHRcdHZhciByZXMgPSB0aGlzID09PSBsb2M7XG5cdFx0aWYgKCFyZXMgJiYgbG9jIGluc3RhbmNlb2YgQ3VydmVMb2NhdGlvbikge1xuXHRcdFx0dmFyIGMxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRjMiA9IGxvYy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwMSA9IGMxLl9wYXRoLFxuXHRcdFx0XHRwMiA9IGMyLl9wYXRoO1xuXHRcdFx0aWYgKHAxID09PSBwMikge1xuXHRcdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRcdFx0ZGlmZiA9IGFicyh0aGlzLmdldE9mZnNldCgpIC0gbG9jLmdldE9mZnNldCgpKSxcblx0XHRcdFx0XHRpMSA9ICFfaWdub3JlT3RoZXIgJiYgdGhpcy5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdGkyID0gIV9pZ25vcmVPdGhlciAmJiBsb2MuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0cmVzID0gKGRpZmYgPCBlcHNpbG9uXG5cdFx0XHRcdFx0XHR8fCBwMSAmJiBhYnMocDEuZ2V0TGVuZ3RoKCkgLSBkaWZmKSA8IGVwc2lsb24pXG5cdFx0XHRcdFx0JiYgKCFpMSAmJiAhaTIgfHwgaTEgJiYgaTIgJiYgaTEuZXF1YWxzKGkyLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG5cdFx0aWYgKHRpbWUgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3RpbWU6ICcgKyBmLm51bWJlcih0aW1lKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRpc1RvdWNoaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKGludGVyICYmIHRoaXMuZ2V0VGFuZ2VudCgpLmlzQ29sbGluZWFyKGludGVyLmdldFRhbmdlbnQoKSkpIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGN1cnZlMiA9IGludGVyLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gIShjdXJ2ZTEuaXNTdHJhaWdodCgpICYmIGN1cnZlMi5pc1N0cmFpZ2h0KClcblx0XHRcdFx0XHQmJiBjdXJ2ZTEuZ2V0TGluZSgpLmludGVyc2VjdChjdXJ2ZTIuZ2V0TGluZSgpKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0Nyb3NzaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgdDEgPSB0aGlzLmdldFRpbWUoKSxcblx0XHRcdHQyID0gaW50ZXIuZ2V0VGltZSgpLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHR0MUluc2lkZSA9IHQxID49IHRNaW4gJiYgdDEgPD0gdE1heCxcblx0XHRcdHQySW5zaWRlID0gdDIgPj0gdE1pbiAmJiB0MiA8PSB0TWF4O1xuXHRcdGlmICh0MUluc2lkZSAmJiB0Mkluc2lkZSlcblx0XHRcdHJldHVybiAhdGhpcy5pc1RvdWNoaW5nKCk7XG5cdFx0dmFyIGMyID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0YzEgPSBjMiAmJiB0MSA8IHRNaW4gPyBjMi5nZXRQcmV2aW91cygpIDogYzIsXG5cdFx0XHRjNCA9IGludGVyLmdldEN1cnZlKCksXG5cdFx0XHRjMyA9IGM0ICYmIHQyIDwgdE1pbiA/IGM0LmdldFByZXZpb3VzKCkgOiBjNDtcblx0XHRpZiAodDEgPiB0TWF4KVxuXHRcdFx0YzIgPSBjMi5nZXROZXh0KCk7XG5cdFx0aWYgKHQyID4gdE1heClcblx0XHRcdGM0ID0gYzQuZ2V0TmV4dCgpO1xuXHRcdGlmICghYzEgfHwgIWMyIHx8ICFjMyB8fCAhYzQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgb2Zmc2V0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkT2Zmc2V0cyhjdXJ2ZSwgZW5kKSB7XG5cdFx0XHR2YXIgdiA9IGN1cnZlLmdldFZhbHVlcygpLFxuXHRcdFx0XHRyb290cyA9IEN1cnZlLmNsYXNzaWZ5KHYpLnJvb3RzIHx8IEN1cnZlLmdldFBlYWtzKHYpLFxuXHRcdFx0XHRjb3VudCA9IHJvb3RzLmxlbmd0aCxcblx0XHRcdFx0b2Zmc2V0ID0gQ3VydmUuZ2V0TGVuZ3RoKHYsXG5cdFx0XHRcdFx0ZW5kICYmIGNvdW50ID8gcm9vdHNbY291bnQgLSAxXSA6IDAsXG5cdFx0XHRcdFx0IWVuZCAmJiBjb3VudCA/IHJvb3RzWzBdIDogMSk7XG5cdFx0XHRvZmZzZXRzLnB1c2goY291bnQgPyBvZmZzZXQgOiBvZmZzZXQgLyAzMik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNJblJhbmdlKGFuZ2xlLCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIG1pbiA8IG1heFxuXHRcdFx0XHRcdD8gYW5nbGUgPiBtaW4gJiYgYW5nbGUgPCBtYXhcblx0XHRcdFx0XHQ6IGFuZ2xlID4gbWluIHx8IGFuZ2xlIDwgbWF4O1xuXHRcdH1cblxuXHRcdGlmICghdDFJbnNpZGUpIHtcblx0XHRcdGFkZE9mZnNldHMoYzEsIHRydWUpO1xuXHRcdFx0YWRkT2Zmc2V0cyhjMiwgZmFsc2UpO1xuXHRcdH1cblx0XHRpZiAoIXQySW5zaWRlKSB7XG5cdFx0XHRhZGRPZmZzZXRzKGMzLCB0cnVlKTtcblx0XHRcdGFkZE9mZnNldHMoYzQsIGZhbHNlKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5nZXRQb2ludCgpLFxuXHRcdFx0b2Zmc2V0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0cyksXG5cdFx0XHR2MiA9IHQxSW5zaWRlID8gYzIuZ2V0VGFuZ2VudEF0VGltZSh0MSlcblx0XHRcdFx0XHQ6IGMyLmdldFBvaW50QXQob2Zmc2V0KS5zdWJ0cmFjdChwdCksXG5cdFx0XHR2MSA9IHQxSW5zaWRlID8gdjIubmVnYXRlKClcblx0XHRcdFx0XHQ6IGMxLmdldFBvaW50QXQoLW9mZnNldCkuc3VidHJhY3QocHQpLFxuXHRcdFx0djQgPSB0Mkluc2lkZSA/IGM0LmdldFRhbmdlbnRBdFRpbWUodDIpXG5cdFx0XHRcdFx0OiBjNC5nZXRQb2ludEF0KG9mZnNldCkuc3VidHJhY3QocHQpLFxuXHRcdFx0djMgPSB0Mkluc2lkZSA/IHY0Lm5lZ2F0ZSgpXG5cdFx0XHRcdFx0OiBjMy5nZXRQb2ludEF0KC1vZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdGExID0gdjEuZ2V0QW5nbGUoKSxcblx0XHRcdGEyID0gdjIuZ2V0QW5nbGUoKSxcblx0XHRcdGEzID0gdjMuZ2V0QW5nbGUoKSxcblx0XHRcdGE0ID0gdjQuZ2V0QW5nbGUoKTtcblx0XHRyZXR1cm4gISEodDFJbnNpZGVcblx0XHRcdFx0PyAoaXNJblJhbmdlKGExLCBhMywgYTQpIF4gaXNJblJhbmdlKGEyLCBhMywgYTQpKSAmJlxuXHRcdFx0XHQgIChpc0luUmFuZ2UoYTEsIGE0LCBhMykgXiBpc0luUmFuZ2UoYTIsIGE0LCBhMykpXG5cdFx0XHRcdDogKGlzSW5SYW5nZShhMywgYTEsIGEyKSBeIGlzSW5SYW5nZShhNCwgYTEsIGEyKSkgJiZcblx0XHRcdFx0ICAoaXNJblJhbmdlKGEzLCBhMiwgYTEpIF4gaXNJblJhbmdlKGE0LCBhMiwgYTEpKSk7XG5cdH0sXG5cblx0aGFzT3ZlcmxhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fb3ZlcmxhcDtcblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIGdldCA9IG5hbWUgKyAnQXQnO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0dGltZSA9IHRoaXMuZ2V0VGltZSgpO1xuXHRcdHJldHVybiB0aW1lICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XSh0aW1lLCB0cnVlKTtcblx0fTtcbn0sIHtcblx0cHJlc2VydmU6IHRydWVcbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGluc2VydChsb2NhdGlvbnMsIGxvYywgbWVyZ2UpIHtcblx0XHR2YXIgbGVuZ3RoID0gbG9jYXRpb25zLmxlbmd0aCxcblx0XHRcdGwgPSAwLFxuXHRcdFx0ciA9IGxlbmd0aCAtIDE7XG5cblx0XHRmdW5jdGlvbiBzZWFyY2goaW5kZXgsIGRpcikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgZGlyOyBpID49IC0xICYmIGkgPD0gbGVuZ3RoOyBpICs9IGRpcikge1xuXHRcdFx0XHR2YXIgbG9jMiA9IGxvY2F0aW9uc1soKGkgJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF07XG5cdFx0XHRcdGlmICghbG9jLmdldFBvaW50KCkuaXNDbG9zZShsb2MyLmdldFBvaW50KCksXG5cdFx0XHRcdFx0XHQxZS03KSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0aWYgKGxvYy5lcXVhbHMobG9jMikpXG5cdFx0XHRcdFx0cmV0dXJuIGxvYzI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR3aGlsZSAobCA8PSByKSB7XG5cdFx0XHR2YXIgbSA9IChsICsgcikgPj4+IDEsXG5cdFx0XHRcdGxvYzIgPSBsb2NhdGlvbnNbbV0sXG5cdFx0XHRcdGZvdW5kO1xuXHRcdFx0aWYgKG1lcmdlICYmIChmb3VuZCA9IGxvYy5lcXVhbHMobG9jMikgPyBsb2MyXG5cdFx0XHRcdFx0OiAoc2VhcmNoKG0sIC0xKSB8fCBzZWFyY2gobSwgMSkpKSkge1xuXHRcdFx0XHRpZiAobG9jLl9vdmVybGFwKSB7XG5cdFx0XHRcdFx0Zm91bmQuX292ZXJsYXAgPSBmb3VuZC5faW50ZXJzZWN0aW9uLl9vdmVybGFwID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0XHR9XG5cdFx0dmFyIHBhdGgxID0gbG9jLmdldFBhdGgoKSxcblx0XHRcdHBhdGgyID0gbG9jMi5nZXRQYXRoKCksXG5cdFx0XHRkaWZmID0gcGF0aDEgIT09IHBhdGgyXG5cdFx0XHRcdD8gcGF0aDEuX2lkIC0gcGF0aDIuX2lkXG5cdFx0XHRcdDogKGxvYy5nZXRJbmRleCgpICsgbG9jLmdldFRpbWUoKSlcblx0XHRcdFx0LSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRUaW1lKCkpO1xuXHRcdFx0aWYgKGRpZmYgPCAwKSB7XG5cdFx0XHRcdHIgPSBtIC0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGwgPSBtICsgMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9jYXRpb25zLnNwbGljZShsLCAwLCBsb2MpO1xuXHRcdHJldHVybiBsb2M7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0aW5zZXJ0OiBpbnNlcnQsXG5cblx0XHRleHBhbmQ6IGZ1bmN0aW9uKGxvY2F0aW9ucykge1xuXHRcdFx0dmFyIGV4cGFuZGVkID0gbG9jYXRpb25zLnNsaWNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGluc2VydChleHBhbmRlZCwgbG9jYXRpb25zW2ldLl9pbnRlcnNlY3Rpb24sIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH19O1xufSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXHRfc2VsZWN0Qm91bmRzOiBmYWxzZSxcblx0X2NhblNjYWxlU3Ryb2tlOiB0cnVlLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoSXRlbSgpIHtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihhcmcpIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRzZWdtZW50cyxcblx0XHRcdFx0Y29tcG91bmQ7XG5cdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBhcmcuc2VnbWVudHM7XG5cdFx0XHRcdGRhdGEgPSBhcmcucGF0aERhdGE7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IGFyZztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZGF0YSA9IGFyZztcblx0XHRcdH1cblx0XHRcdGlmIChzZWdtZW50cykge1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRcdFx0Y29tcG91bmQgPSBmaXJzdCAmJiBBcnJheS5pc0FycmF5KGZpcnN0WzBdKTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSkge1xuXHRcdFx0XHRjb21wb3VuZCA9IChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMVxuXHRcdFx0XHRcdFx0fHwgL3pcXHMqXFxTKy9pLnRlc3QoZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3RvciA9IGNvbXBvdW5kID8gQ29tcG91bmRQYXRoIDogUGF0aDtcblx0XHRcdHJldHVybiBuZXcgY3RvcihhcmcpO1xuXHRcdH1cblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFyZWEoKSA+PSAwO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEgJiYgZGF0YS5tYXRjaCgvW21saHZjc3F0YXpdW15tbGh2Y3NxdGF6XSovaWcpLFxuXHRcdFx0Y29vcmRzLFxuXHRcdFx0cmVsYXRpdmUgPSBmYWxzZSxcblx0XHRcdHByZXZpb3VzLFxuXHRcdFx0Y29udHJvbCxcblx0XHRcdGN1cnJlbnQgPSBuZXcgUG9pbnQoKSxcblx0XHRcdHN0YXJ0ID0gbmV3IFBvaW50KCk7XG5cblx0XHRmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcblx0XHRcdHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcblx0XHRcdGlmIChyZWxhdGl2ZSlcblx0XHRcdFx0dmFsICs9IGN1cnJlbnRbY29vcmRdO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQb2ludChpbmRleCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXgsICd4JyksXG5cdFx0XHRcdGdldENvb3JkKGluZGV4ICsgMSwgJ3knKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzICYmIHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRbMF0sXG5cdFx0XHRcdGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG5cdFx0XHRyZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuXHRcdFx0aWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSlcblx0XHRcdFx0dGhpcy5tb3ZlVG8oY3VycmVudCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcblx0XHRcdFx0XHR0aGlzW21vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRcdGlmIChtb3ZlKSB7XG5cdFx0XHRcdFx0XHRzdGFydCA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRtb3ZlID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRyb2wgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LmNsb25lKCk7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcblx0XHRcdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGogKyAyKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyA0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHQvW2NzXS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gKC9bcXRdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNykge1xuXHRcdFx0XHRcdHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSxcblx0XHRcdFx0XHRcdFx0bmV3IFNpemUoK2Nvb3Jkc1tqXSwgK2Nvb3Jkc1tqICsgMV0pLFxuXHRcdFx0XHRcdFx0XHQrY29vcmRzW2ogKyAyXSwgK2Nvb3Jkc1tqICsgNF0sICtjb29yZHNbaiArIDNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHR0aGlzLmNsb3NlUGF0aCgxZS0xMik7XG5cdFx0XHRcdGN1cnJlbnQgPSBzdGFydDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHdpbmRpbmcgPSBwb2ludC5pc0luc2lkZShcblx0XHRcdFx0dGhpcy5nZXRCb3VuZHMoeyBpbnRlcm5hbDogdHJ1ZSwgaGFuZGxlOiB0cnVlIH0pKVxuXHRcdFx0XHRcdD8gdGhpcy5fZ2V0V2luZGluZyhwb2ludClcblx0XHRcdFx0XHQ6IHt9O1xuXHRcdHJldHVybiB3aW5kaW5nLm9uUGF0aCB8fCAhISh0aGlzLmdldEZpbGxSdWxlKCkgPT09ICdldmVub2RkJ1xuXHRcdFx0XHQ/IHdpbmRpbmcud2luZGluZ0wgJiAxIHx8IHdpbmRpbmcud2luZGluZ1IgJiAxXG5cdFx0XHRcdDogd2luZGluZy53aW5kaW5nKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwYXRoLCBpbmNsdWRlLCBfbWF0cml4LCBfcmV0dXJuRmlyc3QpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMgPT09IHBhdGggfHwgIXBhdGgsXG5cdFx0XHRtYXRyaXgxID0gdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRtYXRyaXgyID0gc2VsZiA/IG1hdHJpeDFcblx0XHRcdFx0OiAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLl9vck51bGxJZklkZW50aXR5KCk7XG5cdFx0cmV0dXJuIHNlbGYgfHwgdGhpcy5nZXRCb3VuZHMobWF0cml4MSkuaW50ZXJzZWN0cyhcblx0XHRcdFx0cGF0aC5nZXRCb3VuZHMobWF0cml4MiksIDFlLTEyKVxuXHRcdFx0XHQ/IEN1cnZlLmdldEludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHR0aGlzLmdldEN1cnZlcygpLCAhc2VsZiAmJiBwYXRoLmdldEN1cnZlcygpLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0bWF0cml4MSwgbWF0cml4MiwgX3JldHVybkZpcnN0KVxuXHRcdFx0XHQ6IFtdO1xuXHR9LFxuXG5cdGdldENyb3NzaW5nczogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbnMocGF0aCwgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdHJldHVybiBpbnRlci5pc0Nyb3NzaW5nKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluTG9jID0gbnVsbDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuXHRcdFx0XHRtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcblx0XHRcdFx0bWluTG9jID0gbG9jO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluTG9jO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuXHR9LFxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG5cdFx0dmFyIGlzUGF0aCA9ICF0aGlzLl9jaGlsZHJlbixcblx0XHRcdG5hbWUgPSBpc1BhdGggPyAnX3NlZ21lbnRzJyA6ICdfY2hpbGRyZW4nLFxuXHRcdFx0aXRlbXNGcm9tID0gZnJvbVtuYW1lXSxcblx0XHRcdGl0ZW1zVG8gPSB0b1tuYW1lXSxcblx0XHRcdGl0ZW1zID0gdGhpc1tuYW1lXTtcblx0XHRpZiAoIWl0ZW1zRnJvbSB8fCAhaXRlbXNUbyB8fCBpdGVtc0Zyb20ubGVuZ3RoICE9PSBpdGVtc1RvLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhbmRzIGluIGludGVycG9sYXRlKCkgY2FsbDogJyArXG5cdFx0XHRcdFx0ZnJvbSArICcsICcgKyB0byk7XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50ID0gaXRlbXMubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoID0gaXRlbXNUby5sZW5ndGg7XG5cdFx0aWYgKGN1cnJlbnQgPCBsZW5ndGgpIHtcblx0XHRcdHZhciBjdG9yID0gaXNQYXRoID8gU2VnbWVudCA6IFBhdGg7XG5cdFx0XHRmb3IgKHZhciBpID0gY3VycmVudDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYWRkKG5ldyBjdG9yKCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY3VycmVudCA+IGxlbmd0aCkge1xuXHRcdFx0dGhpc1tpc1BhdGggPyAncmVtb3ZlU2VnbWVudHMnIDogJ3JlbW92ZUNoaWxkcmVuJ10obGVuZ3RoLCBjdXJyZW50KTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0aXRlbXNbaV0uaW50ZXJwb2xhdGUoaXRlbXNGcm9tW2ldLCBpdGVtc1RvW2ldLCBmYWN0b3IpO1xuXHRcdH1cblx0XHRpZiAoaXNQYXRoKSB7XG5cdFx0XHR0aGlzLnNldENsb3NlZChmcm9tLl9jbG9zZWQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Y29tcGFyZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHZhciBvayA9IGZhbHNlO1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgcGF0aHMxID0gdGhpcy5fY2hpbGRyZW4gfHwgW3RoaXNdLFxuXHRcdFx0XHRwYXRoczIgPSBwYXRoLl9jaGlsZHJlbiA/IHBhdGguX2NoaWxkcmVuLnNsaWNlKCkgOiBbcGF0aF0sXG5cdFx0XHRcdGxlbmd0aDEgPSBwYXRoczEubGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGgyID0gcGF0aHMyLmxlbmd0aCxcblx0XHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRvayA9IHRydWU7XG5cdFx0XHR2YXIgYm91bmRzT3ZlcmxhcHMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEl0ZW1Cb3VuZHNDb2xsaXNpb25zKHBhdGhzMSwgcGF0aHMyLCBOdW1lcmljYWwuR0VPTUVUUklDX0VQU0lMT04pO1xuXHRcdFx0Zm9yICh2YXIgaTEgPSBsZW5ndGgxIC0gMTsgaTEgPj0gMCAmJiBvazsgaTEtLSkge1xuXHRcdFx0XHR2YXIgcGF0aDEgPSBwYXRoczFbaTFdO1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgcGF0aEJvdW5kc092ZXJsYXBzID0gYm91bmRzT3ZlcmxhcHNbaTFdO1xuXHRcdFx0XHRpZiAocGF0aEJvdW5kc092ZXJsYXBzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaTIgPSBwYXRoQm91bmRzT3ZlcmxhcHMubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAhb2s7IGkyLS0pIHtcblx0XHRcdFx0XHRcdGlmIChwYXRoMS5jb21wYXJlKHBhdGhzMltwYXRoQm91bmRzT3ZlcmxhcHNbaTJdXSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFtYXRjaGVkW3BhdGhCb3VuZHNPdmVybGFwc1tpMl1dKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hlZFtwYXRoQm91bmRzT3ZlcmxhcHNbaTJdXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvayA9IG9rICYmIGNvdW50ID09PSBsZW5ndGgyO1xuXHRcdH1cblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dGhpcy5fdmVyc2lvbiA9IDA7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRzZWdtZW50cyA9IEFycmF5LmlzQXJyYXkoYXJnKVxuXHRcdFx0PyB0eXBlb2YgYXJnWzBdID09PSAnb2JqZWN0J1xuXHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHQ6IGFyZ3Ncblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3Ncblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0U2VnbWVudHMoc291cmNlLl9zZWdtZW50cyk7XG5cdFx0dGhpcy5fY2xvc2VkID0gc291cmNlLl9jbG9zZWQ7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9hcmVhID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGZsYWdzICYgMzIpIHtcblx0XHRcdFx0dGhpcy5fdmVyc2lvbisrO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdCAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZsYWdzICYgNjQpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0cmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cztcblx0fSxcblxuXHRzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCksXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxhc3QgPSBzZWdtZW50c1tsZW5ndGggLSAxXTtcblx0XHRcdGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGxhc3QpO1xuXHRcdFx0XHRsZW5ndGgtLTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzLCAwLCB7fSwgbGVuZ3RoKSk7XG5cdFx0fVxuXHRcdGlmIChmdWxseVNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRpZiAoIWN1cnZlcykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcblx0XHRcdFx0XHRzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0cmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHRpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoNDEpO1xuXHRcdH1cblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0ZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSkge1xuXHRcdFx0XHRcdFx0dmFyIGR4ID0gY3VyWCAtIHByZXZYLFxuXHRcdFx0XHRcdFx0XHRkeSA9IGN1clkgLSBwcmV2WTtcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goXG5cdFx0XHRcdFx0XHRcdCAgZHggPT09IDAgPyAndicgKyBmLm51bWJlcihkeSlcblx0XHRcdFx0XHRcdFx0OiBkeSA9PT0gMCA/ICdoJyArIGYubnVtYmVyKGR4KVxuXHRcdFx0XHRcdFx0XHQ6ICdsJyArIGYucGFpcihkeCwgZHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCArICcgJyArIGYucGFpciggaW5YIC0gcHJldlgsICBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0ICsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdH1cblxuXHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1swXSwgdHJ1ZSk7XG5cdFx0XHRwYXJ0cy5wdXNoKCd6Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcnKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0QmFzZS5wdXNoKHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciB0b3RhbCA9IHRoaXMuX2NvdW50Q3VydmVzKCksXG5cdFx0XHRcdHN0YXJ0ID0gaW5kZXggPiAwICYmIGluZGV4ICsgYW1vdW50IC0gMSA9PT0gdG90YWwgPyBpbmRleCAtIDFcblx0XHRcdFx0XHQ6IGluZGV4LFxuXHRcdFx0XHRpbnNlcnQgPSBzdGFydCxcblx0XHRcdFx0ZW5kID0gTWF0aC5taW4oc3RhcnQgKyBhbW91bnQsIHRvdGFsKTtcblx0XHRcdGlmIChzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0Y3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtzdGFydCwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRpbnNlcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnQ7IGkgPCBlbmQ7IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKHN0YXJ0LCBlbmQpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDQxKTtcblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjdXJ2ZTtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgIXN0YXJ0ID8gc2VnbWVudHMubGVuZ3RoIC0gMVxuXHRcdFx0XHQ6IHN0YXJ0IC0gMV0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW3N0YXJ0XSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1tlbmRdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tlbmRdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIGFyZ3MubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3MpKVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJncykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbihpbmRleCwgc2VnbWVudDEgKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIGFyZ3MubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3MsIDEpLCBpbmRleClcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3MsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzKSwgaW5kZXgpO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50czogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdFx0ZW5kID0gQmFzZS5waWNrKGVuZCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gc3RhcnQgPiAwICYmIGVuZCA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBzdGFydCAtIDFcblx0XHRcdFx0XHQ6IHN0YXJ0LFxuXHRcdFx0XHRjdXJ2ZXMgPSBjdXJ2ZXMuc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdFx0Y3VydmVzW2ldLl9wYXRoID0gbnVsbDtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoNDEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHNlZ21lbnRzW2ldLmhhc0hhbmRsZXMoKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uY2xlYXJIYW5kbGVzKCk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmVhID0gdGhpcy5fYXJlYTtcblx0XHRpZiAoYXJlYSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXHRcdFx0YXJlYSA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgbGFzdCA9IGkgKyAxID09PSBsO1xuXHRcdFx0XHRhcmVhICs9IEN1cnZlLmdldEFyZWEoQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdFx0c2VnbWVudHNbaV0sIHNlZ21lbnRzW2xhc3QgPyAwIDogaSArIDFdLFxuXHRcdFx0XHRcdFx0bnVsbCwgbGFzdCAmJiAhY2xvc2VkKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hcmVhID0gYXJlYTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKSAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb25cblx0XHRcdFx0PT09IGxlbmd0aCAqIDc7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcblx0XHRpZiAoIShzZWxlY3Rpb24gJiAxKSlcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3Rpb24uYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGlvbik7XG5cdH0sXG5cblx0X3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0c2VsZWN0aW9uID0gc2VsZWN0ZWQgPyA3IDogMDtcblx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uICogbGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFNlbGVjdGlvbiwgbmV3U2VsZWN0aW9uKSB7XG5cdFx0c2VnbWVudC5fc2VsZWN0aW9uID0gbmV3U2VsZWN0aW9uO1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWdtZW50U2VsZWN0aW9uICs9IG5ld1NlbGVjdGlvbiAtIG9sZFNlbGVjdGlvbjtcblx0XHRpZiAoc2VsZWN0aW9uID4gMClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGl2aWRlQXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG5cdFx0XHRjdXJ2ZTtcblx0XHRyZXR1cm4gbG9jICYmIChjdXJ2ZSA9IGxvYy5nZXRDdXJ2ZSgpLmRpdmlkZUF0KGxvYy5nZXRDdXJ2ZU9mZnNldCgpKSlcblx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdHNwbGl0QXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG5cdFx0XHRpbmRleCA9IGxvYyAmJiBsb2MuaW5kZXgsXG5cdFx0XHR0aW1lID0gbG9jICYmIGxvYy50aW1lLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0aWYgKHRpbWUgPiB0TWF4KSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0dGltZSA9IDA7XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRpbWUgPj0gdE1pbikge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlQXRUaW1lKHRpbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuXHRcdFx0XHRwYXRoO1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb3NlZChmYWxzZSk7XG5cdFx0XHRcdHBhdGggPSB0aGlzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdHBhdGguX2FkZChzZWdzLCAwKTtcblx0XHRcdHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHRpbWUpIHtcblx0XHR2YXIgY3VydmUsXG5cdFx0XHRsb2NhdGlvbiA9IHRpbWUgPT09IHVuZGVmaW5lZCA/IGluZGV4XG5cdFx0XHRcdDogKGN1cnZlID0gdGhpcy5nZXRDdXJ2ZXMoKVtpbmRleF0pXG5cdFx0XHRcdFx0JiYgY3VydmUuZ2V0TG9jYXRpb25BdFRpbWUodGltZSk7XG5cdFx0cmV0dXJuIGxvY2F0aW9uICE9IG51bGwgPyB0aGlzLnNwbGl0QXQobG9jYXRpb24pIDogbnVsbDtcblx0fSxcblxuXHRqb2luOiBmdW5jdGlvbihwYXRoLCB0b2xlcmFuY2UpIHtcblx0XHR2YXIgZXBzaWxvbiA9IHRvbGVyYW5jZSB8fCAwO1xuXHRcdGlmIChwYXRoICYmIHBhdGggIT09IHRoaXMpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0XHRsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAoIWxhc3QyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5pc0Nsb3NlKGZpcnN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG5cdFx0XHRcdGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG5cdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmlzQ2xvc2UoZmlyc3QyLl9wb2ludCwgZXBzaWxvbikpXG5cdFx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRcdHRoaXMuX2FkZChbc2VnbWVudHNbMF1dKTtcblx0XHRcdHBhdGgucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRsYXN0ID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdGlmIChmaXJzdCAhPT0gbGFzdCAmJiBmaXJzdC5fcG9pbnQuaXNDbG9zZShsYXN0Ll9wb2ludCwgZXBzaWxvbikpIHtcblx0XHRcdGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcblx0XHRcdGxhc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRzaW1wbGlmeSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW1wbGlmeSxcblx0XHRcdHRvbGVyYW5jZSA9IHNpbXBsaWZ5ID8gMWUtNyA6IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0aWYgKCFjdXJ2ZS5oYXNIYW5kbGVzKCkgJiYgKCFjdXJ2ZS5oYXNMZW5ndGgodG9sZXJhbmNlKVxuXHRcdFx0XHRcdHx8IHNpbXBsaWZ5ICYmIGN1cnZlLmlzQ29sbGluZWFyKGN1cnZlLmdldE5leHQoKSkpKVxuXHRcdFx0XHRjdXJ2ZS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24oZmxhdG5lc3MpIHtcblx0XHR2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcywgZmxhdG5lc3MgfHwgMC4yNSwgMjU2LCB0cnVlKSxcblx0XHRcdHBhcnRzID0gZmxhdHRlbmVyLnBhcnRzLFxuXHRcdFx0bGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuXHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHBhcnRzW2ldLmN1cnZlLnNsaWNlKDAsIDIpKSk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocGFydHNbbGVuZ3RoIC0gMV0uY3VydmUuc2xpY2UoNikpKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0c2ltcGxpZnk6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdHZhciBzZWdtZW50cyA9IG5ldyBQYXRoRml0dGVyKHRoaXMpLmZpdCh0b2xlcmFuY2UgfHwgMi41KTtcblx0XHRpZiAoc2VnbWVudHMpXG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHRyZXR1cm4gISFzZWdtZW50cztcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRzID0gb3B0aW9ucyB8fCB7fSxcblx0XHRcdHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2FzeW1tZXRyaWMnLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblxuXHRcdGZ1bmN0aW9uIGdldEluZGV4KHZhbHVlLCBfZGVmYXVsdCkge1xuXHRcdFx0dmFyIGluZGV4ID0gdmFsdWUgJiYgdmFsdWUuaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHZhbHVlLnBhdGg7XG5cdFx0XHRcdGlmIChwYXRoICYmIHBhdGggIT09IHRoYXQpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHZhbHVlLl9jbGFzcyArICcgJyArIGluZGV4ICsgJyBvZiAnICsgcGF0aFxuXHRcdFx0XHRcdFx0XHQrICcgaXMgbm90IHBhcnQgb2YgJyArIHRoYXQpO1xuXHRcdFx0XHRpZiAoX2RlZmF1bHQgJiYgdmFsdWUgaW5zdGFuY2VvZiBDdXJ2ZSlcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5kZXggPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBfZGVmYXVsdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBNYXRoLm1pbihpbmRleCA8IDAgJiYgY2xvc2VkXG5cdFx0XHRcdFx0PyBpbmRleCAlIGxlbmd0aFxuXHRcdFx0XHRcdDogaW5kZXggPCAwID8gaW5kZXggKyBsZW5ndGggOiBpbmRleCwgbGVuZ3RoIC0gMSk7XG5cdFx0fVxuXG5cdFx0dmFyIGxvb3AgPSBjbG9zZWQgJiYgb3B0cy5mcm9tID09PSB1bmRlZmluZWQgJiYgb3B0cy50byA9PT0gdW5kZWZpbmVkLFxuXHRcdFx0ZnJvbSA9IGdldEluZGV4KG9wdHMuZnJvbSwgMCksXG5cdFx0XHR0byA9IGdldEluZGV4KG9wdHMudG8sIGxlbmd0aCAtIDEpO1xuXG5cdFx0aWYgKGZyb20gPiB0bykge1xuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmcm9tIC09IGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0bXAgPSBmcm9tO1xuXHRcdFx0XHRmcm9tID0gdG87XG5cdFx0XHRcdHRvID0gdG1wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoL14oPzphc3ltbWV0cmljfGNvbnRpbnVvdXMpJC8udGVzdCh0eXBlKSkge1xuXHRcdFx0dmFyIGFzeW1tZXRyaWMgPSB0eXBlID09PSAnYXN5bW1ldHJpYycsXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluLFxuXHRcdFx0XHRhbW91bnQgPSB0byAtIGZyb20gKyAxLFxuXHRcdFx0XHRuID0gYW1vdW50IC0gMSxcblx0XHRcdFx0cGFkZGluZyA9IGxvb3AgPyBtaW4oYW1vdW50LCA0KSA6IDEsXG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gcGFkZGluZyxcblx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gcGFkZGluZyxcblx0XHRcdFx0a25vdHMgPSBbXTtcblx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gbWluKDEsIGZyb20pO1xuXHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBtaW4oMSwgbGVuZ3RoIC0gdG8gLSAxKTtcblx0XHRcdH1cblx0XHRcdG4gKz0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG5cdFx0XHRpZiAobiA8PSAxKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IGZyb20gLSBwYWRkaW5nTGVmdDsgaSA8PSBuOyBpKyssIGorKykge1xuXHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzWyhqIDwgMCA/IGogKyBsZW5ndGggOiBqKSAlIGxlbmd0aF0uX3BvaW50O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgeCA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94LFxuXHRcdFx0XHR5ID0ga25vdHNbMF0uX3kgKyAyICoga25vdHNbMV0uX3ksXG5cdFx0XHRcdGYgPSAyLFxuXHRcdFx0XHRuXzEgPSBuIC0gMSxcblx0XHRcdFx0cnggPSBbeF0sXG5cdFx0XHRcdHJ5ID0gW3ldLFxuXHRcdFx0XHRyZiA9IFtmXSxcblx0XHRcdFx0cHggPSBbXSxcblx0XHRcdFx0cHkgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnRlcm5hbCA9IGkgPCBuXzEsXG5cdFx0XHRcdFx0YSA9IGludGVybmFsID8gMSA6IGFzeW1tZXRyaWMgPyAxIDogMixcblx0XHRcdFx0XHRiID0gaW50ZXJuYWwgPyA0IDogYXN5bW1ldHJpYyA/IDIgOiA3LFxuXHRcdFx0XHRcdHUgPSBpbnRlcm5hbCA/IDQgOiBhc3ltbWV0cmljID8gMyA6IDgsXG5cdFx0XHRcdFx0diA9IGludGVybmFsID8gMiA6IGFzeW1tZXRyaWMgPyAwIDogMSxcblx0XHRcdFx0XHRtID0gYSAvIGY7XG5cdFx0XHRcdGYgPSByZltpXSA9IGIgLSBtO1xuXHRcdFx0XHR4ID0gcnhbaV0gPSB1ICoga25vdHNbaV0uX3ggKyB2ICoga25vdHNbaSArIDFdLl94IC0gbSAqIHg7XG5cdFx0XHRcdHkgPSByeVtpXSA9IHUgKiBrbm90c1tpXS5feSArIHYgKiBrbm90c1tpICsgMV0uX3kgLSBtICogeTtcblx0XHRcdH1cblxuXHRcdFx0cHhbbl8xXSA9IHJ4W25fMV0gLyByZltuXzFdO1xuXHRcdFx0cHlbbl8xXSA9IHJ5W25fMV0gLyByZltuXzFdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRweFtpXSA9IChyeFtpXSAtIHB4W2kgKyAxXSkgLyByZltpXTtcblx0XHRcdFx0cHlbaV0gPSAocnlbaV0gLSBweVtpICsgMV0pIC8gcmZbaV07XG5cdFx0XHR9XG5cdFx0XHRweFtuXSA9ICgzICoga25vdHNbbl0uX3ggLSBweFtuXzFdKSAvIDI7XG5cdFx0XHRweVtuXSA9ICgzICoga25vdHNbbl0uX3kgLSBweVtuXzFdKSAvIDI7XG5cblx0XHRcdGZvciAodmFyIGkgPSBwYWRkaW5nTGVmdCwgbWF4ID0gbiAtIHBhZGRpbmdSaWdodCwgaiA9IGZyb207XG5cdFx0XHRcdFx0aSA8PSBtYXg7IGkrKywgaisrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaiA8IDAgPyBqICsgbGVuZ3RoIDogal0sXG5cdFx0XHRcdFx0cHQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdFx0XHRoeCA9IHB4W2ldIC0gcHQuX3gsXG5cdFx0XHRcdFx0aHkgPSBweVtpXSAtIHB0Ll95O1xuXHRcdFx0XHRpZiAobG9vcCB8fCBpIDwgbWF4KVxuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KGh4LCBoeSk7XG5cdFx0XHRcdGlmIChsb29wIHx8IGkgPiBwYWRkaW5nTGVmdClcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKC1oeCwgLWh5KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xuXHRcdFx0XHRzZWdtZW50c1tpIDwgMCA/IGkgKyBsZW5ndGggOiBpXS5zbW9vdGgob3B0cyxcblx0XHRcdFx0XHRcdCFsb29wICYmIGkgPT09IGZyb20sICFsb29wICYmIGkgPT09IHRvKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0dG9TaGFwZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdHNpemUsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHR0b3BDZW50ZXI7XG5cblx0XHRmdW5jdGlvbiBpc0NvbGxpbmVhcihpLCBqKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdHNlZzMgPSBzZWdtZW50c1tqXSxcblx0XHRcdFx0c2VnNCA9IHNlZzMuZ2V0TmV4dCgpO1xuXHRcdFx0cmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzMuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWc0Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc0NvbGxpbmVhcihcblx0XHRcdFx0XHRcdHNlZzQuX3BvaW50LnN1YnRyYWN0KHNlZzMuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcblx0XHRcdHZhciBzZWcyID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzEgPSBzZWcyLmdldFByZXZpb3VzKCksXG5cdFx0XHRcdHNlZzMgPSBzZWcyLmdldE5leHQoKTtcblx0XHRcdHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdFx0c2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0FyYyhpKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdGhhbmRsZTEgPSBzZWcxLl9oYW5kbGVPdXQsXG5cdFx0XHRcdGhhbmRsZTIgPSBzZWcyLl9oYW5kbGVJbixcblx0XHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0XHRpZiAoaGFuZGxlMS5pc09ydGhvZ29uYWwoaGFuZGxlMikpIHtcblx0XHRcdFx0dmFyIHB0MSA9IHNlZzEuX3BvaW50LFxuXHRcdFx0XHRcdHB0MiA9IHNlZzIuX3BvaW50LFxuXHRcdFx0XHRcdGNvcm5lciA9IG5ldyBMaW5lKHB0MSwgaGFuZGxlMSwgdHJ1ZSkuaW50ZXJzZWN0KFxuXHRcdFx0XHRcdFx0XHRuZXcgTGluZShwdDIsIGhhbmRsZTIsIHRydWUpLCB0cnVlKTtcblx0XHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MSkuZ2V0TGVuZ3RoKCkgLSBrYXBwYSlcblx0XHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MikuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNIYW5kbGVzKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQ29sbGluZWFyKDAsIDIpICYmIGlzQ29sbGluZWFyKDEsIDMpICYmIGlzT3J0aG9nb25hbCgxKSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCAzKSwgZ2V0RGlzdGFuY2UoMCwgMSkpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50LmFkZChzZWdtZW50c1syXS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gOCAmJiBpc0FyYygwKSAmJiBpc0FyYygyKSAmJiBpc0FyYyg0KVxuXHRcdFx0XHQmJiBpc0FyYyg2KSAmJiBpc0NvbGxpbmVhcigxLCA1KSAmJiBpc0NvbGxpbmVhcigzLCA3KSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuXHRcdFx0cmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSxcblx0XHRcdFx0XHRnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5DaXJjbGU7XG5cdFx0XHRcdHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuXHRcdFx0XHRyYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRzaGFwZSA9IG5ldyB0eXBlKHtcblx0XHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHRzaGFwZS5jb3B5QXR0cmlidXRlcyh0aGlzLCB0cnVlKTtcblx0XHRcdHNoYXBlLl9tYXRyaXgucHJlcGVuZCh0aGlzLl9tYXRyaXgpO1xuXHRcdFx0c2hhcGUucm90YXRlKHRvcENlbnRlci5zdWJ0cmFjdChjZW50ZXIpLmdldEFuZ2xlKCkgKyA5MCk7XG5cdFx0XHRpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KVxuXHRcdFx0XHRzaGFwZS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0dG9QYXRoOiAnI2Nsb25lJyxcblxuXHRjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBhdGgpIHtcblx0XHRpZiAoIXBhdGggfHwgcGF0aCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdHJldHVybiBjb21wYXJlLmJhc2UuY2FsbCh0aGlzLCBwYXRoKTtcblx0XHR2YXIgY3VydmVzMSA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRjdXJ2ZXMyID0gcGF0aC5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBjdXJ2ZXMyLmxlbmd0aDtcblx0XHRpZiAoIWxlbmd0aDEgfHwgIWxlbmd0aDIpIHtcblx0XHRcdHJldHVybiBsZW5ndGgxID09IGxlbmd0aDI7XG5cdFx0fVxuXHRcdHZhciB2MSA9IGN1cnZlczFbMF0uZ2V0VmFsdWVzKCksXG5cdFx0XHR2YWx1ZXMyID0gW10sXG5cdFx0XHRwb3MxID0gMCwgcG9zMixcblx0XHRcdGVuZDEgPSAwLCBlbmQyO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG5cdFx0XHR2YXIgdjIgPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcygpO1xuXHRcdFx0dmFsdWVzMi5wdXNoKHYyKTtcblx0XHRcdHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cdFx0XHRpZiAob3ZlcmxhcHMpIHtcblx0XHRcdFx0cG9zMiA9ICFpICYmIG92ZXJsYXBzWzBdWzBdID4gMCA/IGxlbmd0aDIgLSAxIDogaTtcblx0XHRcdFx0ZW5kMiA9IG92ZXJsYXBzWzBdWzFdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0ZXBzaWxvbiA9IDFlLTgsXG5cdFx0XHR2MiA9IHZhbHVlczJbcG9zMl0sXG5cdFx0XHRzdGFydDI7XG5cdFx0d2hpbGUgKHYxICYmIHYyKSB7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdHZhciB0MSA9IG92ZXJsYXBzWzBdWzBdO1xuXHRcdFx0XHRpZiAoYWJzKHQxIC0gZW5kMSkgPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0ZW5kMSA9IG92ZXJsYXBzWzFdWzBdO1xuXHRcdFx0XHRcdGlmIChlbmQxID09PSAxKSB7XG5cdFx0XHRcdFx0XHR2MSA9ICsrcG9zMSA8IGxlbmd0aDEgPyBjdXJ2ZXMxW3BvczFdLmdldFZhbHVlcygpIDogbnVsbDtcblx0XHRcdFx0XHRcdGVuZDEgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdDIgPSBvdmVybGFwc1swXVsxXTtcblx0XHRcdFx0XHRpZiAoYWJzKHQyIC0gZW5kMikgPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXN0YXJ0Milcblx0XHRcdFx0XHRcdFx0c3RhcnQyID0gW3BvczIsIHQyXTtcblx0XHRcdFx0XHRcdGVuZDIgPSBvdmVybGFwc1sxXVsxXTtcblx0XHRcdFx0XHRcdGlmIChlbmQyID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgrK3BvczIgPj0gbGVuZ3RoMilcblx0XHRcdFx0XHRcdFx0XHRwb3MyID0gMDtcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZXMyW3BvczJdIHx8IGN1cnZlczJbcG9zMl0uZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdFx0XHRcdGVuZDIgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF2MSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3RhcnQyWzBdID09PSBwb3MyICYmIHN0YXJ0MlsxXSA9PT0gZW5kMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcblx0XHRcdHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZVxuXHRcdFx0XHRcdD8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuXHRcdFx0XHRcdFx0PyAwIDogbnVsbDtcblx0XHRpZiAoc3Ryb2tlUmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuXHRcdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IHN0cm9rZVBhZGRpbmcuYWRkKFxuXHRcdFx0XHRcdFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpvaW4gPSBjYXAgPSAncm91bmQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcblx0XHRcdHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcblx0XHRcdGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG5cdFx0XHRcdGlmIChwdCAhPT0gYW5jaG9yKVxuXHRcdFx0XHRcdHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cdFx0XHRcdGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQ6IHNlZyxcblx0XHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuXHRcdFx0cmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG5cdFx0XHRcdCYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKVxuXHRcdFx0XHR8fCAoIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzKSAmJiAoXG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHxcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcblx0XHRcdGFyZWEuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuXHRcdFx0dmFyIGlzSm9pbiA9IGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcblx0XHRcdFx0XHQmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMTtcblx0XHRcdGlmICgoaXNKb2luID8gam9pbiA6IGNhcCkgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJlYSA9IG5ldyBQYXRoKHsgaW50ZXJuYWw6IHRydWUsIGNsb3NlZDogdHJ1ZSB9KTtcblx0XHRcdFx0aWYgKGlzSm9pbikge1xuXHRcdFx0XHRcdGlmICghc2VnbWVudC5pc1Ntb290aCgpKSB7XG5cdFx0XHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQgICBtaXRlckxpbWl0LCBudWxsLCBzdHJva2VNYXRyaXgsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCBzdHJva2VSYWRpdXMsIG51bGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeCwgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0dmFyIGxvYztcblx0XHRcdFx0XHRyZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcblx0XHRcdFx0XHRcdHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG5cdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuXHRcdFx0XHRcdHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspXG5cdFx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGlmIChzdHJva2VSYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0dmFyIHRpbWUgPSBsb2MuZ2V0VGltZSgpO1xuXHRcdFx0XHRpZiAodGltZSA9PT0gMCB8fCB0aW1lID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKVxuXHRcdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0XHRcdFx0PD0gbWl0ZXJMaW1pdCAqIHN0cm9rZVJhZGl1c1xuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHR8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogbG9jLmdldFBvaW50KClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBzdGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjdXJ2ZXMubGVuZ3RoID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5nZXRMZW5ndGgoKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvZmZzZXQgJiYgb2Zmc2V0LmdldFBhdGggJiYgb2Zmc2V0LmdldFBhdGgoKSA9PT0gdGhpcykge1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0c1dpdGhUYW5nZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAodGFuZ2VudC5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRzID0gW107XG5cdFx0dmFyIGN1cnZlU3RhcnQgPSAwO1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0dmFyIGN1cnZlVGltZXMgPSBjdXJ2ZS5nZXRUaW1lc1dpdGhUYW5nZW50KHRhbmdlbnQpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSBjdXJ2ZVRpbWVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gY3VydmVTdGFydCArIGN1cnZlLmdldE9mZnNldEF0VGltZShjdXJ2ZVRpbWVzW2pdKTtcblx0XHRcdFx0aWYgKG9mZnNldHMuaW5kZXhPZihvZmZzZXQpIDwgMCkge1xuXHRcdFx0XHRcdG9mZnNldHMucHVzaChvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdXJ2ZVN0YXJ0ICs9IGN1cnZlLmxlbmd0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldHM7XG5cdH1cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGRyYXdIYW5kbGVzKGN0eCwgc2VnbWVudHMsIG1hdHJpeCwgc2l6ZSkge1xuXHRcdGlmIChzaXplIDw9IDApIHJldHVybjtcblxuXHRcdHZhciBoYWxmID0gc2l6ZSAvIDIsXG5cdFx0XHRtaW5pU2l6ZSA9IHNpemUgLSAyLFxuXHRcdFx0bWluaUhhbGYgPSBoYWxmIC0gMSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHBYLCBwWTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlbGVjdGlvbiA9IHNlZ21lbnQuX3NlbGVjdGlvbjtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdHBYID0gY29vcmRzWzBdO1xuXHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc2VsZWN0aW9uICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzZWxlY3Rpb24gJiA0KVxuXHRcdFx0XHRkcmF3SGFuZGxlKDQpO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiwgcFkgLSBoYWxmLCBzaXplLCBzaXplKTtcblx0XHRcdGlmIChtaW5pU2l6ZSA+IDAgJiYgIShzZWxlY3Rpb24gJiAxKSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gbWluaUhhbGYsIHBZIC0gbWluaUhhbGYsIG1pbmlTaXplLCBtaW5pU2l6ZSk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG5cdFx0XHRcdHJldHVybiBkYXNoQXJyYXlbKChpICUgZGFzaExlbmd0aCkgKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIDAuMjUsIDMyLCBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBmbGF0dGVuZXIubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGZyb20gLT0gZ2V0T2Zmc2V0KGktLSkgKyBnZXRPZmZzZXQoaS0tKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRvID0gZnJvbSArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+IDAgfHwgdG8gPiAwKVxuXHRcdFx0XHRcdFx0XHRcdGZsYXR0ZW5lci5kcmF3UGFydChjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuXHRcdFx0XHRcdFx0XHRmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0ZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcblx0XHR9XG5cdH07XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcblx0XHRyZXR1cm4gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdHRoaXMucmVtb3ZlU2VnbWVudCgwKTtcblx0XHRcdGlmICghc2VnbWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtb3ZlQnkoKSBpcyB1bnN1cHBvcnRlZCBvbiBQYXRoIGl0ZW1zLicpO1xuXHRcdH0sXG5cblx0XHRsaW5lVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRoYW5kbGUxID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpO1xuXHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQoaGFuZGxlMS5zdWJ0cmFjdChjdXJyZW50Ll9wb2ludCkpO1xuXHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQodG8sIGhhbmRsZTIuc3VidHJhY3QodG8pKSBdKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0aGFuZGxlID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dCA9IEJhc2UucGljayhCYXNlLnJlYWQoYXJncyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcblx0XHRcdFx0ZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHRocm91Z2gsXG5cdFx0XHRcdHBlZWsgPSBCYXNlLnBlZWsoYXJncyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3MpIDw9IDIpIHtcblx0XHRcdFx0dGhyb3VnaCA9IHRvO1xuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJncyk7XG5cdFx0XHR9IGVsc2UgaWYgKCFmcm9tLmVxdWFscyh0bykpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmdzKSxcblx0XHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0XHRpZiAoaXNaZXJvKHJhZGl1cy53aWR0aCkgfHwgaXNaZXJvKHJhZGl1cy5oZWlnaHQpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmdzKSxcblx0XHRcdFx0XHRjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmdzKSxcblx0XHRcdFx0XHRsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0cnggPSBhYnMocmFkaXVzLndpZHRoKSxcblx0XHRcdFx0XHRyeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeCxcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeSxcblx0XHRcdFx0XHR4U3EgPSB4ICogeCxcblx0XHRcdFx0XHR5U3EgPSB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IHNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuXHRcdFx0XHRpZiAoZmFjdG9yID4gMSkge1xuXHRcdFx0XHRcdHJ4ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeSAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcng7XG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmFjdG9yID0gKHJ4U3EgKiByeVNxIC0gcnhTcSAqIHlTcSAtIHJ5U3EgKiB4U3EpIC9cblx0XHRcdFx0XHRcdChyeFNxICogeVNxICsgcnlTcSAqIHhTcSk7XG5cdFx0XHRcdGlmIChhYnMoZmFjdG9yKSA8IDFlLTEyKVxuXHRcdFx0XHRcdGZhY3RvciA9IDA7XG5cdFx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeClcblx0XHRcdFx0XHRcdC5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSkgKiBzcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlciwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBhYnMoZXh0ZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aHJvdWdoU2lkZSA9PT0gY2VudGVyU2lkZSkge1xuXHRcdFx0XHRcdGV4dGVudCArPSBleHRlbnQgPCAwID8gMzYwIDogLTM2MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV4dGVudCkge1xuXHRcdFx0XHR2YXIgZXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRcdFx0ZXh0ID0gYWJzKGV4dGVudCksXG5cdFx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbCgoZXh0IC0gZXBzaWxvbikgLyA5MCksXG5cdFx0XHRcdFx0aW5jID0gZXh0ZW50IC8gY291bnQsXG5cdFx0XHRcdFx0aGFsZiA9IGluYyAqIE1hdGguUEkgLyAzNjAsXG5cdFx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0XHRvdXQgPSBudWxsO1xuXHRcdFx0XHRcdGlmIChpIDwgY291bnQpIHtcblx0XHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0XHRwdCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yKTtcblx0XHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIF9pbiA9IHZlY3Rvci5yb3RhdGUoLTkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdFx0X2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpXG5cdFx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGxpbmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHR0aHJvdWdoID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJncyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1cnZlVG8oY3VycmVudC5hZGQodGhyb3VnaCksIGN1cnJlbnQuYWRkKHRvKSwgcGFyYW1ldGVyKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRoYW5kbGUxID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmdzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSxcblx0XHRcdFx0XHRjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3MpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJncyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0YXJjQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmdzKSksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhCYXNlLnBlZWsoYXJncyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmdzKSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHR0aGlzLmpvaW4odGhpcywgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH07XG59LCB7XG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIG1ldGhvZCA9IG9wdGlvbnMuaGFuZGxlXG5cdFx0XHRcdD8gJ2dldEhhbmRsZUJvdW5kcydcblx0XHRcdFx0OiBvcHRpb25zLnN0cm9rZVxuXHRcdFx0XHQ/ICdnZXRTdHJva2VCb3VuZHMnXG5cdFx0XHRcdDogJ2dldEJvdW5kcyc7XG5cdFx0cmV0dXJuIFBhdGhbbWV0aG9kXSh0aGlzLl9zZWdtZW50cywgdGhpcy5fY2xvc2VkLCB0aGlzLCBtYXRyaXgsIG9wdGlvbnMpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zLCBzdHJva2VQYWRkaW5nKSB7XG5cdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0aWYgKCFmaXJzdClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNikpLFxuXHRcdFx0bWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuXHRcdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaV0sXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpICsgNF0sXG5cdFx0XHRcdFx0Y29vcmRzW2kgKyAyXSxcblx0XHRcdFx0XHRjb29yZHNbaV0sXG5cdFx0XHRcdFx0aSwgc3Ryb2tlUGFkZGluZyA/IHN0cm9rZVBhZGRpbmdbaV0gOiAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRtcCA9IHByZXZDb29yZHM7XG5cdFx0XHRwcmV2Q29vcmRzID0gY29vcmRzO1xuXHRcdFx0Y29vcmRzID0gdG1wO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChjbG9zZWQpXG5cdFx0XHRwcm9jZXNzU2VnbWVudChmaXJzdCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRnZXRTdHJva2VCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBzdHlsZSA9IHBhdGguZ2V0U3R5bGUoKSxcblx0XHRcdHN0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0c3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpLFxuXHRcdFx0c3Ryb2tlTWF0cml4ID0gc3Ryb2tlICYmIHBhdGguX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHN0cm9rZSAmJiBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0Ym91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zLFxuXHRcdFx0XHRzdHJva2VQYWRkaW5nKTtcblx0XHRpZiAoIXN0cm9rZSlcblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0dmFyIHN0cm9rZVJhZGl1cyA9IHN0cm9rZVdpZHRoIC8gMixcblx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCksXG5cdFx0XHRqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShzdHJva2VQYWRkaW5nKSk7XG5cblx0XHRmdW5jdGlvbiBhZGRQb2ludChwb2ludCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLmluY2x1ZGUocG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFJvdW5kKHNlZ21lbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy51bml0ZShcblx0XHRcdFx0XHRqb2luQm91bmRzLnNldENlbnRlcihzZWdtZW50Ll9wb2ludC50cmFuc2Zvcm0obWF0cml4KSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuXHRcdFx0aWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgc2VnbWVudC5pc1Ntb290aCgpKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHN0cm9rZVJhZGl1cywgbWl0ZXJMaW1pdCxcblx0XHRcdFx0XHRcdG1hdHJpeCwgc3Ryb2tlTWF0cml4LCBhZGRQb2ludCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkQ2FwKHNlZ21lbnQsIGNhcCkge1xuXHRcdFx0aWYgKGNhcCA9PT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhZGRSb3VuZChzZWdtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHN0cm9rZVJhZGl1cywgbWF0cml4LFxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LCBhZGRQb2ludCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSk7XG5cdFx0aWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YWRkSm9pbihzZWdtZW50c1tpXSwgam9pbik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0XHRhZGRDYXAoc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIGNhcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0X2dldFN0cm9rZVBhZGRpbmc6IGZ1bmN0aW9uKHJhZGl1cywgbWF0cml4KSB7XG5cdFx0aWYgKCFtYXRyaXgpXG5cdFx0XHRyZXR1cm4gW3JhZGl1cywgcmFkaXVzXTtcblx0XHR2YXIgaG9yID0gbmV3IFBvaW50KHJhZGl1cywgMCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHR2ZXIgPSBuZXcgUG9pbnQoMCwgcmFkaXVzKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHBoaSA9IGhvci5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YSA9IGhvci5nZXRMZW5ndGgoKSxcblx0XHRcdGIgPSB2ZXIuZ2V0TGVuZ3RoKCk7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKHBoaSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhwaGkpLFxuXHRcdFx0dGFuID0gTWF0aC50YW4ocGhpKSxcblx0XHRcdHR4ID0gTWF0aC5hdGFuMihiICogdGFuLCBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuMihiLCB0YW4gKiBhKTtcblx0XHRyZXR1cm4gW01hdGguYWJzKGEgKiBNYXRoLmNvcyh0eCkgKiBjb3MgKyBiICogTWF0aC5zaW4odHgpICogc2luKSxcblx0XHRcdFx0TWF0aC5hYnMoYiAqIE1hdGguc2luKHR5KSAqIGNvcyArIGEgKiBNYXRoLmNvcyh0eSkgKiBzaW4pXTtcblx0fSxcblxuXHRfYWRkQmV2ZWxKb2luOiBmdW5jdGlvbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIG1hdHJpeCxcblx0XHRcdHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQsIGlzQXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50MSgpLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdFRpbWUoMSkubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0XHQudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCksXG5cdFx0XHRub3JtYWwyID0gY3VydmUyLmdldE5vcm1hbEF0VGltZSgwKS5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHRcdC50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0YW5nbGUgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMik7XG5cdFx0aWYgKGFuZ2xlIDwgMCB8fCBhbmdsZSA+PSAxODApIHtcblx0XHRcdG5vcm1hbDEgPSBub3JtYWwxLm5lZ2F0ZSgpO1xuXHRcdFx0bm9ybWFsMiA9IG5vcm1hbDIubmVnYXRlKCk7XG5cdFx0fVxuXHRcdGlmIChpc0FyZWEpXG5cdFx0XHRhZGRQb2ludChwb2ludCk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRpZiAoam9pbiA9PT0gJ21pdGVyJykge1xuXHRcdFx0dmFyIGNvcm5lciA9IG5ldyBMaW5lKHBvaW50LmFkZChub3JtYWwxKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDEueSwgbm9ybWFsMS54KSwgdHJ1ZVxuXHRcdFx0XHQpLmludGVyc2VjdChuZXcgTGluZShwb2ludC5hZGQobm9ybWFsMiksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwyLnksIG5vcm1hbDIueCksIHRydWVcblx0XHRcdFx0KSwgdHJ1ZSk7XG5cdFx0XHRpZiAoY29ybmVyICYmIHBvaW50LmdldERpc3RhbmNlKGNvcm5lcikgPD0gbWl0ZXJMaW1pdCAqIHJhZGl1cykge1xuXHRcdFx0XHRhZGRQb2ludChjb3JuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBtYXRyaXgsIHN0cm9rZU1hdHJpeCxcblx0XHRcdGFkZFBvaW50LCBpc0FyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludC50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKVxuXHRcdFx0XHRcdC5tdWx0aXBseShsb2MuZ2V0VGltZSgpID09PSAwID8gcmFkaXVzIDogLXJhZGl1cylcblx0XHRcdFx0XHQudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCk7XG5cdFx0aWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcblx0XHRcdGlmIChpc0FyZWEpIHtcblx0XHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRcdH1cblx0XHRcdHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUoLTkwKSk7XG5cdFx0fVxuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBzdHlsZSA9IHBhdGguZ2V0U3R5bGUoKSxcblx0XHRcdHN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyxcblx0XHRcdGpvaW5QYWRkaW5nO1xuXHRcdGlmIChzdHJva2UpIHtcblx0XHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXRoLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSxcblx0XHRcdFx0c3Ryb2tlUmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXM7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguU1FSVDIpO1xuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0am9pblBhZGRpbmcgPSBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKGpvaW5SYWRpdXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0fVxuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHR4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG5cdFx0XHRcdHZhciBwYWRkaW5nID0gIWogPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKFtcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJncywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJncyk7XG5cdFx0fSxcblxuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdFx0fSxcblxuXHRcdFJvdW5kUmVjdGFuZ2xlOiAnI1JlY3RhbmdsZScsXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3MpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmdzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0ZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnZnJvbScpLFxuXHRcdFx0XHR0aHJvdWdoID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGgubW92ZVRvKGZyb20pO1xuXHRcdFx0cGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG5cdFx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHRcdH0sXG5cblx0XHRSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKSxcblx0XHRcdFx0c2lkZXMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gc2lkZXMsXG5cdFx0XHRcdHRocmVlID0gc2lkZXMgJSAzID09PSAwLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQoXG5cdFx0XHRcdFx0dmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuXHRcdH0sXG5cblx0XHRTdGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmdzLCAncG9pbnRzJykgKiAyLFxuXHRcdFx0XHRyYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1czEnKSxcblx0XHRcdFx0cmFkaXVzMiA9IEJhc2UucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG91bmRQYXRoKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIGl0ZW1zKSB7XG5cdFx0dmFyIGxpc3QgPSBpdGVtcyxcblx0XHRcdGZpcnN0ID0gbGlzdFswXTtcblx0XHRpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0WzBdID09PSAnbnVtYmVyJylcblx0XHRcdGxpc3QgPSBbbGlzdF07XG5cdFx0Zm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0XHRpZiAobGlzdCA9PT0gaXRlbXMgJiYgIShpdGVtIGluc3RhbmNlb2YgUGF0aCkpXG5cdFx0XHRcdGxpc3QgPSBCYXNlLnNsaWNlKGxpc3QpO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcblx0XHRcdFx0bGlzdFtpXSA9IG5ldyBQYXRoKHsgc2VnbWVudHM6IGl0ZW0sIGluc2VydDogZmFsc2UgfSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcblx0XHRcdFx0bGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgW2ksIDFdLmNvbmNhdChpdGVtLnJlbW92ZUNoaWxkcmVuKCkpKTtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGluc2VydENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgbGlzdCk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbiByZWR1Y2Uob3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHBhdGggPSBjaGlsZHJlbltpXS5yZWR1Y2Uob3B0aW9ucyk7XG5cdFx0XHRpZiAocGF0aC5pc0VtcHR5KCkpXG5cdFx0XHRcdHBhdGgucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVkdWNlLmJhc2UuY2FsbCh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICghY2hpbGRyZW5baV0uX2Nsb3NlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjaGlsZHJlbltpXS5zZXRDbG9zZWQoY2xvc2VkKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGN1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRCYXNlLnB1c2goY3VydmVzLCBjaGlsZHJlbltpXS5nZXRDdXJ2ZXMoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0YXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGNoaWxkcmVuW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGxlbmd0aCArPSBjaGlsZHJlbltpXS5nZXRMZW5ndGgoKTtcblx0XHRyZXR1cm4gbGVuZ3RoO1xuXHR9LFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRwYXRocyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0cGF0aHMucHVzaChjaGlsZC5nZXRQYXRoRGF0YShfbWF0cml4ICYmICFteC5pc0lkZW50aXR5KClcblx0XHRcdFx0XHQ/IF9tYXRyaXguYXBwZW5kZWQobXgpIDogX21hdHJpeCwgX3ByZWNpc2lvbikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHMuam9pbignJyk7XG5cdH0sXG5cblx0X2hpdFRlc3RDaGlsZHJlbjogZnVuY3Rpb24gX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuXHRcdHJldHVybiBfaGl0VGVzdENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBwb2ludCxcblx0XHRcdFx0b3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJyA/IG9wdGlvbnNcblx0XHRcdFx0XHQ6IEJhc2Uuc2V0KHt9LCBvcHRpb25zLCB7IGZpbGw6IGZhbHNlIH0pLFxuXHRcdFx0XHR2aWV3TWF0cml4KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKCFjaGlsZHJlbi5sZW5ndGgpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGRvbnRTdGFydDogdHJ1ZSwgZG9udEZpbmlzaDogdHJ1ZSB9KTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG5cblx0XHRpZiAoIXBhcmFtLmNsaXApIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzZWxlY3Rpb25JdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0aWYgKCFzZWxlY3Rpb25JdGVtc1tjaGlsZC5faWRdKSB7XG5cdFx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHRcdDogbWF0cml4LmFwcGVuZGVkKG14KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50UGF0aCh0aGF0LCBjaGVjaykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoYXQuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGVjayAmJiAhY2hpbGRyZW4ubGVuZ3RoKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJyxcblx0XHRcdCdhcmNUbycsICdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsXG5cdFx0XHQnYXJjQnknXSxcblx0XHRmdW5jdGlvbihrZXkpIHtcblx0XHRcdHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcGF0aCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpO1xuXHRcdFx0XHRwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcblx0XHRcdFx0XHRwYXRoID0gY3VycmVudCAmJiBjdXJyZW50LmlzRW1wdHkoKSA/IGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0OiBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdGlmIChwYXRoICE9PSBjdXJyZW50KVxuXHRcdFx0XHRcdHRoaXMuYWRkQ2hpbGQocGF0aCk7XG5cdFx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRcdGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdFx0XHRnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgodG9sZXJhbmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59LCBCYXNlLmVhY2goWydyZXZlcnNlJywgJ2ZsYXR0ZW4nLCAnc2ltcGxpZnknLCAnc21vb3RoJ10sIGZ1bmN0aW9uKGtleSkge1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbihwYXJhbSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cmVzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRyZXMgPSBjaGlsZHJlbltpXVtrZXldKHBhcmFtKSB8fCByZXM7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH07XG59LCB7fSkpO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0bWF4ID0gTWF0aC5tYXgsXG5cdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0b3BlcmF0b3JzID0ge1xuXHRcdFx0dW5pdGU6ICAgICB7ICcxJzogdHJ1ZSwgJzInOiB0cnVlIH0sXG5cdFx0XHRpbnRlcnNlY3Q6IHsgJzInOiB0cnVlIH0sXG5cdFx0XHRzdWJ0cmFjdDogIHsgJzEnOiB0cnVlIH0sXG5cdFx0XHRleGNsdWRlOiAgIHsgJzEnOiB0cnVlLCAnLTEnOiB0cnVlIH1cblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGdldFBhdGhzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5fY2hpbGRyZW4gfHwgW3BhdGhdO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCwgcmVzb2x2ZSkge1xuXHRcdHZhciByZXMgPSBwYXRoXG5cdFx0XHQuY2xvbmUoZmFsc2UpXG5cdFx0XHQucmVkdWNlKHsgc2ltcGxpZnk6IHRydWUgfSlcblx0XHRcdC50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHZhciBwYXRocyA9IGdldFBhdGhzKHJlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRpZiAoIXBhdGguX2Nsb3NlZCAmJiAhcGF0aC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0XHRwYXRoLmNsb3NlUGF0aCgxZS0xMik7XG5cdFx0XHRcdFx0cGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbigwLCAwKTtcblx0XHRcdFx0XHRwYXRoLmdldExhc3RTZWdtZW50KCkuc2V0SGFuZGxlT3V0KDAsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXMgPSByZXNcblx0XHRcdFx0LnJlc29sdmVDcm9zc2luZ3MoKVxuXHRcdFx0XHQucmVvcmllbnQocmVzLmdldEZpbGxSdWxlKCkgPT09ICdub256ZXJvJywgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVSZXN1bHQocGF0aHMsIHNpbXBsaWZ5LCBwYXRoMSwgcGF0aDIsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbXBvdW5kUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHBhdGhzLCB0cnVlKTtcblx0XHRyZXN1bHQgPSByZXN1bHQucmVkdWNlKHsgc2ltcGxpZnk6IHNpbXBsaWZ5IH0pO1xuXHRcdGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnQgPT0gZmFsc2UpKSB7XG5cdFx0XHRyZXN1bHQuaW5zZXJ0QWJvdmUocGF0aDIgJiYgcGF0aDEuaXNTaWJsaW5nKHBhdGgyKVxuXHRcdFx0XHRcdCYmIHBhdGgxLmdldEluZGV4KCkgPCBwYXRoMi5nZXRJbmRleCgpID8gcGF0aDIgOiBwYXRoMSk7XG5cdFx0fVxuXHRcdHJlc3VsdC5jb3B5QXR0cmlidXRlcyhwYXRoMSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbHRlckludGVyc2VjdGlvbihpbnRlcikge1xuXHRcdHJldHVybiBpbnRlci5oYXNPdmVybGFwKCkgfHwgaW50ZXIuaXNDcm9zc2luZygpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMudHJhY2UgPT0gZmFsc2UgfHwgb3B0aW9ucy5zdHJva2UpICYmXG5cdFx0XHRcdC9eKHN1YnRyYWN0fGludGVyc2VjdCkkLy50ZXN0KG9wZXJhdGlvbikpXG5cdFx0XHRyZXR1cm4gc3BsaXRCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKTtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEsIHRydWUpLFxuXHRcdFx0X3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyLCB0cnVlKSxcblx0XHRcdG9wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdGlvbl07XG5cdFx0b3BlcmF0b3Jbb3BlcmF0aW9uXSA9IHRydWU7XG5cdFx0aWYgKF9wYXRoMiAmJiAob3BlcmF0b3Iuc3VidHJhY3QgfHwgb3BlcmF0b3IuZXhjbHVkZSlcblx0XHRcdFx0XiAoX3BhdGgyLmlzQ2xvY2t3aXNlKCkgXiBfcGF0aDEuaXNDbG9ja3dpc2UoKSkpXG5cdFx0XHRfcGF0aDIucmV2ZXJzZSgpO1xuXHRcdHZhciBjcm9zc2luZ3MgPSBkaXZpZGVMb2NhdGlvbnMoQ3VydmVMb2NhdGlvbi5leHBhbmQoXG5cdFx0XHRcdF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZmlsdGVySW50ZXJzZWN0aW9uKSkpLFxuXHRcdFx0cGF0aHMxID0gZ2V0UGF0aHMoX3BhdGgxKSxcblx0XHRcdHBhdGhzMiA9IF9wYXRoMiAmJiBnZXRQYXRocyhfcGF0aDIpLFxuXHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdGN1cnZlcyA9IFtdLFxuXHRcdFx0cGF0aHM7XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0UGF0aHMocGF0aHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdEJhc2UucHVzaChzZWdtZW50cywgcGF0aC5fc2VnbWVudHMpO1xuXHRcdFx0XHRCYXNlLnB1c2goY3VydmVzLCBwYXRoLmdldEN1cnZlcygpKTtcblx0XHRcdFx0cGF0aC5fb3ZlcmxhcHNPbmx5ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDdXJ2ZXMoaW5kaWNlcykge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5kaWNlcyAmJiBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsaXN0LnB1c2goY3VydmVzW2luZGljZXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblxuXHRcdGlmIChjcm9zc2luZ3MubGVuZ3RoKSB7XG5cdFx0XHRjb2xsZWN0UGF0aHMocGF0aHMxKTtcblx0XHRcdGlmIChwYXRoczIpXG5cdFx0XHRcdGNvbGxlY3RQYXRocyhwYXRoczIpO1xuXG5cdFx0XHR2YXIgY3VydmVzVmFsdWVzID0gbmV3IEFycmF5KGN1cnZlcy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGN1cnZlc1ZhbHVlc1tpXSA9IGN1cnZlc1tpXS5nZXRWYWx1ZXMoKTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJ2ZUNvbGxpc2lvbnMgPSBDb2xsaXNpb25EZXRlY3Rpb24uZmluZEN1cnZlQm91bmRzQ29sbGlzaW9ucyhcblx0XHRcdFx0XHRjdXJ2ZXNWYWx1ZXMsIGN1cnZlc1ZhbHVlcywgMCwgdHJ1ZSk7XG5cdFx0XHR2YXIgY3VydmVDb2xsaXNpb25zTWFwID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aWQgPSBjdXJ2ZS5fcGF0aC5faWQsXG5cdFx0XHRcdFx0bWFwID0gY3VydmVDb2xsaXNpb25zTWFwW2lkXSA9IGN1cnZlQ29sbGlzaW9uc01hcFtpZF0gfHwge307XG5cdFx0XHRcdG1hcFtjdXJ2ZS5nZXRJbmRleCgpXSA9IHtcblx0XHRcdFx0XHRob3I6IGdldEN1cnZlcyhjdXJ2ZUNvbGxpc2lvbnNbaV0uaG9yKSxcblx0XHRcdFx0XHR2ZXI6IGdldEN1cnZlcyhjdXJ2ZUNvbGxpc2lvbnNbaV0udmVyKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNyb3NzaW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cHJvcGFnYXRlV2luZGluZyhjcm9zc2luZ3NbaV0uX3NlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLFxuXHRcdFx0XHRcdFx0Y3VydmVDb2xsaXNpb25zTWFwLCBvcGVyYXRvcik7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRpZiAoIXNlZ21lbnQuX3dpbmRpbmcpIHtcblx0XHRcdFx0XHRwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLFxuXHRcdFx0XHRcdFx0XHRjdXJ2ZUNvbGxpc2lvbnNNYXAsIG9wZXJhdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIShpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCkpXG5cdFx0XHRcdFx0c2VnbWVudC5fcGF0aC5fb3ZlcmxhcHNPbmx5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRwYXRocyA9IHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aHMgPSByZW9yaWVudFBhdGhzKFxuXHRcdFx0XHRcdHBhdGhzMiA/IHBhdGhzMS5jb25jYXQocGF0aHMyKSA6IHBhdGhzMS5zbGljZSgpLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0XHRcdHJldHVybiAhIW9wZXJhdG9yW3ddO1xuXHRcdFx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCB0cnVlLCBwYXRoMSwgcGF0aDIsIG9wdGlvbnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3BsaXRCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKSB7XG5cdFx0dmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxKSxcblx0XHRcdF9wYXRoMiA9IHByZXBhcmVQYXRoKHBhdGgyKSxcblx0XHRcdGNyb3NzaW5ncyA9IF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZmlsdGVySW50ZXJzZWN0aW9uKSxcblx0XHRcdHN1YnRyYWN0ID0gb3BlcmF0aW9uID09PSAnc3VidHJhY3QnLFxuXHRcdFx0ZGl2aWRlID0gb3BlcmF0aW9uID09PSAnZGl2aWRlJyxcblx0XHRcdGFkZGVkID0ge30sXG5cdFx0XHRwYXRocyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkUGF0aChwYXRoKSB7XG5cdFx0XHRpZiAoIWFkZGVkW3BhdGguX2lkXSAmJiAoZGl2aWRlIHx8XG5cdFx0XHRcdFx0X3BhdGgyLmNvbnRhaW5zKHBhdGguZ2V0UG9pbnRBdChwYXRoLmdldExlbmd0aCgpIC8gMikpXG5cdFx0XHRcdFx0XHReIHN1YnRyYWN0KSkge1xuXHRcdFx0XHRwYXRocy51bnNoaWZ0KHBhdGgpO1xuXHRcdFx0XHRyZXR1cm4gYWRkZWRbcGF0aC5faWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gY3Jvc3NpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcGF0aCA9IGNyb3NzaW5nc1tpXS5zcGxpdCgpO1xuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0aWYgKGFkZFBhdGgocGF0aCkpXG5cdFx0XHRcdFx0cGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbigwLCAwKTtcblx0XHRcdFx0X3BhdGgxLmdldExhc3RTZWdtZW50KCkuc2V0SGFuZGxlT3V0KDAsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhZGRQYXRoKF9wYXRoMSk7XG5cdFx0cmV0dXJuIGNyZWF0ZVJlc3VsdChwYXRocywgZmFsc2UsIHBhdGgxLCBwYXRoMik7XG5cdH1cblxuXHRmdW5jdGlvbiBsaW5rSW50ZXJzZWN0aW9ucyhmcm9tLCB0bykge1xuXHRcdHZhciBwcmV2ID0gZnJvbTtcblx0XHR3aGlsZSAocHJldikge1xuXHRcdFx0aWYgKHByZXYgPT09IHRvKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRwcmV2ID0gcHJldi5fcHJldmlvdXM7XG5cdFx0fVxuXHRcdHdoaWxlIChmcm9tLl9uZXh0ICYmIGZyb20uX25leHQgIT09IHRvKVxuXHRcdFx0ZnJvbSA9IGZyb20uX25leHQ7XG5cdFx0aWYgKCFmcm9tLl9uZXh0KSB7XG5cdFx0XHR3aGlsZSAodG8uX3ByZXZpb3VzKVxuXHRcdFx0XHR0byA9IHRvLl9wcmV2aW91cztcblx0XHRcdGZyb20uX25leHQgPSB0bztcblx0XHRcdHRvLl9wcmV2aW91cyA9IGZyb207XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xlYXJDdXJ2ZUhhbmRsZXMoY3VydmVzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdGN1cnZlc1tpXS5jbGVhckhhbmRsZXMoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlb3JpZW50UGF0aHMocGF0aHMsIGlzSW5zaWRlLCBjbG9ja3dpc2UpIHtcblx0XHR2YXIgbGVuZ3RoID0gcGF0aHMgJiYgcGF0aHMubGVuZ3RoO1xuXHRcdGlmIChsZW5ndGgpIHtcblx0XHRcdHZhciBsb29rdXAgPSBCYXNlLmVhY2gocGF0aHMsIGZ1bmN0aW9uIChwYXRoLCBpKSB7XG5cdFx0XHRcdFx0dGhpc1twYXRoLl9pZF0gPSB7XG5cdFx0XHRcdFx0XHRjb250YWluZXI6IG51bGwsXG5cdFx0XHRcdFx0XHR3aW5kaW5nOiBwYXRoLmlzQ2xvY2t3aXNlKCkgPyAxIDogLTEsXG5cdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sIHt9KSxcblx0XHRcdFx0c29ydGVkID0gcGF0aHMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFicyhiLmdldEFyZWEoKSkgLSBhYnMoYS5nZXRBcmVhKCkpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0Zmlyc3QgPSBzb3J0ZWRbMF07XG5cdFx0XHR2YXIgY29sbGlzaW9ucyA9IENvbGxpc2lvbkRldGVjdGlvbi5maW5kSXRlbUJvdW5kc0NvbGxpc2lvbnMoc29ydGVkLFxuXHRcdFx0XHRcdG51bGwsIE51bWVyaWNhbC5HRU9NRVRSSUNfRVBTSUxPTik7XG5cdFx0XHRpZiAoY2xvY2t3aXNlID09IG51bGwpXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IGZpcnN0LmlzQ2xvY2t3aXNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoMSA9IHNvcnRlZFtpXSxcblx0XHRcdFx0XHRlbnRyeTEgPSBsb29rdXBbcGF0aDEuX2lkXSxcblx0XHRcdFx0XHRjb250YWluZXJXaW5kaW5nID0gMCxcblx0XHRcdFx0XHRpbmRpY2VzID0gY29sbGlzaW9uc1tpXTtcblx0XHRcdFx0aWYgKGluZGljZXMpIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBudWxsO1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSBpbmRpY2VzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kaWNlc1tqXSA8IGkpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnQgPSBwb2ludCB8fCBwYXRoMS5nZXRJbnRlcmlvclBvaW50KCk7XG5cdFx0XHRcdFx0XHRcdHZhciBwYXRoMiA9IHNvcnRlZFtpbmRpY2VzW2pdXTtcblx0XHRcdFx0XHRcdFx0aWYgKHBhdGgyLmNvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlbnRyeTIgPSBsb29rdXBbcGF0aDIuX2lkXTtcblx0XHRcdFx0XHRcdFx0XHRjb250YWluZXJXaW5kaW5nID0gZW50cnkyLndpbmRpbmc7XG5cdFx0XHRcdFx0XHRcdFx0ZW50cnkxLndpbmRpbmcgKz0gY29udGFpbmVyV2luZGluZztcblx0XHRcdFx0XHRcdFx0XHRlbnRyeTEuY29udGFpbmVyID0gZW50cnkyLmV4Y2x1ZGVcblx0XHRcdFx0XHRcdFx0XHRcdD8gZW50cnkyLmNvbnRhaW5lciA6IHBhdGgyO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0luc2lkZShlbnRyeTEud2luZGluZykgPT09IGlzSW5zaWRlKGNvbnRhaW5lcldpbmRpbmcpKSB7XG5cdFx0XHRcdFx0ZW50cnkxLmV4Y2x1ZGUgPSB0cnVlO1xuXHRcdFx0XHRcdHBhdGhzW2VudHJ5MS5pbmRleF0gPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjb250YWluZXIgPSBlbnRyeTEuY29udGFpbmVyO1xuXHRcdFx0XHRcdHBhdGgxLnNldENsb2Nrd2lzZShcblx0XHRcdFx0XHRcdFx0Y29udGFpbmVyID8gIWNvbnRhaW5lci5pc0Nsb2Nrd2lzZSgpIDogY2xvY2t3aXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXZpZGVMb2NhdGlvbnMobG9jYXRpb25zLCBpbmNsdWRlLCBjbGVhckxhdGVyKSB7XG5cdFx0dmFyIHJlc3VsdHMgPSBpbmNsdWRlICYmIFtdLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRjbGVhckhhbmRsZXMgPSBmYWxzZSxcblx0XHRcdGNsZWFyQ3VydmVzID0gY2xlYXJMYXRlciB8fCBbXSxcblx0XHRcdGNsZWFyTG9va3VwID0gY2xlYXJMYXRlciAmJiB7fSxcblx0XHRcdHJlbm9ybWFsaXplTG9jcyxcblx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SWQoY3VydmUpIHtcblx0XHRcdHJldHVybiBjdXJ2ZS5fcGF0aC5faWQgKyAnLicgKyBjdXJ2ZS5fc2VnbWVudDEuX2luZGV4O1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAoY2xlYXJMYXRlciAmJiBjbGVhckxhdGVyLmxlbmd0aCkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY2xlYXJMYXRlcltpXTtcblx0XHRcdGlmIChjdXJ2ZS5fcGF0aClcblx0XHRcdFx0Y2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcblx0XHRcdFx0dGltZSA9IGxvYy5fdGltZSxcblx0XHRcdFx0b3JpZ1RpbWUgPSB0aW1lLFxuXHRcdFx0XHRleGNsdWRlID0gaW5jbHVkZSAmJiAhaW5jbHVkZShsb2MpLFxuXHRcdFx0XHRjdXJ2ZSA9IGxvYy5fY3VydmUsXG5cdFx0XHRcdHNlZ21lbnQ7XG5cdFx0XHRpZiAoY3VydmUpIHtcblx0XHRcdFx0aWYgKGN1cnZlICE9PSBwcmV2Q3VydmUpIHtcblx0XHRcdFx0XHRjbGVhckhhbmRsZXMgPSAhY3VydmUuaGFzSGFuZGxlcygpXG5cdFx0XHRcdFx0XHRcdHx8IGNsZWFyTG9va3VwICYmIGNsZWFyTG9va3VwW2dldElkKGN1cnZlKV07XG5cdFx0XHRcdFx0cmVub3JtYWxpemVMb2NzID0gW107XG5cdFx0XHRcdFx0cHJldlRpbWUgPSBudWxsO1xuXHRcdFx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZUaW1lID49IHRNaW4pIHtcblx0XHRcdFx0XHR0aW1lIC89IHByZXZUaW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhjbHVkZSkge1xuXHRcdFx0XHRpZiAocmVub3JtYWxpemVMb2NzKVxuXHRcdFx0XHRcdHJlbm9ybWFsaXplTG9jcy5wdXNoKGxvYyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpbmNsdWRlKSB7XG5cdFx0XHRcdHJlc3VsdHMudW5zaGlmdChsb2MpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlRpbWUgPSBvcmlnVGltZTtcblx0XHRcdGlmICh0aW1lIDwgdE1pbikge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lID4gdE1heCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5ld0N1cnZlID0gY3VydmUuZGl2aWRlQXRUaW1lKHRpbWUsIHRydWUpO1xuXHRcdFx0XHRpZiAoY2xlYXJIYW5kbGVzKVxuXHRcdFx0XHRcdGNsZWFyQ3VydmVzLnB1c2goY3VydmUsIG5ld0N1cnZlKTtcblx0XHRcdFx0c2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHJlbm9ybWFsaXplTG9jcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdHZhciBsID0gcmVub3JtYWxpemVMb2NzW2pdO1xuXHRcdFx0XHRcdGwuX3RpbWUgPSAobC5fdGltZSAtIHRpbWUpIC8gKDEgLSB0aW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bG9jLl9zZXRTZWdtZW50KHNlZ21lbnQpO1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRkZXN0ID0gbG9jLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMoaW50ZXIsIGRlc3QpO1xuXHRcdFx0XHR2YXIgb3RoZXIgPSBpbnRlcjtcblx0XHRcdFx0d2hpbGUgKG90aGVyKSB7XG5cdFx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMob3RoZXIuX2ludGVyc2VjdGlvbiwgaW50ZXIpO1xuXHRcdFx0XHRcdG90aGVyID0gb3RoZXIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGRlc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghY2xlYXJMYXRlcilcblx0XHRcdGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcblx0XHRyZXR1cm4gcmVzdWx0cyB8fCBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGRpciwgY2xvc2VkLCBkb250RmxpcCkge1xuXHRcdHZhciBjdXJ2ZXNMaXN0ID0gQXJyYXkuaXNBcnJheShjdXJ2ZXMpXG5cdFx0XHQ/IGN1cnZlc1xuXHRcdFx0OiBjdXJ2ZXNbZGlyID8gJ2hvcicgOiAndmVyJ107XG5cdFx0dmFyIGlhID0gZGlyID8gMSA6IDAsXG5cdFx0XHRpbyA9IGlhIF4gMSxcblx0XHRcdHB2ID0gW3BvaW50LngsIHBvaW50LnldLFxuXHRcdFx0cGEgPSBwdltpYV0sXG5cdFx0XHRwbyA9IHB2W2lvXSxcblx0XHRcdHdpbmRpbmdFcHNpbG9uID0gMWUtOSxcblx0XHRcdHF1YWxpdHlFcHNpbG9uID0gMWUtNixcblx0XHRcdHBhTCA9IHBhIC0gd2luZGluZ0Vwc2lsb24sXG5cdFx0XHRwYVIgPSBwYSArIHdpbmRpbmdFcHNpbG9uLFxuXHRcdFx0d2luZGluZ0wgPSAwLFxuXHRcdFx0d2luZGluZ1IgPSAwLFxuXHRcdFx0cGF0aFdpbmRpbmdMID0gMCxcblx0XHRcdHBhdGhXaW5kaW5nUiA9IDAsXG5cdFx0XHRvblBhdGggPSBmYWxzZSxcblx0XHRcdG9uQW55UGF0aCA9IGZhbHNlLFxuXHRcdFx0cXVhbGl0eSA9IDEsXG5cdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0dlByZXYsXG5cdFx0XHR2Q2xvc2U7XG5cblx0XHRmdW5jdGlvbiBhZGRXaW5kaW5nKHYpIHtcblx0XHRcdHZhciBvMCA9IHZbaW8gKyAwXSxcblx0XHRcdFx0bzMgPSB2W2lvICsgNl07XG5cdFx0XHRpZiAocG8gPCBtaW4obzAsIG8zKSB8fCBwbyA+IG1heChvMCwgbzMpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBhMCA9IHZbaWEgKyAwXSxcblx0XHRcdFx0YTEgPSB2W2lhICsgMl0sXG5cdFx0XHRcdGEyID0gdltpYSArIDRdLFxuXHRcdFx0XHRhMyA9IHZbaWEgKyA2XTtcblx0XHRcdGlmIChvMCA9PT0gbzMpIHtcblx0XHRcdFx0aWYgKGEwIDwgcGFSICYmIGEzID4gcGFMIHx8IGEzIDwgcGFSICYmIGEwID4gcGFMKSB7XG5cdFx0XHRcdFx0b25QYXRoID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdCA9ICAgcG8gPT09IG8wID8gMFxuXHRcdFx0XHRcdDogcG8gPT09IG8zID8gMVxuXHRcdFx0XHRcdDogcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpXG5cdFx0XHRcdFx0PyAxXG5cdFx0XHRcdFx0OiBDdXJ2ZS5zb2x2ZUN1YmljKHYsIGlvLCBwbywgcm9vdHMsIDAsIDEpID4gMFxuXHRcdFx0XHRcdFx0PyByb290c1swXVxuXHRcdFx0XHRcdFx0OiAxLFxuXHRcdFx0XHRhID0gICB0ID09PSAwID8gYTBcblx0XHRcdFx0XHQ6IHQgPT09IDEgPyBhM1xuXHRcdFx0XHRcdDogQ3VydmUuZ2V0UG9pbnQodiwgdClbZGlyID8gJ3knIDogJ3gnXSxcblx0XHRcdFx0d2luZGluZyA9IG8wID4gbzMgPyAxIDogLTEsXG5cdFx0XHRcdHdpbmRpbmdQcmV2ID0gdlByZXZbaW9dID4gdlByZXZbaW8gKyA2XSA/IDEgOiAtMSxcblx0XHRcdFx0YTNQcmV2ID0gdlByZXZbaWEgKyA2XTtcblx0XHRcdGlmIChwbyAhPT0gbzApIHtcblx0XHRcdFx0aWYgKGEgPCBwYUwpIHtcblx0XHRcdFx0XHRwYXRoV2luZGluZ0wgKz0gd2luZGluZztcblx0XHRcdFx0fSBlbHNlIGlmIChhID4gcGFSKSB7XG5cdFx0XHRcdFx0cGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b25QYXRoID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYSA+IHBhIC0gcXVhbGl0eUVwc2lsb24gJiYgYSA8IHBhICsgcXVhbGl0eUVwc2lsb24pXG5cdFx0XHRcdFx0cXVhbGl0eSAvPSAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHdpbmRpbmcgIT09IHdpbmRpbmdQcmV2KSB7XG5cdFx0XHRcdFx0aWYgKGEwIDwgcGFMKSB7XG5cdFx0XHRcdFx0XHRwYXRoV2luZGluZ0wgKz0gd2luZGluZztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGEwID4gcGFSKSB7XG5cdFx0XHRcdFx0XHRwYXRoV2luZGluZ1IgKz0gd2luZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYTAgIT0gYTNQcmV2KSB7XG5cdFx0XHRcdFx0aWYgKGEzUHJldiA8IHBhUiAmJiBhID4gcGFSKSB7XG5cdFx0XHRcdFx0XHRwYXRoV2luZGluZ1IgKz0gd2luZGluZztcblx0XHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhM1ByZXYgPiBwYUwgJiYgYSA8IHBhTCkge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRvblBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRxdWFsaXR5IC89IDQ7XG5cdFx0XHR9XG5cdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRyZXR1cm4gIWRvbnRGbGlwICYmIGEgPiBwYUwgJiYgYSA8IHBhUlxuXHRcdFx0XHRcdCYmIEN1cnZlLmdldFRhbmdlbnQodiwgdClbZGlyID8gJ3gnIDogJ3knXSA9PT0gMFxuXHRcdFx0XHRcdCYmIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgIWRpciwgY2xvc2VkLCB0cnVlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG5cdFx0XHR2YXIgbzAgPSB2W2lvICsgMF0sXG5cdFx0XHRcdG8xID0gdltpbyArIDJdLFxuXHRcdFx0XHRvMiA9IHZbaW8gKyA0XSxcblx0XHRcdFx0bzMgPSB2W2lvICsgNl07XG5cdFx0XHRpZiAocG8gPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSAmJiBwbyA+PSBtaW4obzAsIG8xLCBvMiwgbzMpKSB7XG5cdFx0XHRcdHZhciBhMCA9IHZbaWEgKyAwXSxcblx0XHRcdFx0XHRhMSA9IHZbaWEgKyAyXSxcblx0XHRcdFx0XHRhMiA9IHZbaWEgKyA0XSxcblx0XHRcdFx0XHRhMyA9IHZbaWEgKyA2XSxcblx0XHRcdFx0XHRtb25vQ3VydmVzID0gcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpXG5cdFx0XHRcdFx0XHRcdD8gW3ZdIDogQ3VydmUuZ2V0TW9ub0N1cnZlcyh2LCBkaXIpLFxuXHRcdFx0XHRcdHJlcztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtb25vQ3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChyZXMgPSBhZGRXaW5kaW5nKG1vbm9DdXJ2ZXNbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc0xpc3RbaV0sXG5cdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aCxcblx0XHRcdFx0diA9IGN1cnZlLmdldFZhbHVlcygpLFxuXHRcdFx0XHRyZXM7XG5cdFx0XHRpZiAoIWkgfHwgY3VydmVzTGlzdFtpIC0gMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0dlByZXYgPSBudWxsO1xuXHRcdFx0XHRpZiAoIXBhdGguX2Nsb3NlZCkge1xuXHRcdFx0XHRcdHZDbG9zZSA9IEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRcdFx0cGF0aC5nZXRMYXN0Q3VydmUoKS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdFx0XHRjdXJ2ZS5nZXRTZWdtZW50MSgpLFxuXHRcdFx0XHRcdFx0XHRudWxsLCAhY2xvc2VkKTtcblx0XHRcdFx0XHRpZiAodkNsb3NlW2lvXSAhPT0gdkNsb3NlW2lvICsgNl0pIHtcblx0XHRcdFx0XHRcdHZQcmV2ID0gdkNsb3NlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdlByZXYpIHtcblx0XHRcdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRcdFx0dmFyIHByZXYgPSBwYXRoLmdldExhc3RDdXJ2ZSgpO1xuXHRcdFx0XHRcdHdoaWxlIChwcmV2ICYmIHByZXYgIT09IGN1cnZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdjIgPSBwcmV2LmdldFZhbHVlcygpO1xuXHRcdFx0XHRcdFx0aWYgKHYyW2lvXSAhPT0gdjJbaW8gKyA2XSkge1xuXHRcdFx0XHRcdFx0XHR2UHJldiA9IHYyO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHByZXYgPSBwcmV2LmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXMgPSBoYW5kbGVDdXJ2ZSh2KSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0aWYgKGkgKyAxID09PSBsIHx8IGN1cnZlc0xpc3RbaSArIDFdLl9wYXRoICE9PSBwYXRoKSB7XG5cdFx0XHRcdGlmICh2Q2xvc2UgJiYgKHJlcyA9IGhhbmRsZUN1cnZlKHZDbG9zZSkpKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdGlmIChvblBhdGggJiYgIXBhdGhXaW5kaW5nTCAmJiAhcGF0aFdpbmRpbmdSKSB7XG5cdFx0XHRcdFx0cGF0aFdpbmRpbmdMID0gcGF0aFdpbmRpbmdSID0gcGF0aC5pc0Nsb2Nrd2lzZShjbG9zZWQpIF4gZGlyXG5cdFx0XHRcdFx0XHRcdD8gMSA6IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdpbmRpbmdMICs9IHBhdGhXaW5kaW5nTDtcblx0XHRcdFx0d2luZGluZ1IgKz0gcGF0aFdpbmRpbmdSO1xuXHRcdFx0XHRwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSAwO1xuXHRcdFx0XHRpZiAob25QYXRoKSB7XG5cdFx0XHRcdFx0b25BbnlQYXRoID0gdHJ1ZTtcblx0XHRcdFx0XHRvblBhdGggPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2Q2xvc2UgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aW5kaW5nTCA9IGFicyh3aW5kaW5nTCk7XG5cdFx0d2luZGluZ1IgPSBhYnMod2luZGluZ1IpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aW5kaW5nOiBtYXgod2luZGluZ0wsIHdpbmRpbmdSKSxcblx0XHRcdHdpbmRpbmdMOiB3aW5kaW5nTCxcblx0XHRcdHdpbmRpbmdSOiB3aW5kaW5nUixcblx0XHRcdHF1YWxpdHk6IHF1YWxpdHksXG5cdFx0XHRvblBhdGg6IG9uQW55UGF0aFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIHBhdGgxLCBwYXRoMiwgY3VydmVDb2xsaXNpb25zTWFwLFxuXHRcdFx0b3BlcmF0b3IpIHtcblx0XHR2YXIgY2hhaW4gPSBbXSxcblx0XHRcdHN0YXJ0ID0gc2VnbWVudCxcblx0XHRcdHRvdGFsTGVuZ3RoID0gMCxcblx0XHRcdHdpbmRpbmc7XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIGN1cnZlID0gc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKGN1cnZlKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0Y2hhaW4ucHVzaCh7IHNlZ21lbnQ6IHNlZ21lbnQsIGN1cnZlOiBjdXJ2ZSwgbGVuZ3RoOiBsZW5ndGggfSk7XG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHR9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnQpO1xuXHRcdHZhciBvZmZzZXRzID0gWzAuNSwgMC4yNSwgMC43NV0sXG5cdFx0XHR3aW5kaW5nID0geyB3aW5kaW5nOiAwLCBxdWFsaXR5OiAtMSB9LFxuXHRcdFx0dE1pbiA9IDFlLTMsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAmJiB3aW5kaW5nLnF1YWxpdHkgPCAwLjU7IGkrKykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogb2Zmc2V0c1tpXTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBsID0gY2hhaW4ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IGNoYWluW2pdLFxuXHRcdFx0XHRcdGN1cnZlTGVuZ3RoID0gZW50cnkubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnZlID0gZW50cnkuY3VydmUsXG5cdFx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBwYXRoLl9wYXJlbnQsXG5cdFx0XHRcdFx0XHRvcGVyYW5kID0gcGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogcGF0aCxcblx0XHRcdFx0XHRcdHQgPSBOdW1lcmljYWwuY2xhbXAoY3VydmUuZ2V0VGltZUF0KGxlbmd0aCksIHRNaW4sIHRNYXgpLFxuXHRcdFx0XHRcdFx0cHQgPSBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0KSxcblx0XHRcdFx0XHRcdGRpciA9IGFicyhjdXJ2ZS5nZXRUYW5nZW50QXRUaW1lKHQpLnkpIDwgTWF0aC5TUVJUMV8yO1xuXHRcdFx0XHRcdHZhciB3aW5kID0gbnVsbDtcblx0XHRcdFx0XHRpZiAob3BlcmF0b3Iuc3VidHJhY3QgJiYgcGF0aDIpIHtcblx0XHRcdFx0XHRcdHZhciBvdGhlclBhdGggPSBvcGVyYW5kID09PSBwYXRoMSA/IHBhdGgyIDogcGF0aDEsXG5cdFx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nID0gb3RoZXJQYXRoLl9nZXRXaW5kaW5nKHB0LCBkaXIsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKG9wZXJhbmQgPT09IHBhdGgxICYmIHBhdGhXaW5kaW5nLndpbmRpbmcgfHxcblx0XHRcdFx0XHRcdFx0b3BlcmFuZCA9PT0gcGF0aDIgJiYgIXBhdGhXaW5kaW5nLndpbmRpbmcpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHBhdGhXaW5kaW5nLnF1YWxpdHkgPCAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0d2luZCA9IHsgd2luZGluZzogMCwgcXVhbGl0eTogMSB9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdpbmQgPSAgd2luZCB8fCBnZXRXaW5kaW5nKFxuXHRcdFx0XHRcdFx0XHRwdCwgY3VydmVDb2xsaXNpb25zTWFwW3BhdGguX2lkXVtjdXJ2ZS5nZXRJbmRleCgpXSxcblx0XHRcdFx0XHRcdFx0ZGlyLCB0cnVlKTtcblx0XHRcdFx0XHRpZiAod2luZC5xdWFsaXR5ID4gd2luZGluZy5xdWFsaXR5KVxuXHRcdFx0XHRcdFx0d2luZGluZyA9IHdpbmQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBqID0gY2hhaW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdGNoYWluW2pdLnNlZ21lbnQuX3dpbmRpbmcgPSB3aW5kaW5nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSB7XG5cdFx0dmFyIHBhdGhzID0gW10sXG5cdFx0XHRzdGFydHM7XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkKHNlZykge1xuXHRcdFx0dmFyIHdpbmRpbmc7XG5cdFx0XHRyZXR1cm4gISEoc2VnICYmICFzZWcuX3Zpc2l0ZWQgJiYgKCFvcGVyYXRvclxuXHRcdFx0XHRcdHx8IG9wZXJhdG9yWyh3aW5kaW5nID0gc2VnLl93aW5kaW5nIHx8IHt9KS53aW5kaW5nXVxuXHRcdFx0XHRcdFx0JiYgIShvcGVyYXRvci51bml0ZSAmJiB3aW5kaW5nLndpbmRpbmcgPT09IDJcblx0XHRcdFx0XHRcdFx0JiYgd2luZGluZy53aW5kaW5nTCAmJiB3aW5kaW5nLndpbmRpbmdSKSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU3RhcnQoc2VnKSB7XG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzZWcgPT09IHN0YXJ0c1tpXSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdmlzaXRQYXRoKHBhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0c2VnbWVudHNbaV0uX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENyb3NzaW5nU2VnbWVudHMoc2VnbWVudCwgY29sbGVjdFN0YXJ0cykge1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRzdGFydCA9IGludGVyLFxuXHRcdFx0XHRjcm9zc2luZ3MgPSBbXTtcblx0XHRcdGlmIChjb2xsZWN0U3RhcnRzKVxuXHRcdFx0XHRzdGFydHMgPSBbc2VnbWVudF07XG5cblx0XHRcdGZ1bmN0aW9uIGNvbGxlY3QoaW50ZXIsIGVuZCkge1xuXHRcdFx0XHR3aGlsZSAoaW50ZXIgJiYgaW50ZXIgIT09IGVuZCkge1xuXHRcdFx0XHRcdHZhciBvdGhlciA9IGludGVyLl9zZWdtZW50LFxuXHRcdFx0XHRcdFx0cGF0aCA9IG90aGVyICYmIG90aGVyLl9wYXRoO1xuXHRcdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0XHR2YXIgbmV4dCA9IG90aGVyLmdldE5leHQoKSB8fCBwYXRoLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0XHRcdFx0XHRuZXh0SW50ZXIgPSBuZXh0Ll9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgIT09IHNlZ21lbnQgJiYgKGlzU3RhcnQob3RoZXIpXG5cdFx0XHRcdFx0XHRcdHx8IGlzU3RhcnQobmV4dClcblx0XHRcdFx0XHRcdFx0fHwgbmV4dCAmJiAoaXNWYWxpZChvdGhlcikgJiYgKGlzVmFsaWQobmV4dClcblx0XHRcdFx0XHRcdFx0XHR8fCBuZXh0SW50ZXIgJiYgaXNWYWxpZChuZXh0SW50ZXIuX3NlZ21lbnQpKSkpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y3Jvc3NpbmdzLnB1c2gob3RoZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGNvbGxlY3RTdGFydHMpXG5cdFx0XHRcdFx0XHRcdHN0YXJ0cy5wdXNoKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW50ZXIgPSBpbnRlci5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0Y29sbGVjdChpbnRlcik7XG5cdFx0XHRcdHdoaWxlIChpbnRlciAmJiBpbnRlci5fcHJldmlvdXMpXG5cdFx0XHRcdFx0aW50ZXIgPSBpbnRlci5fcHJldmlvdXM7XG5cdFx0XHRcdGNvbGxlY3QoaW50ZXIsIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcm9zc2luZ3M7XG5cdFx0fVxuXG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0XHR2YXIgaW50ZXIxID0gc2VnMS5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRpbnRlcjIgPSBzZWcyLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdG92ZXIxID0gISEoaW50ZXIxICYmIGludGVyMS5fb3ZlcmxhcCksXG5cdFx0XHRcdG92ZXIyID0gISEoaW50ZXIyICYmIGludGVyMi5fb3ZlcmxhcCksXG5cdFx0XHRcdHBhdGgxID0gc2VnMS5fcGF0aCxcblx0XHRcdFx0cGF0aDIgPSBzZWcyLl9wYXRoO1xuXHRcdFx0cmV0dXJuIG92ZXIxIF4gb3ZlcjJcblx0XHRcdFx0XHQ/IG92ZXIxID8gMSA6IC0xXG5cdFx0XHRcdFx0OiAhaW50ZXIxIF4gIWludGVyMlxuXHRcdFx0XHRcdFx0PyBpbnRlcjEgPyAxIDogLTFcblx0XHRcdFx0XHRcdDogcGF0aDEgIT09IHBhdGgyXG5cdFx0XHRcdFx0XHRcdD8gcGF0aDEuX2lkIC0gcGF0aDIuX2lkXG5cdFx0XHRcdFx0XHRcdDogc2VnMS5faW5kZXggLSBzZWcyLl9pbmRleDtcblx0XHR9KTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHZhbGlkID0gaXNWYWxpZChzZWcpLFxuXHRcdFx0XHRwYXRoID0gbnVsbCxcblx0XHRcdFx0ZmluaXNoZWQgPSBmYWxzZSxcblx0XHRcdFx0Y2xvc2VkID0gdHJ1ZSxcblx0XHRcdFx0YnJhbmNoZXMgPSBbXSxcblx0XHRcdFx0YnJhbmNoLFxuXHRcdFx0XHR2aXNpdGVkLFxuXHRcdFx0XHRoYW5kbGVJbjtcblx0XHRcdGlmICh2YWxpZCAmJiBzZWcuX3BhdGguX292ZXJsYXBzT25seSkge1xuXHRcdFx0XHR2YXIgcGF0aDEgPSBzZWcuX3BhdGgsXG5cdFx0XHRcdFx0cGF0aDIgPSBzZWcuX2ludGVyc2VjdGlvbi5fc2VnbWVudC5fcGF0aDtcblx0XHRcdFx0aWYgKHBhdGgxLmNvbXBhcmUocGF0aDIpKSB7XG5cdFx0XHRcdFx0aWYgKHBhdGgxLmdldEFyZWEoKSlcblx0XHRcdFx0XHRcdHBhdGhzLnB1c2gocGF0aDEuY2xvbmUoZmFsc2UpKTtcblx0XHRcdFx0XHR2aXNpdFBhdGgocGF0aDEpO1xuXHRcdFx0XHRcdHZpc2l0UGF0aChwYXRoMik7XG5cdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHZhbGlkKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9ICFwYXRoLFxuXHRcdFx0XHRcdGNyb3NzaW5ncyA9IGdldENyb3NzaW5nU2VnbWVudHMoc2VnLCBmaXJzdCksXG5cdFx0XHRcdFx0b3RoZXIgPSBjcm9zc2luZ3Muc2hpZnQoKSxcblx0XHRcdFx0XHRmaW5pc2hlZCA9ICFmaXJzdCAmJiAoaXNTdGFydChzZWcpIHx8IGlzU3RhcnQob3RoZXIpKSxcblx0XHRcdFx0XHRjcm9zcyA9ICFmaW5pc2hlZCAmJiBvdGhlcjtcblx0XHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0XHRicmFuY2ggPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaW5pc2hlZCkge1xuXHRcdFx0XHRcdGlmIChzZWcuaXNGaXJzdCgpIHx8IHNlZy5pc0xhc3QoKSlcblx0XHRcdFx0XHRcdGNsb3NlZCA9IHNlZy5fcGF0aC5fY2xvc2VkO1xuXHRcdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNyb3NzICYmIGJyYW5jaCkge1xuXHRcdFx0XHRcdGJyYW5jaGVzLnB1c2goYnJhbmNoKTtcblx0XHRcdFx0XHRicmFuY2ggPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYnJhbmNoKSB7XG5cdFx0XHRcdFx0aWYgKGNyb3NzKVxuXHRcdFx0XHRcdFx0Y3Jvc3NpbmdzLnB1c2goc2VnKTtcblx0XHRcdFx0XHRicmFuY2ggPSB7XG5cdFx0XHRcdFx0XHRzdGFydDogcGF0aC5fc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0Y3Jvc3NpbmdzOiBjcm9zc2luZ3MsXG5cdFx0XHRcdFx0XHR2aXNpdGVkOiB2aXNpdGVkID0gW10sXG5cdFx0XHRcdFx0XHRoYW5kbGVJbjogaGFuZGxlSW5cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjcm9zcylcblx0XHRcdFx0XHRzZWcgPSBvdGhlcjtcblx0XHRcdFx0aWYgKCFpc1ZhbGlkKHNlZykpIHtcblx0XHRcdFx0XHRwYXRoLnJlbW92ZVNlZ21lbnRzKGJyYW5jaC5zdGFydCk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGsgPSB2aXNpdGVkLmxlbmd0aDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtqXS5fdmlzaXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aXNpdGVkLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0c2VnID0gYnJhbmNoICYmIGJyYW5jaC5jcm9zc2luZ3Muc2hpZnQoKTtcblx0XHRcdFx0XHRcdGlmICghc2VnIHx8ICFzZWcuX3BhdGgpIHtcblx0XHRcdFx0XHRcdFx0c2VnID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnJhbmNoID0gYnJhbmNoZXMucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChicmFuY2gpIHtcblx0XHRcdFx0XHRcdFx0XHR2aXNpdGVkID0gYnJhbmNoLnZpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0aGFuZGxlSW4gPSBicmFuY2guaGFuZGxlSW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChicmFuY2ggJiYgIWlzVmFsaWQoc2VnKSk7XG5cdFx0XHRcdFx0aWYgKCFzZWcpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbmV4dCA9IHNlZy5nZXROZXh0KCk7XG5cdFx0XHRcdHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGhhbmRsZUluLFxuXHRcdFx0XHRcdFx0bmV4dCAmJiBzZWcuX2hhbmRsZU91dCkpO1xuXHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHR2aXNpdGVkLnB1c2goc2VnKTtcblx0XHRcdFx0c2VnID0gbmV4dCB8fCBzZWcuX3BhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGhhbmRsZUluID0gbmV4dCAmJiBuZXh0Ll9oYW5kbGVJbjtcblx0XHRcdH1cblx0XHRcdGlmIChmaW5pc2hlZCkge1xuXHRcdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdFx0cGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbihoYW5kbGVJbik7XG5cdFx0XHRcdFx0cGF0aC5zZXRDbG9zZWQoY2xvc2VkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGF0aC5nZXRBcmVhKCkgIT09IDApIHtcblx0XHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBkaXIsIGNsb3NlZCkge1xuXHRcdFx0cmV0dXJuIGdldFdpbmRpbmcocG9pbnQsIHRoaXMuZ2V0Q3VydmVzKCksIGRpciwgY2xvc2VkKTtcblx0XHR9LFxuXG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnaW50ZXJzZWN0Jywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdzdWJ0cmFjdCcsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgKG9wdGlvbnMudHJhY2UgPT0gZmFsc2UgfHwgb3B0aW9ucy5zdHJva2UpXG5cdFx0XHRcdFx0PyBzcGxpdEJvb2xlYW4odGhpcywgcGF0aCwgJ2RpdmlkZScpXG5cdFx0XHRcdFx0OiBjcmVhdGVSZXN1bHQoW1xuXHRcdFx0XHRcdFx0dGhpcy5zdWJ0cmFjdChwYXRoLCBvcHRpb25zKSxcblx0XHRcdFx0XHRcdHRoaXMuaW50ZXJzZWN0KHBhdGgsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XSwgdHJ1ZSwgdGhpcywgcGF0aCwgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdHJlc29sdmVDcm9zc2luZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRcdHBhdGhzID0gY2hpbGRyZW4gfHwgW3RoaXNdO1xuXG5cdFx0XHRmdW5jdGlvbiBoYXNPdmVybGFwKHNlZywgcGF0aCkge1xuXHRcdFx0XHR2YXIgaW50ZXIgPSBzZWcgJiYgc2VnLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdHJldHVybiBpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCAmJiBpbnRlci5fcGF0aCA9PT0gcGF0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhc092ZXJsYXBzID0gZmFsc2UsXG5cdFx0XHRcdGhhc0Nyb3NzaW5ncyA9IGZhbHNlLFxuXHRcdFx0XHRpbnRlcnNlY3Rpb25zID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKG51bGwsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVyLmhhc092ZXJsYXAoKSAmJiAoaGFzT3ZlcmxhcHMgPSB0cnVlKSB8fFxuXHRcdFx0XHRcdFx0XHRpbnRlci5pc0Nyb3NzaW5nKCkgJiYgKGhhc0Nyb3NzaW5ncyA9IHRydWUpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0Y2xlYXJDdXJ2ZXMgPSBoYXNPdmVybGFwcyAmJiBoYXNDcm9zc2luZ3MgJiYgW107XG5cdFx0XHRpbnRlcnNlY3Rpb25zID0gQ3VydmVMb2NhdGlvbi5leHBhbmQoaW50ZXJzZWN0aW9ucyk7XG5cdFx0XHRpZiAoaGFzT3ZlcmxhcHMpIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBzID0gZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVyLmhhc092ZXJsYXAoKTtcblx0XHRcdFx0fSwgY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHR2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldLFxuXHRcdFx0XHRcdFx0cGF0aCA9IG92ZXJsYXAuX3BhdGgsXG5cdFx0XHRcdFx0XHRzZWcgPSBvdmVybGFwLl9zZWdtZW50LFxuXHRcdFx0XHRcdFx0cHJldiA9IHNlZy5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0bmV4dCA9IHNlZy5nZXROZXh0KCk7XG5cdFx0XHRcdFx0aWYgKGhhc092ZXJsYXAocHJldiwgcGF0aCkgJiYgaGFzT3ZlcmxhcChuZXh0LCBwYXRoKSkge1xuXHRcdFx0XHRcdFx0c2VnLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0cHJldi5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cdFx0XHRcdFx0XHRuZXh0Ll9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYgIT09IHNlZyAmJiAhcHJldi5nZXRDdXJ2ZSgpLmhhc0xlbmd0aCgpKSB7XG5cdFx0XHRcdFx0XHRcdG5leHQuX2hhbmRsZUluLnNldChwcmV2Ll9oYW5kbGVJbik7XG5cdFx0XHRcdFx0XHRcdHByZXYucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzQ3Jvc3NpbmdzKSB7XG5cdFx0XHRcdGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zLCBoYXNPdmVybGFwcyAmJiBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRcdHZhciBjdXJ2ZTEgPSBpbnRlci5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdFx0c2VnMSA9IGludGVyLmdldFNlZ21lbnQoKSxcblx0XHRcdFx0XHRcdG90aGVyID0gaW50ZXIuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0XHRcdGN1cnZlMiA9IG90aGVyLl9jdXJ2ZSxcblx0XHRcdFx0XHRcdHNlZzIgPSBvdGhlci5fc2VnbWVudDtcblx0XHRcdFx0XHRpZiAoY3VydmUxICYmIGN1cnZlMiAmJiBjdXJ2ZTEuX3BhdGggJiYgY3VydmUyLl9wYXRoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0aWYgKHNlZzEpXG5cdFx0XHRcdFx0XHRzZWcxLl9pbnRlcnNlY3Rpb24gPSBudWxsO1xuXHRcdFx0XHRcdGlmIChzZWcyKVxuXHRcdFx0XHRcdFx0c2VnMi5faW50ZXJzZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0fSwgY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRpZiAoY2xlYXJDdXJ2ZXMpXG5cdFx0XHRcdFx0Y2xlYXJDdXJ2ZUhhbmRsZXMoY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRwYXRocyA9IHRyYWNlUGF0aHMoQmFzZS5lYWNoKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRcdFx0QmFzZS5wdXNoKHRoaXMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0fSwgW10pKTtcblx0XHRcdH1cblx0XHRcdHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG5cdFx0XHRcdGl0ZW07XG5cdFx0XHRpZiAobGVuZ3RoID4gMSAmJiBjaGlsZHJlbikge1xuXHRcdFx0XHRpZiAocGF0aHMgIT09IGNoaWxkcmVuKVxuXHRcdFx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4ocGF0aHMpO1xuXHRcdFx0XHRpdGVtID0gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoID09PSAxICYmICFjaGlsZHJlbikge1xuXHRcdFx0XHRpZiAocGF0aHNbMF0gIT09IHRoaXMpXG5cdFx0XHRcdFx0dGhpcy5zZXRTZWdtZW50cyhwYXRoc1swXS5yZW1vdmVTZWdtZW50cygpKTtcblx0XHRcdFx0aXRlbSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWl0ZW0pIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRpdGVtLmFkZENoaWxkcmVuKHBhdGhzKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVkdWNlKCk7XG5cdFx0XHRcdGl0ZW0uY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0XHRcdHRoaXMucmVwbGFjZVdpdGgoaXRlbSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9LFxuXG5cdFx0cmVvcmllbnQ6IGZ1bmN0aW9uKG5vblplcm8sIGNsb2Nrd2lzZSkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4ocmVvcmllbnRQYXRocyh0aGlzLnJlbW92ZUNoaWxkcmVuKCksXG5cdFx0XHRcdFx0XHRmdW5jdGlvbih3KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAhIShub25aZXJvID8gdyA6IHcgJiAxKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9ja3dpc2UoY2xvY2t3aXNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0XHRwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRcdHkgPSBwb2ludC55LFxuXHRcdFx0XHRcdGludGVyY2VwdHMgPSBbXSxcblx0XHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdiA9IGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0XHRcdG8wID0gdlsxXSxcblx0XHRcdFx0XHRcdG8xID0gdlszXSxcblx0XHRcdFx0XHRcdG8yID0gdls1XSxcblx0XHRcdFx0XHRcdG8zID0gdls3XTtcblx0XHRcdFx0XHRpZiAoeSA+PSBtaW4obzAsIG8xLCBvMiwgbzMpICYmIHkgPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSkge1xuXHRcdFx0XHRcdFx0dmFyIG1vbm9DdXJ2ZXMgPSBDdXJ2ZS5nZXRNb25vQ3VydmVzKHYpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSBtb25vQ3VydmVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbXYgPSBtb25vQ3VydmVzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdG1vMCA9IG12WzFdLFxuXHRcdFx0XHRcdFx0XHRcdG1vMyA9IG12WzddO1xuXHRcdFx0XHRcdFx0XHRpZiAoKG1vMCAhPT0gbW8zKSAmJlxuXHRcdFx0XHRcdFx0XHRcdCh5ID49IG1vMCAmJiB5IDw9IG1vMyB8fCB5ID49IG1vMyAmJiB5IDw9IG1vMCkpe1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4ID0geSA9PT0gbW8wID8gbXZbMF1cblx0XHRcdFx0XHRcdFx0XHRcdDogeSA9PT0gbW8zID8gbXZbNl1cblx0XHRcdFx0XHRcdFx0XHRcdDogQ3VydmUuc29sdmVDdWJpYyhtdiwgMSwgeSwgcm9vdHMsIDAsIDEpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdD09PSAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdD8gQ3VydmUuZ2V0UG9pbnQobXYsIHJvb3RzWzBdKS54XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDogKG12WzBdICsgbXZbNl0pIC8gMjtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcmNlcHRzLnB1c2goeCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGludGVyY2VwdHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGludGVyY2VwdHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cdFx0XHRcdFx0cG9pbnQueCA9IChpbnRlcmNlcHRzWzBdICsgaW50ZXJjZXB0c1sxXSkgLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBQYXRoRmxhdHRlbmVyID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoRmxhdHRlbmVyJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBmbGF0bmVzcywgbWF4UmVjdXJzaW9uLCBpZ25vcmVTdHJhaWdodCwgbWF0cml4KSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdGxlbmd0aCA9IDAsXG5cdFx0XHRtaW5TcGFuID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG5cdFx0XHRzZWdtZW50MjtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcblx0XHRcdGN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCB0MSwgdDIpIHtcblx0XHRcdGlmICgodDIgLSB0MSkgPiBtaW5TcGFuXG5cdFx0XHRcdFx0JiYgIShpZ25vcmVTdHJhaWdodCAmJiBDdXJ2ZS5pc1N0cmFpZ2h0KGN1cnZlKSlcblx0XHRcdFx0XHQmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCBmbGF0bmVzcyB8fCAwLjI1KSkge1xuXHRcdFx0XHR2YXIgaGFsdmVzID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlLCAwLjUpLFxuXHRcdFx0XHRcdHRNaWQgPSAodDEgKyB0MikgLyAyO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoaGFsdmVzWzBdLCBpbmRleCwgdDEsIHRNaWQpO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoaGFsdmVzWzFdLCBpbmRleCwgdE1pZCwgdDIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGR4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcblx0XHRcdFx0XHRkeSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHRcdGlmIChkaXN0ID4gMCkge1xuXHRcdFx0XHRcdGxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0b2Zmc2V0OiBsZW5ndGgsXG5cdFx0XHRcdFx0XHRjdXJ2ZTogY3VydmUsXG5cdFx0XHRcdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRcdFx0XHR0aW1lOiB0Mixcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50MiA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKTtcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudDI7XG5cdFx0fVxuXHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MiB8fCBzZWdtZW50MSwgc2VnbWVudHNbMF0pO1xuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRfZ2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLnBhcnRzLFxuXHRcdFx0bGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuXHRcdFx0c3RhcnQsXG5cdFx0XHRpLCBqID0gdGhpcy5pbmRleDtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpID0gajtcblx0XHRcdGlmICghaiB8fCBwYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHBhcnRzW2kgLSAxXSxcblx0XHRcdFx0XHRwcmV2VGltZSA9IHByZXYgJiYgcHJldi5pbmRleCA9PT0gcGFydC5pbmRleCA/IHByZXYudGltZSA6IDAsXG5cdFx0XHRcdFx0cHJldk9mZnNldCA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aW5kZXg6IHBhcnQuaW5kZXgsXG5cdFx0XHRcdFx0dGltZTogcHJldlRpbWUgKyAocGFydC50aW1lIC0gcHJldlRpbWUpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2T2Zmc2V0KSAvIChwYXJ0Lm9mZnNldCAtIHByZXZPZmZzZXQpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRpbmRleDogcGFydHNbbGVuZ3RoIC0gMV0uaW5kZXgsXG5cdFx0XHR0aW1lOiAxXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdHZhciBzdGFydCA9IHRoaXMuX2dldChmcm9tKSxcblx0XHRcdGVuZCA9IHRoaXMuX2dldCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0LmluZGV4LCBsID0gZW5kLmluZGV4OyBpIDw9IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09PSBzdGFydC5pbmRleCA/IHN0YXJ0LnRpbWUgOiAwLFxuXHRcdFx0XHRcdGkgPT09IGVuZC5pbmRleCA/IGVuZC50aW1lIDogMSk7XG5cdFx0XHRpZiAoaSA9PT0gc3RhcnQuaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5fZ2V0KG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS50aW1lKTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzID0gW10sXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0Y2xvc2VkID0gcGF0aC5fY2xvc2VkO1xuXHRcdGZvciAodmFyIGkgPSAwLCBwcmV2LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludDtcblx0XHRcdGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHByZXYgPSBwb2ludC5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0cG9pbnRzLnVuc2hpZnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cdFx0XHRwb2ludHMucHVzaChwb2ludHNbMV0pO1xuXHRcdH1cblx0XHR0aGlzLmNsb3NlZCA9IGNsb3NlZDtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gbnVsbDtcblx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0c2VnbWVudHMgPSBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV07XG5cdFx0XHRpZiAobGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgMCwgbGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRcdHBvaW50c1sxXS5zdWJ0cmFjdChwb2ludHNbMF0pLFxuXHRcdFx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAodGhpcy5jbG9zZWQpIHtcblx0XHRcdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0XHRcdHNlZ21lbnRzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBzZWdtZW50cztcblx0fSxcblxuXHRmaXRDdWJpYzogZnVuY3Rpb24oc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZiAobGFzdCAtIGZpcnN0ID09PSAxKSB7XG5cdFx0XHR2YXIgcHQxID0gcG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gcG9pbnRzW2xhc3RdLFxuXHRcdFx0XHRkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuXHRcdFx0dGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgW3B0MSwgcHQxLmFkZCh0YW4xLm5vcm1hbGl6ZShkaXN0KSksXG5cdFx0XHRcdFx0cHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdVByaW1lID0gdGhpcy5jaG9yZExlbmd0aFBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCksXG5cdFx0XHRtYXhFcnJvciA9IE1hdGgubWF4KGVycm9yLCBlcnJvciAqIGVycm9yKSxcblx0XHRcdHNwbGl0LFxuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcblx0XHRcdHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG5cdFx0XHRpZiAobWF4LmVycm9yIDwgZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgY3VydmUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzcGxpdCA9IG1heC5pbmRleDtcblx0XHRcdGlmIChtYXguZXJyb3IgPj0gbWF4RXJyb3IpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgdGFuQ2VudGVyID0gcG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QocG9pbnRzW3NwbGl0ICsgMV0pO1xuXHRcdHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIHNwbGl0LCBsYXN0LCB0YW5DZW50ZXIubmVnYXRlKCksIHRhbjIpO1xuXHR9LFxuXG5cdGFkZEN1cnZlOiBmdW5jdGlvbihzZWdtZW50cywgY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdHByZXYuc2V0SGFuZGxlT3V0KGN1cnZlWzFdLnN1YnRyYWN0KGN1cnZlWzBdKSk7XG5cdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChjdXJ2ZVszXSwgY3VydmVbMl0uc3VidHJhY3QoY3VydmVbM10pKSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdHB0MSA9IHBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSBwb2ludHNbbGFzdF0sXG5cdFx0XHRDID0gW1swLCAwXSwgWzAsIDBdXSxcblx0XHRcdFggPSBbMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxhc3QgLSBmaXJzdCArIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB1ID0gdVByaW1lW2ldLFxuXHRcdFx0XHR0ID0gMSAtIHUsXG5cdFx0XHRcdGIgPSAzICogdSAqIHQsXG5cdFx0XHRcdGIwID0gdCAqIHQgKiB0LFxuXHRcdFx0XHRiMSA9IGIgKiB0LFxuXHRcdFx0XHRiMiA9IGIgKiB1LFxuXHRcdFx0XHRiMyA9IHUgKiB1ICogdSxcblx0XHRcdFx0YTEgPSB0YW4xLm5vcm1hbGl6ZShiMSksXG5cdFx0XHRcdGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuXHRcdFx0XHR0bXAgPSBwb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSxcblx0XHRcdGFscGhhMjtcblx0XHRpZiAoYWJzKGRldEMwQzEpID4gZXBzaWxvbikge1xuXHRcdFx0dmFyIGRldEMwWCA9IENbMF1bMF0gKiBYWzFdICAgIC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMSA9IFhbMF0gICAgKiBDWzFdWzFdIC0gWFsxXSAgICAqIENbMF1bMV07XG5cdFx0XHRhbHBoYTEgPSBkZXRYQzEgLyBkZXRDMEMxO1xuXHRcdFx0YWxwaGEyID0gZGV0QzBYIC8gZGV0QzBDMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGMwID0gQ1swXVswXSArIENbMF1bMV0sXG5cdFx0XHRcdGMxID0gQ1sxXVswXSArIENbMV1bMV07XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBhYnMoYzApID4gZXBzaWxvbiA/IFhbMF0gLyBjMFxuXHRcdFx0XHRcdFx0XHQ6IGFicyhjMSkgPiBlcHNpbG9uID8gWFsxXSAvIGMxXG5cdFx0XHRcdFx0XHRcdDogMDtcblx0XHR9XG5cblx0XHR2YXIgc2VnTGVuZ3RoID0gcHQyLmdldERpc3RhbmNlKHB0MSksXG5cdFx0XHRlcHMgPSBlcHNpbG9uICogc2VnTGVuZ3RoLFxuXHRcdFx0aGFuZGxlMSxcblx0XHRcdGhhbmRsZTI7XG5cdFx0aWYgKGFscGhhMSA8IGVwcyB8fCBhbHBoYTIgPCBlcHMpIHtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaW5lID0gcHQyLnN1YnRyYWN0KHB0MSk7XG5cdFx0XHRoYW5kbGUxID0gdGFuMS5ub3JtYWxpemUoYWxwaGExKTtcblx0XHRcdGhhbmRsZTIgPSB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpO1xuXHRcdFx0aWYgKGhhbmRsZTEuZG90KGxpbmUpIC0gaGFuZGxlMi5kb3QobGluZSkgPiBzZWdMZW5ndGggKiBzZWdMZW5ndGgpIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcblx0XHRcdFx0aGFuZGxlMSA9IGhhbmRsZTIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLFxuXHRcdFx0XHRwdDEuYWRkKGhhbmRsZTEgfHwgdGFuMS5ub3JtYWxpemUoYWxwaGExKSksXG5cdFx0XHRcdHB0Mi5hZGQoaGFuZGxlMiB8fCB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpKSxcblx0XHRcdFx0cHQyXTtcblx0fSxcblxuXHRyZXBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHUsIGN1cnZlKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdGhpcy5maW5kUm9vdChjdXJ2ZSwgdGhpcy5wb2ludHNbaV0sIHVbaSAtIGZpcnN0XSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gdS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICh1W2ldIDw9IHVbaSAtIDFdKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGZpbmRSb290OiBmdW5jdGlvbihjdXJ2ZSwgcG9pbnQsIHUpIHtcblx0XHR2YXIgY3VydmUxID0gW10sXG5cdFx0XHRjdXJ2ZTIgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAyOyBpKyspIHtcblx0XHRcdGN1cnZlMVtpXSA9IGN1cnZlW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZVtpXSkubXVsdGlwbHkoMyk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuXHRcdFx0Y3VydmUyW2ldID0gY3VydmUxW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZTFbaV0pLm11bHRpcGx5KDIpO1xuXHRcdH1cblx0XHR2YXIgcHQgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1KSxcblx0XHRcdHB0MSA9IHRoaXMuZXZhbHVhdGUoMiwgY3VydmUxLCB1KSxcblx0XHRcdHB0MiA9IHRoaXMuZXZhbHVhdGUoMSwgY3VydmUyLCB1KSxcblx0XHRcdGRpZmYgPSBwdC5zdWJ0cmFjdChwb2ludCksXG5cdFx0XHRkZiA9IHB0MS5kb3QocHQxKSArIGRpZmYuZG90KHB0Mik7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc01hY2hpbmVaZXJvKGRmKSA/IHUgOiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y29udGVudDogbnVsbFxuXHR9LFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IGZhbHNlLCBoYW5kbGU6IGZhbHNlIH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnO1xuXHRcdHRoaXMuX2xpbmVzID0gW107XG5cdFx0dmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdCYmIGFyZy54ID09PSB1bmRlZmluZWQgJiYgYXJnLnkgPT09IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50ID09PSBpdGVtLl9jb250ZW50O1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldENvbnRlbnQoc291cmNlLl9jb250ZW50KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDUyMSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHR2YXIgbGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh4LFxuXHRcdFx0XHRcdG51bUxpbmVzID8gLSAwLjc1ICogbGVhZGluZyA6IDAsXG5cdFx0XHRcdFx0d2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpIDogcmVjdDtcblx0fVxufSk7XG5cbnZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0bmFtZWRDb2xvcnMgPSB7XG5cdFx0XHR0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdXG5cdFx0fSxcblx0XHRjb2xvckN0eDtcblxuXHRmdW5jdGlvbiBmcm9tQ1NTKHN0cmluZykge1xuXHRcdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChcblx0XHRcdFx0L14jKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KT8kL2lcblx0XHRcdCkgfHwgc3RyaW5nLm1hdGNoKFxuXHRcdFx0XHQvXiMoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSkoW1xcZGEtZl0pPyQvaVxuXHRcdFx0KSxcblx0XHRcdHR5cGUgPSAncmdiJyxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gbWF0Y2hbNF0gPyA0IDogMztcblx0XHRcdGNvbXBvbmVudHMgPSBuZXcgQXJyYXkoYW1vdW50KTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihyZ2J8aHNsKWE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0dHlwZSA9IG1hdGNoWzFdO1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzJdLnRyaW0oKS5zcGxpdCgvWyxcXHNdKy9nKTtcblx0XHRcdHZhciBpc0hTTCA9IHR5cGUgPT09ICdoc2wnO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihjb21wb25lbnRzLmxlbmd0aCwgNCk7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoY29tcG9uZW50KTtcblx0XHRcdFx0aWYgKGlzSFNMKSB7XG5cdFx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRcdHZhciB1bml0ID0gY29tcG9uZW50Lm1hdGNoKC8oW2Etel0qKSQvKVsxXTtcblx0XHRcdFx0XHRcdHZhbHVlICo9ICh7XG5cdFx0XHRcdFx0XHRcdHR1cm46IDM2MCxcblx0XHRcdFx0XHRcdFx0cmFkOiAxODAgLyBNYXRoLlBJLFxuXHRcdFx0XHRcdFx0XHRncmFkOiAwLjlcblx0XHRcdFx0XHRcdH1bdW5pdF0gfHwgMSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpIDwgMykge1xuXHRcdFx0XHRcdFx0dmFsdWUgLz0gMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpIDwgMykge1xuXHRcdFx0XHRcdHZhbHVlIC89IC8lJC8udGVzdChjb21wb25lbnQpID8gMTAwIDogMjU1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXTtcblx0XHRcdGlmICghY29sb3IpIHtcblx0XHRcdFx0aWYgKHdpbmRvdykge1xuXHRcdFx0XHRcdGlmICghY29sb3JDdHgpIHtcblx0XHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRcdGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcblx0XHRcdFx0XHRjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRcdGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXSA9IFtcblx0XHRcdFx0XHRcdGRhdGFbMF0gLyAyNTUsXG5cdFx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdFx0ZGF0YVsyXSAvIDI1NVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29sb3IgPSBbMCwgMCwgMF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gW3R5cGUsIGNvbXBvbmVudHNdO1xuXHR9XG5cblx0dmFyIGhzYkluZGljZXMgPSBbXG5cdFx0WzAsIDMsIDFdLFxuXHRcdFsyLCAwLCAxXSxcblx0XHRbMSwgMCwgM10sXG5cdFx0WzEsIDIsIDBdLFxuXHRcdFszLCAxLCAwXSxcblx0XHRbMCwgMSwgMl1cblx0XTtcblxuXHR2YXIgY29udmVydGVycyA9IHtcblx0XHQncmdiLWhzYic6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRoID0gZGVsdGEgPT09IDAgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDtcblx0XHRcdHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuXHRcdH0sXG5cblx0XHQnaHNiLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGIpIHtcblx0XHRcdGggPSAoKChoIC8gNjApICUgNikgKyA2KSAlIDY7XG5cdFx0XHR2YXIgaSA9IE1hdGguZmxvb3IoaCksXG5cdFx0XHRcdGYgPSBoIC0gaSxcblx0XHRcdFx0aSA9IGhzYkluZGljZXNbaV0sXG5cdFx0XHRcdHYgPSBbXG5cdFx0XHRcdFx0Yixcblx0XHRcdFx0XHRiICogKDEgLSBzKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogZiksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqICgxIC0gZikpXG5cdFx0XHRcdF07XG5cdFx0XHRyZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuXHRcdH0sXG5cblx0XHQncmdiLWhzbCc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG5cdFx0XHRcdGggPSBhY2hyb21hdGljID8gMFxuXHRcdFx0XHRcdDogICAoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0OiAgICAgICAgICAgIChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsXG5cdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDIsXG5cdFx0XHRcdHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjVcblx0XHRcdFx0XHRcdD8gZGVsdGEgLyAobWF4ICsgbWluKVxuXHRcdFx0XHRcdFx0OiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0XHRcdHJldHVybiBbaCwgcywgbF07XG5cdFx0fSxcblxuXHRcdCdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuXHRcdFx0aCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG5cdFx0XHRpZiAocyA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtsLCBsLCBsXTtcblx0XHRcdHZhciB0M3MgPSBbIGggKyAxIC8gMywgaCwgaCAtIDEgLyAzIF0sXG5cdFx0XHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcblx0XHRcdFx0dDEgPSAyICogbCAtIHQyLFxuXHRcdFx0XHRjID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdDMgPSB0M3NbaV07XG5cdFx0XHRcdGlmICh0MyA8IDApIHQzICs9IDE7XG5cdFx0XHRcdGlmICh0MyA+IDEpIHQzIC09IDE7XG5cdFx0XHRcdGNbaV0gPSA2ICogdDMgPCAxXG5cdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1xuXHRcdFx0XHRcdDogMiAqIHQzIDwgMVxuXHRcdFx0XHRcdFx0PyB0MlxuXHRcdFx0XHRcdFx0OiAzICogdDMgPCAyXG5cdFx0XHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzKSAqIDZcblx0XHRcdFx0XHRcdFx0OiB0MTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHRyZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1yZ2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gW2csIGcsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdFx0Y29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuXHRcdEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuXHRcdFx0XHRwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHQ/IG5hbWUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IEdyYWRpZW50LnJlYWQoXG5cdFx0XHRcdFx0XHRcdFx0QXJyYXkuaXNBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdDogYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogK3ZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cmVhZGluZyA9IHRoaXMuX19yZWFkLFxuXHRcdFx0XHRyZWFkID0gMCxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0Y29tcG9uZW50cyxcblx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdHZhbHVlcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0YXJncyA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1swXTtcblx0XHRcdH1cblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcblx0XHRcdFx0dHlwZSA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1sxXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmc7XG5cdFx0XHRcdFx0YWxwaGEgPSBhcmdzWzJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdFx0YXJncyA9IEJhc2Uuc2xpY2UoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAocmVhZGluZykge1xuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiBsZW5ndGgpXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBCYXNlLnNsaWNlKHZhbHVlcywgMCwgbGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhciBjb252ZXJ0ZWQgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0dHlwZSA9IGNvbnZlcnRlZFswXTtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gY29udmVydGVkWzFdO1xuXHRcdFx0XHRcdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0dHlwZSA9IGFyZy5fdHlwZTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmcuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLl9hbHBoYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwb2ludClcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IEdyYWRpZW50KSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGFyZ3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnaHVlJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0PyAnbGlnaHRuZXNzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdoc2wnXG5cdFx0XHRcdFx0XHRcdFx0OiAnaHNiJ1xuXHRcdFx0XHRcdFx0XHQ6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCAncmFkaWFsJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5JyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdD8gJ2dyYXknXG5cdFx0XHRcdFx0XHRcdFx0XHQ6ICdyZ2InO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRcdFx0cGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV07XG5cdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVhZGluZyAmJiB0eXBlKVxuXHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgJ3JnYic7XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0dmFyIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3RoaXMuX3R5cGVdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlcyAmJiB2YWx1ZXNbaV0pO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0aGlzLl90eXBlXTtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcikge1xuXHRcdFx0XHRpZiAodGhpcy5fc2V0dGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCgxMjkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY29udmVydGVyO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKVxuXHRcdFx0XHRcdDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKVxuXHRcdFx0XHRcdFx0PyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cylcblx0XHRcdFx0XHRcdDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLXJnYiddLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cykpO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIHRoaXMuX2NvbnZlcnQodHlwZSksIHRoaXMuX2FscGhhKTtcblx0XHR9LFxuXG5cdFx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0XHR9LFxuXG5cdFx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR9LFxuXG5cdFx0Z2V0Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2godGhpcy5fYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdFx0fSxcblxuXHRcdGdldEFscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuXHRcdH0sXG5cblx0XHRzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGEgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1pbihNYXRoLm1heChhbHBoYSwgMCksIDEpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH0sXG5cblx0XHRoYXNBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbDtcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0dmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yLCB0cnVlKVxuXHRcdFx0XHRcdD8gQ29sb3IucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdFx0OiBjb2xvcjtcblx0XHRcdHJldHVybiBjb2wgPT09IHRoaXMgfHwgY29sICYmIHRoaXMuX2NsYXNzID09PSBjb2wuX2NsYXNzXG5cdFx0XHRcdFx0JiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlXG5cdFx0XHRcdFx0JiYgdGhpcy5nZXRBbHBoYSgpID09PSBjb2wuZ2V0QWxwaGEoKVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM10sXG5cdFx0XHRcdGludmVyc2UgPSBtYXRyaXggJiYgbWF0cml4LmludmVydGVkKCksXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGludmVyc2UpIHtcblx0XHRcdFx0b3JpZ2luID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQob3JpZ2luKTtcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChkZXN0aW5hdGlvbik7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQoaGlnaGxpZ2h0KTtcblx0XHRcdH1cblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IGhpZ2hsaWdodC5zdWJ0cmFjdChvcmlnaW4pO1xuXHRcdFx0XHRcdGlmICh2ZWN0b3IuZ2V0TGVuZ3RoKCkgPiByYWRpdXMpXG5cdFx0XHRcdFx0XHRoaWdobGlnaHQgPSBvcmlnaW4uYWRkKHZlY3Rvci5ub3JtYWxpemUocmFkaXVzIC0gMC4xKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSxcblx0XHRcdFx0XHRcdDAsIG9yaWdpbi54LCBvcmlnaW4ueSwgcmFkaXVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG9yaWdpbi54LCBvcmlnaW4ueSxcblx0XHRcdFx0XHRcdGRlc3RpbmF0aW9uLngsIGRlc3RpbmF0aW9uLnkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRvZmZzZXQgPSBzdG9wLl9vZmZzZXQ7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChcblx0XHRcdFx0XHRcdG9mZnNldCA9PSBudWxsID8gaSAvIChsIC0gMSkgOiBvZmZzZXQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRPd25lcjogZnVuY3Rpb24oY29sb3IsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0aWYgKGNvbG9yLl9vd25lciAmJiBvd25lciAmJiBjb2xvci5fb3duZXIgIT09IG93bmVyKSB7XG5cdFx0XHRcdFx0XHRjb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghY29sb3IuX293bmVyIF4gIW93bmVyKSB7XG5cdFx0XHRcdFx0XHRjb2xvci5fb3duZXIgPSBvd25lciB8fCBudWxsO1xuXHRcdFx0XHRcdFx0Y29sb3IuX3NldHRlciA9IHNldHRlciB8fCBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29sb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0YWRkOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSArIGI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAqIGI7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLyBiO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKG9wZXJhdG9ycywgZnVuY3Rpb24ob3BlcmF0b3IsIG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzMSA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29tcG9uZW50czJbaV0gPSBvcGVyYXRvcihjb21wb25lbnRzMVtpXSwgY29tcG9uZW50czJbaV0pO1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzMixcblx0XHRcdFx0XHR0aGlzLl9hbHBoYSAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gb3BlcmF0b3IodGhpcy5fYWxwaGEsIGNvbG9yLmdldEFscGhhKCkpXG5cdFx0XHRcdFx0XHRcdDogbnVsbCk7XG5cdFx0fTtcblx0fSwge1xuXHR9KTtcbn0pO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0aWYgKHN0b3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChzdG9wcykpIHtcblx0XHRcdHRoaXMuc2V0KHN0b3BzKTtcblx0XHRcdHN0b3BzID0gcmFkaWFsID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3N0b3BzID09IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAoIXRoaXMuX293bmVycy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdG9wcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgR3JhZGllbnQoc3RvcHMsIHRoaXMuX3JhZGlhbCk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAoc3RvcHMubGVuZ3RoIDwgMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0fVxuXHRcdHZhciBfc3RvcHMgPSB0aGlzLl9zdG9wcztcblx0XHRpZiAoX3N0b3BzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IF9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdF9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdF9zdG9wcyA9IHRoaXMuX3N0b3BzID0gR3JhZGllbnRTdG9wLnJlYWRMaXN0KHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdF9zdG9wc1tpXS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzcykge1xuXHRcdFx0dmFyIHN0b3BzMSA9IHRoaXMuX3N0b3BzLFxuXHRcdFx0XHRzdG9wczIgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdGxlbmd0aCA9IHN0b3BzMS5sZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoID09PSBzdG9wczIubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIXN0b3BzMVtpXS5lcXVhbHMoc3RvcHMyW2ldKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEdyYWRpZW50U3RvcCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnRTdG9wJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudFN0b3AoYXJnMCwgYXJnMSkge1xuXHRcdHZhciBjb2xvciA9IGFyZzAsXG5cdFx0XHRvZmZzZXQgPSBhcmcxO1xuXHRcdGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcgJiYgYXJnMSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSAmJiB0eXBlb2YgYXJnMFswXSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRvZmZzZXQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmICgnY29sb3InIGluIGFyZzAgfHwgJ29mZnNldCcgaW4gYXJnMFxuXHRcdFx0XHRcdHx8ICdyYW1wUG9pbnQnIGluIGFyZzApIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwLmNvbG9yO1xuXHRcdFx0XHRvZmZzZXQgPSBhcmcwLm9mZnNldCB8fCBhcmcwLnJhbXBQb2ludCB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHR0aGlzLnNldE9mZnNldChvZmZzZXQpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9vZmZzZXQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgY29sb3IgPSB0aGlzLl9jb2xvcixcblx0XHRcdG9mZnNldCA9IHRoaXMuX29mZnNldDtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUob2Zmc2V0ID09IG51bGwgPyBbY29sb3JdIDogW2NvbG9yLCBvZmZzZXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoMTI5KTtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vZmZzZXQ7XG5cdH0sXG5cblx0c2V0T2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogJyNnZXRPZmZzZXQnLFxuXHRzZXRSYW1wUG9pbnQ6ICcjc2V0T2Zmc2V0JyxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRDb2xvci5fc2V0T3duZXIodGhpcy5fY29sb3IsIG51bGwpO1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IuX3NldE93bmVyKENvbG9yLnJlYWQoYXJndW1lbnRzLCAwKSwgdGhpcyxcblx0XHRcdFx0J3NldENvbG9yJyk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3RvcCkge1xuXHRcdHJldHVybiBzdG9wID09PSB0aGlzIHx8IHN0b3AgJiYgdGhpcy5fY2xhc3MgPT09IHN0b3AuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX2NvbG9yLmVxdWFscyhzdG9wLl9jb2xvcilcblx0XHRcdFx0JiYgdGhpcy5fb2Zmc2V0ID09IHN0b3AuX29mZnNldFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBTdHlsZSA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGl0ZW1EZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cdFx0ZmlsbFJ1bGU6ICdub256ZXJvJyxcblx0XHRzdHJva2VDb2xvcjogbnVsbCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHNoYWRvd0NvbG9yOiBudWxsLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiBudWxsXG5cdH0sXG5cdGdyb3VwRGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgaXRlbURlZmF1bHRzLCB7XG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRsZWFkaW5nOiBudWxsLFxuXHRcdGp1c3RpZmljYXRpb246ICdsZWZ0J1xuXHR9KSxcblx0dGV4dERlZmF1bHRzID0gQmFzZS5zZXQoe30sIGdyb3VwRGVmYXVsdHMsIHtcblx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdH0pLFxuXHRmbGFncyA9IHtcblx0XHRzdHJva2VXaWR0aDogMTkzLFxuXHRcdHN0cm9rZUNhcDogMTkzLFxuXHRcdHN0cm9rZUpvaW46IDE5Myxcblx0XHRzdHJva2VTY2FsaW5nOiAyMDEsXG5cdFx0bWl0ZXJMaW1pdDogMTkzLFxuXHRcdGZvbnRGYW1pbHk6IDksXG5cdFx0Zm9udFdlaWdodDogOSxcblx0XHRmb250U2l6ZTogOSxcblx0XHRmb250OiA5LFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9LFxuXHRpdGVtID0ge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH0sXG5cdGZpZWxkcyA9IHtcblx0XHRfY2xhc3M6ICdTdHlsZScsXG5cdFx0YmVhbnM6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuXHRcdFx0dGhpcy5fdmFsdWVzID0ge307XG5cdFx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHRcdHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0XG5cdFx0XHRcdFx0fHwgcGFwZXIucHJvamVjdDtcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gIV9vd25lciB8fCBfb3duZXIgaW5zdGFuY2VvZiBHcm91cCA/IGdyb3VwRGVmYXVsdHNcblx0XHRcdFx0XHQ6IF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtID8gdGV4dERlZmF1bHRzXG5cdFx0XHRcdFx0OiBpdGVtRGVmYXVsdHM7XG5cdFx0XHRpZiAoc3R5bGUpXG5cdFx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0XHR9XG5cdH07XG5cblx0QmFzZS5lYWNoKGdyb3VwRGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKTtcblx0XHRcdGlmIChhcHBseVRvQ2hpbGRyZW4pIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0Y2hpbGRyZW5baV0uX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrZXkgPT09ICdzZWxlY3RlZENvbG9yJyB8fCAhYXBwbHlUb0NoaWxkcmVuKVxuXHRcdFx0XHRcdCYmIGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdGlmIChvbGQpIHtcblx0XHRcdFx0XHRcdFx0Q29sb3IuX3NldE93bmVyKG9sZCwgbnVsbCk7XG5cdFx0XHRcdFx0XHRcdG9sZC5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHRhcHBseVRvQ2hpbGRyZW4gJiYgc2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAob3duZXIpXG5cdFx0XHRcdFx0XHRvd25lci5fY2hhbmdlZChmbGFnIHx8IDEyOSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZmllbGRzW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSxcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRpZiAoYXBwbHlUb0NoaWxkcmVuICYmICFfZG9udE1lcmdlKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBjaGlsZFZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBpc0NvbG9yID8gQ29sb3IgOiBpc1BvaW50ID8gUG9pbnQgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChjdG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IGN0b3IpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gY3Rvci5yZWFkKFt2YWx1ZV0sIDAsXG5cdFx0XHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSwgY2xvbmU6IHRydWUgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgJiYgaXNDb2xvcikge1xuXHRcdFx0XHR2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsIGFwcGx5VG9DaGlsZHJlbiAmJiBzZXQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEJhc2UuZWFjaCh7XG5cdFx0Rm9udDogJ0ZvbnRGYW1pbHknLFxuXHRcdFdpbmRpbmdSdWxlOiAnRmlsbFJ1bGUnXG5cdH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgZ2V0ID0gJ2dldCcgKyBrZXksXG5cdFx0XHRzZXQgPSAnc2V0JyArIGtleTtcblx0XHRmaWVsZHNbZ2V0XSA9IGl0ZW1bZ2V0XSA9ICcjZ2V0JyArIHZhbHVlO1xuXHRcdGZpZWxkc1tzZXRdID0gaXRlbVtzZXRdID0gJyNzZXQnICsgdmFsdWU7XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRmdW5jdGlvbiBjb21wYXJlKHN0eWxlMSwgc3R5bGUyLCBzZWNvbmRhcnkpIHtcblx0XHRcdHZhciB2YWx1ZXMxID0gc3R5bGUxLl92YWx1ZXMsXG5cdFx0XHRcdHZhbHVlczIgPSBzdHlsZTIuX3ZhbHVlcyxcblx0XHRcdFx0ZGVmYXVsdHMyID0gc3R5bGUyLl9kZWZhdWx0cztcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMxKSB7XG5cdFx0XHRcdHZhciB2YWx1ZTEgPSB2YWx1ZXMxW2tleV0sXG5cdFx0XHRcdFx0dmFsdWUyID0gdmFsdWVzMltrZXldO1xuXHRcdFx0XHRpZiAoIShzZWNvbmRhcnkgJiYga2V5IGluIHZhbHVlczIpICYmICFCYXNlLmVxdWFscyh2YWx1ZTEsXG5cdFx0XHRcdFx0XHR2YWx1ZTIgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzMltrZXldIDogdmFsdWUyKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBjb21wYXJlKHRoaXMsIHN0eWxlKVxuXHRcdFx0XHQmJiBjb21wYXJlKHN0eWxlLCB0aGlzLCB0cnVlKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbG9yO1xuXHRcdGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcblx0XHRpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0Y29sb3IgPSB0aGlzLmdldFN0cm9rZUNvbG9yKCk7XG5cdFx0aWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdGNvbG9yID0gdGhpcy5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuXHRcdHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMDtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgKHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMFxuXHRcdFx0XHR8fCAhdGhpcy5nZXRTaGFkb3dPZmZzZXQoKS5pc1plcm8oKSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblx0XHRcdGlmICghdmlld3BvcnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcblx0XHRcdFx0dmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuXHRcdH0sXG5cblx0XHRnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG5cdFx0fSxcblxuXHRcdGlzSW52aXNpYmxlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcblx0XHR9LFxuXG5cdFx0aXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG5cdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsICYmIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFydHNbaV07XG5cdFx0XHRcdFx0dmFyIG9wdGlvbnMgPSAoXG5cdFx0XHRcdFx0XHRlbCA9PT0gZG9jdW1lbnRcblx0XHRcdFx0XHRcdCYmIChuYW1lID09PSAndG91Y2hzdGFydCcgfHwgbmFtZSA9PT0gJ3RvdWNobW92ZScpXG5cdFx0XHRcdFx0KSA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IGZhbHNlO1xuXHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG5hdGl2ZVJlcXVlc3QgPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuXHRcdHJlcXVlc3RlZCA9IGZhbHNlLFxuXHRcdGNhbGxiYWNrcyA9IFtdLFxuXHRcdHRpbWVyO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHR2YXIgZnVuY3Rpb25zID0gY2FsbGJhY2tzO1xuXHRcdGNhbGxiYWNrcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gZnVuY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGZ1bmN0aW9uc1tpXSgpO1xuXHRcdHJlcXVlc3RlZCA9IG5hdGl2ZVJlcXVlc3QgJiYgY2FsbGJhY2tzLmxlbmd0aDtcblx0XHRpZiAocmVxdWVzdGVkKVxuXHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoIXJlcXVlc3RlZCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghdGltZXIpIHtcblx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblxuXHRcdGZ1bmN0aW9uIGdldFNpemUobmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRbbmFtZV0gfHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuXHRcdFx0dmFyIHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gc2l6ZS5pc05hTigpIHx8IHNpemUuaXNaZXJvKClcblx0XHRcdFx0XHQ/IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKVxuXHRcdFx0XHRcdDogc2l6ZTtcblx0XHR9XG5cblx0XHR2YXIgc2l6ZTtcblx0XHRpZiAod2luZG93ICYmIGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5faWQgPSAncGFwZXItdmlldy0nICsgVmlldy5faWQrKyk7XG5cdFx0XHREb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHRcdERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0XHR1c2VyRHJhZzogbm9uZSxcblx0XHRcdFx0dXNlclNlbGVjdDogbm9uZSxcblx0XHRcdFx0dG91Y2hDYWxsb3V0OiBub25lLFxuXHRcdFx0XHRjb250ZW50Wm9vbWluZzogbm9uZSxcblx0XHRcdFx0dGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG5cdFx0XHRcdFx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoYXQuc2V0Vmlld1NpemUoZ2V0Q2FudmFzU2l6ZSgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRzaXplID0gZ2V0Q2FudmFzU2l6ZSgpO1xuXG5cdFx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0YXRzJylcblx0XHRcdFx0XHQmJiB0eXBlb2YgU3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHRcdHZhciBzdGF0cyA9IHRoaXMuX3N0YXRzLmRvbUVsZW1lbnQsXG5cdFx0XHRcdFx0c3R5bGUgPSBzdGF0cy5zdHlsZSxcblx0XHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHRzdHlsZS5sZWZ0ID0gb2Zmc2V0LnggKyAncHgnO1xuXHRcdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZWxlbWVudCk7XG5cdFx0XHRlbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0dGhpcy5fc2NvcGUgPSBwcm9qZWN0Ll9zY29wZTtcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblx0XHRpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdCh0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCkpLl9vd25lciA9IHRoaXM7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRoaXM7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX2ZyYW1lSXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl9pdGVtRXZlbnRzID0geyBuYXRpdmU6IHt9LCB2aXJ0dWFsOiB7fSB9O1xuXHRcdHRoaXMuX2F1dG9VcGRhdGUgPSAhcGFwZXIuYWdlbnQubm9kZTtcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAocHJvamVjdC5fdmlldyA9PT0gdGhpcylcblx0XHRcdHByb2plY3QuX3ZpZXcgPSBudWxsO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHREb21FdmVudC5yZW1vdmUod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLm9mZignZnJhbWUnKTtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9ldmVudHM6IEJhc2UuZWFjaChcblx0XHRJdGVtLl9pdGVtSGFuZGxlcnMuY29uY2F0KFsnb25SZXNpemUnLCAnb25LZXlEb3duJywgJ29uS2V5VXAnXSksXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHt9O1xuXHRcdH0sIHtcblx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdCksXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdGdldEF1dG9VcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuXHR9LFxuXG5cdHNldEF1dG9VcGRhdGU6IGZ1bmN0aW9uKGF1dG9VcGRhdGUpIHtcblx0XHR0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcblx0XHRpZiAoYXV0b1VwZGF0ZSlcblx0XHRcdHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRyZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZCkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0RG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHRoYXQuX2FuaW1hdGUpIHtcblx0XHRcdFx0XHR0aGF0LnJlcXVlc3RVcGRhdGUoKTtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoYXQuX2VsZW1lbnQ7XG5cdFx0XHRcdFx0aWYgKCghRG9tRWxlbWVudC5nZXRQcmVmaXhlZChkb2N1bWVudCwgJ2hpZGRlbicpXG5cdFx0XHRcdFx0XHRcdHx8IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdrZWVwYWxpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdD09PSAndHJ1ZScpICYmIERvbUVsZW1lbnQuaXNJblZpZXcoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRcdHRoYXQuX2hhbmRsZUZyYW1lKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGF0Ll9hdXRvVXBkYXRlKVxuXHRcdFx0XHRcdHRoYXQudXBkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSB0cnVlO1xuXHRcdHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fbGFzdCA/IG5vdyAtIHRoaXMuX2xhc3QgOiAwO1xuXHRcdHRoaXMuX2xhc3QgPSBub3c7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9jaGFuZ2VkKDQwOTcpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gKiA3Mjtcblx0fSxcblxuXHRnZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRWaWV3U2l6ZScpO1xuXHR9LFxuXG5cdHNldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0ZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcblx0XHRpZiAoZGVsdGEuaXNaZXJvKCkpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0dGhpcy5lbWl0KCdyZXNpemUnLCB7IHNpemU6IHNpemUsIGRlbHRhOiBkZWx0YSB9KTtcblx0XHRpZiAodGhpcy5fYXV0b1VwZGF0ZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEVsZW1lbnRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRpZiAoZWxlbWVudC53aWR0aCAhPT0gd2lkdGgpXG5cdFx0XHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aDtcblx0XHRcdGlmIChlbGVtZW50LmhlaWdodCAhPT0gaGVpZ2h0KVxuXHRcdFx0XHRlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG5cdFx0XHRcdFx0bmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5zZXJ0ZWQodGhpcy5fZWxlbWVudCk7XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0cGl4ZWxzO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuXHRcdFx0XHR0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHR0ZW1wLnN0eWxlLmZvbnRTaXplID0gc2l6ZTtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZCh0ZW1wKTtcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQoRG9tRWxlbWVudC5nZXRTdHlsZXModGVtcCkuZm9udFNpemUpO1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHRlbXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KHBpeGVscyk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHJldHVybiAwO1xuXHR9XG59LCBCYXNlLmVhY2goWydyb3RhdGUnLCAnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIHJvdGF0ZSA9IGtleSA9PT0gJ3JvdGF0ZSc7XG5cdHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0dmFsdWUgPSAocm90YXRlID8gQmFzZSA6IFBvaW50KS5yZWFkKGFyZ3MpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmdzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClba2V5XSh2YWx1ZSxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyKHRydWUpKSk7XG5cdH07XG59LCB7XG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZSh0aGlzLmdldENlbnRlcigpLnN1YnRyYWN0KGNlbnRlcikpO1xuXHR9LFxuXG5cdGdldFpvb206IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsaW5nID0gdGhpcy5fZGVjb21wb3NlKCkuc2NhbGluZztcblx0XHRyZXR1cm4gKHNjYWxpbmcueCArIHNjYWxpbmcueSkgLyAyO1xuXHR9LFxuXG5cdHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcblx0XHR0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuZ2V0Wm9vbSgpLFxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoKSkpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVjb21wb3NlKCkucm90YXRpb247XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGluZyA9IHRoaXMuX2RlY29tcG9zZSgpLnNjYWxpbmc7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuXHRcdFx0c2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY3VycmVudCAmJiBzY2FsaW5nKSB7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRtYXRyaXguc2V0LmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX21hdHJpeC5hcHBlbmQobWF0cml4KTtcblx0fSxcblxuXHRzY3JvbGxCeTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKTtcblx0fVxufSksIHtcblxuXHRwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRFdmVudFBvaW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdUb1Byb2plY3QoRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB0aGlzLl9lbGVtZW50KSk7XG5cdH0sXG5cbn0sIHtcblx0c3RhdGljczoge1xuXHRcdF92aWV3czogW10sXG5cdFx0X3ZpZXdzQnlJZDoge30sXG5cdFx0X2lkOiAwLFxuXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbihwcm9qZWN0LCBlbGVtZW50KSB7XG5cdFx0XHRpZiAoZG9jdW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG5cdFx0XHR2YXIgY3RvciA9IHdpbmRvdyA/IENhbnZhc1ZpZXcgOiBWaWV3O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHByb2plY3QsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0aWYgKCF3aW5kb3cpXG5cdFx0cmV0dXJuO1xuXHR2YXIgcHJldkZvY3VzLFxuXHRcdHRlbXBGb2N1cyxcblx0XHRkcmFnZ2luZyA9IGZhbHNlLFxuXHRcdG1vdXNlRG93biA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGdldFZpZXcoZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcblx0XHRyZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBWaWV3Ll92aWV3c0J5SWRbXG5cdFx0XHRcdHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2lkJyldO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghdmlldyB8fCAhdmlldy5pc1Zpc2libGUoKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBWaWV3Ll92aWV3cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKCh2aWV3ID0gVmlldy5fdmlld3NbaV0pLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIHBvaW50KSB7XG5cdFx0dmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2Vtb3ZlJywgZXZlbnQsIHBvaW50KTtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHt9LFxuXHRcdGRvY0V2ZW50cyA9IHtcblx0XHRcdG1vdXNlb3V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRcdGlmICh2aWV3ICYmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSkge1xuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSBEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpLFxuXHRcdFx0XHRcdFx0eCA9IG9mZnNldC54LFxuXHRcdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0XHRheCA9IGFicyh4KSxcblx0XHRcdFx0XHRcdG1heCA9IDEgPDwgMjUsXG5cdFx0XHRcdFx0XHRkaWZmID0gYXggLSBtYXg7XG5cdFx0XHRcdFx0b2Zmc2V0LnggPSBhYnMoZGlmZikgPCBheCA/IGRpZmYgKiAoeCA8IDAgPyAtMSA6IDEpIDogeDtcblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIHZpZXcudmlld1RvUHJvamVjdChvZmZzZXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0c2Nyb2xsOiB1cGRhdGVGb2N1c1xuXHRcdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KTtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHRkcmFnZ2luZyA9IHRydWU7XG5cdFx0XHR2aWV3Ll9oYW5kbGVNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZW1vdmVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCFtb3VzZURvd24pIHtcblx0XHRcdHZhciB0YXJnZXQgPSBnZXRWaWV3KGV2ZW50KTtcblx0XHRcdGlmICh0YXJnZXQpIHtcblx0XHRcdFx0aWYgKHZpZXcgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdGlmICh2aWV3KVxuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50KTtcblx0XHRcdFx0XHRpZiAoIXByZXZGb2N1cylcblx0XHRcdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB0YXJnZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGVtcEZvY3VzICYmIHRlbXBGb2N1cyA9PT0gdmlldykge1xuXHRcdFx0XHRpZiAocHJldkZvY3VzICYmICFwcmV2Rm9jdXMuaXNJbnNlcnRlZCgpKVxuXHRcdFx0XHRcdHByZXZGb2N1cyA9IG51bGw7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHRwcmV2Rm9jdXMgPSBudWxsO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldylcblx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbigpIHtcblx0XHRtb3VzZURvd24gPSB0cnVlO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZXVwXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICh2aWV3ICYmIGRyYWdnaW5nKVxuXHRcdFx0dmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2V1cCcsIGV2ZW50KTtcblx0XHRtb3VzZURvd24gPSBkcmFnZ2luZyA9IGZhbHNlO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0dmFyIGNhbGxlZCA9IGZhbHNlLFxuXHRcdHByZXZlbnRlZCA9IGZhbHNlLFxuXHRcdGZhbGxiYWNrcyA9IHtcblx0XHRcdGRvdWJsZWNsaWNrOiAnY2xpY2snLFxuXHRcdFx0bW91c2VkcmFnOiAnbW91c2Vtb3ZlJ1xuXHRcdH0sXG5cdFx0d2FzSW5WaWV3ID0gZmFsc2UsXG5cdFx0b3ZlclZpZXcsXG5cdFx0ZG93blBvaW50LFxuXHRcdGxhc3RQb2ludCxcblx0XHRkb3duSXRlbSxcblx0XHRvdmVySXRlbSxcblx0XHRkcmFnSXRlbSxcblx0XHRjbGlja0l0ZW0sXG5cdFx0Y2xpY2tUaW1lLFxuXHRcdGRibENsaWNrO1xuXG5cdGZ1bmN0aW9uIGVtaXRNb3VzZUV2ZW50KG9iaiwgdGFyZ2V0LCB0eXBlLCBldmVudCwgcG9pbnQsIHByZXZQb2ludCxcblx0XHRcdHN0b3BJdGVtKSB7XG5cdFx0dmFyIHN0b3BwZWQgPSBmYWxzZSxcblx0XHRcdG1vdXNlRXZlbnQ7XG5cblx0XHRmdW5jdGlvbiBlbWl0KG9iaiwgdHlwZSkge1xuXHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRpZiAoIW1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgfHwgb2JqLFxuXHRcdFx0XHRcdFx0XHRwcmV2UG9pbnQgPyBwb2ludC5zdWJ0cmFjdChwcmV2UG9pbnQpIDogbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9iai5lbWl0KHR5cGUsIG1vdXNlRXZlbnQpKSB7XG5cdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAobW91c2VFdmVudC5wcmV2ZW50ZWQpXG5cdFx0XHRcdFx0XHRwcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChtb3VzZUV2ZW50LnN0b3BwZWQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1t0eXBlXTtcblx0XHRcdFx0aWYgKGZhbGxiYWNrKVxuXHRcdFx0XHRcdHJldHVybiBlbWl0KG9iaiwgZmFsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdoaWxlIChvYmogJiYgb2JqICE9PSBzdG9wSXRlbSkge1xuXHRcdFx0aWYgKGVtaXQob2JqLCB0eXBlKSlcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRvYmogPSBvYmouX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHN0b3BwZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBlbWl0TW91c2VFdmVudHModmlldywgaGl0SXRlbSwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQpIHtcblx0XHR2aWV3Ll9wcm9qZWN0LnJlbW92ZU9uKHR5cGUpO1xuXHRcdHByZXZlbnRlZCA9IGNhbGxlZCA9IGZhbHNlO1xuXHRcdHJldHVybiAoZHJhZ0l0ZW0gJiYgZW1pdE1vdXNlRXZlbnQoZHJhZ0l0ZW0sIG51bGwsIHR5cGUsIGV2ZW50LFxuXHRcdFx0XHRcdHBvaW50LCBwcmV2UG9pbnQpXG5cdFx0XHR8fCBoaXRJdGVtICYmIGhpdEl0ZW0gIT09IGRyYWdJdGVtXG5cdFx0XHRcdCYmICFoaXRJdGVtLmlzRGVzY2VuZGFudChkcmFnSXRlbSlcblx0XHRcdFx0JiYgZW1pdE1vdXNlRXZlbnQoaGl0SXRlbSwgbnVsbCwgdHlwZSA9PT0gJ21vdXNlZHJhZycgP1xuXHRcdFx0XHRcdCdtb3VzZW1vdmUnIDogdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQsIGRyYWdJdGVtKVxuXHRcdFx0fHwgZW1pdE1vdXNlRXZlbnQodmlldywgZHJhZ0l0ZW0gfHwgaGl0SXRlbSB8fCB2aWV3LCB0eXBlLCBldmVudCxcblx0XHRcdFx0XHRwb2ludCwgcHJldlBvaW50KSk7XG5cdH1cblxuXHR2YXIgaXRlbUV2ZW50c01hcCA9IHtcblx0XHRtb3VzZWRvd246IHtcblx0XHRcdG1vdXNlZG93bjogMSxcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHR9LFxuXHRcdG1vdXNldXA6IHtcblx0XHRcdG1vdXNldXA6IDEsXG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRjbGljazogMSxcblx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0fSxcblx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRtb3VzZWxlYXZlOiAxXG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0X3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cblx0XHRfaGFuZGxlTW91c2VFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQsIHBvaW50KSB7XG5cdFx0XHR2YXIgaXRlbUV2ZW50cyA9IHRoaXMuX2l0ZW1FdmVudHMsXG5cdFx0XHRcdGhpdEl0ZW1zID0gaXRlbUV2ZW50cy5uYXRpdmVbdHlwZV0sXG5cdFx0XHRcdG5hdGl2ZU1vdmUgPSB0eXBlID09PSAnbW91c2Vtb3ZlJyxcblx0XHRcdFx0dG9vbCA9IHRoaXMuX3Njb3BlLnRvb2wsXG5cdFx0XHRcdHZpZXcgPSB0aGlzO1xuXG5cdFx0XHRmdW5jdGlvbiByZXNwb25kcyh0eXBlKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtRXZlbnRzLnZpcnR1YWxbdHlwZV0gfHwgdmlldy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHRcdFx0fHwgdG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmF0aXZlTW92ZSAmJiBkcmFnZ2luZyAmJiByZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdHR5cGUgPSAnbW91c2VkcmFnJztcblx0XHRcdGlmICghcG9pbnQpXG5cdFx0XHRcdHBvaW50ID0gdGhpcy5nZXRFdmVudFBvaW50KGV2ZW50KTtcblxuXHRcdFx0dmFyIGluVmlldyA9IHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpLFxuXHRcdFx0XHRoaXQgPSBoaXRJdGVtcyAmJiBpblZpZXcgJiYgdmlldy5fcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG5cdFx0XHRcdFx0dG9sZXJhbmNlOiAwLFxuXHRcdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdFx0c3Ryb2tlOiB0cnVlXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRoaXRJdGVtID0gaGl0ICYmIGhpdC5pdGVtIHx8IG51bGwsXG5cdFx0XHRcdGhhbmRsZSA9IGZhbHNlLFxuXHRcdFx0XHRtb3VzZSA9IHt9O1xuXHRcdFx0bW91c2VbdHlwZS5zdWJzdHIoNSldID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGhpdEl0ZW1zICYmIGhpdEl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdGlmIChvdmVySXRlbSkge1xuXHRcdFx0XHRcdGVtaXRNb3VzZUV2ZW50KG92ZXJJdGVtLCBudWxsLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhpdEl0ZW0pIHtcblx0XHRcdFx0XHRlbWl0TW91c2VFdmVudChoaXRJdGVtLCBudWxsLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3Zlckl0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdhc0luVmlldyBeIGluVmlldykge1xuXHRcdFx0XHRlbWl0TW91c2VFdmVudCh0aGlzLCBudWxsLCBpblZpZXcgPyAnbW91c2VlbnRlcicgOiAnbW91c2VsZWF2ZScsXG5cdFx0XHRcdFx0XHRldmVudCwgcG9pbnQpO1xuXHRcdFx0XHRvdmVyVmlldyA9IGluVmlldyA/IHRoaXMgOiBudWxsO1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChpblZpZXcgfHwgbW91c2UuZHJhZykgJiYgIXBvaW50LmVxdWFscyhsYXN0UG9pbnQpKSB7XG5cdFx0XHRcdGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCBuYXRpdmVNb3ZlID8gdHlwZSA6ICdtb3VzZW1vdmUnLFxuXHRcdFx0XHRcdFx0ZXZlbnQsIHBvaW50LCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0d2FzSW5WaWV3ID0gaW5WaWV3O1xuXHRcdFx0aWYgKG1vdXNlLmRvd24gJiYgaW5WaWV3IHx8IG1vdXNlLnVwICYmIGRvd25Qb2ludCkge1xuXHRcdFx0XHRlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgdHlwZSwgZXZlbnQsIHBvaW50LCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAobW91c2UuZG93bikge1xuXHRcdFx0XHRcdGRibENsaWNrID0gaGl0SXRlbSA9PT0gY2xpY2tJdGVtXG5cdFx0XHRcdFx0XHQmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdFx0ZG93bkl0ZW0gPSBjbGlja0l0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0XHRcdGlmICghcHJldmVudGVkICYmIGhpdEl0ZW0pIHtcblx0XHRcdFx0XHRcdHZhciBpdGVtID0gaGl0SXRlbTtcblx0XHRcdFx0XHRcdHdoaWxlIChpdGVtICYmICFpdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0XHRcdGlmIChpdGVtKVxuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbSA9IGhpdEl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvd25Qb2ludCA9IHBvaW50O1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1vdXNlLnVwKSB7XG5cdFx0XHRcdFx0aWYgKCFwcmV2ZW50ZWQgJiYgaGl0SXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0XHRlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgZGJsQ2xpY2sgPyAnZG91YmxlY2xpY2snXG5cdFx0XHRcdFx0XHRcdFx0OiAnY2xpY2snLCBldmVudCwgcG9pbnQsIGRvd25Qb2ludCk7XG5cdFx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb3duSXRlbSA9IGRyYWdJdGVtID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3YXNJblZpZXcgPSBmYWxzZTtcblx0XHRcdFx0aGFuZGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGxhc3RQb2ludCA9IHBvaW50O1xuXHRcdFx0aWYgKGhhbmRsZSAmJiB0b29sKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRvb2wuX2hhbmRsZU1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCBtb3VzZSlcblx0XHRcdFx0XHR8fCBjYWxsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2Vcblx0XHRcdFx0JiYgKGNhbGxlZCAmJiAhbW91c2UubW92ZSB8fCBtb3VzZS5kb3duICYmIHJlc3BvbmRzKCdtb3VzZXVwJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hhbmRsZUtleUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpIHtcblx0XHRcdHZhciBzY29wZSA9IHRoaXMuX3Njb3BlLFxuXHRcdFx0XHR0b29sID0gc2NvcGUudG9vbCxcblx0XHRcdFx0a2V5RXZlbnQ7XG5cblx0XHRcdGZ1bmN0aW9uIGVtaXQob2JqKSB7XG5cdFx0XHRcdGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0XHRcdG9iai5lbWl0KHR5cGUsIGtleUV2ZW50ID0ga2V5RXZlbnRcblx0XHRcdFx0XHRcdFx0fHwgbmV3IEtleUV2ZW50KHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3RlcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdGVtaXQodGhpcyk7XG5cdFx0XHRcdGlmICh0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSkpXG5cdFx0XHRcdFx0ZW1pdCh0b29sKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NvdW50SXRlbUV2ZW50OiBmdW5jdGlvbih0eXBlLCBzaWduKSB7XG5cdFx0XHR2YXIgaXRlbUV2ZW50cyA9IHRoaXMuX2l0ZW1FdmVudHMsXG5cdFx0XHRcdG5hdGl2ZSA9IGl0ZW1FdmVudHMubmF0aXZlLFxuXHRcdFx0XHR2aXJ0dWFsID0gaXRlbUV2ZW50cy52aXJ0dWFsO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGl0ZW1FdmVudHNNYXApIHtcblx0XHRcdFx0bmF0aXZlW2tleV0gPSAobmF0aXZlW2tleV0gfHwgMClcblx0XHRcdFx0XHRcdCsgKGl0ZW1FdmVudHNNYXBba2V5XVt0eXBlXSB8fCAwKSAqIHNpZ247XG5cdFx0XHR9XG5cdFx0XHR2aXJ0dWFsW3R5cGVdID0gKHZpcnR1YWxbdHlwZV0gfHwgMCkgKyBzaWduO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHR1cGRhdGVGb2N1czogdXBkYXRlRm9jdXMsXG5cblx0XHRcdF9yZXNldFN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZHJhZ2dpbmcgPSBtb3VzZURvd24gPSBjYWxsZWQgPSB3YXNJblZpZXcgPSBmYWxzZTtcblx0XHRcdFx0cHJldkZvY3VzID0gdGVtcEZvY3VzID0gb3ZlclZpZXcgPSBkb3duUG9pbnQgPSBsYXN0UG9pbnQgPVxuXHRcdFx0XHRcdGRvd25JdGVtID0gb3Zlckl0ZW0gPSBkcmFnSXRlbSA9IGNsaWNrSXRlbSA9IGNsaWNrVGltZSA9XG5cdFx0XHRcdFx0ZGJsQ2xpY2sgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdFx0aWYgKHNpemUuaXNaZXJvKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcblx0XHRcdFx0XHRcdCsgQmFzZS5zbGljZShhcmd1bWVudHMsIDEpKTtcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQoY3R4LFxuXHRcdFx0XHRcdFx0J2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdFx0fVxuXHRcdFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuXHRcdHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHR0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKTtcblx0fSxcblxuXHRfc2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uIF9zZXRFbGVtZW50U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvO1xuXHRcdF9zZXRFbGVtZW50U2l6ZS5iYXNlLmNhbGwodGhpcywgd2lkdGggKiBwaXhlbFJhdGlvLCBoZWlnaHQgKiBwaXhlbFJhdGlvKTtcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0XHRjdHggPSB0aGlzLl9jb250ZXh0O1xuXHRcdFx0aWYgKCFQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbiBnZXRQaXhlbFNpemUoc2l6ZSkge1xuXHRcdHZhciBhZ2VudCA9IHBhcGVyLmFnZW50LFxuXHRcdFx0cGl4ZWxzO1xuXHRcdGlmIChhZ2VudCAmJiBhZ2VudC5maXJlZm94KSB7XG5cdFx0XHRwaXhlbHMgPSBnZXRQaXhlbFNpemUuYmFzZS5jYWxsKHRoaXMsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdFx0cHJldkZvbnQgPSBjdHguZm9udDtcblx0XHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChjdHguZm9udCk7XG5cdFx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWxzO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0XHRpZiAocHJvamVjdClcblx0XHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEV2ZW50KGV2ZW50KSB7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdHRoaXMudHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGU7XG5cdH0sXG5cblx0cHJldmVudGVkOiBmYWxzZSxcblx0c3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJldmVudGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR0aGlzLnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0Z2V0VGltZVN0YW1wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudC50aW1lU3RhbXA7XG5cdH0sXG5cblx0Z2V0TW9kaWZpZXJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gS2V5Lm1vZGlmaWVycztcblx0fVxufSk7XG5cbnZhciBLZXlFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ0tleUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBLZXlFdmVudCh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHR0aGlzLmtleSA9IGtleTtcblx0XHR0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3Rlcjtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIGtleTogJ1wiICsgdGhpcy5rZXlcblx0XHRcdFx0KyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXJcblx0XHRcdFx0KyBcIicsIG1vZGlmaWVyczogXCIgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgXCIgfVwiO1xuXHR9XG59KTtcblxudmFyIEtleSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGtleUxvb2t1cCA9IHtcblx0XHRcdCdcXHQnOiAndGFiJyxcblx0XHRcdCcgJzogJ3NwYWNlJyxcblx0XHRcdCdcXGInOiAnYmFja3NwYWNlJyxcblx0XHRcdCdcXHg3Zic6ICdkZWxldGUnLFxuXHRcdFx0J1NwYWNlYmFyJzogJ3NwYWNlJyxcblx0XHRcdCdEZWwnOiAnZGVsZXRlJyxcblx0XHRcdCdXaW4nOiAnbWV0YScsXG5cdFx0XHQnRXNjJzogJ2VzY2FwZSdcblx0XHR9LFxuXG5cdFx0Y2hhckxvb2t1cCA9IHtcblx0XHRcdCd0YWInOiAnXFx0Jyxcblx0XHRcdCdzcGFjZSc6ICcgJyxcblx0XHRcdCdlbnRlcic6ICdcXHInXG5cdFx0fSxcblxuXHRcdGtleU1hcCA9IHt9LFxuXHRcdGNoYXJNYXAgPSB7fSxcblx0XHRtZXRhRml4TWFwLFxuXHRcdGRvd25LZXksXG5cblx0XHRtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG5cdFx0XHRzaGlmdDogZmFsc2UsXG5cdFx0XHRjb250cm9sOiBmYWxzZSxcblx0XHRcdGFsdDogZmFsc2UsXG5cdFx0XHRtZXRhOiBmYWxzZSxcblx0XHRcdGNhcHNMb2NrOiBmYWxzZSxcblx0XHRcdHNwYWNlOiBmYWxzZVxuXHRcdH0pLmluamVjdCh7XG5cdFx0XHRvcHRpb246IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hbHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGNvbW1hbmQ6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblx0XHRcdFx0XHRyZXR1cm4gYWdlbnQgJiYgYWdlbnQubWFjID8gdGhpcy5tZXRhIDogdGhpcy5jb250cm9sO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0S2V5KGV2ZW50KSB7XG5cdFx0dmFyIGtleSA9IGV2ZW50LmtleSB8fCBldmVudC5rZXlJZGVudGlmaWVyO1xuXHRcdGtleSA9IC9eVVxcKy8udGVzdChrZXkpXG5cdFx0XHRcdD8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChrZXkuc3Vic3RyKDIpLCAxNikpXG5cdFx0XHRcdDogL15BcnJvd1tBLVpdLy50ZXN0KGtleSkgPyBrZXkuc3Vic3RyKDUpXG5cdFx0XHRcdDoga2V5ID09PSAnVW5pZGVudGlmaWVkJyAgfHwga2V5ID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSlcblx0XHRcdFx0XHQ6IGtleTtcblx0XHRyZXR1cm4ga2V5TG9va3VwW2tleV0gfHxcblx0XHRcdFx0KGtleS5sZW5ndGggPiAxID8gQmFzZS5oeXBoZW5hdGUoa2V5KSA6IGtleS50b0xvd2VyQ2FzZSgpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleShkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpIHtcblx0XHR2YXIgdHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuXHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhck1hcFtrZXldID0gY2hhcmFjdGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgY2hhck1hcFtrZXldO1xuXHRcdH1cblx0XHRpZiAoa2V5Lmxlbmd0aCA+IDEgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKGtleSkpIGluIG1vZGlmaWVycykge1xuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRcdHZhciBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXHRcdFx0aWYgKG5hbWUgPT09ICdtZXRhJyAmJiBhZ2VudCAmJiBhZ2VudC5tYWMpIHtcblx0XHRcdFx0aWYgKGRvd24pIHtcblx0XHRcdFx0XHRtZXRhRml4TWFwID0ge307XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBtZXRhRml4TWFwKSB7XG5cdFx0XHRcdFx0XHRpZiAoayBpbiBjaGFyTWFwKVxuXHRcdFx0XHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGssIG1ldGFGaXhNYXBba10sIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWV0YUZpeE1hcCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRvd24gJiYgbWV0YUZpeE1hcCkge1xuXHRcdFx0bWV0YUZpeE1hcFtrZXldID0gY2hhcmFjdGVyO1xuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmlldy5faGFuZGxlS2V5RXZlbnQoZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsIGV2ZW50LCBrZXksXG5cdFx0XHRcdFx0Y2hhcmFjdGVyKTtcblx0XHR9XG5cdH1cblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCksXG5cdFx0XHRcdGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cdFx0XHRpZiAoa2V5Lmxlbmd0aCA+IDEgfHwgYWdlbnQgJiYgKGFnZW50LmNocm9tZSAmJiAoZXZlbnQuYWx0S2V5XG5cdFx0XHRcdFx0XHR8fCBhZ2VudC5tYWMgJiYgZXZlbnQubWV0YUtleVxuXHRcdFx0XHRcdFx0fHwgIWFnZW50Lm1hYyAmJiBldmVudC5jdHJsS2V5KSkpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGtleSxcblx0XHRcdFx0XHRcdGNoYXJMb29rdXBba2V5XSB8fCAoa2V5Lmxlbmd0aCA+IDEgPyAnJyA6IGtleSksIGV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvd25LZXkgPSBrZXk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25LZXkpIHtcblx0XHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCksXG5cdFx0XHRcdFx0Y29kZSA9IGV2ZW50LmNoYXJDb2RlLFxuXHRcdFx0XHRcdGNoYXJhY3RlciA9IGNvZGUgPj0gMzIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG5cdFx0XHRcdFx0XHQ6IGtleS5sZW5ndGggPiAxID8gJycgOiBrZXk7XG5cdFx0XHRcdGlmIChrZXkgIT09IGRvd25LZXkpIHtcblx0XHRcdFx0XHRrZXkgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KTtcblx0XHRcdFx0ZG93bktleSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCk7XG5cdFx0XHRpZiAoa2V5IGluIGNoYXJNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRibHVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGNoYXJNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0bW9kaWZpZXJzOiBtb2RpZmllcnMsXG5cblx0XHRpc0Rvd246IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuICEha2V5TWFwW2tleV07XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdNb3VzZUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0XHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSlcblx0XHRcdFx0PyAnX2Rvd25Db3VudCcgOiAnX21vdmVDb3VudCddO1xuXHR9LFxuXG5cdHNldENvdW50OiBmdW5jdGlvbihjb3VudCkge1xuXHRcdHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ2Rvd25Db3VudCcgOiAnY291bnQnXVxuXHRcdFx0PSBjb3VudDtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2l0ZW0pIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHJlc3VsdC5pdGVtLFxuXHRcdFx0XHRcdHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0d2hpbGUgKC9eKEdyb3VwfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHBhcmVudDtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH0sXG5cblx0c2V0SXRlbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3sgdHlwZTogJyArIHRoaXMudHlwZVxuXHRcdFx0XHQrICcsIHBvaW50OiAnICsgdGhpcy5nZXRQb2ludCgpXG5cdFx0XHRcdCsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KClcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbCcsXG5cdF9saXN0OiAndG9vbHMnLFxuXHRfcmVmZXJlbmNlOiAndG9vbCcsXG5cdF9ldmVudHM6IFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcblx0XHRcdCdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJywgJ29uS2V5RG93bicsXG5cdFx0XHQnb25LZXlVcCddLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX21vdmVDb3VudCA9IC0xO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IC0xO1xuXHRcdHRoaXMuc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSB0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCwgcG9pbnQsIG1vdXNlKSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHRpZiAobW91c2UuZHJhZyAmJiAhdGhpcy5yZXNwb25kcyh0eXBlKSlcblx0XHRcdHR5cGUgPSAnbW91c2Vtb3ZlJztcblx0XHR2YXIgbW92ZSA9IG1vdXNlLm1vdmUgfHwgbW91c2UuZHJhZyxcblx0XHRcdHJlc3BvbmRzID0gdGhpcy5yZXNwb25kcyh0eXBlKSxcblx0XHRcdG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdG1heERpc3RhbmNlID0gdGhpcy5tYXhEaXN0YW5jZSxcblx0XHRcdGNhbGxlZCA9IGZhbHNlLFxuXHRcdFx0dG9vbCA9IHRoaXM7XG5cdFx0ZnVuY3Rpb24gdXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQsXG5cdFx0XHRcdHRvb2xQb2ludCA9IG1vdmUgPyB0b29sLl9wb2ludCA6ICh0b29sLl9kb3duUG9pbnQgfHwgcHQpO1xuXHRcdFx0aWYgKG1vdmUpIHtcblx0XHRcdFx0aWYgKHRvb2wuX21vdmVDb3VudCA+PSAwICYmIHB0LmVxdWFscyh0b29sUG9pbnQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0b29sUG9pbnQgJiYgKG1pbkRpc3RhbmNlICE9IG51bGwgfHwgbWF4RGlzdGFuY2UgIT0gbnVsbCkpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gcHQuc3VidHJhY3QodG9vbFBvaW50KSxcblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gdmVjdG9yLmdldExlbmd0aCgpO1xuXHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IChtaW5EaXN0YW5jZSB8fCAwKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRpZiAobWF4RGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdHB0ID0gdG9vbFBvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKFxuXHRcdFx0XHRcdFx0XHRcdE1hdGgubWluKGRpc3RhbmNlLCBtYXhEaXN0YW5jZSkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9vbC5fbW92ZUNvdW50Kys7XG5cdFx0XHR9XG5cdFx0XHR0b29sLl9wb2ludCA9IHB0O1xuXHRcdFx0dG9vbC5fbGFzdFBvaW50ID0gdG9vbFBvaW50IHx8IHB0O1xuXHRcdFx0aWYgKG1vdXNlLmRvd24pIHtcblx0XHRcdFx0dG9vbC5fbW92ZUNvdW50ID0gLTE7XG5cdFx0XHRcdHRvb2wuX2Rvd25Qb2ludCA9IHB0O1xuXHRcdFx0XHR0b29sLl9kb3duQ291bnQrKztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVtaXQoKSB7XG5cdFx0XHRpZiAocmVzcG9uZHMpIHtcblx0XHRcdFx0Y2FsbGVkID0gdG9vbC5lbWl0KHR5cGUsIG5ldyBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpKVxuXHRcdFx0XHRcdFx0fHwgY2FsbGVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtb3VzZS5kb3duKSB7XG5cdFx0XHR1cGRhdGUoKTtcblx0XHRcdGVtaXQoKTtcblx0XHR9IGVsc2UgaWYgKG1vdXNlLnVwKSB7XG5cdFx0XHR1cGRhdGUobnVsbCwgbWF4RGlzdGFuY2UpO1xuXHRcdFx0ZW1pdCgpO1xuXHRcdH0gZWxzZSBpZiAocmVzcG9uZHMpIHtcblx0XHRcdHdoaWxlICh1cGRhdGUobWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSlcblx0XHRcdFx0ZW1pdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FsbGVkO1xuXHR9XG5cbn0pO1xuXG52YXIgVHdlZW4gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1R3ZWVuJyxcblxuXHRzdGF0aWNzOiB7XG5cdFx0ZWFzaW5nczogbmV3IEJhc2Uoe1xuXHRcdFx0bGluZWFyOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCAqICgyIC0gdCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0IDwgMC41XG5cdFx0XHRcdFx0PyAyICogdCAqIHRcblx0XHRcdFx0XHQ6IC0xICsgMiAqICgyIC0gdCkgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgPCAwLjVcblx0XHRcdFx0XHQ/IDQgKiB0ICogdCAqIHRcblx0XHRcdFx0XHQ6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJblF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZU91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiAxIC0gKC0tdCkgKiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCA8IDAuNVxuXHRcdFx0XHRcdD8gOCAqIHQgKiB0ICogdCAqIHRcblx0XHRcdFx0XHQ6IDEgLSA4ICogKC0tdCkgKiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgPCAwLjVcblx0XHRcdFx0XHQ/IDE2ICogdCAqIHQgKiB0ICogdCAqIHRcblx0XHRcdFx0XHQ6IDEgKyAxNiAqICgtLXQpICogdCAqIHQgKiB0ICogdDtcblx0XHRcdH1cblx0XHR9KVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFR3ZWVuKG9iamVjdCwgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KSB7XG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgZWFzaW5nO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdHlwZSA9PT0gJ2Z1bmN0aW9uJztcblx0XHR0aGlzLnR5cGUgPSBpc0Z1bmN0aW9uXG5cdFx0XHQ/IHR5cGVcblx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0PyBlYXNpbmdcblx0XHRcdFx0OiAnbGluZWFyJztcblx0XHR0aGlzLmVhc2luZyA9IGlzRnVuY3Rpb24gPyBlYXNpbmcgOiBUd2Vlbi5lYXNpbmdzW3RoaXMudHlwZV07XG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fdGhlbiA9IG51bGw7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblx0XHR2YXIgc3RhdGUgPSBmcm9tIHx8IHRvO1xuXHRcdHRoaXMuX2tleXMgPSBzdGF0ZSA/IE9iamVjdC5rZXlzKHN0YXRlKSA6IFtdO1xuXHRcdHRoaXMuX3BhcnNlZEtleXMgPSB0aGlzLl9wYXJzZUtleXModGhpcy5fa2V5cyk7XG5cdFx0dGhpcy5fZnJvbSA9IHN0YXRlICYmIHRoaXMuX2dldFN0YXRlKGZyb20pO1xuXHRcdHRoaXMuX3RvID0gc3RhdGUgJiYgdGhpcy5fZ2V0U3RhdGUodG8pO1xuXHRcdGlmIChzdGFydCAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHR9XG5cdH0sXG5cblx0dGhlbjogZnVuY3Rpb24odGhlbikge1xuXHRcdHRoaXMuX3RoZW4gPSB0aGVuO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihwcm9ncmVzcykge1xuXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcblx0XHRcdGlmIChwcm9ncmVzcyA+PSAxKSB7XG5cdFx0XHRcdHByb2dyZXNzID0gMTtcblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmYWN0b3IgPSB0aGlzLmVhc2luZyhwcm9ncmVzcyksXG5cdFx0XHRcdGtleXMgPSB0aGlzLl9rZXlzLFxuXHRcdFx0XHRnZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0PyB2YWx1ZShmYWN0b3IsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cyAmJiBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXSxcblx0XHRcdFx0XHRmcm9tID0gZ2V0VmFsdWUodGhpcy5fZnJvbVtrZXldKSxcblx0XHRcdFx0XHR0byA9IGdldFZhbHVlKHRoaXMuX3RvW2tleV0pLFxuXHRcdFx0XHRcdHZhbHVlID0gKGZyb20gJiYgdG8gJiYgZnJvbS5fX2FkZCAmJiB0by5fX2FkZClcblx0XHRcdFx0XHRcdD8gdG8uX19zdWJ0cmFjdChmcm9tKS5fX211bHRpcGx5KGZhY3RvcikuX19hZGQoZnJvbSlcblx0XHRcdFx0XHRcdDogKCh0byAtIGZyb20pICogZmFjdG9yKSArIGZyb207XG5cdFx0XHRcdHRoaXMuX3NldFByb3BlcnR5KHRoaXMuX3BhcnNlZEtleXNba2V5XSwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5yZXNwb25kcygndXBkYXRlJykpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgQmFzZSh7XG5cdFx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzLFxuXHRcdFx0XHRcdGZhY3RvcjogZmFjdG9yXG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5ydW5uaW5nICYmIHRoaXMuX3RoZW4pIHtcblx0XHRcdFx0dGhpcy5fdGhlbih0aGlzLm9iamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9ldmVudHM6IHtcblx0XHRvblVwZGF0ZToge31cblx0fSxcblxuXHRfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0cHJvZ3Jlc3MgPSBzdGFydFRpbWVcblx0XHRcdFx0PyAodGltZSAtIHN0YXJ0VGltZSkgLyB0aGlzLmR1cmF0aW9uXG5cdFx0XHRcdDogMDtcblx0XHRpZiAoIXN0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGUocHJvZ3Jlc3MpO1xuXHR9LFxuXG5cdF9nZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX2tleXMsXG5cdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXSxcblx0XHRcdFx0cGF0aCA9IHRoaXMuX3BhcnNlZEtleXNba2V5XSxcblx0XHRcdFx0Y3VycmVudCA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgpLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0XHR2YXIgcmVzb2x2ZWQgPSB0aGlzLl9yZXNvbHZlVmFsdWUoY3VycmVudCwgc3RhdGVba2V5XSk7XG5cdFx0XHRcdHRoaXMuX3NldFByb3BlcnR5KHBhdGgsIHJlc29sdmVkKTtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoKTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS5jbG9uZSA/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fc2V0UHJvcGVydHkocGF0aCwgY3VycmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGN1cnJlbnQgJiYgY3VycmVudC5jbG9uZSA/IGN1cnJlbnQuY2xvbmUoKSA6IGN1cnJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9yZXNvbHZlVmFsdWU6IGZ1bmN0aW9uKGN1cnJlbnQsIHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdHZhciBvcGVyYXRvciA9IHZhbHVlWzBdO1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdG9wZXJhdG9yICYmXG5cdFx0XHRcdFx0b3BlcmF0b3IubWF0Y2ggJiZcblx0XHRcdFx0XHRvcGVyYXRvci5tYXRjaCgvXlsrXFwtXFwqXFwvXT0vKVxuXHRcdFx0XHQpXG5cdFx0XHRcdFx0PyB0aGlzLl9jYWxjdWxhdGUoY3VycmVudCwgb3BlcmF0b3JbMF0sIHZhbHVlWzFdKVxuXHRcdFx0XHRcdDogdmFsdWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmFyIG1hdGNoID0gdmFsdWUubWF0Y2goL15bK1xcLSovXT0oLiopLyk7XG5cdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKG1hdGNoWzFdLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHQvKFsnXCJdKT8oW2EtekEtWjAtOV9dKykoWydcIl0pPzovZyxcblx0XHRcdFx0XHRcdCdcIiQyXCI6ICdcblx0XHRcdFx0XHQpKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY3VsYXRlKGN1cnJlbnQsIHZhbHVlWzBdLCBwYXJzZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblxuXHRfY2FsY3VsYXRlOiBmdW5jdGlvbihsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcblx0XHRyZXR1cm4gcGFwZXIuUGFwZXJTY3JpcHQuY2FsY3VsYXRlQmluYXJ5KGxlZnQsIG9wZXJhdG9yLCByaWdodCk7XG5cdH0sXG5cblx0X3BhcnNlS2V5czogZnVuY3Rpb24oa2V5cykge1xuXHRcdHZhciBwYXJzZWQgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXSxcblx0XHRcdFx0cGF0aCA9IGtleVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXC4oW14uXSopL2csICcvJDEnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXFtbJ1wiXT8oW14nXCJcXF1dKilbJ1wiXT9cXF0vZywgJy8kMScpO1xuXHRcdFx0cGFyc2VkW2tleV0gPSBwYXRoLnNwbGl0KCcvJyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZWQ7XG5cdH0sXG5cblx0X2dldFByb3BlcnR5OiBmdW5jdGlvbihwYXRoLCBvZmZzZXQpIHtcblx0XHR2YXIgb2JqID0gdGhpcy5vYmplY3Q7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aCAtIChvZmZzZXQgfHwgMCk7IGkgPCBsICYmIG9iajsgaSsrKSB7XG5cdFx0XHRvYmogPSBvYmpbcGF0aFtpXV07XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0X3NldFByb3BlcnR5OiBmdW5jdGlvbihwYXRoLCB2YWx1ZSkge1xuXHRcdHZhciBkZXN0ID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCwgMSk7XG5cdFx0aWYgKGRlc3QpIHtcblx0XHRcdGRlc3RbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbHVlO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBIdHRwID0ge1xuXHRyZXF1ZXN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHhociA9IG5ldyBzZWxmLlhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oKG9wdGlvbnMubWV0aG9kIHx8ICdnZXQnKS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLnVybCxcblx0XHRcdFx0QmFzZS5waWNrKG9wdGlvbnMuYXN5bmMsIHRydWUpKTtcblx0XHRpZiAob3B0aW9ucy5taW1lVHlwZSlcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKG9wdGlvbnMubWltZVR5cGUpO1xuXHRcdHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXHRcdFx0aWYgKHN0YXR1cyA9PT0gMCB8fCBzdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5vbkxvYWQpIHtcblx0XHRcdFx0XHRvcHRpb25zLm9uTG9hZC5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHhoci5vbmVycm9yKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXMsXG5cdFx0XHRcdG1lc3NhZ2UgPSAnQ291bGQgbm90IGxvYWQgXCInICsgb3B0aW9ucy51cmwgKyAnXCIgKFN0YXR1czogJ1xuXHRcdFx0XHRcdFx0KyBzdGF0dXMgKyAnKSc7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yKSB7XG5cdFx0XHRcdG9wdGlvbnMub25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHhoci5zZW5kKG51bGwpO1xuXHR9XG59O1xuXG52YXIgQ2FudmFzUHJvdmlkZXIgPSBCYXNlLmV4cG9ydHMuQ2FudmFzUHJvdmlkZXIgPSB7XG5cdGNhbnZhc2VzOiBbXSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoIXdpbmRvdylcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBjYW52YXMsXG5cdFx0XHRjbGVhciA9IHRydWU7XG5cdFx0aWYgKHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGhlaWdodCA9IHdpZHRoLmhlaWdodDtcblx0XHRcdHdpZHRoID0gd2lkdGgud2lkdGg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNhbnZhc2VzLmxlbmd0aCkge1xuXHRcdFx0Y2FudmFzID0gdGhpcy5jYW52YXNlcy5wb3AoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0XHRjbGVhciA9IGZhbHNlO1xuXHRcdH1cblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2FudmFzICcgKyBjYW52YXMgK1xuXHRcdFx0XHRcdCcgaXMgdW5hYmxlIHRvIHByb3ZpZGUgYSAyRCBjb250ZXh0LicpO1xuXHRcdH1cblx0XHRpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcblx0XHRcdGlmIChjbGVhcilcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCArIDEsIGhlaWdodCArIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fSxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXHRcdHJldHVybiBjYW52YXMgPyBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGNhbnZhcyA9IG9iaiAmJiBvYmouY2FudmFzID8gb2JqLmNhbnZhcyA6IG9iajtcblx0XHRpZiAoY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0XHRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5yZXN0b3JlKCk7XG5cdFx0XHR0aGlzLmNhbnZhc2VzLnB1c2goY2FudmFzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBCbGVuZE1vZGUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtaW4gPSBNYXRoLm1pbixcblx0XHRtYXggPSBNYXRoLm1heCxcblx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRzciwgc2csIHNiLCBzYSxcblx0XHRiciwgYmcsIGJiLCBiYSxcblx0XHRkciwgZGcsIGRiO1xuXG5cdGZ1bmN0aW9uIGdldEx1bShyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMdW0ociwgZywgYiwgbCkge1xuXHRcdHZhciBkID0gbCAtIGdldEx1bShyLCBnLCBiKTtcblx0XHRkciA9IHIgKyBkO1xuXHRcdGRnID0gZyArIGQ7XG5cdFx0ZGIgPSBiICsgZDtcblx0XHR2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcblx0XHRcdG1uID0gbWluKGRyLCBkZywgZGIpLFxuXHRcdFx0bXggPSBtYXgoZHIsIGRnLCBkYik7XG5cdFx0aWYgKG1uIDwgMCkge1xuXHRcdFx0dmFyIGxtbiA9IGwgLSBtbjtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbCAvIGxtbjtcblx0XHR9XG5cdFx0aWYgKG14ID4gMjU1KSB7XG5cdFx0XHR2YXIgbG4gPSAyNTUgLSBsLFxuXHRcdFx0XHRteGwgPSBteCAtIGw7XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbG4gLyBteGw7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2F0KHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gbWF4KHIsIGcsIGIpIC0gbWluKHIsIGcsIGIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcblx0XHR2YXIgY29sID0gW3IsIGcsIGJdLFxuXHRcdFx0bXggPSBtYXgociwgZywgYiksXG5cdFx0XHRtbiA9IG1pbihyLCBnLCBiKSxcblx0XHRcdG1kO1xuXHRcdG1uID0gbW4gPT09IHIgPyAwIDogbW4gPT09IGcgPyAxIDogMjtcblx0XHRteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG5cdFx0bWQgPSBtaW4obW4sIG14KSA9PT0gMCA/IG1heChtbiwgbXgpID09PSAxID8gMiA6IDEgOiAwO1xuXHRcdGlmIChjb2xbbXhdID4gY29sW21uXSkge1xuXHRcdFx0Y29sW21kXSA9IChjb2xbbWRdIC0gY29sW21uXSkgKiBzIC8gKGNvbFtteF0gLSBjb2xbbW5dKTtcblx0XHRcdGNvbFtteF0gPSBzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2xbbWRdID0gY29sW214XSA9IDA7XG5cdFx0fVxuXHRcdGNvbFttbl0gPSAwO1xuXHRcdGRyID0gY29sWzBdO1xuXHRcdGRnID0gY29sWzFdO1xuXHRcdGRiID0gY29sWzJdO1xuXHR9XG5cblx0dmFyIG1vZGVzID0ge1xuXHRcdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKiBzciAvIDI1NTtcblx0XHRcdGRnID0gYmcgKiBzZyAvIDI1NTtcblx0XHRcdGRiID0gYmIgKiBzYiAvIDI1NTtcblx0XHR9LFxuXG5cdFx0c2NyZWVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAtIChiciAqIHNyIC8gMjU1KTtcblx0XHRcdGRnID0gYmcgKyBzZyAtIChiZyAqIHNnIC8gMjU1KTtcblx0XHRcdGRiID0gYmIgKyBzYiAtIChiYiAqIHNiIC8gMjU1KTtcblx0XHR9LFxuXG5cdFx0b3ZlcmxheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgMTI4ID8gMiAqIGJyICogc3IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnIDwgMTI4ID8gMiAqIGJnICogc2cgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiIDwgMTI4ID8gMiAqIGJiICogc2IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdzb2Z0LWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdCA9IHNyICogYnIgLyAyNTU7XG5cdFx0XHRkciA9IHQgKyBiciAqICgyNTUgLSAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNnICogYmcgLyAyNTU7XG5cdFx0XHRkZyA9IHQgKyBiZyAqICgyNTUgLSAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNiICogYmIgLyAyNTU7XG5cdFx0XHRkYiA9IHQgKyBiYiAqICgyNTUgLSAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnaGFyZC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnY29sb3ItZG9kZ2UnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDAgPyAwIDogc3IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJyIC8gKDI1NSAtIHNyKSk7XG5cdFx0XHRkZyA9IGJnID09PSAwID8gMCA6IHNnID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiZyAvICgyNTUgLSBzZykpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMCA/IDAgOiBzYiA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmIgLyAoMjU1IC0gc2IpKTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWJ1cm4nOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDI1NSA/IDI1NSA6IHNyID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYnIpICogMjU1IC8gc3IpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMjU1ID8gMjU1IDogc2cgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiZykgKiAyNTUgLyBzZyk7XG5cdFx0XHRkYiA9IGJiID09PSAyNTUgPyAyNTUgOiBzYiA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJiKSAqIDI1NSAvIHNiKTtcblx0XHR9LFxuXG5cdFx0ZGFya2VuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0bGlnaHRlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID4gc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA+IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPiBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGRpZmZlcmVuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAtIHNyO1xuXHRcdFx0aWYgKGRyIDwgMClcblx0XHRcdFx0ZHIgPSAtZHI7XG5cdFx0XHRkZyA9IGJnIC0gc2c7XG5cdFx0XHRpZiAoZGcgPCAwKVxuXHRcdFx0XHRkZyA9IC1kZztcblx0XHRcdGRiID0gYmIgLSBzYjtcblx0XHRcdGlmIChkYiA8IDApXG5cdFx0XHRcdGRiID0gLWRiO1xuXHRcdH0sXG5cblx0XHRleGNsdXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRodWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KHNyLCBzZywgc2IsIGdldFNhdChiciwgYmcsIGJiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0c2F0dXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoYnIsIGJnLCBiYiwgZ2V0U2F0KHNyLCBzZywgc2IpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuXHRcdH0sXG5cblx0XHRjb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oc3IsIHNnLCBzYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWluKGJyICsgc3IsIDI1NSk7XG5cdFx0XHRkZyA9IG1pbihiZyArIHNnLCAyNTUpO1xuXHRcdFx0ZGIgPSBtaW4oYmIgKyBzYiwgMjU1KTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtYXgoYnIgLSBzciwgMCk7XG5cdFx0XHRkZyA9IG1heChiZyAtIHNnLCAwKTtcblx0XHRcdGRiID0gbWF4KGJiIC0gc2IsIDApO1xuXHRcdH0sXG5cblx0XHRhdmVyYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gKGJyICsgc3IpIC8gMjtcblx0XHRcdGRnID0gKGJnICsgc2cpIC8gMjtcblx0XHRcdGRiID0gKGJiICsgc2IpIC8gMjtcblx0XHR9LFxuXG5cdFx0bmVnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAyNTUgLSBhYnMoMjU1IC0gc3IgLSBicik7XG5cdFx0XHRkZyA9IDI1NSAtIGFicygyNTUgLSBzZyAtIGJnKTtcblx0XHRcdGRiID0gMjU1IC0gYWJzKDI1NSAtIHNiIC0gYmIpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFtcblx0XHQnc291cmNlLW92ZXInLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLCAnc291cmNlLWF0b3AnLFxuXHRcdCdkZXN0aW5hdGlvbi1vdmVyJywgJ2Rlc3RpbmF0aW9uLWluJywgJ2Rlc3RpbmF0aW9uLW91dCcsXG5cdFx0J2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXG5cdF0sIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHR0aGlzW21vZGVdID0gdHJ1ZTtcblx0fSwge30pO1xuXG5cdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRpZiAoY3R4KSB7XG5cdFx0QmFzZS5lYWNoKG1vZGVzLCBmdW5jdGlvbihmdW5jLCBtb2RlKSB7XG5cdFx0XHR2YXIgZGFya2VuID0gbW9kZSA9PT0gJ2RhcmtlbicsXG5cdFx0XHRcdG9rID0gZmFsc2U7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjMzAwJyA6ICcjYTAwJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdFx0aWYgKGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT09IG1vZGUpIHtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyNhMDAnIDogJyMzMDAnO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0XHRvayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVswXSAhPT0gZGFya2VuXG5cdFx0XHRcdFx0XHRcdD8gMTcwIDogNTE7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0bmF0aXZlTW9kZXNbbW9kZV0gPSBvaztcblx0XHR9KTtcblx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdH1cblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihtb2RlLCBzcmNDb250ZXh0LCBkc3RDb250ZXh0LCBhbHBoYSwgb2Zmc2V0KSB7XG5cdFx0dmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuXHRcdFx0bm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG5cdFx0aWYgKG5vcm1hbCB8fCBuYXRpdmVNb2Rlc1ttb2RlXSkge1xuXHRcdFx0ZHN0Q29udGV4dC5zYXZlKCk7XG5cdFx0XHRkc3RDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICghbm9ybWFsKVxuXHRcdFx0XHRkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0XHRkc3RDb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHByb2Nlc3MgPSBtb2Rlc1ttb2RlXTtcblx0XHRcdGlmICghcHJvY2Vzcylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KSxcblx0XHRcdFx0ZHN0ID0gZHN0RGF0YS5kYXRhLFxuXHRcdFx0XHRzcmMgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0XHRzciA9IHNyY1tpXTtcblx0XHRcdFx0YnIgPSBkc3RbaV07XG5cdFx0XHRcdHNnID0gc3JjW2kgKyAxXTtcblx0XHRcdFx0YmcgPSBkc3RbaSArIDFdO1xuXHRcdFx0XHRzYiA9IHNyY1tpICsgMl07XG5cdFx0XHRcdGJiID0gZHN0W2kgKyAyXTtcblx0XHRcdFx0c2EgPSBzcmNbaSArIDNdO1xuXHRcdFx0XHRiYSA9IGRzdFtpICsgM107XG5cdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0dmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcblx0XHRcdFx0XHRhMiA9IDEgLSBhMTtcblx0XHRcdFx0ZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG5cdFx0XHRcdGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcblx0XHRcdFx0ZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuXHRcdFx0XHRkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG5cdFx0XHR9XG5cdFx0XHRkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBTdmdFbGVtZW50ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgc3ZnID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHR4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJyxcblx0XHR4bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHRhdHRyaWJ1dGVOYW1lc3BhY2UgPSB7XG5cdFx0XHRocmVmOiB4bGluayxcblx0XHRcdHhsaW5rOiB4bWxucyxcblx0XHRcdHhtbG5zOiB4bWxucyArICcvJyxcblx0XHRcdCd4bWxuczp4bGluayc6IHhtbG5zICsgJy8nXG5cdFx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGUodGFnLCBhdHRyaWJ1dGVzLCBmb3JtYXR0ZXIpIHtcblx0XHRyZXR1cm4gc2V0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmcsIHRhZyksIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXQobm9kZSwgbmFtZSkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IG5hbWVzcGFjZVxuXHRcdFx0XHQ/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKVxuXHRcdFx0XHQ6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ251bGwnID8gbnVsbCA6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG5vZGUsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0dmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdFx0bmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlW25hbWVdO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgZm9ybWF0dGVyKVxuXHRcdFx0XHR2YWx1ZSA9IGZvcm1hdHRlci5udW1iZXIodmFsdWUpO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3ZnOiBzdmcsXG5cdFx0eG1sbnM6IHhtbG5zLFxuXHRcdHhsaW5rOiB4bGluayxcblxuXHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdGdldDogZ2V0LFxuXHRcdHNldDogc2V0XG5cdH07XG59O1xuXG52YXIgU3ZnU3R5bGVzID0gQmFzZS5lYWNoKHtcblx0ZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcblx0ZmlsbFJ1bGU6IFsnZmlsbC1ydWxlJywgJ3N0cmluZyddLFxuXHRzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcblx0c3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuXHRzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuXHRzdHJva2VTY2FsaW5nOiBbJ3ZlY3Rvci1lZmZlY3QnLCAnbG9va3VwJywge1xuXHRcdHRydWU6ICdub25lJyxcblx0XHRmYWxzZTogJ25vbi1zY2FsaW5nLXN0cm9rZSdcblx0fSwgZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdCYmIChpdGVtIGluc3RhbmNlb2YgUGF0aEl0ZW1cblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgU2hhcGVcblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuXHR9XSxcblx0bWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcblx0ZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcblx0ZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcblx0Zm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcblx0Zm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcblx0Zm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuXHRqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcblx0XHRsZWZ0OiAnc3RhcnQnLFxuXHRcdGNlbnRlcjogJ21pZGRsZScsXG5cdFx0cmlnaHQ6ICdlbmQnXG5cdH1dLFxuXHRvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG5cdGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHlsZSddXG59LCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0bG9va3VwID0gZW50cnlbMl07XG5cdHRoaXNba2V5XSA9IHtcblx0XHR0eXBlOiBlbnRyeVsxXSxcblx0XHRwcm9wZXJ0eToga2V5LFxuXHRcdGF0dHJpYnV0ZTogZW50cnlbMF0sXG5cdFx0dG9TVkc6IGxvb2t1cCxcblx0XHRmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHRoaXNbdmFsdWVdID0gbmFtZTtcblx0XHR9LCB7fSksXG5cdFx0ZXhwb3J0RmlsdGVyOiBlbnRyeVszXSxcblx0XHRnZXQ6ICdnZXQnICsgcGFydCxcblx0XHRzZXQ6ICdzZXQnICsgcGFydFxuXHR9O1xufSwge30pO1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBmb3JtYXR0ZXI7XG5cblx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKG1hdHJpeCwgY29vcmRpbmF0ZXMsIGNlbnRlcikge1xuXHRcdHZhciBhdHRycyA9IG5ldyBCYXNlKCksXG5cdFx0XHR0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdGlmIChjb29yZGluYXRlcykge1xuXHRcdFx0dmFyIHBvaW50O1xuXHRcdFx0aWYgKG1hdHJpeC5pc0ludmVydGlibGUoKSkge1xuXHRcdFx0XHRtYXRyaXggPSBtYXRyaXguX3NoaWZ0bGVzcygpO1xuXHRcdFx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG5cdFx0XHRcdHRyYW5zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gbmV3IFBvaW50KCk7XG5cdFx0XHR9XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG5cdFx0fVxuXHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCkge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdFx0XHRhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG5cdFx0XHRcdFx0c2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmcsXG5cdFx0XHRcdFx0c2tldyA9IGRlY29tcG9zZWQuc2tld2luZztcblx0XHRcdFx0aWYgKHRyYW5zICYmICF0cmFucy5pc1plcm8oKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCd0cmFuc2xhdGUoJyArIGZvcm1hdHRlci5wb2ludCh0cmFucykgKyAnKScpO1xuXHRcdFx0XHRpZiAoYW5nbGUpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgncm90YXRlKCcgKyBmb3JtYXR0ZXIubnVtYmVyKGFuZ2xlKSArICcpJyk7XG5cdFx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcblx0XHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArJyknKTtcblx0XHRcdFx0aWYgKHNrZXcueClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdza2V3WCgnICsgZm9ybWF0dGVyLm51bWJlcihza2V3LngpICsgJyknKTtcblx0XHRcdFx0aWYgKHNrZXcueSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdza2V3WSgnICsgZm9ybWF0dGVyLm51bWJlcihza2V3LnkpICsgJyknKTtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgbWF0cml4LmdldFZhbHVlcygpLmpvaW4oJywnKSArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGF0dHJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JvdXAoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpLFxuXHRcdFx0Y2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcblx0XHR2YXIgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdnJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IGV4cG9ydFNWRyhjaGlsZCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAoY2hpbGROb2RlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc0NsaXBNYXNrKCkpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdjbGlwUGF0aCcpO1xuXHRcdFx0XHRcdGNsaXAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0XHRzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuXHRcdFx0XHRcdFN2Z0VsZW1lbnQuc2V0KG5vZGUsIHtcblx0XHRcdFx0XHRcdCdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzaXplID0gaXRlbS5nZXRTaXplKCksXG5cdFx0XHRpbWFnZSA9IGl0ZW0uZ2V0SW1hZ2UoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gb3B0aW9ucy5lbWJlZEltYWdlcyA9PSBmYWxzZSAmJiBpbWFnZSAmJiBpbWFnZS5zcmNcblx0XHRcdFx0fHwgaXRlbS50b0RhdGFVUkwoKTtcblx0XHRyZXR1cm4gU3ZnRWxlbWVudC5jcmVhdGUoJ2ltYWdlJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgbWF0Y2hTaGFwZXMgPSBvcHRpb25zLm1hdGNoU2hhcGVzO1xuXHRcdGlmIChtYXRjaFNoYXBlcykge1xuXHRcdFx0dmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcblx0XHRcdGlmIChzaGFwZSlcblx0XHRcdFx0cmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHR0eXBlLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHRpZiAobWF0Y2hTaGFwZXMgJiYgbGVuZ3RoID49IDIgJiYgIWl0ZW0uaGFzSGFuZGxlcygpKSB7XG5cdFx0XHRpZiAobGVuZ3RoID4gMikge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRycy5wb2ludHMgPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ2xpbmUnO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0ZW5kID0gc2VnbWVudHNbMV0uX3BvaW50O1xuXHRcdFx0XHRhdHRycy5zZXQoe1xuXHRcdFx0XHRcdHgxOiBzdGFydC54LFxuXHRcdFx0XHRcdHkxOiBzdGFydC55LFxuXHRcdFx0XHRcdHgyOiBlbmQueCxcblx0XHRcdFx0XHR5MjogZW5kLnlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR5cGUgPSAncGF0aCc7XG5cdFx0XHRhdHRycy5kID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0fVxuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSh0eXBlLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNoYXBlKGl0ZW0pIHtcblx0XHR2YXIgdHlwZSA9IGl0ZW0uX3R5cGUsXG5cdFx0XHRyYWRpdXMgPSBpdGVtLl9yYWRpdXMsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUsIHR5cGUgIT09ICdyZWN0YW5nbGUnKTtcblx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdHR5cGUgPSAncmVjdCc7XG5cdFx0XHR2YXIgc2l6ZSA9IGl0ZW0uX3NpemUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRhdHRycy54IC09IHdpZHRoIC8gMjtcblx0XHRcdGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcblx0XHRcdGF0dHJzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRhdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRyYWRpdXMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0YXR0cnMuciA9IHJhZGl1cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnJ4ID0gcmFkaXVzLndpZHRoO1xuXHRcdFx0XHRhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSh0eXBlLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0dmFyIGRhdGEgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRpZiAoZGF0YSlcblx0XHRcdGF0dHJzLmQgPSBkYXRhO1xuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgncGF0aCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U3ltYm9sSXRlbShpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRkZWZpbml0aW9uID0gaXRlbS5fZGVmaW5pdGlvbixcblx0XHRcdG5vZGUgPSBnZXREZWZpbml0aW9uKGRlZmluaXRpb24sICdzeW1ib2wnKSxcblx0XHRcdGRlZmluaXRpb25JdGVtID0gZGVmaW5pdGlvbi5faXRlbSxcblx0XHRcdGJvdW5kcyA9IGRlZmluaXRpb25JdGVtLmdldFN0cm9rZUJvdW5kcygpO1xuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0bm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzeW1ib2wnLCB7XG5cdFx0XHRcdHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuXHRcdFx0fSk7XG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uSXRlbSwgb3B0aW9ucykpO1xuXHRcdFx0c2V0RGVmaW5pdGlvbihkZWZpbml0aW9uLCBub2RlLCAnc3ltYm9sJyk7XG5cdFx0fVxuXHRcdGF0dHJzLmhyZWYgPSAnIycgKyBub2RlLmlkO1xuXHRcdGF0dHJzLnggKz0gYm91bmRzLng7XG5cdFx0YXR0cnMueSArPSBib3VuZHMueTtcblx0XHRhdHRycy53aWR0aCA9IGJvdW5kcy53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuXHRcdGF0dHJzLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgndXNlJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuXHRcdHZhciBncmFkaWVudE5vZGUgPSBnZXREZWZpbml0aW9uKGNvbG9yLCAnY29sb3InKTtcblx0XHRpZiAoIWdyYWRpZW50Tm9kZSkge1xuXHRcdFx0dmFyIGdyYWRpZW50ID0gY29sb3IuZ2V0R3JhZGllbnQoKSxcblx0XHRcdFx0cmFkaWFsID0gZ3JhZGllbnQuX3JhZGlhbCxcblx0XHRcdFx0b3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCksXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29sb3IuZ2V0RGVzdGluYXRpb24oKSxcblx0XHRcdFx0YXR0cnM7XG5cdFx0XHRpZiAocmFkaWFsKSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdGN4OiBvcmlnaW4ueCxcblx0XHRcdFx0XHRjeTogb3JpZ2luLnksXG5cdFx0XHRcdFx0cjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgaGlnaGxpZ2h0ID0gY29sb3IuZ2V0SGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHRhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuXHRcdFx0XHRcdGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHgxOiBvcmlnaW4ueCxcblx0XHRcdFx0XHR5MTogb3JpZ2luLnksXG5cdFx0XHRcdFx0eDI6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHRcdFx0eTI6IGRlc3RpbmF0aW9uLnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuXHRcdFx0Z3JhZGllbnROb2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoKHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicpXG5cdFx0XHRcdFx0KyAnR3JhZGllbnQnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0XHRcdHZhciBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV0sXG5cdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcC5fY29sb3IsXG5cdFx0XHRcdFx0YWxwaGEgPSBzdG9wQ29sb3IuZ2V0QWxwaGEoKSxcblx0XHRcdFx0XHRvZmZzZXQgPSBzdG9wLl9vZmZzZXQ7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdG9mZnNldDogb2Zmc2V0ID09IG51bGwgPyBpIC8gKGwgLSAxKSA6IG9mZnNldFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoc3RvcENvbG9yKVxuXHRcdFx0XHRcdGF0dHJzWydzdG9wLWNvbG9yJ10gPSBzdG9wQ29sb3IudG9DU1ModHJ1ZSk7XG5cdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChcblx0XHRcdFx0XHRcdFN2Z0VsZW1lbnQuY3JlYXRlKCdzdG9wJywgYXR0cnMsIGZvcm1hdHRlcikpO1xuXHRcdFx0fVxuXHRcdFx0c2V0RGVmaW5pdGlvbihjb2xvciwgZ3JhZGllbnROb2RlLCAnY29sb3InKTtcblx0XHR9XG5cdFx0cmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRUZXh0KGl0ZW0pIHtcblx0XHR2YXIgbm9kZSA9IFN2Z0VsZW1lbnQuY3JlYXRlKCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRcdGZvcm1hdHRlcik7XG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uX2NvbnRlbnQ7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHR2YXIgZXhwb3J0ZXJzID0ge1xuXHRcdEdyb3VwOiBleHBvcnRHcm91cCxcblx0XHRMYXllcjogZXhwb3J0R3JvdXAsXG5cdFx0UmFzdGVyOiBleHBvcnRSYXN0ZXIsXG5cdFx0UGF0aDogZXhwb3J0UGF0aCxcblx0XHRTaGFwZTogZXhwb3J0U2hhcGUsXG5cdFx0Q29tcG91bmRQYXRoOiBleHBvcnRDb21wb3VuZFBhdGgsXG5cdFx0U3ltYm9sSXRlbTogZXhwb3J0U3ltYm9sSXRlbSxcblx0XHRQb2ludFRleHQ6IGV4cG9ydFRleHRcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBhdHRycyA9IHt9LFxuXHRcdFx0cGFyZW50ID0gIWlzUm9vdCAmJiBpdGVtLmdldFBhcmVudCgpLFxuXHRcdFx0c3R5bGUgPSBbXTtcblxuXHRcdGlmIChpdGVtLl9uYW1lICE9IG51bGwpXG5cdFx0XHRhdHRycy5pZCA9IGl0ZW0uX25hbWU7XG5cblx0XHRCYXNlLmVhY2goU3ZnU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdFx0dmFyIGdldCA9IGVudHJ5LmdldCxcblx0XHRcdFx0dHlwZSA9IGVudHJ5LnR5cGUsXG5cdFx0XHRcdHZhbHVlID0gaXRlbVtnZXRdKCk7XG5cdFx0XHRpZiAoZW50cnkuZXhwb3J0RmlsdGVyXG5cdFx0XHRcdFx0PyBlbnRyeS5leHBvcnRGaWx0ZXIoaXRlbSwgdmFsdWUpXG5cdFx0XHRcdFx0OiAhcGFyZW50IHx8ICFCYXNlLmVxdWFscyhwYXJlbnRbZ2V0XSgpLCB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb2xvcicgJiYgdmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBhbHBoYSA9IHZhbHVlLmdldEFscGhhKCk7XG5cdFx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZSArICctb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09ICdzdHlsZScpIHtcblx0XHRcdFx0XHRzdHlsZS5wdXNoKGVudHJ5LmF0dHJpYnV0ZSArICc6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlXSA9IHZhbHVlID09IG51bGwgPyAnbm9uZSdcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InID8gdmFsdWUuZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHQ/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWUudG9DU1ModHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknID8gdmFsdWUuam9pbignLCcpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCcgPyBlbnRyeS50b1NWR1t2YWx1ZV1cblx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHN0eWxlLmxlbmd0aClcblx0XHRcdGF0dHJzLnN0eWxlID0gc3R5bGUuam9pbignOycpO1xuXG5cdFx0aWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG5cdFx0XHRkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuXHRcdGlmICghaXRlbS5fdmlzaWJsZSlcblx0XHRcdGF0dHJzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdHJldHVybiBTdmdFbGVtZW50LnNldChub2RlLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucztcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGRlZmluaXRpb25zID0geyBpZHM6IHt9LCBzdmdzOiB7fSB9O1xuXHRcdHJldHVybiBpdGVtICYmIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJ1xuXHRcdFx0XHQrIChpdGVtLl9pZCB8fCBpdGVtLl9faWQgfHwgKGl0ZW0uX19pZCA9IFVJRC5nZXQoJ3N2ZycpKSldO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGdldERlZmluaXRpb24oKTtcblx0XHR2YXIgdHlwZUlkID0gZGVmaW5pdGlvbnMuaWRzW3R5cGVdID0gKGRlZmluaXRpb25zLmlkc1t0eXBlXSB8fCAwKSArIDE7XG5cdFx0bm9kZS5pZCA9IHR5cGUgKyAnLScgKyB0eXBlSWQ7XG5cdFx0ZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCldID0gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ZnID0gbm9kZSxcblx0XHRcdGRlZnMgPSBudWxsO1xuXHRcdGlmIChkZWZpbml0aW9ucykge1xuXHRcdFx0c3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG5cdFx0XHRcdGlmICghZGVmcykge1xuXHRcdFx0XHRcdGlmICghc3ZnKSB7XG5cdFx0XHRcdFx0XHRzdmcgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJyk7XG5cdFx0XHRcdFx0XHRzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKFN2Z0VsZW1lbnQuY3JlYXRlKCdkZWZzJyksXG5cdFx0XHRcdFx0XHRcdHN2Zy5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZzLmFwcGVuZENoaWxkKGRlZmluaXRpb25zLnN2Z3NbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9ucy5hc1N0cmluZ1xuXHRcdFx0XHQ/IG5ldyBzZWxmLlhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpXG5cdFx0XHRcdDogc3ZnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U1ZHKGl0ZW0sIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBleHBvcnRlciA9IGV4cG9ydGVyc1tpdGVtLl9jbGFzc10sXG5cdFx0XHRub2RlID0gZXhwb3J0ZXIgJiYgZXhwb3J0ZXIoaXRlbSwgb3B0aW9ucyk7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHZhciBvbkV4cG9ydCA9IG9wdGlvbnMub25FeHBvcnQ7XG5cdFx0XHRpZiAob25FeHBvcnQpXG5cdFx0XHRcdG5vZGUgPSBvbkV4cG9ydChpdGVtLCBub2RlLCBvcHRpb25zKSB8fCBub2RlO1xuXHRcdFx0dmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShpdGVtLl9kYXRhKTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEgIT09ICd7fScgJiYgZGF0YSAhPT0gJ251bGwnKVxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJywgZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKGV4cG9ydFNWRyh0aGlzLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHRcdGJvdW5kcyA9IEJhc2UucGljayhvcHRpb25zLmJvdW5kcywgJ3ZpZXcnKSxcblx0XHRcdFx0bXggPSBvcHRpb25zLm1hdHJpeCB8fCBib3VuZHMgPT09ICd2aWV3JyAmJiB2aWV3Ll9tYXRyaXgsXG5cdFx0XHRcdG1hdHJpeCA9IG14ICYmIE1hdHJpeC5yZWFkKFtteF0pLFxuXHRcdFx0XHRyZWN0ID0gYm91bmRzID09PSAndmlldydcblx0XHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoWzAsIDBdLCB2aWV3LmdldFZpZXdTaXplKCkpXG5cdFx0XHRcdFx0OiBib3VuZHMgPT09ICdjb250ZW50J1xuXHRcdFx0XHRcdFx0PyBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwgeyBzdHJva2U6IHRydWUgfSlcblx0XHRcdFx0XHRcdFx0LnJlY3Rcblx0XHRcdFx0XHRcdDogUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10sIDAsIHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHZlcnNpb246ICcxLjEnLFxuXHRcdFx0XHRcdHhtbG5zOiBTdmdFbGVtZW50LnN2Zyxcblx0XHRcdFx0XHQneG1sbnM6eGxpbmsnOiBTdmdFbGVtZW50LnhsaW5rLFxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKHJlY3QpIHtcblx0XHRcdFx0YXR0cnMud2lkdGggPSByZWN0LndpZHRoO1xuXHRcdFx0XHRhdHRycy5oZWlnaHQgPSByZWN0LmhlaWdodDtcblx0XHRcdFx0aWYgKHJlY3QueCB8fCByZWN0LnggPT09IDAgfHwgcmVjdC55IHx8IHJlY3QueSA9PT0gMClcblx0XHRcdFx0XHRhdHRycy52aWV3Qm94ID0gZm9ybWF0dGVyLnJlY3RhbmdsZShyZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycsIGF0dHJzLCBmb3JtYXR0ZXIpLFxuXHRcdFx0XHRwYXJlbnQgPSBub2RlO1xuXHRcdFx0aWYgKG1hdHJpeCAmJiAhbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0XHRwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFN2Z0VsZW1lbnQuY3JlYXRlKCdnJyxcblx0XHRcdFx0XHRcdGdldFRyYW5zZm9ybShtYXRyaXgpLCBmb3JtYXR0ZXIpKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChleHBvcnRTVkcoY2hpbGRyZW5baV0sIG9wdGlvbnMsIHRydWUpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9LFxuXHRcdHJvb3RTaXplO1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCxcblx0XHRcdGRlZmF1bHRWYWx1ZSkge1xuXHRcdHZhciB2YWx1ZSA9IFN2Z0VsZW1lbnQuZ2V0KG5vZGUsIG5hbWUpIHx8IGRlZmF1bHRWYWx1ZSxcblx0XHRcdHJlcyA9IHZhbHVlID09IG51bGxcblx0XHRcdFx0PyBhbGxvd051bGxcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IGlzU3RyaW5nID8gJycgOiAwXG5cdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHQ/IHZhbHVlXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKTtcblx0XHRyZXR1cm4gLyVcXHMqJC8udGVzdCh2YWx1ZSlcblx0XHRcdD8gKHJlcyAvIDEwMCkgKiAoYWxsb3dQZXJjZW50ID8gMVxuXHRcdFx0XHQ6IHJvb3RTaXplWy94fF53aWR0aC8udGVzdChuYW1lKSA/ICd3aWR0aCcgOiAnaGVpZ2h0J10pXG5cdFx0XHQ6IHJlcztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvaW50KG5vZGUsIHgsIHksIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WCwgZGVmYXVsdFkpIHtcblx0XHR4ID0gZ2V0VmFsdWUobm9kZSwgeCB8fCAneCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCwgZGVmYXVsdFgpO1xuXHRcdHkgPSBnZXRWYWx1ZShub2RlLCB5IHx8ICd5JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WSk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCB3LCBoLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCkge1xuXHRcdHcgPSBnZXRWYWx1ZShub2RlLCB3IHx8ICd3aWR0aCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCk7XG5cdFx0aCA9IGdldFZhbHVlKG5vZGUsIGggfHwgJ2hlaWdodCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbFxuXHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh2YWx1ZSlcblx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknID9cblx0XHRcdFx0XHR2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdXG5cdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJyA/IGdldERlZmluaXRpb24odmFsdWUpIHx8IHZhbHVlXG5cdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCcgPyBsb29rdXBbdmFsdWVdXG5cdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRpc0NsaXAgPSB0eXBlID09PSAnY2xpcHBhdGgnLFxuXHRcdFx0aXNEZWZzID0gdHlwZSA9PT0gJ2RlZnMnLFxuXHRcdFx0aXRlbSA9IG5ldyBHcm91cCgpLFxuXHRcdFx0cHJvamVjdCA9IGl0ZW0uX3Byb2plY3QsXG5cdFx0XHRjdXJyZW50U3R5bGUgPSBwcm9qZWN0Ll9jdXJyZW50U3R5bGUsXG5cdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdGlmICghaXNDbGlwICYmICFpc0RlZnMpIHtcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdHZhciBkZWZzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRlZnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGltcG9ydE5vZGUoZGVmc1tpXSwgb3B0aW9ucywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IG5vZGVzW2ldLFxuXHRcdFx0XHRjaGlsZDtcblx0XHRcdGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDFcblx0XHRcdFx0XHQmJiAhL15kZWZzJC9pLnRlc3QoY2hpbGROb2RlLm5vZGVOYW1lKVxuXHRcdFx0XHRcdCYmIChjaGlsZCA9IGltcG9ydE5vZGUoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24pKVxuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHR9XG5cdFx0aXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0aWYgKGlzQ2xpcClcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbS5yZWR1Y2UoKSwgbm9kZSwgaXNSb290KTtcblx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGU7XG5cdFx0aWYgKGlzQ2xpcCB8fCBpc0RlZnMpIHtcblx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgY29vcmRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLm1hdGNoKFxuXHRcdFx0XHRcdC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaSArIDFdKSkpO1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcblx0XHRpZiAodHlwZSA9PT0gJ3BvbHlnb24nKVxuXHRcdFx0cGF0aC5jbG9zZVBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuXHRcdHJldHVybiBQYXRoSXRlbS5jcmVhdGUobm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdHJhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG5cdFx0XHRncmFkaWVudDtcblx0XHRpZiAoaWQpIHtcblx0XHRcdGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cdFx0XHRpZiAoZ3JhZGllbnQuX3JhZGlhbCBeIHJhZGlhbCkge1xuXHRcdFx0XHRncmFkaWVudCA9IGdyYWRpZW50LmNsb25lKCk7XG5cdFx0XHRcdGdyYWRpZW50Ll9yYWRpYWwgPSByYWRpYWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3RvcHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0c3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdFx0Z3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIHJhZGlhbCk7XG5cdFx0fVxuXHRcdHZhciBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQsXG5cdFx0XHRzY2FsZVRvQm91bmRzID0gZ2V0VmFsdWUobm9kZSwgJ2dyYWRpZW50VW5pdHMnLCB0cnVlKSAhPT1cblx0XHRcdFx0J3VzZXJTcGFjZU9uVXNlJztcblx0XHRpZiAocmFkaWFsKSB7XG5cdFx0XHRvcmlnaW4gPSBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knLCBmYWxzZSwgc2NhbGVUb0JvdW5kcyxcblx0XHRcdFx0JzUwJScsICc1MCUnKTtcblx0XHRcdGRlc3RpbmF0aW9uID0gb3JpZ2luLmFkZChcblx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InLCBmYWxzZSwgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsICc1MCUnKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlLCBzY2FsZVRvQm91bmRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMsXG5cdFx0XHRcdCcwJScsICcwJScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInLCBmYWxzZSwgc2NhbGVUb0JvdW5kcyxcblx0XHRcdFx0JzEwMCUnLCAnMCUnKTtcblx0XHR9XG5cdFx0dmFyIGNvbG9yID0gYXBwbHlBdHRyaWJ1dGVzKFxuXHRcdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdGNvbG9yLl9zY2FsZVRvQm91bmRzID0gc2NhbGVUb0JvdW5kcztcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpbXBvcnRlcnMgPSB7XG5cdFx0JyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0cmV0dXJuIGltcG9ydE5vZGUoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBnZXRTaXplKG5vZGUpO1xuXHRcdFx0XHR0aGlzLnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRQb2ludChub2RlKS5hZGQoc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9tYXRyaXguYXBwZW5kKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByYXN0ZXI7XG5cdFx0fSxcblxuXHRcdHN5bWJvbDogZnVuY3Rpb24obm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN5bWJvbERlZmluaXRpb24oXG5cdFx0XHRcdFx0aW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdGRlZnM6IGltcG9ydEdyb3VwLFxuXG5cdFx0dXNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0XHRkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbaWRdLFxuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KG5vZGUpO1xuXHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0XHQ/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uXG5cdFx0XHRcdFx0XHQ/IGRlZmluaXRpb24ucGxhY2UocG9pbnQpXG5cdFx0XHRcdFx0XHQ6IGRlZmluaXRpb24uY2xvbmUoKS50cmFuc2xhdGUocG9pbnQpXG5cdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRjaXJjbGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuQ2lyY2xlKFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRcdGdldFZhbHVlKG5vZGUsICdyJykpO1xuXHRcdH0sXG5cblx0XHRlbGxpcHNlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkVsbGlwc2Uoe1xuXHRcdFx0XHRjZW50ZXI6IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuXHRcdFx0XHRyYWRpdXM6IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRyZWN0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKFxuXHRcdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSksXG5cdFx0XHRcdFx0XHRnZXRTaXplKG5vZGUpXG5cdFx0XHRcdFx0KSwgZ2V0U2l6ZShub2RlLCAncngnLCAncnknKSk7XG5cdFx0XHR9LFxuXG5cdFx0bGluZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQYXRoLkxpbmUoXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSkuYWRkKFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICdkeCcsICdkeScpKSk7XG5cdFx0XHR0ZXh0LnNldENvbnRlbnQobm9kZS50ZXh0Q29udGVudC50cmltKCkgfHwgJycpO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fSxcblxuXHRcdHN3aXRjaDogaW1wb3J0R3JvdXBcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdGlmIChpdGVtLnRyYW5zZm9ybSkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybXMgPSAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgJycpLnNwbGl0KC9cXClcXHMqL2cpLFxuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2ldO1xuXHRcdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0dmFyIHBhcnRzID0gdHJhbnNmb3JtLnNwbGl0KC9cXChcXHMqLyksXG5cdFx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSB2Lmxlbmd0aDsgaiA8IG07IGorKylcblx0XHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0bWF0cml4LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdIHx8IDAsIHZbMl0gfHwgMCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0bWF0cml4LnRyYW5zbGF0ZSh2WzBdLCB2WzFdIHx8IDApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdza2V3WCc6XG5cdFx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NrZXdZJzpcblx0XHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIga2V5ID0gbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJyA6ICdnZXRTdHJva2VDb2xvcicsXG5cdFx0XHRjb2xvciA9IGl0ZW1ba2V5XSAmJiBpdGVtW2tleV0oKTtcblx0XHRpZiAoY29sb3IpXG5cdFx0XHRjb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdH1cblxuXHR2YXIgYXR0cmlidXRlcyA9IEJhc2Uuc2V0KEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0dGhpc1tlbnRyeS5hdHRyaWJ1dGVdID0gZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtW2VudHJ5LnNldF0pIHtcblx0XHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJykge1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKGNvbG9yLl9zY2FsZVRvQm91bmRzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBib3VuZHMgPSBpdGVtLmdldEJvdW5kcygpO1xuXHRcdFx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpXG5cdFx0XHRcdFx0XHRcdFx0LnRyYW5zbGF0ZShib3VuZHMuZ2V0UG9pbnQoKSlcblx0XHRcdFx0XHRcdFx0XHQuc2NhbGUoYm91bmRzLmdldFNpemUoKSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHt9KSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRWaXNpYmxlKVxuXHRcdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRWaXNpYmxlKVxuXHRcdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1jb2xvcic6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRDb2xvcilcblx0XHRcdFx0aXRlbS5zZXRDb2xvcih2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uX2NvbG9yKVxuXHRcdFx0XHRpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdG9mZnNldDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldE9mZnNldCkge1xuXHRcdFx0XHR2YXIgcGVyY2VudCA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcblx0XHRcdFx0aXRlbS5zZXRPZmZzZXQocGVyY2VudCA/IHBlcmNlbnRbMV0gLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSksXG5cdFx0XHRcdGdyb3VwLFxuXHRcdFx0XHRtYXRyaXg7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgPyBzaXplLmRpdmlkZShyZWN0LmdldFNpemUoKSkgOiAxLFxuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpXG5cdFx0XHRcdFx0XHQudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKS5uZWdhdGUoKSk7XG5cdFx0XHRcdGdyb3VwID0gaXRlbTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24pIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHRncm91cCA9IGl0ZW0uX2l0ZW07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3JvdXApICB7XG5cdFx0XHRcdGlmIChnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPT0gJ3Zpc2libGUnKSB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpO1xuXHRcdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1hdHJpeClcblx0XHRcdFx0XHRncm91cC50cmFuc2Zvcm0obWF0cml4KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcblx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXHRcdGlmICghdmFsdWUgJiYgbm9kZS5zdHlsZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gQmFzZS5jYW1lbGl6ZShuYW1lKTtcblx0XHRcdHZhbHVlID0gbm9kZS5zdHlsZVtzdHlsZV07XG5cdFx0XHRpZiAoIXZhbHVlICYmIHN0eWxlcy5ub2RlW3N0eWxlXSAhPT0gc3R5bGVzLnBhcmVudFtzdHlsZV0pXG5cdFx0XHRcdHZhbHVlID0gc3R5bGVzLm5vZGVbc3R5bGVdO1xuXHRcdH1cblx0XHRyZXR1cm4gIXZhbHVlID8gdW5kZWZpbmVkXG5cdFx0XHRcdDogdmFsdWUgPT09ICdub25lJyA/IG51bGxcblx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuXHRcdFx0c3R5bGVzID0ge1xuXHRcdFx0XHRub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcblx0XHRcdFx0cGFyZW50OiAhaXNSb290ICYmICEvXmRlZnMkL2kudGVzdChwYXJlbnQudGFnTmFtZSlcblx0XHRcdFx0XHRcdCYmIERvbUVsZW1lbnQuZ2V0U3R5bGVzKHBhcmVudCkgfHwge31cblx0XHRcdH07XG5cdFx0QmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGFwcGx5LCBuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcblx0XHRcdGl0ZW0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0JiYgYXBwbHkoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykgfHwgaXRlbTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24odmFsdWUpIHtcblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXFwoKD86W1wiJyNdKikoW15cIicpXSspLyksXG5cdFx0XHRuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV0sXG5cdFx0XHRyZXMgPSBuYW1lICYmIGRlZmluaXRpb25zW3dpbmRvd1xuXHRcdFx0XHRcdD8gbmFtZS5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMF0gKyAnIycsICcnKVxuXHRcdFx0XHRcdDogbmFtZV07XG5cdFx0aWYgKHJlcyAmJiByZXMuX3NjYWxlVG9Cb3VuZHMpIHtcblx0XHRcdHJlcyA9IHJlcy5jbG9uZSgpO1xuXHRcdFx0cmVzLl9zY2FsZVRvQm91bmRzID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydE5vZGUobm9kZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIHR5cGUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRpc0VsZW1lbnQgPSB0eXBlICE9PSAnI2RvY3VtZW50Jyxcblx0XHRcdGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdFx0Y29udGFpbmVyLFxuXHRcdFx0cGFyZW50LFxuXHRcdFx0bmV4dDtcblx0XHRpZiAoaXNSb290ICYmIGlzRWxlbWVudCkge1xuXHRcdFx0cm9vdFNpemUgPSBwYXBlci5nZXRWaWV3KCkuZ2V0U2l6ZSgpO1xuXHRcdFx0cm9vdFNpemUgPSBnZXRTaXplKG5vZGUsIG51bGwsIG51bGwsIHRydWUpIHx8IHJvb3RTaXplO1xuXHRcdFx0Y29udGFpbmVyID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycsIHtcblx0XHRcdFx0c3R5bGU6ICdzdHJva2Utd2lkdGg6IDFweDsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwJ1xuXHRcdFx0fSk7XG5cdFx0XHRwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRuZXh0ID0gbm9kZS5uZXh0U2libGluZztcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0XHR9XG5cdFx0dmFyIHNldHRpbmdzID0gcGFwZXIuc2V0dGluZ3MsXG5cdFx0XHRhcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4LFxuXHRcdFx0aW5zZXJ0SXRlbXMgPSBzZXR0aW5ncy5pbnNlcnRJdGVtcztcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuXHRcdHNldHRpbmdzLmluc2VydEl0ZW1zID0gZmFsc2U7XG5cdFx0dmFyIGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuXHRcdFx0aXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkgfHwgbnVsbDtcblx0XHRzZXR0aW5ncy5pbnNlcnRJdGVtcyA9IGluc2VydEl0ZW1zO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gYXBwbHlNYXRyaXg7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGlmIChpc0VsZW1lbnQgJiYgIShpdGVtIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHR2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0LFxuXHRcdFx0XHRkYXRhID0gaXNFbGVtZW50ICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnKTtcblx0XHRcdGlmIChvbkltcG9ydClcblx0XHRcdFx0aXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cdFx0XHRpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEpXG5cdFx0XHRcdGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7fTtcblx0XHRcdGlmIChpdGVtICYmIEJhc2UucGljayhvcHRpb25zLmFwcGx5TWF0cml4LCBhcHBseU1hdHJpeCkpXG5cdFx0XHRcdGl0ZW0ubWF0cml4LmFwcGx5KHRydWUsIHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIG93bmVyKSB7XG5cdFx0aWYgKCFzb3VyY2UpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyB7IG9uTG9hZDogb3B0aW9ucyB9XG5cdFx0XHRcdDogb3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgc2NvcGUgPSBwYXBlcixcblx0XHRcdGl0ZW0gPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkKHN2Zykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2Ygc3ZnID09PSAnb2JqZWN0J1xuXHRcdFx0XHRcdD8gc3ZnXG5cdFx0XHRcdFx0OiBuZXcgc2VsZi5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoXG5cdFx0XHRcdFx0XHRzdmcudHJpbSgpLFxuXHRcdFx0XHRcdFx0J2ltYWdlL3N2Zyt4bWwnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCFub2RlLm5vZGVOYW1lKSB7XG5cdFx0XHRcdFx0bm9kZSA9IG51bGw7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0XHRpdGVtID0gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCB0cnVlKTtcblx0XHRcdFx0aWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuaW5zZXJ0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkO1xuXHRcdFx0XHRpZiAob25Mb2FkKVxuXHRcdFx0XHRcdG9uTG9hZChpdGVtLCBzdmcpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvbkVycm9yKGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uRXJyb3IobWVzc2FnZSwgc3RhdHVzKSB7XG5cdFx0XHR2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvcjtcblx0XHRcdGlmIChvbkVycm9yKSB7XG5cdFx0XHRcdG9uRXJyb3IobWVzc2FnZSwgc3RhdHVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIS9eW1xcc1xcU10qPC8udGVzdChzb3VyY2UpKSB7XG5cdFx0XHR2YXIgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRvbkxvYWQobm9kZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRIdHRwLnJlcXVlc3Qoe1xuXHRcdFx0XHRcdHVybDogc291cmNlLFxuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0XHRcdG9uRXJyb3I6IG9uRXJyb3Jcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG9uTG9hZChyZWFkZXIucmVzdWx0KTtcblx0XHRcdH07XG5cdFx0XHRyZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRvbkVycm9yKHJlYWRlci5lcnJvcik7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNUZXh0KHNvdXJjZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uTG9hZChzb3VyY2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdGhpcyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbkJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgZ2xvYmFsID0gdGhpcyxcblx0XHRhY29ybiA9IGdsb2JhbC5hY29ybjtcblx0aWYgKCFhY29ybiAmJiB0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0cnkgeyBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7IH0gY2F0Y2goZSkge31cblx0fVxuXHRpZiAoIWFjb3JuKSB7XG5cdFx0dmFyIGV4cG9ydHMsIG1vZHVsZTtcblx0XHRhY29ybiA9IGV4cG9ydHMgPSBtb2R1bGUgPSB7fTtcblxuKGZ1bmN0aW9uKHJvb3QsIG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIHJldHVybiBtb2QoZXhwb3J0cyk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSByZXR1cm4gZGVmaW5lKFtcImV4cG9ydHNcIl0sIG1vZCk7XG4gIG1vZChyb290LmFjb3JuIHx8IChyb290LmFjb3JuID0ge30pKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gXCIwLjUuMFwiO1xuXG4gIHZhciBvcHRpb25zLCBpbnB1dCwgaW5wdXRMZW4sIHNvdXJjZUZpbGU7XG5cbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKGlucHQsIG9wdHMpIHtcblx0aW5wdXQgPSBTdHJpbmcoaW5wdCk7IGlucHV0TGVuID0gaW5wdXQubGVuZ3RoO1xuXHRzZXRPcHRpb25zKG9wdHMpO1xuXHRpbml0VG9rZW5TdGF0ZSgpO1xuXHRyZXR1cm4gcGFyc2VUb3BMZXZlbChvcHRpb25zLnByb2dyYW0pO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XG5cdGVjbWFWZXJzaW9uOiA1LFxuXHRzdHJpY3RTZW1pY29sb25zOiBmYWxzZSxcblx0YWxsb3dUcmFpbGluZ0NvbW1hczogdHJ1ZSxcblx0Zm9yYmlkUmVzZXJ2ZWQ6IGZhbHNlLFxuXHRhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG5cdGxvY2F0aW9uczogZmFsc2UsXG5cdG9uQ29tbWVudDogbnVsbCxcblx0cmFuZ2VzOiBmYWxzZSxcblx0cHJvZ3JhbTogbnVsbCxcblx0c291cmNlRmlsZTogbnVsbCxcblx0ZGlyZWN0U291cmNlRmlsZTogbnVsbFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0cykge1xuXHRvcHRpb25zID0gb3B0cyB8fCB7fTtcblx0Zm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHQpKVxuXHQgIG9wdGlvbnNbb3B0XSA9IGRlZmF1bHRPcHRpb25zW29wdF07XG5cdHNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGUgfHwgbnVsbDtcbiAgfVxuXG4gIHZhciBnZXRMaW5lSW5mbyA9IGV4cG9ydHMuZ2V0TGluZUluZm8gPSBmdW5jdGlvbihpbnB1dCwgb2Zmc2V0KSB7XG5cdGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcblx0ICBsaW5lQnJlYWsubGFzdEluZGV4ID0gY3VyO1xuXHQgIHZhciBtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KTtcblx0ICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcblx0XHQrK2xpbmU7XG5cdFx0Y3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdCAgfSBlbHNlIGJyZWFrO1xuXHR9XG5cdHJldHVybiB7bGluZTogbGluZSwgY29sdW1uOiBvZmZzZXQgLSBjdXJ9O1xuICB9O1xuXG4gIGV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbihpbnB0LCBvcHRzKSB7XG5cdGlucHV0ID0gU3RyaW5nKGlucHQpOyBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcblx0c2V0T3B0aW9ucyhvcHRzKTtcblx0aW5pdFRva2VuU3RhdGUoKTtcblxuXHR2YXIgdCA9IHt9O1xuXHRmdW5jdGlvbiBnZXRUb2tlbihmb3JjZVJlZ2V4cCkge1xuXHQgIGxhc3RFbmQgPSB0b2tFbmQ7XG5cdCAgcmVhZFRva2VuKGZvcmNlUmVnZXhwKTtcblx0ICB0LnN0YXJ0ID0gdG9rU3RhcnQ7IHQuZW5kID0gdG9rRW5kO1xuXHQgIHQuc3RhcnRMb2MgPSB0b2tTdGFydExvYzsgdC5lbmRMb2MgPSB0b2tFbmRMb2M7XG5cdCAgdC50eXBlID0gdG9rVHlwZTsgdC52YWx1ZSA9IHRva1ZhbDtcblx0ICByZXR1cm4gdDtcblx0fVxuXHRnZXRUb2tlbi5qdW1wVG8gPSBmdW5jdGlvbihwb3MsIHJlQWxsb3dlZCkge1xuXHQgIHRva1BvcyA9IHBvcztcblx0ICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0XHR0b2tDdXJMaW5lID0gMTtcblx0XHR0b2tMaW5lU3RhcnQgPSBsaW5lQnJlYWsubGFzdEluZGV4ID0gMDtcblx0XHR2YXIgbWF0Y2g7XG5cdFx0d2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCBwb3MpIHtcblx0XHQgICsrdG9rQ3VyTGluZTtcblx0XHQgIHRva0xpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH1cblx0ICB9XG5cdCAgdG9rUmVnZXhwQWxsb3dlZCA9IHJlQWxsb3dlZDtcblx0ICBza2lwU3BhY2UoKTtcblx0fTtcblx0cmV0dXJuIGdldFRva2VuO1xuICB9O1xuXG4gIHZhciB0b2tQb3M7XG5cbiAgdmFyIHRva1N0YXJ0LCB0b2tFbmQ7XG5cbiAgdmFyIHRva1N0YXJ0TG9jLCB0b2tFbmRMb2M7XG5cbiAgdmFyIHRva1R5cGUsIHRva1ZhbDtcblxuICB2YXIgdG9rUmVnZXhwQWxsb3dlZDtcblxuICB2YXIgdG9rQ3VyTGluZSwgdG9rTGluZVN0YXJ0O1xuXG4gIHZhciBsYXN0U3RhcnQsIGxhc3RFbmQsIGxhc3RFbmRMb2M7XG5cbiAgdmFyIGluRnVuY3Rpb24sIGxhYmVscywgc3RyaWN0O1xuXG4gIGZ1bmN0aW9uIHJhaXNlKHBvcywgbWVzc2FnZSkge1xuXHR2YXIgbG9jID0gZ2V0TGluZUluZm8oaW5wdXQsIHBvcyk7XG5cdG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcblx0dmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcblx0ZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdG9rUG9zO1xuXHR0aHJvdyBlcnI7XG4gIH1cblxuICB2YXIgZW1wdHkgPSBbXTtcblxuICB2YXIgX251bSA9IHt0eXBlOiBcIm51bVwifSwgX3JlZ2V4cCA9IHt0eXBlOiBcInJlZ2V4cFwifSwgX3N0cmluZyA9IHt0eXBlOiBcInN0cmluZ1wifTtcbiAgdmFyIF9uYW1lID0ge3R5cGU6IFwibmFtZVwifSwgX2VvZiA9IHt0eXBlOiBcImVvZlwifTtcblxuICB2YXIgX2JyZWFrID0ge2tleXdvcmQ6IFwiYnJlYWtcIn0sIF9jYXNlID0ge2tleXdvcmQ6IFwiY2FzZVwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX2NhdGNoID0ge2tleXdvcmQ6IFwiY2F0Y2hcIn07XG4gIHZhciBfY29udGludWUgPSB7a2V5d29yZDogXCJjb250aW51ZVwifSwgX2RlYnVnZ2VyID0ge2tleXdvcmQ6IFwiZGVidWdnZXJcIn0sIF9kZWZhdWx0ID0ge2tleXdvcmQ6IFwiZGVmYXVsdFwifTtcbiAgdmFyIF9kbyA9IHtrZXl3b3JkOiBcImRvXCIsIGlzTG9vcDogdHJ1ZX0sIF9lbHNlID0ge2tleXdvcmQ6IFwiZWxzZVwiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9maW5hbGx5ID0ge2tleXdvcmQ6IFwiZmluYWxseVwifSwgX2ZvciA9IHtrZXl3b3JkOiBcImZvclwiLCBpc0xvb3A6IHRydWV9LCBfZnVuY3Rpb24gPSB7a2V5d29yZDogXCJmdW5jdGlvblwifTtcbiAgdmFyIF9pZiA9IHtrZXl3b3JkOiBcImlmXCJ9LCBfcmV0dXJuID0ge2tleXdvcmQ6IFwicmV0dXJuXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfc3dpdGNoID0ge2tleXdvcmQ6IFwic3dpdGNoXCJ9O1xuICB2YXIgX3Rocm93ID0ge2tleXdvcmQ6IFwidGhyb3dcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF90cnkgPSB7a2V5d29yZDogXCJ0cnlcIn0sIF92YXIgPSB7a2V5d29yZDogXCJ2YXJcIn07XG4gIHZhciBfd2hpbGUgPSB7a2V5d29yZDogXCJ3aGlsZVwiLCBpc0xvb3A6IHRydWV9LCBfd2l0aCA9IHtrZXl3b3JkOiBcIndpdGhcIn0sIF9uZXcgPSB7a2V5d29yZDogXCJuZXdcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfdGhpcyA9IHtrZXl3b3JkOiBcInRoaXNcIn07XG5cbiAgdmFyIF9udWxsID0ge2tleXdvcmQ6IFwibnVsbFwiLCBhdG9tVmFsdWU6IG51bGx9LCBfdHJ1ZSA9IHtrZXl3b3JkOiBcInRydWVcIiwgYXRvbVZhbHVlOiB0cnVlfTtcbiAgdmFyIF9mYWxzZSA9IHtrZXl3b3JkOiBcImZhbHNlXCIsIGF0b21WYWx1ZTogZmFsc2V9O1xuXG4gIHZhciBfaW4gPSB7a2V5d29yZDogXCJpblwiLCBiaW5vcDogNywgYmVmb3JlRXhwcjogdHJ1ZX07XG5cbiAgdmFyIGtleXdvcmRUeXBlcyA9IHtcImJyZWFrXCI6IF9icmVhaywgXCJjYXNlXCI6IF9jYXNlLCBcImNhdGNoXCI6IF9jYXRjaCxcblx0XHRcdFx0XHQgIFwiY29udGludWVcIjogX2NvbnRpbnVlLCBcImRlYnVnZ2VyXCI6IF9kZWJ1Z2dlciwgXCJkZWZhdWx0XCI6IF9kZWZhdWx0LFxuXHRcdFx0XHRcdCAgXCJkb1wiOiBfZG8sIFwiZWxzZVwiOiBfZWxzZSwgXCJmaW5hbGx5XCI6IF9maW5hbGx5LCBcImZvclwiOiBfZm9yLFxuXHRcdFx0XHRcdCAgXCJmdW5jdGlvblwiOiBfZnVuY3Rpb24sIFwiaWZcIjogX2lmLCBcInJldHVyblwiOiBfcmV0dXJuLCBcInN3aXRjaFwiOiBfc3dpdGNoLFxuXHRcdFx0XHRcdCAgXCJ0aHJvd1wiOiBfdGhyb3csIFwidHJ5XCI6IF90cnksIFwidmFyXCI6IF92YXIsIFwid2hpbGVcIjogX3doaWxlLCBcIndpdGhcIjogX3dpdGgsXG5cdFx0XHRcdFx0ICBcIm51bGxcIjogX251bGwsIFwidHJ1ZVwiOiBfdHJ1ZSwgXCJmYWxzZVwiOiBfZmFsc2UsIFwibmV3XCI6IF9uZXcsIFwiaW5cIjogX2luLFxuXHRcdFx0XHRcdCAgXCJpbnN0YW5jZW9mXCI6IHtrZXl3b3JkOiBcImluc3RhbmNlb2ZcIiwgYmlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9LCBcInRoaXNcIjogX3RoaXMsXG5cdFx0XHRcdFx0ICBcInR5cGVvZlwiOiB7a2V5d29yZDogXCJ0eXBlb2ZcIiwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSxcblx0XHRcdFx0XHQgIFwidm9pZFwiOiB7a2V5d29yZDogXCJ2b2lkXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0sXG5cdFx0XHRcdFx0ICBcImRlbGV0ZVwiOiB7a2V5d29yZDogXCJkZWxldGVcIiwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfX07XG5cbiAgdmFyIF9icmFja2V0TCA9IHt0eXBlOiBcIltcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9icmFja2V0UiA9IHt0eXBlOiBcIl1cIn0sIF9icmFjZUwgPSB7dHlwZTogXCJ7XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JyYWNlUiA9IHt0eXBlOiBcIn1cIn0sIF9wYXJlbkwgPSB7dHlwZTogXCIoXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfcGFyZW5SID0ge3R5cGU6IFwiKVwifTtcbiAgdmFyIF9jb21tYSA9IHt0eXBlOiBcIixcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9zZW1pID0ge3R5cGU6IFwiO1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9jb2xvbiA9IHt0eXBlOiBcIjpcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9kb3QgPSB7dHlwZTogXCIuXCJ9LCBfcXVlc3Rpb24gPSB7dHlwZTogXCI/XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIHZhciBfc2xhc2ggPSB7Ymlub3A6IDEwLCBiZWZvcmVFeHByOiB0cnVlfSwgX2VxID0ge2lzQXNzaWduOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9hc3NpZ24gPSB7aXNBc3NpZ246IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2luY0RlYyA9IHtwb3N0Zml4OiB0cnVlLCBwcmVmaXg6IHRydWUsIGlzVXBkYXRlOiB0cnVlfSwgX3ByZWZpeCA9IHtwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2xvZ2ljYWxPUiA9IHtiaW5vcDogMSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfbG9naWNhbEFORCA9IHtiaW5vcDogMiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZU9SID0ge2Jpbm9wOiAzLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9iaXR3aXNlWE9SID0ge2Jpbm9wOiA0LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9iaXR3aXNlQU5EID0ge2Jpbm9wOiA1LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9lcXVhbGl0eSA9IHtiaW5vcDogNiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfcmVsYXRpb25hbCA9IHtiaW5vcDogNywgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0U2hpZnQgPSB7Ymlub3A6IDgsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3BsdXNNaW4gPSB7Ymlub3A6IDksIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfbXVsdGlwbHlNb2R1bG8gPSB7Ymlub3A6IDEwLCBiZWZvcmVFeHByOiB0cnVlfTtcblxuICBleHBvcnRzLnRva1R5cGVzID0ge2JyYWNrZXRMOiBfYnJhY2tldEwsIGJyYWNrZXRSOiBfYnJhY2tldFIsIGJyYWNlTDogX2JyYWNlTCwgYnJhY2VSOiBfYnJhY2VSLFxuXHRcdFx0XHRcdCAgcGFyZW5MOiBfcGFyZW5MLCBwYXJlblI6IF9wYXJlblIsIGNvbW1hOiBfY29tbWEsIHNlbWk6IF9zZW1pLCBjb2xvbjogX2NvbG9uLFxuXHRcdFx0XHRcdCAgZG90OiBfZG90LCBxdWVzdGlvbjogX3F1ZXN0aW9uLCBzbGFzaDogX3NsYXNoLCBlcTogX2VxLCBuYW1lOiBfbmFtZSwgZW9mOiBfZW9mLFxuXHRcdFx0XHRcdCAgbnVtOiBfbnVtLCByZWdleHA6IF9yZWdleHAsIHN0cmluZzogX3N0cmluZ307XG4gIGZvciAodmFyIGt3IGluIGtleXdvcmRUeXBlcykgZXhwb3J0cy50b2tUeXBlc1tcIl9cIiArIGt3XSA9IGtleXdvcmRUeXBlc1trd107XG5cbiAgZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuXHR3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcblx0dmFyIGYgPSBcIlwiLCBjYXRzID0gW107XG5cdG91dDogZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgY2F0cy5sZW5ndGg7ICsrailcblx0XHRpZiAoY2F0c1tqXVswXS5sZW5ndGggPT0gd29yZHNbaV0ubGVuZ3RoKSB7XG5cdFx0ICBjYXRzW2pdLnB1c2god29yZHNbaV0pO1xuXHRcdCAgY29udGludWUgb3V0O1xuXHRcdH1cblx0ICBjYXRzLnB1c2goW3dvcmRzW2ldXSk7XG5cdH1cblx0ZnVuY3Rpb24gY29tcGFyZVRvKGFycikge1xuXHQgIGlmIChhcnIubGVuZ3RoID09IDEpIHJldHVybiBmICs9IFwicmV0dXJuIHN0ciA9PT0gXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbMF0pICsgXCI7XCI7XG5cdCAgZiArPSBcInN3aXRjaChzdHIpe1wiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBmICs9IFwiY2FzZSBcIiArIEpTT04uc3RyaW5naWZ5KGFycltpXSkgKyBcIjpcIjtcblx0ICBmICs9IFwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wiO1xuXHR9XG5cblx0aWYgKGNhdHMubGVuZ3RoID4gMykge1xuXHQgIGNhdHMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7fSk7XG5cdCAgZiArPSBcInN3aXRjaChzdHIubGVuZ3RoKXtcIjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhdHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgY2F0ID0gY2F0c1tpXTtcblx0XHRmICs9IFwiY2FzZSBcIiArIGNhdFswXS5sZW5ndGggKyBcIjpcIjtcblx0XHRjb21wYXJlVG8oY2F0KTtcblx0ICB9XG5cdCAgZiArPSBcIn1cIjtcblxuXHR9IGVsc2Uge1xuXHQgIGNvbXBhcmVUbyh3b3Jkcyk7XG5cdH1cblx0cmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbiAgfVxuXG4gIHZhciBpc1Jlc2VydmVkV29yZDMgPSBtYWtlUHJlZGljYXRlKFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiKTtcblxuICB2YXIgaXNSZXNlcnZlZFdvcmQ1ID0gbWFrZVByZWRpY2F0ZShcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpO1xuXG4gIHZhciBpc1N0cmljdFJlc2VydmVkV29yZCA9IG1ha2VQcmVkaWNhdGUoXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpO1xuXG4gIHZhciBpc1N0cmljdEJhZElkV29yZCA9IG1ha2VQcmVkaWNhdGUoXCJldmFsIGFyZ3VtZW50c1wiKTtcblxuICB2YXIgaXNLZXl3b3JkID0gbWFrZVByZWRpY2F0ZShcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiKTtcblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4gIHZhciBuZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZztcblxuICB2YXIgaXNJZGVudGlmaWVyU3RhcnQgPSBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuXHRpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG5cdGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuXHRpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG5cdGlmIChjb2RlIDwgMTIzKXJldHVybiB0cnVlO1xuXHRyZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH07XG5cbiAgdmFyIGlzSWRlbnRpZmllckNoYXIgPSBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG5cdGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcblx0aWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG5cdGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcblx0aWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG5cdGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcblx0aWYgKGNvZGUgPCAxMjMpcmV0dXJuIHRydWU7XG5cdHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbGluZV9sb2NfdCgpIHtcblx0dGhpcy5saW5lID0gdG9rQ3VyTGluZTtcblx0dGhpcy5jb2x1bW4gPSB0b2tQb3MgLSB0b2tMaW5lU3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0VG9rZW5TdGF0ZSgpIHtcblx0dG9rQ3VyTGluZSA9IDE7XG5cdHRva1BvcyA9IHRva0xpbmVTdGFydCA9IDA7XG5cdHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuXHRza2lwU3BhY2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuXHR0b2tFbmQgPSB0b2tQb3M7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykgdG9rRW5kTG9jID0gbmV3IGxpbmVfbG9jX3Q7XG5cdHRva1R5cGUgPSB0eXBlO1xuXHRza2lwU3BhY2UoKTtcblx0dG9rVmFsID0gdmFsO1xuXHR0b2tSZWdleHBBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcEJsb2NrQ29tbWVudCgpIHtcblx0dmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3Q7XG5cdHZhciBzdGFydCA9IHRva1BvcywgZW5kID0gaW5wdXQuaW5kZXhPZihcIiovXCIsIHRva1BvcyArPSAyKTtcblx0aWYgKGVuZCA9PT0gLTEpIHJhaXNlKHRva1BvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7XG5cdHRva1BvcyA9IGVuZCArIDI7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHQgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBzdGFydDtcblx0ICB2YXIgbWF0Y2g7XG5cdCAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0b2tQb3MpIHtcblx0XHQrK3Rva0N1ckxpbmU7XG5cdFx0dG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdCAgfVxuXHR9XG5cdGlmIChvcHRpb25zLm9uQ29tbWVudClcblx0ICBvcHRpb25zLm9uQ29tbWVudCh0cnVlLCBpbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0b2tQb3MsXG5cdFx0XHRcdFx0XHRzdGFydExvYywgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcExpbmVDb21tZW50KCkge1xuXHR2YXIgc3RhcnQgPSB0b2tQb3M7XG5cdHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190O1xuXHR2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcys9Mik7XG5cdHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbiAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG5cdCAgKyt0b2tQb3M7XG5cdCAgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdH1cblx0aWYgKG9wdGlvbnMub25Db21tZW50KVxuXHQgIG9wdGlvbnMub25Db21tZW50KGZhbHNlLCBpbnB1dC5zbGljZShzdGFydCArIDIsIHRva1BvcyksIHN0YXJ0LCB0b2tQb3MsXG5cdFx0XHRcdFx0XHRzdGFydExvYywgb3B0aW9ucy5sb2NhdGlvbnMgJiYgbmV3IGxpbmVfbG9jX3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFNwYWNlKCkge1xuXHR3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4pIHtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdCAgaWYgKGNoID09PSAzMikge1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDEzKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdFx0aWYgKG5leHQgPT09IDEwKSB7XG5cdFx0ICArK3Rva1Bvcztcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdFx0ICArK3Rva0N1ckxpbmU7XG5cdFx0ICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG5cdFx0fVxuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDEwIHx8IGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdFx0ICArK3Rva0N1ckxpbmU7XG5cdFx0ICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG5cdFx0fVxuXHQgIH0gZWxzZSBpZiAoY2ggPiA4ICYmIGNoIDwgMTQpIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2UgaWYgKGNoID09PSA0Nykge1xuXHRcdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0XHRpZiAobmV4dCA9PT0gNDIpIHtcblx0XHQgIHNraXBCbG9ja0NvbW1lbnQoKTtcblx0XHR9IGVsc2UgaWYgKG5leHQgPT09IDQ3KSB7XG5cdFx0ICBza2lwTGluZUNvbW1lbnQoKTtcblx0XHR9IGVsc2UgYnJlYWs7XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gMTYwKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIGlmIChjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSB7XG5cdFx0YnJlYWs7XG5cdCAgfVxuXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fZG90KCkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHJldHVybiByZWFkTnVtYmVyKHRydWUpO1xuXHQrK3Rva1Bvcztcblx0cmV0dXJuIGZpbmlzaFRva2VuKF9kb3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3NsYXNoKCkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmICh0b2tSZWdleHBBbGxvd2VkKSB7Kyt0b2tQb3M7IHJldHVybiByZWFkUmVnZXhwKCk7fVxuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKF9zbGFzaCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfbXVsdGlwbHlNb2R1bG8sIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA9PT0gY29kZSkgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9sb2dpY2FsT1IgOiBfbG9naWNhbEFORCwgMik7XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gX2JpdHdpc2VPUiA6IF9iaXR3aXNlQU5ELCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9jYXJldCgpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKF9iaXR3aXNlWE9SLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IGNvZGUpIHtcblx0ICBpZiAobmV4dCA9PSA0NSAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDYyICYmXG5cdFx0ICBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rUG9zKSkpIHtcblx0XHR0b2tQb3MgKz0gMztcblx0XHRza2lwTGluZUNvbW1lbnQoKTtcblx0XHRza2lwU3BhY2UoKTtcblx0XHRyZXR1cm4gcmVhZFRva2VuKCk7XG5cdCAgfVxuXHQgIHJldHVybiBmaW5pc2hPcChfaW5jRGVjLCAyKTtcblx0fVxuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKF9wbHVzTWluLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9sdF9ndChjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0dmFyIHNpemUgPSAxO1xuXHRpZiAobmV4dCA9PT0gY29kZSkge1xuXHQgIHNpemUgPSBjb2RlID09PSA2MiAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuXHQgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIHNpemUgKyAxKTtcblx0ICByZXR1cm4gZmluaXNoT3AoX2JpdFNoaWZ0LCBzaXplKTtcblx0fVxuXHRpZiAobmV4dCA9PSAzMyAmJiBjb2RlID09IDYwICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT0gNDUgJiZcblx0XHRpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDMpID09IDQ1KSB7XG5cdCAgdG9rUG9zICs9IDQ7XG5cdCAgc2tpcExpbmVDb21tZW50KCk7XG5cdCAgc2tpcFNwYWNlKCk7XG5cdCAgcmV0dXJuIHJlYWRUb2tlbigpO1xuXHR9XG5cdGlmIChuZXh0ID09PSA2MSlcblx0ICBzaXplID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjEgPyAzIDogMjtcblx0cmV0dXJuIGZpbmlzaE9wKF9yZWxhdGlvbmFsLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfZXF1YWxpdHksIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoY29kZSA9PT0gNjEgPyBfZXEgOiBfcHJlZml4LCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuXHRzd2l0Y2goY29kZSkge1xuXHRjYXNlIDQ2OlxuXHQgIHJldHVybiByZWFkVG9rZW5fZG90KCk7XG5cblx0Y2FzZSA0MDogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5MKTtcblx0Y2FzZSA0MTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5SKTtcblx0Y2FzZSA1OTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfc2VtaSk7XG5cdGNhc2UgNDQ6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2NvbW1hKTtcblx0Y2FzZSA5MTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldEwpO1xuXHRjYXNlIDkzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFja2V0Uik7XG5cdGNhc2UgMTIzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZUwpO1xuXHRjYXNlIDEyNTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VSKTtcblx0Y2FzZSA1ODogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfY29sb24pO1xuXHRjYXNlIDYzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9xdWVzdGlvbik7XG5cblx0Y2FzZSA0ODpcblx0ICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdCAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHJlYWRIZXhOdW1iZXIoKTtcblx0Y2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1Nzpcblx0ICByZXR1cm4gcmVhZE51bWJlcihmYWxzZSk7XG5cblx0Y2FzZSAzNDogY2FzZSAzOTpcblx0ICByZXR1cm4gcmVhZFN0cmluZyhjb2RlKTtcblxuXHRjYXNlIDQ3OlxuXHQgIHJldHVybiByZWFkVG9rZW5fc2xhc2goY29kZSk7XG5cblx0Y2FzZSAzNzogY2FzZSA0Mjpcblx0ICByZXR1cm4gcmVhZFRva2VuX211bHRfbW9kdWxvKCk7XG5cblx0Y2FzZSAxMjQ6IGNhc2UgMzg6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcblxuXHRjYXNlIDk0OlxuXHQgIHJldHVybiByZWFkVG9rZW5fY2FyZXQoKTtcblxuXHRjYXNlIDQzOiBjYXNlIDQ1OlxuXHQgIHJldHVybiByZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cblx0Y2FzZSA2MDogY2FzZSA2Mjpcblx0ICByZXR1cm4gcmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG5cdGNhc2UgNjE6IGNhc2UgMzM6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuXG5cdGNhc2UgMTI2OlxuXHQgIHJldHVybiBmaW5pc2hPcChfcHJlZml4LCAxKTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCkge1xuXHRpZiAoIWZvcmNlUmVnZXhwKSB0b2tTdGFydCA9IHRva1Bvcztcblx0ZWxzZSB0b2tQb3MgPSB0b2tTdGFydCArIDE7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykgdG9rU3RhcnRMb2MgPSBuZXcgbGluZV9sb2NfdDtcblx0aWYgKGZvcmNlUmVnZXhwKSByZXR1cm4gcmVhZFJlZ2V4cCgpO1xuXHRpZiAodG9rUG9zID49IGlucHV0TGVuKSByZXR1cm4gZmluaXNoVG9rZW4oX2VvZik7XG5cblx0dmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlKSB8fCBjb2RlID09PSA5MiApIHJldHVybiByZWFkV29yZCgpO1xuXG5cdHZhciB0b2sgPSBnZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuXG5cdGlmICh0b2sgPT09IGZhbHNlKSB7XG5cdCAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblx0ICBpZiAoY2ggPT09IFwiXFxcXFwiIHx8IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoY2gpKSByZXR1cm4gcmVhZFdvcmQoKTtcblx0ICByYWlzZSh0b2tQb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG5cdH1cblx0cmV0dXJuIHRvaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE9wKHR5cGUsIHNpemUpIHtcblx0dmFyIHN0ciA9IGlucHV0LnNsaWNlKHRva1BvcywgdG9rUG9zICsgc2l6ZSk7XG5cdHRva1BvcyArPSBzaXplO1xuXHRmaW5pc2hUb2tlbih0eXBlLCBzdHIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFJlZ2V4cCgpIHtcblx0dmFyIGNvbnRlbnQgPSBcIlwiLCBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRva1Bvcztcblx0Zm9yICg7Oykge1xuXHQgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG5cdCAgdmFyIGNoID0gaW5wdXQuY2hhckF0KHRva1Bvcyk7XG5cdCAgaWYgKG5ld2xpbmUudGVzdChjaCkpIHJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG5cdCAgaWYgKCFlc2NhcGVkKSB7XG5cdFx0aWYgKGNoID09PSBcIltcIikgaW5DbGFzcyA9IHRydWU7XG5cdFx0ZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIGluQ2xhc3MgPSBmYWxzZTtcblx0XHRlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIGJyZWFrO1xuXHRcdGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG5cdCAgfSBlbHNlIGVzY2FwZWQgPSBmYWxzZTtcblx0ICArK3Rva1Bvcztcblx0fVxuXHR2YXIgY29udGVudCA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuXHQrK3Rva1Bvcztcblx0dmFyIG1vZHMgPSByZWFkV29yZDEoKTtcblx0aWYgKG1vZHMgJiYgIS9eW2dtc2l5XSokLy50ZXN0KG1vZHMpKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIHJlZ2V4cCBmbGFnXCIpO1xuXHR0cnkge1xuXHQgIHZhciB2YWx1ZSA9IG5ldyBSZWdFeHAoY29udGVudCwgbW9kcyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0ICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSByYWlzZShzdGFydCwgZS5tZXNzYWdlKTtcblx0ICByYWlzZShlKTtcblx0fVxuXHRyZXR1cm4gZmluaXNoVG9rZW4oX3JlZ2V4cCwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEludChyYWRpeCwgbGVuKSB7XG5cdHZhciBzdGFydCA9IHRva1BvcywgdG90YWwgPSAwO1xuXHRmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcblx0ICB2YXIgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSwgdmFsO1xuXHQgIGlmIChjb2RlID49IDk3KSB2YWwgPSBjb2RlIC0gOTcgKyAxMDtcblx0ICBlbHNlIGlmIChjb2RlID49IDY1KSB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcblx0ICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHZhbCA9IGNvZGUgLSA0ODtcblx0ICBlbHNlIHZhbCA9IEluZmluaXR5O1xuXHQgIGlmICh2YWwgPj0gcmFkaXgpIGJyZWFrO1xuXHQgICsrdG9rUG9zO1xuXHQgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcblx0fVxuXHRpZiAodG9rUG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0b2tQb3MgLSBzdGFydCAhPT0gbGVuKSByZXR1cm4gbnVsbDtcblxuXHRyZXR1cm4gdG90YWw7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSGV4TnVtYmVyKCkge1xuXHR0b2tQb3MgKz0gMjtcblx0dmFyIHZhbCA9IHJlYWRJbnQoMTYpO1xuXHRpZiAodmFsID09IG51bGwpIHJhaXNlKHRva1N0YXJ0ICsgMiwgXCJFeHBlY3RlZCBoZXhhZGVjaW1hbCBudW1iZXJcIik7XG5cdGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG5cdHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZE51bWJlcihzdGFydHNXaXRoRG90KSB7XG5cdHZhciBzdGFydCA9IHRva1BvcywgaXNGbG9hdCA9IGZhbHNlLCBvY3RhbCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gNDg7XG5cdGlmICghc3RhcnRzV2l0aERvdCAmJiByZWFkSW50KDEwKSA9PT0gbnVsbCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG5cdGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ2KSB7XG5cdCAgKyt0b2tQb3M7XG5cdCAgcmVhZEludCgxMCk7XG5cdCAgaXNGbG9hdCA9IHRydWU7XG5cdH1cblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdGlmIChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpIHtcblx0ICBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCgrK3Rva1Bvcyk7XG5cdCAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSArK3Rva1Bvcztcblx0ICBpZiAocmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuXHQgIGlzRmxvYXQgPSB0cnVlO1xuXHR9XG5cdGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG5cblx0dmFyIHN0ciA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpLCB2YWw7XG5cdGlmIChpc0Zsb2F0KSB2YWwgPSBwYXJzZUZsb2F0KHN0cik7XG5cdGVsc2UgaWYgKCFvY3RhbCB8fCBzdHIubGVuZ3RoID09PSAxKSB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcblx0ZWxzZSBpZiAoL1s4OV0vLnRlc3Qoc3RyKSB8fCBzdHJpY3QpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuXHRlbHNlIHZhbCA9IHBhcnNlSW50KHN0ciwgOCk7XG5cdHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN0cmluZyhxdW90ZSkge1xuXHR0b2tQb3MrKztcblx0dmFyIG91dCA9IFwiXCI7XG5cdGZvciAoOzspIHtcblx0ICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuXHQgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0ICBpZiAoY2ggPT09IHF1b3RlKSB7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0cmV0dXJuIGZpbmlzaFRva2VuKF9zdHJpbmcsIG91dCk7XG5cdCAgfVxuXHQgIGlmIChjaCA9PT0gOTIpIHtcblx0XHRjaCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuXHRcdHZhciBvY3RhbCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHRva1BvcywgdG9rUG9zICsgMykpO1xuXHRcdGlmIChvY3RhbCkgb2N0YWwgPSBvY3RhbFswXTtcblx0XHR3aGlsZSAob2N0YWwgJiYgcGFyc2VJbnQob2N0YWwsIDgpID4gMjU1KSBvY3RhbCA9IG9jdGFsLnNsaWNlKDAsIC0xKTtcblx0XHRpZiAob2N0YWwgPT09IFwiMFwiKSBvY3RhbCA9IG51bGw7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0aWYgKG9jdGFsKSB7XG5cdFx0ICBpZiAoc3RyaWN0KSByYWlzZSh0b2tQb3MgLSAyLCBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIik7XG5cdFx0ICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChvY3RhbCwgOCkpO1xuXHRcdCAgdG9rUG9zICs9IG9jdGFsLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHQgIHN3aXRjaCAoY2gpIHtcblx0XHQgIGNhc2UgMTEwOiBvdXQgKz0gXCJcXG5cIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDExNDogb3V0ICs9IFwiXFxyXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMjA6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDIpKTsgYnJlYWs7XG5cdFx0ICBjYXNlIDExNzogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoNCkpOyBicmVhaztcblx0XHQgIGNhc2UgODU6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDgpKTsgYnJlYWs7XG5cdFx0ICBjYXNlIDExNjogb3V0ICs9IFwiXFx0XCI7IGJyZWFrO1xuXHRcdCAgY2FzZSA5ODogb3V0ICs9IFwiXFxiXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTg6IG91dCArPSBcIlxcdTAwMGJcIjsgYnJlYWs7XG5cdFx0ICBjYXNlIDEwMjogb3V0ICs9IFwiXFxmXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSA0ODogb3V0ICs9IFwiXFwwXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMzogaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gMTApICsrdG9rUG9zO1xuXHRcdCAgY2FzZSAxMDpcblx0XHRcdGlmIChvcHRpb25zLmxvY2F0aW9ucykgeyB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7ICsrdG9rQ3VyTGluZTsgfVxuXHRcdFx0YnJlYWs7XG5cdFx0ICBkZWZhdWx0OiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IGJyZWFrO1xuXHRcdCAgfVxuXHRcdH1cblx0ICB9IGVsc2Uge1xuXHRcdGlmIChjaCA9PT0gMTMgfHwgY2ggPT09IDEwIHx8IGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuXHRcdG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblx0XHQrK3Rva1Bvcztcblx0ICB9XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRIZXhDaGFyKGxlbikge1xuXHR2YXIgbiA9IHJlYWRJbnQoMTYsIGxlbik7XG5cdGlmIChuID09PSBudWxsKSByYWlzZSh0b2tTdGFydCwgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTtcblx0cmV0dXJuIG47XG4gIH1cblxuICB2YXIgY29udGFpbnNFc2M7XG5cbiAgZnVuY3Rpb24gcmVhZFdvcmQxKCkge1xuXHRjb250YWluc0VzYyA9IGZhbHNlO1xuXHR2YXIgd29yZCwgZmlyc3QgPSB0cnVlLCBzdGFydCA9IHRva1Bvcztcblx0Zm9yICg7Oykge1xuXHQgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcblx0ICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcblx0XHRpZiAoY29udGFpbnNFc2MpIHdvcmQgKz0gaW5wdXQuY2hhckF0KHRva1Bvcyk7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcblx0XHRpZiAoIWNvbnRhaW5zRXNjKSB3b3JkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG5cdFx0Y29udGFpbnNFc2MgPSB0cnVlO1xuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKSAhPSAxMTcpXG5cdFx0ICByYWlzZSh0b2tQb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTtcblx0XHQrK3Rva1Bvcztcblx0XHR2YXIgZXNjID0gcmVhZEhleENoYXIoNCk7XG5cdFx0dmFyIGVzY1N0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjKTtcblx0XHRpZiAoIWVzY1N0cikgcmFpc2UodG9rUG9zIC0gMSwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuXHRcdGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQoZXNjKSA6IGlzSWRlbnRpZmllckNoYXIoZXNjKSkpXG5cdFx0ICByYWlzZSh0b2tQb3MgLSA0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG5cdFx0d29yZCArPSBlc2NTdHI7XG5cdCAgfSBlbHNlIHtcblx0XHRicmVhaztcblx0ICB9XG5cdCAgZmlyc3QgPSBmYWxzZTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnNFc2MgPyB3b3JkIDogaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkV29yZCgpIHtcblx0dmFyIHdvcmQgPSByZWFkV29yZDEoKTtcblx0dmFyIHR5cGUgPSBfbmFtZTtcblx0aWYgKCFjb250YWluc0VzYyAmJiBpc0tleXdvcmQod29yZCkpXG5cdCAgdHlwZSA9IGtleXdvcmRUeXBlc1t3b3JkXTtcblx0cmV0dXJuIGZpbmlzaFRva2VuKHR5cGUsIHdvcmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcblx0bGFzdFN0YXJ0ID0gdG9rU3RhcnQ7XG5cdGxhc3RFbmQgPSB0b2tFbmQ7XG5cdGxhc3RFbmRMb2MgPSB0b2tFbmRMb2M7XG5cdHJlYWRUb2tlbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3RyaWN0KHN0cmN0KSB7XG5cdHN0cmljdCA9IHN0cmN0O1xuXHR0b2tQb3MgPSB0b2tTdGFydDtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdCAgd2hpbGUgKHRva1BvcyA8IHRva0xpbmVTdGFydCkge1xuXHRcdHRva0xpbmVTdGFydCA9IGlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRva0xpbmVTdGFydCAtIDIpICsgMTtcblx0XHQtLXRva0N1ckxpbmU7XG5cdCAgfVxuXHR9XG5cdHNraXBTcGFjZSgpO1xuXHRyZWFkVG9rZW4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGVfdCgpIHtcblx0dGhpcy50eXBlID0gbnVsbDtcblx0dGhpcy5zdGFydCA9IHRva1N0YXJ0O1xuXHR0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBub2RlX2xvY190KCkge1xuXHR0aGlzLnN0YXJ0ID0gdG9rU3RhcnRMb2M7XG5cdHRoaXMuZW5kID0gbnVsbDtcblx0aWYgKHNvdXJjZUZpbGUgIT09IG51bGwpIHRoaXMuc291cmNlID0gc291cmNlRmlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Tm9kZSgpIHtcblx0dmFyIG5vZGUgPSBuZXcgbm9kZV90KCk7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucylcblx0ICBub2RlLmxvYyA9IG5ldyBub2RlX2xvY190KCk7XG5cdGlmIChvcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG5cdCAgbm9kZS5zb3VyY2VGaWxlID0gb3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlO1xuXHRpZiAob3B0aW9ucy5yYW5nZXMpXG5cdCAgbm9kZS5yYW5nZSA9IFt0b2tTdGFydCwgMF07XG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnROb2RlRnJvbShvdGhlcikge1xuXHR2YXIgbm9kZSA9IG5ldyBub2RlX3QoKTtcblx0bm9kZS5zdGFydCA9IG90aGVyLnN0YXJ0O1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0ICBub2RlLmxvYyA9IG5ldyBub2RlX2xvY190KCk7XG5cdCAgbm9kZS5sb2Muc3RhcnQgPSBvdGhlci5sb2Muc3RhcnQ7XG5cdH1cblx0aWYgKG9wdGlvbnMucmFuZ2VzKVxuXHQgIG5vZGUucmFuZ2UgPSBbb3RoZXIucmFuZ2VbMF0sIDBdO1xuXG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZShub2RlLCB0eXBlKSB7XG5cdG5vZGUudHlwZSA9IHR5cGU7XG5cdG5vZGUuZW5kID0gbGFzdEVuZDtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKVxuXHQgIG5vZGUubG9jLmVuZCA9IGxhc3RFbmRMb2M7XG5cdGlmIChvcHRpb25zLnJhbmdlcylcblx0ICBub2RlLnJhbmdlWzFdID0gbGFzdEVuZDtcblx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VzZVN0cmljdChzdG10KSB7XG5cdHJldHVybiBvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJlxuXHQgIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZWF0KHR5cGUpIHtcblx0aWYgKHRva1R5cGUgPT09IHR5cGUpIHtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkluc2VydFNlbWljb2xvbigpIHtcblx0cmV0dXJuICFvcHRpb25zLnN0cmljdFNlbWljb2xvbnMgJiZcblx0ICAodG9rVHlwZSA9PT0gX2VvZiB8fCB0b2tUeXBlID09PSBfYnJhY2VSIHx8IG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbWljb2xvbigpIHtcblx0aWYgKCFlYXQoX3NlbWkpICYmICFjYW5JbnNlcnRTZW1pY29sb24oKSkgdW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0KHR5cGUpIHtcblx0aWYgKHRva1R5cGUgPT09IHR5cGUpIG5leHQoKTtcblx0ZWxzZSB1bmV4cGVjdGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmV4cGVjdGVkKCkge1xuXHRyYWlzZSh0b2tTdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMVmFsKGV4cHIpIHtcblx0aWYgKGV4cHIudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgZXhwci50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIilcblx0ICByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG5cdGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBpc1N0cmljdEJhZElkV29yZChleHByLm5hbWUpKVxuXHQgIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIFwiICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRvcExldmVsKHByb2dyYW0pIHtcblx0bGFzdFN0YXJ0ID0gbGFzdEVuZCA9IHRva1Bvcztcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSBsYXN0RW5kTG9jID0gbmV3IGxpbmVfbG9jX3Q7XG5cdGluRnVuY3Rpb24gPSBzdHJpY3QgPSBudWxsO1xuXHRsYWJlbHMgPSBbXTtcblx0cmVhZFRva2VuKCk7XG5cblx0dmFyIG5vZGUgPSBwcm9ncmFtIHx8IHN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWU7XG5cdGlmICghcHJvZ3JhbSkgbm9kZS5ib2R5ID0gW107XG5cdHdoaWxlICh0b2tUeXBlICE9PSBfZW9mKSB7XG5cdCAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuXHQgIGlmIChmaXJzdCAmJiBpc1VzZVN0cmljdChzdG10KSkgc2V0U3RyaWN0KHRydWUpO1xuXHQgIGZpcnN0ID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpO1xuICB9XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuXHRpZiAodG9rVHlwZSA9PT0gX3NsYXNoIHx8IHRva1R5cGUgPT09IF9hc3NpZ24gJiYgdG9rVmFsID09IFwiLz1cIilcblx0ICByZWFkVG9rZW4odHJ1ZSk7XG5cblx0dmFyIHN0YXJ0dHlwZSA9IHRva1R5cGUsIG5vZGUgPSBzdGFydE5vZGUoKTtcblxuXHRzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuXHRjYXNlIF9icmVhazogY2FzZSBfY29udGludWU6XG5cdCAgbmV4dCgpO1xuXHQgIHZhciBpc0JyZWFrID0gc3RhcnR0eXBlID09PSBfYnJlYWs7XG5cdCAgaWYgKGVhdChfc2VtaSkgfHwgY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUubGFiZWwgPSBudWxsO1xuXHQgIGVsc2UgaWYgKHRva1R5cGUgIT09IF9uYW1lKSB1bmV4cGVjdGVkKCk7XG5cdCAgZWxzZSB7XG5cdFx0bm9kZS5sYWJlbCA9IHBhcnNlSWRlbnQoKTtcblx0XHRzZW1pY29sb24oKTtcblx0ICB9XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBsYWIgPSBsYWJlbHNbaV07XG5cdFx0aWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG5cdFx0ICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSBicmVhaztcblx0XHQgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrO1xuXHRcdH1cblx0ICB9XG5cdCAgaWYgKGkgPT09IGxhYmVscy5sZW5ndGgpIHJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBzdGFydHR5cGUua2V5d29yZCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfZGVidWdnZXI6XG5cdCAgbmV4dCgpO1xuXHQgIHNlbWljb2xvbigpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfZG86XG5cdCAgbmV4dCgpO1xuXHQgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG5cdCAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBsYWJlbHMucG9wKCk7XG5cdCAgZXhwZWN0KF93aGlsZSk7XG5cdCAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBzZW1pY29sb24oKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfZm9yOlxuXHQgIG5leHQoKTtcblx0ICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXHQgIGV4cGVjdChfcGFyZW5MKTtcblx0ICBpZiAodG9rVHlwZSA9PT0gX3NlbWkpIHJldHVybiBwYXJzZUZvcihub2RlLCBudWxsKTtcblx0ICBpZiAodG9rVHlwZSA9PT0gX3Zhcikge1xuXHRcdHZhciBpbml0ID0gc3RhcnROb2RlKCk7XG5cdFx0bmV4dCgpO1xuXHRcdHBhcnNlVmFyKGluaXQsIHRydWUpO1xuXHRcdGZpbmlzaE5vZGUoaW5pdCwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuXHRcdGlmIChpbml0LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZWF0KF9pbikpXG5cdFx0ICByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTtcblx0XHRyZXR1cm4gcGFyc2VGb3Iobm9kZSwgaW5pdCk7XG5cdCAgfVxuXHQgIHZhciBpbml0ID0gcGFyc2VFeHByZXNzaW9uKGZhbHNlLCB0cnVlKTtcblx0ICBpZiAoZWF0KF9pbikpIHtjaGVja0xWYWwoaW5pdCk7IHJldHVybiBwYXJzZUZvckluKG5vZGUsIGluaXQpO31cblx0ICByZXR1cm4gcGFyc2VGb3Iobm9kZSwgaW5pdCk7XG5cblx0Y2FzZSBfZnVuY3Rpb246XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUpO1xuXG5cdGNhc2UgX2lmOlxuXHQgIG5leHQoKTtcblx0ICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbm9kZS5hbHRlcm5hdGUgPSBlYXQoX2Vsc2UpID8gcGFyc2VTdGF0ZW1lbnQoKSA6IG51bGw7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9yZXR1cm46XG5cdCAgaWYgKCFpbkZ1bmN0aW9uICYmICFvcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuXHRcdHJhaXNlKHRva1N0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG5cdCAgbmV4dCgpO1xuXG5cdCAgaWYgKGVhdChfc2VtaSkgfHwgY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuXHQgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7IHNlbWljb2xvbigpOyB9XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfc3dpdGNoOlxuXHQgIG5leHQoKTtcblx0ICBub2RlLmRpc2NyaW1pbmFudCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgbm9kZS5jYXNlcyA9IFtdO1xuXHQgIGV4cGVjdChfYnJhY2VMKTtcblx0ICBsYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG5cblx0ICBmb3IgKHZhciBjdXIsIHNhd0RlZmF1bHQ7IHRva1R5cGUgIT0gX2JyYWNlUjspIHtcblx0XHRpZiAodG9rVHlwZSA9PT0gX2Nhc2UgfHwgdG9rVHlwZSA9PT0gX2RlZmF1bHQpIHtcblx0XHQgIHZhciBpc0Nhc2UgPSB0b2tUeXBlID09PSBfY2FzZTtcblx0XHQgIGlmIChjdXIpIGZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG5cdFx0ICBub2RlLmNhc2VzLnB1c2goY3VyID0gc3RhcnROb2RlKCkpO1xuXHRcdCAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcblx0XHQgIG5leHQoKTtcblx0XHQgIGlmIChpc0Nhc2UpIGN1ci50ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdFx0ICBlbHNlIHtcblx0XHRcdGlmIChzYXdEZWZhdWx0KSByYWlzZShsYXN0U3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyBzYXdEZWZhdWx0ID0gdHJ1ZTtcblx0XHRcdGN1ci50ZXN0ID0gbnVsbDtcblx0XHQgIH1cblx0XHQgIGV4cGVjdChfY29sb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBpZiAoIWN1cikgdW5leHBlY3RlZCgpO1xuXHRcdCAgY3VyLmNvbnNlcXVlbnQucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcblx0XHR9XG5cdCAgfVxuXHQgIGlmIChjdXIpIGZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG5cdCAgbmV4dCgpO1xuXHQgIGxhYmVscy5wb3AoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF90aHJvdzpcblx0ICBuZXh0KCk7XG5cdCAgaWYgKG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKVxuXHRcdHJhaXNlKGxhc3RFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpO1xuXHQgIG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICBzZW1pY29sb24oKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3RyeTpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5ibG9jayA9IHBhcnNlQmxvY2soKTtcblx0ICBub2RlLmhhbmRsZXIgPSBudWxsO1xuXHQgIGlmICh0b2tUeXBlID09PSBfY2F0Y2gpIHtcblx0XHR2YXIgY2xhdXNlID0gc3RhcnROb2RlKCk7XG5cdFx0bmV4dCgpO1xuXHRcdGV4cGVjdChfcGFyZW5MKTtcblx0XHRjbGF1c2UucGFyYW0gPSBwYXJzZUlkZW50KCk7XG5cdFx0aWYgKHN0cmljdCAmJiBpc1N0cmljdEJhZElkV29yZChjbGF1c2UucGFyYW0ubmFtZSkpXG5cdFx0ICByYWlzZShjbGF1c2UucGFyYW0uc3RhcnQsIFwiQmluZGluZyBcIiArIGNsYXVzZS5wYXJhbS5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG5cdFx0ZXhwZWN0KF9wYXJlblIpO1xuXHRcdGNsYXVzZS5ndWFyZCA9IG51bGw7XG5cdFx0Y2xhdXNlLmJvZHkgPSBwYXJzZUJsb2NrKCk7XG5cdFx0bm9kZS5oYW5kbGVyID0gZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG5cdCAgfVxuXHQgIG5vZGUuZ3VhcmRlZEhhbmRsZXJzID0gZW1wdHk7XG5cdCAgbm9kZS5maW5hbGl6ZXIgPSBlYXQoX2ZpbmFsbHkpID8gcGFyc2VCbG9jaygpIDogbnVsbDtcblx0ICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG5cdFx0cmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3Zhcjpcblx0ICBuZXh0KCk7XG5cdCAgcGFyc2VWYXIobm9kZSk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuXG5cdGNhc2UgX3doaWxlOlxuXHQgIG5leHQoKTtcblx0ICBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG5cdCAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBsYWJlbHMucG9wKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF93aXRoOlxuXHQgIGlmIChzdHJpY3QpIHJhaXNlKHRva1N0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTtcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5vYmplY3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2JyYWNlTDpcblx0ICByZXR1cm4gcGFyc2VCbG9jaygpO1xuXG5cdGNhc2UgX3NlbWk6XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG5cblx0ZGVmYXVsdDpcblx0ICB2YXIgbWF5YmVOYW1lID0gdG9rVmFsLCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgaWYgKHN0YXJ0dHlwZSA9PT0gX25hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBlYXQoX2NvbG9uKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKVxuXHRcdCAgaWYgKGxhYmVsc1tpXS5uYW1lID09PSBtYXliZU5hbWUpIHJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG5cdFx0dmFyIGtpbmQgPSB0b2tUeXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdG9rVHlwZSA9PT0gX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuXHRcdGxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmR9KTtcblx0XHRub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHRcdGxhYmVscy5wb3AoKTtcblx0XHRub2RlLmxhYmVsID0gZXhwcjtcblx0XHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG5cdCAgfSBlbHNlIHtcblx0XHRub2RlLmV4cHJlc3Npb24gPSBleHByO1xuXHRcdHNlbWljb2xvbigpO1xuXHRcdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcblx0ICB9XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGFyZW5FeHByZXNzaW9uKCkge1xuXHRleHBlY3QoX3BhcmVuTCk7XG5cdHZhciB2YWwgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9wYXJlblIpO1xuXHRyZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VCbG9jayhhbGxvd1N0cmljdCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHN0cmljdCA9IGZhbHNlLCBvbGRTdHJpY3Q7XG5cdG5vZGUuYm9keSA9IFtdO1xuXHRleHBlY3QoX2JyYWNlTCk7XG5cdHdoaWxlICghZWF0KF9icmFjZVIpKSB7XG5cdCAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuXHQgIGlmIChmaXJzdCAmJiBhbGxvd1N0cmljdCAmJiBpc1VzZVN0cmljdChzdG10KSkge1xuXHRcdG9sZFN0cmljdCA9IHN0cmljdDtcblx0XHRzZXRTdHJpY3Qoc3RyaWN0ID0gdHJ1ZSk7XG5cdCAgfVxuXHQgIGZpcnN0ID0gZmFsc2U7XG5cdH1cblx0aWYgKHN0cmljdCAmJiAhb2xkU3RyaWN0KSBzZXRTdHJpY3QoZmFsc2UpO1xuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb3Iobm9kZSwgaW5pdCkge1xuXHRub2RlLmluaXQgPSBpbml0O1xuXHRleHBlY3QoX3NlbWkpO1xuXHRub2RlLnRlc3QgPSB0b2tUeXBlID09PSBfc2VtaSA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9zZW1pKTtcblx0bm9kZS51cGRhdGUgPSB0b2tUeXBlID09PSBfcGFyZW5SID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRleHBlY3QoX3BhcmVuUik7XG5cdG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdGxhYmVscy5wb3AoKTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZvckluKG5vZGUsIGluaXQpIHtcblx0bm9kZS5sZWZ0ID0gaW5pdDtcblx0bm9kZS5yaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRleHBlY3QoX3BhcmVuUik7XG5cdG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdGxhYmVscy5wb3AoKTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGb3JJblN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVmFyKG5vZGUsIG5vSW4pIHtcblx0bm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcblx0bm9kZS5raW5kID0gXCJ2YXJcIjtcblx0Zm9yICg7Oykge1xuXHQgIHZhciBkZWNsID0gc3RhcnROb2RlKCk7XG5cdCAgZGVjbC5pZCA9IHBhcnNlSWRlbnQoKTtcblx0ICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0QmFkSWRXb3JkKGRlY2wuaWQubmFtZSkpXG5cdFx0cmFpc2UoZGVjbC5pZC5zdGFydCwgXCJCaW5kaW5nIFwiICsgZGVjbC5pZC5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgZGVjbC5pbml0ID0gZWF0KF9lcSkgPyBwYXJzZUV4cHJlc3Npb24odHJ1ZSwgbm9JbikgOiBudWxsO1xuXHQgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2goZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG5cdCAgaWYgKCFlYXQoX2NvbW1hKSkgYnJlYWs7XG5cdH1cblx0cmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24obm9Db21tYSwgbm9Jbikge1xuXHR2YXIgZXhwciA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG5cdGlmICghbm9Db21tYSAmJiB0b2tUeXBlID09PSBfY29tbWEpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG5cdCAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcblx0ICB3aGlsZSAoZWF0KF9jb21tYSkpIG5vZGUuZXhwcmVzc2lvbnMucHVzaChwYXJzZU1heWJlQXNzaWduKG5vSW4pKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVBc3NpZ24obm9Jbikge1xuXHR2YXIgbGVmdCA9IHBhcnNlTWF5YmVDb25kaXRpb25hbChub0luKTtcblx0aWYgKHRva1R5cGUuaXNBc3NpZ24pIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obGVmdCk7XG5cdCAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcblx0ICBub2RlLmxlZnQgPSBsZWZ0O1xuXHQgIG5leHQoKTtcblx0ICBub2RlLnJpZ2h0ID0gcGFyc2VNYXliZUFzc2lnbihub0luKTtcblx0ICBjaGVja0xWYWwobGVmdCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcblx0fVxuXHRyZXR1cm4gbGVmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVDb25kaXRpb25hbChub0luKSB7XG5cdHZhciBleHByID0gcGFyc2VFeHByT3BzKG5vSW4pO1xuXHRpZiAoZWF0KF9xdWVzdGlvbikpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG5cdCAgbm9kZS50ZXN0ID0gZXhwcjtcblx0ICBub2RlLmNvbnNlcXVlbnQgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG5cdCAgZXhwZWN0KF9jb2xvbik7XG5cdCAgbm9kZS5hbHRlcm5hdGUgPSBwYXJzZUV4cHJlc3Npb24odHJ1ZSwgbm9Jbik7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJPcHMobm9Jbikge1xuXHRyZXR1cm4gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KCksIC0xLCBub0luKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwck9wKGxlZnQsIG1pblByZWMsIG5vSW4pIHtcblx0dmFyIHByZWMgPSB0b2tUeXBlLmJpbm9wO1xuXHRpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0b2tUeXBlICE9PSBfaW4pKSB7XG5cdCAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG5cdFx0dmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuXHRcdG5vZGUubGVmdCA9IGxlZnQ7XG5cdFx0bm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcblx0XHR2YXIgb3AgPSB0b2tUeXBlO1xuXHRcdG5leHQoKTtcblx0XHRub2RlLnJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KCksIHByZWMsIG5vSW4pO1xuXHRcdHZhciBleHByTm9kZSA9IGZpbmlzaE5vZGUobm9kZSwgKG9wID09PSBfbG9naWNhbE9SIHx8IG9wID09PSBfbG9naWNhbEFORCkgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG5cdFx0cmV0dXJuIHBhcnNlRXhwck9wKGV4cHJOb2RlLCBtaW5QcmVjLCBub0luKTtcblx0ICB9XG5cdH1cblx0cmV0dXJuIGxlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlVW5hcnkoKSB7XG5cdGlmICh0b2tUeXBlLnByZWZpeCkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRva1R5cGUuaXNVcGRhdGU7XG5cdCAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcblx0ICBub2RlLnByZWZpeCA9IHRydWU7XG5cdCAgdG9rUmVnZXhwQWxsb3dlZCA9IHRydWU7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuYXJndW1lbnQgPSBwYXJzZU1heWJlVW5hcnkoKTtcblx0ICBpZiAodXBkYXRlKSBjaGVja0xWYWwobm9kZS5hcmd1bWVudCk7XG5cdCAgZWxzZSBpZiAoc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcblx0XHRcdCAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG5cdFx0cmFpc2Uobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHZhciBleHByID0gcGFyc2VFeHByU3Vic2NyaXB0cygpO1xuXHR3aGlsZSAodG9rVHlwZS5wb3N0Zml4ICYmICFjYW5JbnNlcnRTZW1pY29sb24oKSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShleHByKTtcblx0ICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuXHQgIG5vZGUucHJlZml4ID0gZmFsc2U7XG5cdCAgbm9kZS5hcmd1bWVudCA9IGV4cHI7XG5cdCAgY2hlY2tMVmFsKGV4cHIpO1xuXHQgIG5leHQoKTtcblx0ICBleHByID0gZmluaXNoTm9kZShub2RlLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHRzKCkge1xuXHRyZXR1cm4gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgbm9DYWxscykge1xuXHRpZiAoZWF0KF9kb3QpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuXHQgIG5vZGUub2JqZWN0ID0gYmFzZTtcblx0ICBub2RlLnByb3BlcnR5ID0gcGFyc2VJZGVudCh0cnVlKTtcblx0ICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG5cdCAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG5cdH0gZWxzZSBpZiAoZWF0KF9icmFja2V0TCkpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG5cdCAgbm9kZS5vYmplY3QgPSBiYXNlO1xuXHQgIG5vZGUucHJvcGVydHkgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ICBub2RlLmNvbXB1dGVkID0gdHJ1ZTtcblx0ICBleHBlY3QoX2JyYWNrZXRSKTtcblx0ICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcblx0fSBlbHNlIGlmICghbm9DYWxscyAmJiBlYXQoX3BhcmVuTCkpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oYmFzZSk7XG5cdCAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuXHQgIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG5cdCAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuXHR9IGVsc2UgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJBdG9tKCkge1xuXHRzd2l0Y2ggKHRva1R5cGUpIHtcblx0Y2FzZSBfdGhpczpcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuXHRjYXNlIF9uYW1lOlxuXHQgIHJldHVybiBwYXJzZUlkZW50KCk7XG5cdGNhc2UgX251bTogY2FzZSBfc3RyaW5nOiBjYXNlIF9yZWdleHA6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBub2RlLnZhbHVlID0gdG9rVmFsO1xuXHQgIG5vZGUucmF3ID0gaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCk7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuXHRjYXNlIF9udWxsOiBjYXNlIF90cnVlOiBjYXNlIF9mYWxzZTpcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHQgIG5vZGUudmFsdWUgPSB0b2tUeXBlLmF0b21WYWx1ZTtcblx0ICBub2RlLnJhdyA9IHRva1R5cGUua2V5d29yZDtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG5cdGNhc2UgX3BhcmVuTDpcblx0ICB2YXIgdG9rU3RhcnRMb2MxID0gdG9rU3RhcnRMb2MsIHRva1N0YXJ0MSA9IHRva1N0YXJ0O1xuXHQgIG5leHQoKTtcblx0ICB2YXIgdmFsID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgdmFsLnN0YXJ0ID0gdG9rU3RhcnQxO1xuXHQgIHZhbC5lbmQgPSB0b2tFbmQ7XG5cdCAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdFx0dmFsLmxvYy5zdGFydCA9IHRva1N0YXJ0TG9jMTtcblx0XHR2YWwubG9jLmVuZCA9IHRva0VuZExvYztcblx0ICB9XG5cdCAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuXHRcdHZhbC5yYW5nZSA9IFt0b2tTdGFydDEsIHRva0VuZF07XG5cdCAgZXhwZWN0KF9wYXJlblIpO1xuXHQgIHJldHVybiB2YWw7XG5cblx0Y2FzZSBfYnJhY2tldEw6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5lbGVtZW50cyA9IHBhcnNlRXhwckxpc3QoX2JyYWNrZXRSLCB0cnVlLCB0cnVlKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKTtcblxuXHRjYXNlIF9icmFjZUw6XG5cdCAgcmV0dXJuIHBhcnNlT2JqKCk7XG5cblx0Y2FzZSBfZnVuY3Rpb246XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIHBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UpO1xuXG5cdGNhc2UgX25ldzpcblx0ICByZXR1cm4gcGFyc2VOZXcoKTtcblxuXHRkZWZhdWx0OlxuXHQgIHVuZXhwZWN0ZWQoKTtcblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOZXcoKSB7XG5cdHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdG5leHQoKTtcblx0bm9kZS5jYWxsZWUgPSBwYXJzZVN1YnNjcmlwdHMocGFyc2VFeHByQXRvbSgpLCB0cnVlKTtcblx0aWYgKGVhdChfcGFyZW5MKSkgbm9kZS5hcmd1bWVudHMgPSBwYXJzZUV4cHJMaXN0KF9wYXJlblIsIGZhbHNlKTtcblx0ZWxzZSBub2RlLmFyZ3VtZW50cyA9IGVtcHR5O1xuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iaigpIHtcblx0dmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBzYXdHZXRTZXQgPSBmYWxzZTtcblx0bm9kZS5wcm9wZXJ0aWVzID0gW107XG5cdG5leHQoKTtcblx0d2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcblx0ICBpZiAoIWZpcnN0KSB7XG5cdFx0ZXhwZWN0KF9jb21tYSk7XG5cdFx0aWYgKG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoX2JyYWNlUikpIGJyZWFrO1xuXHQgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG5cdCAgdmFyIHByb3AgPSB7a2V5OiBwYXJzZVByb3BlcnR5TmFtZSgpfSwgaXNHZXRTZXQgPSBmYWxzZSwga2luZDtcblx0ICBpZiAoZWF0KF9jb2xvbikpIHtcblx0XHRwcm9wLnZhbHVlID0gcGFyc2VFeHByZXNzaW9uKHRydWUpO1xuXHRcdGtpbmQgPSBwcm9wLmtpbmQgPSBcImluaXRcIjtcblx0ICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuXHRcdFx0XHQgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikpIHtcblx0XHRpc0dldFNldCA9IHNhd0dldFNldCA9IHRydWU7XG5cdFx0a2luZCA9IHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG5cdFx0cHJvcC5rZXkgPSBwYXJzZVByb3BlcnR5TmFtZSgpO1xuXHRcdGlmICh0b2tUeXBlICE9PSBfcGFyZW5MKSB1bmV4cGVjdGVkKCk7XG5cdFx0cHJvcC52YWx1ZSA9IHBhcnNlRnVuY3Rpb24oc3RhcnROb2RlKCksIGZhbHNlKTtcblx0ICB9IGVsc2UgdW5leHBlY3RlZCgpO1xuXG5cdCAgaWYgKHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChzdHJpY3QgfHwgc2F3R2V0U2V0KSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0ICB2YXIgb3RoZXIgPSBub2RlLnByb3BlcnRpZXNbaV07XG5cdFx0ICBpZiAob3RoZXIua2V5Lm5hbWUgPT09IHByb3Aua2V5Lm5hbWUpIHtcblx0XHRcdHZhciBjb25mbGljdCA9IGtpbmQgPT0gb3RoZXIua2luZCB8fCBpc0dldFNldCAmJiBvdGhlci5raW5kID09PSBcImluaXRcIiB8fFxuXHRcdFx0ICBraW5kID09PSBcImluaXRcIiAmJiAob3RoZXIua2luZCA9PT0gXCJnZXRcIiB8fCBvdGhlci5raW5kID09PSBcInNldFwiKTtcblx0XHRcdGlmIChjb25mbGljdCAmJiAhc3RyaWN0ICYmIGtpbmQgPT09IFwiaW5pdFwiICYmIG90aGVyLmtpbmQgPT09IFwiaW5pdFwiKSBjb25mbGljdCA9IGZhbHNlO1xuXHRcdFx0aWYgKGNvbmZsaWN0KSByYWlzZShwcm9wLmtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7XG5cdFx0ICB9XG5cdFx0fVxuXHQgIH1cblx0ICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcblx0fVxuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TmFtZSgpIHtcblx0aWYgKHRva1R5cGUgPT09IF9udW0gfHwgdG9rVHlwZSA9PT0gX3N0cmluZykgcmV0dXJuIHBhcnNlRXhwckF0b20oKTtcblx0cmV0dXJuIHBhcnNlSWRlbnQodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG5cdGlmICh0b2tUeXBlID09PSBfbmFtZSkgbm9kZS5pZCA9IHBhcnNlSWRlbnQoKTtcblx0ZWxzZSBpZiAoaXNTdGF0ZW1lbnQpIHVuZXhwZWN0ZWQoKTtcblx0ZWxzZSBub2RlLmlkID0gbnVsbDtcblx0bm9kZS5wYXJhbXMgPSBbXTtcblx0dmFyIGZpcnN0ID0gdHJ1ZTtcblx0ZXhwZWN0KF9wYXJlbkwpO1xuXHR3aGlsZSAoIWVhdChfcGFyZW5SKSkge1xuXHQgIGlmICghZmlyc3QpIGV4cGVjdChfY29tbWEpOyBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cdCAgbm9kZS5wYXJhbXMucHVzaChwYXJzZUlkZW50KCkpO1xuXHR9XG5cblx0dmFyIG9sZEluRnVuYyA9IGluRnVuY3Rpb24sIG9sZExhYmVscyA9IGxhYmVscztcblx0aW5GdW5jdGlvbiA9IHRydWU7IGxhYmVscyA9IFtdO1xuXHRub2RlLmJvZHkgPSBwYXJzZUJsb2NrKHRydWUpO1xuXHRpbkZ1bmN0aW9uID0gb2xkSW5GdW5jOyBsYWJlbHMgPSBvbGRMYWJlbHM7XG5cblx0aWYgKHN0cmljdCB8fCBub2RlLmJvZHkuYm9keS5sZW5ndGggJiYgaXNVc2VTdHJpY3Qobm9kZS5ib2R5LmJvZHlbMF0pKSB7XG5cdCAgZm9yICh2YXIgaSA9IG5vZGUuaWQgPyAtMSA6IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBpZCA9IGkgPCAwID8gbm9kZS5pZCA6IG5vZGUucGFyYW1zW2ldO1xuXHRcdGlmIChpc1N0cmljdFJlc2VydmVkV29yZChpZC5uYW1lKSB8fCBpc1N0cmljdEJhZElkV29yZChpZC5uYW1lKSlcblx0XHQgIHJhaXNlKGlkLnN0YXJ0LCBcIkRlZmluaW5nICdcIiArIGlkLm5hbWUgKyBcIicgaW4gc3RyaWN0IG1vZGVcIik7XG5cdFx0aWYgKGkgPj0gMCkgZm9yICh2YXIgaiA9IDA7IGogPCBpOyArK2opIGlmIChpZC5uYW1lID09PSBub2RlLnBhcmFtc1tqXS5uYW1lKVxuXHRcdCAgcmFpc2UoaWQuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaCBpbiBzdHJpY3QgbW9kZVwiKTtcblx0ICB9XG5cdH1cblxuXHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHkpIHtcblx0dmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuXHR3aGlsZSAoIWVhdChjbG9zZSkpIHtcblx0ICBpZiAoIWZpcnN0KSB7XG5cdFx0ZXhwZWN0KF9jb21tYSk7XG5cdFx0aWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiBvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KGNsb3NlKSkgYnJlYWs7XG5cdCAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cblx0ICBpZiAoYWxsb3dFbXB0eSAmJiB0b2tUeXBlID09PSBfY29tbWEpIGVsdHMucHVzaChudWxsKTtcblx0ICBlbHNlIGVsdHMucHVzaChwYXJzZUV4cHJlc3Npb24odHJ1ZSkpO1xuXHR9XG5cdHJldHVybiBlbHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZGVudChsaWJlcmFsKSB7XG5cdHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdGlmIChsaWJlcmFsICYmIG9wdGlvbnMuZm9yYmlkUmVzZXJ2ZWQgPT0gXCJldmVyeXdoZXJlXCIpIGxpYmVyYWwgPSBmYWxzZTtcblx0aWYgKHRva1R5cGUgPT09IF9uYW1lKSB7XG5cdCAgaWYgKCFsaWJlcmFsICYmXG5cdFx0ICAob3B0aW9ucy5mb3JiaWRSZXNlcnZlZCAmJlxuXHRcdCAgIChvcHRpb25zLmVjbWFWZXJzaW9uID09PSAzID8gaXNSZXNlcnZlZFdvcmQzIDogaXNSZXNlcnZlZFdvcmQ1KSh0b2tWYWwpIHx8XG5cdFx0ICAgc3RyaWN0ICYmIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHRva1ZhbCkpICYmXG5cdFx0ICBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKS5pbmRleE9mKFwiXFxcXFwiKSA9PSAtMSlcblx0XHRyYWlzZSh0b2tTdGFydCwgXCJUaGUga2V5d29yZCAnXCIgKyB0b2tWYWwgKyBcIicgaXMgcmVzZXJ2ZWRcIik7XG5cdCAgbm9kZS5uYW1lID0gdG9rVmFsO1xuXHR9IGVsc2UgaWYgKGxpYmVyYWwgJiYgdG9rVHlwZS5rZXl3b3JkKSB7XG5cdCAgbm9kZS5uYW1lID0gdG9rVHlwZS5rZXl3b3JkO1xuXHR9IGVsc2Uge1xuXHQgIHVuZXhwZWN0ZWQoKTtcblx0fVxuXHR0b2tSZWdleHBBbGxvd2VkID0gZmFsc2U7XG5cdG5leHQoKTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG5cbn0pO1xuXG5cdFx0aWYgKCFhY29ybi52ZXJzaW9uKVxuXHRcdFx0YWNvcm4gPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiAoZ2xvYmFsLmFjb3JuIHx8IGFjb3JuKS5wYXJzZShjb2RlLCBvcHRpb25zKTtcblx0fVxuXG5cdHZhciBiaW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0JysnOiAnX19hZGQnLFxuXHRcdCctJzogJ19fc3VidHJhY3QnLFxuXHRcdCcqJzogJ19fbXVsdGlwbHknLFxuXHRcdCcvJzogJ19fZGl2aWRlJyxcblx0XHQnJSc6ICdfX21vZHVsbycsXG5cdFx0Jz09JzogJ19fZXF1YWxzJyxcblx0XHQnIT0nOiAnX19lcXVhbHMnXG5cdH07XG5cblx0dmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCctJzogJ19fbmVnYXRlJyxcblx0XHQnKyc6ICdfX3NlbGYnXG5cdH07XG5cblx0dmFyIGZpZWxkcyA9IEJhc2UuZWFjaChcblx0XHRbJ2FkZCcsICdzdWJ0cmFjdCcsICdtdWx0aXBseScsICdkaXZpZGUnLCAnbW9kdWxvJywgJ2VxdWFscycsICduZWdhdGUnXSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzWydfXycgKyBuYW1lXSA9ICcjJyArIG5hbWU7XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRfX3NlbGY6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdCk7XG5cdFBvaW50LmluamVjdChmaWVsZHMpO1xuXHRTaXplLmluamVjdChmaWVsZHMpO1xuXHRDb2xvci5pbmplY3QoZmllbGRzKTtcblxuXHRmdW5jdGlvbiBfXyRfXyhsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcblx0XHR2YXIgaGFuZGxlciA9IGJpbmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cdFx0aWYgKGxlZnQgJiYgbGVmdFtoYW5kbGVyXSkge1xuXHRcdFx0dmFyIHJlcyA9IGxlZnRbaGFuZGxlcl0ocmlnaHQpO1xuXHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSAnIT0nID8gIXJlcyA6IHJlcztcblx0XHR9XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuXHRcdGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuXHRcdGNhc2UgJy8nOiByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuXHRcdGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuXHRcdGNhc2UgJz09JzogcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG5cdFx0Y2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPSByaWdodDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiAkX18ob3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dmFyIGhhbmRsZXIgPSB1bmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cdFx0aWYgKHZhbHVlICYmIHZhbHVlW2hhbmRsZXJdKVxuXHRcdFx0cmV0dXJuIHZhbHVlW2hhbmRsZXJdKCk7XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gK3ZhbHVlO1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gLXZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBpbGUoY29kZSwgb3B0aW9ucykge1xuXHRcdGlmICghY29kZSlcblx0XHRcdHJldHVybiAnJztcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciBpbnNlcnRpb25zID0gW107XG5cblx0XHRmdW5jdGlvbiBnZXRPZmZzZXQob2Zmc2V0KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc2VydGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnNlcnRpb24gPSBpbnNlcnRpb25zW2ldO1xuXHRcdFx0XHRpZiAoaW5zZXJ0aW9uWzBdID49IG9mZnNldClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0b2Zmc2V0ICs9IGluc2VydGlvblsxXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29kZShub2RlKSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChub2RlLnJhbmdlWzFdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QmV0d2VlbihsZWZ0LCByaWdodCkge1xuXHRcdFx0cmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChsZWZ0LnJhbmdlWzFdKSxcblx0XHRcdFx0XHRnZXRPZmZzZXQocmlnaHQucmFuZ2VbMF0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlQ29kZShub2RlLCBzdHIpIHtcblx0XHRcdHZhciBzdGFydCA9IGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0ZW5kID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pLFxuXHRcdFx0XHRpbnNlcnQgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluc2VydGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHN0YXJ0ID4gaW5zZXJ0aW9uc1tpXVswXSkge1xuXHRcdFx0XHRcdGluc2VydCA9IGkgKyAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbnNlcnRpb25zLnNwbGljZShpbnNlcnQsIDAsIFtzdGFydCwgc3RyLmxlbmd0aCAtIGVuZCArIHN0YXJ0XSk7XG5cdFx0XHRjb2RlID0gY29kZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgc3RyICsgY29kZS5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVPdmVybG9hZGluZyhub2RlLCBwYXJlbnQpIHtcblx0XHRcdHN3aXRjaCAobm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiB1bmFyeU9wZXJhdG9yc1xuXHRcdFx0XHRcdFx0JiYgbm9kZS5hcmd1bWVudC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KTtcblx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAnJF9fKFwiJyArIG5vZGUub3BlcmF0b3IgKyAnXCIsICdcblx0XHRcdFx0XHRcdFx0KyBhcmcgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIGJpbmFyeU9wZXJhdG9yc1xuXHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0YmV0d2VlbiA9IGdldEJldHdlZW4obm9kZS5sZWZ0LCBub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAnX18kX18oJyArIGxlZnQgKyAnLCdcblx0XHRcdFx0XHRcdFx0KyBiZXR3ZWVuLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcgKyBvcGVyYXRvciksXG5cdFx0XHRcdFx0XHRcdFx0J1wiJyArIG9wZXJhdG9yICsgJ1wiJylcblx0XHRcdFx0XHRcdFx0KyAnLCAnICsgcmlnaHQgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG5cdFx0XHRjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG5cdFx0XHRcdHZhciBwYXJlbnRUeXBlID0gcGFyZW50ICYmIHBhcmVudC50eXBlO1xuXHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdHBhcmVudFR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0JiYgL15bPSE8Pl0vLnRlc3QocGFyZW50Lm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIHBhcmVudC5jb21wdXRlZFxuXHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gJ1VwZGF0ZUV4cHJlc3Npb24nKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KSxcblx0XHRcdFx0XHRcdFx0ZXhwID0gJ19fJF9fKCcgKyBhcmcgKyAnLCBcIicgKyBub2RlLm9wZXJhdG9yWzBdXG5cdFx0XHRcdFx0XHRcdFx0XHQrICdcIiwgMSknLFxuXHRcdFx0XHRcdFx0XHRzdHIgPSBhcmcgKyAnID0gJyArIGV4cDtcblx0XHRcdFx0XHRcdGlmIChub2RlLnByZWZpeCkge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSAnKCcgKyBzdHIgKyAnKSc7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nIHx8XG5cdFx0XHRcdFx0XHRcdHBhcmVudFR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8XG5cdFx0XHRcdFx0XHRcdHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChnZXRDb2RlKHBhcmVudC5sZWZ0IHx8IHBhcmVudC5pZCkgPT09IGFyZylcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBleHA7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICc7ICcgKyBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoL14uPSQvLnRlc3Qobm9kZS5vcGVyYXRvcilcblx0XHRcdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuXHRcdFx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdFx0XHRleHAgPSBsZWZ0ICsgJyA9IF9fJF9fKCcgKyBsZWZ0ICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJztcblx0XHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgL15cXCguKlxcKSQvLnRlc3QoZ2V0Q29kZShub2RlKSlcblx0XHRcdFx0XHRcdFx0XHRcdD8gJygnICsgZXhwICsgJyknIDogZXhwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlRXhwb3J0cyhub2RlKSB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJzpcblx0XHRcdFx0cmVwbGFjZUNvZGUoe1xuXHRcdFx0XHRcdHJhbmdlOiBbbm9kZS5zdGFydCwgbm9kZS5kZWNsYXJhdGlvbi5zdGFydF1cblx0XHRcdFx0fSwgJ21vZHVsZS5leHBvcnRzID0gJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbic6XG5cdFx0XHRcdHZhciBkZWNsYXJhdGlvbiA9IG5vZGUuZGVjbGFyYXRpb247XG5cdFx0XHRcdHZhciBzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzO1xuXHRcdFx0XHRpZiAoZGVjbGFyYXRpb24pIHtcblx0XHRcdFx0XHR2YXIgZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zO1xuXHRcdFx0XHRcdGlmIChkZWNsYXJhdGlvbnMpIHtcblx0XHRcdFx0XHRcdGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlYykge1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShkZWMsICdtb2R1bGUuZXhwb3J0cy4nICsgZ2V0Q29kZShkZWMpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUoe1xuXHRcdFx0XHRcdFx0XHRyYW5nZTogW1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb24uc3RhcnQgKyBkZWNsYXJhdGlvbi5raW5kLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHR9LCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNwZWNpZmllcnMpIHtcblx0XHRcdFx0XHR2YXIgZXhwb3J0cyA9IHNwZWNpZmllcnMubWFwKGZ1bmN0aW9uKHNwZWNpZmllcikge1xuXHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBnZXRDb2RlKHNwZWNpZmllcik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ21vZHVsZS5leHBvcnRzLicgKyBuYW1lICsgJyA9ICcgKyBuYW1lICsgJzsgJztcblx0XHRcdFx0XHR9KS5qb2luKCcnKTtcblx0XHRcdFx0XHRpZiAoZXhwb3J0cykge1xuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgZXhwb3J0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhbGtBU1Qobm9kZSwgcGFyZW50LCBwYXBlckZlYXR1cmVzKSB7XG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuXHRcdFx0XHRcdGlmIChrZXkgIT09ICdyYW5nZScgJiYga2V5ICE9PSAnbG9jJykge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSwgcGFwZXJGZWF0dXJlcyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlLCBub2RlLCBwYXBlckZlYXR1cmVzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhcGVyRmVhdHVyZXMub3BlcmF0b3JPdmVybG9hZGluZyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRoYW5kbGVPdmVybG9hZGluZyhub2RlLCBwYXJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXBlckZlYXR1cmVzLm1vZHVsZUV4cG9ydHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0aGFuZGxlRXhwb3J0cyhub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuY29kZVZMUSh2YWx1ZSkge1xuXHRcdFx0dmFyIHJlcyA9ICcnLFxuXHRcdFx0XHRiYXNlNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cdFx0XHR2YWx1ZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyAodmFsdWUgPCAwID8gMSA6IDApO1xuXHRcdFx0d2hpbGUgKHZhbHVlIHx8ICFyZXMpIHtcblx0XHRcdFx0dmFyIG5leHQgPSB2YWx1ZSAmICgzMiAtIDEpO1xuXHRcdFx0XHR2YWx1ZSA+Pj0gNTtcblx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdG5leHQgfD0gMzI7XG5cdFx0XHRcdHJlcyArPSBiYXNlNjRbbmV4dF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblxuXHRcdHZhciB1cmwgPSBvcHRpb25zLnVybCB8fCAnJyxcblx0XHRcdHNvdXJjZU1hcHMgPSBvcHRpb25zLnNvdXJjZU1hcHMsXG5cdFx0XHRwYXBlckZlYXR1cmVzID0gb3B0aW9ucy5wYXBlckZlYXR1cmVzIHx8IHt9LFxuXHRcdFx0c291cmNlID0gb3B0aW9ucy5zb3VyY2UgfHwgY29kZSxcblx0XHRcdG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDAsXG5cdFx0XHRhZ2VudCA9IHBhcGVyLmFnZW50LFxuXHRcdFx0dmVyc2lvbiA9IGFnZW50LnZlcnNpb25OdW1iZXIsXG5cdFx0XHRvZmZzZXRDb2RlID0gZmFsc2UsXG5cdFx0XHRsaW5lQnJlYWtzID0gL1xcclxcbnxcXG58XFxyL21nLFxuXHRcdFx0bWFwO1xuXHRcdGlmIChzb3VyY2VNYXBzICYmIChhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzMFxuXHRcdFx0XHR8fCBhZ2VudC53ZWJraXQgJiYgdmVyc2lvbiA+PSA1MzcuNzZcblx0XHRcdFx0fHwgYWdlbnQuZmlyZWZveCAmJiB2ZXJzaW9uID49IDIzXG5cdFx0XHRcdHx8IGFnZW50Lm5vZGUpKSB7XG5cdFx0XHRpZiAoYWdlbnQubm9kZSkge1xuXHRcdFx0XHRvZmZzZXQgLT0gMjtcblx0XHRcdH0gZWxzZSBpZiAod2luZG93ICYmIHVybCAmJiAhd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZih1cmwpKSB7XG5cdFx0XHRcdHZhciBodG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXS5pbm5lckhUTUw7XG5cdFx0XHRcdG9mZnNldCA9IGh0bWwuc3Vic3RyKDAsIGh0bWwuaW5kZXhPZihjb2RlKSArIDEpLm1hdGNoKFxuXHRcdFx0XHRcdFx0bGluZUJyZWFrcykubGVuZ3RoICsgMTtcblx0XHRcdH1cblx0XHRcdG9mZnNldENvZGUgPSBvZmZzZXQgPiAwICYmICEoXG5cdFx0XHRcdFx0YWdlbnQuY2hyb21lICYmIHZlcnNpb24gPj0gMzYgfHxcblx0XHRcdFx0XHRhZ2VudC5zYWZhcmkgJiYgdmVyc2lvbiA+PSA2MDAgfHxcblx0XHRcdFx0XHRhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gNDAgfHxcblx0XHRcdFx0XHRhZ2VudC5ub2RlKTtcblx0XHRcdHZhciBtYXBwaW5ncyA9IFsnQUEnICsgZW5jb2RlVkxRKG9mZnNldENvZGUgPyAwIDogb2Zmc2V0KSArICdBJ107XG5cdFx0XHRtYXBwaW5ncy5sZW5ndGggPSAoY29kZS5tYXRjaChsaW5lQnJlYWtzKSB8fCBbXSkubGVuZ3RoICsgMVxuXHRcdFx0XHRcdCsgKG9mZnNldENvZGUgPyBvZmZzZXQgOiAwKTtcblx0XHRcdG1hcCA9IHtcblx0XHRcdFx0dmVyc2lvbjogMyxcblx0XHRcdFx0ZmlsZTogdXJsLFxuXHRcdFx0XHRuYW1lczpbXSxcblx0XHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLmpvaW4oJztBQUNBJyksXG5cdFx0XHRcdHNvdXJjZVJvb3Q6ICcnLFxuXHRcdFx0XHRzb3VyY2VzOiBbdXJsXSxcblx0XHRcdFx0c291cmNlc0NvbnRlbnQ6IFtzb3VyY2VdXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHRwYXBlckZlYXR1cmVzLm9wZXJhdG9yT3ZlcmxvYWRpbmcgIT09IGZhbHNlIHx8XG5cdFx0XHRwYXBlckZlYXR1cmVzLm1vZHVsZUV4cG9ydHMgIT09IGZhbHNlXG5cdFx0KSB7XG5cdFx0XHR3YWxrQVNUKHBhcnNlKGNvZGUsIHtcblx0XHRcdFx0cmFuZ2VzOiB0cnVlLFxuXHRcdFx0XHRwcmVzZXJ2ZVBhcmVuczogdHJ1ZSxcblx0XHRcdFx0c291cmNlVHlwZTogJ21vZHVsZSdcblx0XHRcdH0pLCBudWxsLCBwYXBlckZlYXR1cmVzKTtcblx0XHR9XG5cdFx0aWYgKG1hcCkge1xuXHRcdFx0aWYgKG9mZnNldENvZGUpIHtcblx0XHRcdFx0Y29kZSA9IG5ldyBBcnJheShvZmZzZXQgKyAxKS5qb2luKCdcXG4nKSArIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoL14oaW5saW5lfGJvdGgpJC8udGVzdChzb3VyY2VNYXBzKSkge1xuXHRcdFx0XHRjb2RlICs9IFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIlxuXHRcdFx0XHRcdFx0KyBzZWxmLmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KFxuXHRcdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShtYXApKSkpO1xuXHRcdFx0fVxuXHRcdFx0Y29kZSArPSBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyAodXJsIHx8ICdwYXBlcnNjcmlwdCcpO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRzb3VyY2U6IHNvdXJjZSxcblx0XHRcdGNvZGU6IGNvZGUsXG5cdFx0XHRtYXA6IG1hcFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBleGVjdXRlKGNvZGUsIHNjb3BlLCBvcHRpb25zKSB7XG5cdFx0cGFwZXIgPSBzY29wZTtcblx0XHR2YXIgdmlldyA9IHNjb3BlLmdldFZpZXcoKSxcblx0XHRcdHRvb2wgPSAvXFxidG9vbFxcLlxcdyt8XFxzK29uKD86S2V5fE1vdXNlKSg/OlVwfERvd258TW92ZXxEcmFnKVxcYi9cblx0XHRcdFx0XHQudGVzdChjb2RlKSAmJiAhL1xcYm5ld1xccytUb29sXFxiLy50ZXN0KGNvZGUpXG5cdFx0XHRcdFx0XHQ/IG5ldyBUb29sKCkgOiBudWxsLFxuXHRcdFx0dG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuXHRcdFx0aGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcblx0XHRcdHBhcmFtcyA9IFtdLFxuXHRcdFx0YXJncyA9IFtdLFxuXHRcdFx0ZnVuYyxcblx0XHRcdGNvbXBpbGVkID0gdHlwZW9mIGNvZGUgPT09ICdvYmplY3QnID8gY29kZSA6IGNvbXBpbGUoY29kZSwgb3B0aW9ucyk7XG5cdFx0Y29kZSA9IGNvbXBpbGVkLmNvZGU7XG5cdFx0ZnVuY3Rpb24gZXhwb3NlKHNjb3BlLCBoaWRkZW4pIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBzY29wZSkge1xuXHRcdFx0XHRpZiAoKGhpZGRlbiB8fCAhL15fLy50ZXN0KGtleSkpICYmIG5ldyBSZWdFeHAoJyhbXFxcXGJcXFxcc1xcXFxXXXxeKSdcblx0XHRcdFx0XHRcdCsga2V5LnJlcGxhY2UoL1xcJC9nLCAnXFxcXCQnKSArICdcXFxcYicpLnRlc3QoY29kZSkpIHtcblx0XHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdGFyZ3MucHVzaChzY29wZVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRleHBvc2UoeyBfXyRfXzogX18kX18sICRfXzogJF9fLCBwYXBlcjogc2NvcGUsIHRvb2w6IHRvb2wgfSxcblx0XHRcdFx0dHJ1ZSk7XG5cdFx0ZXhwb3NlKHNjb3BlKTtcblx0XHRjb2RlID0gJ3ZhciBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH07ICcgKyBjb2RlO1xuXHRcdHZhciBleHBvcnRzID0gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdGlmIChuZXcgUmVnRXhwKCdcXFxccysnICsga2V5ICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHR0aGlzLnB1c2goJ21vZHVsZS5leHBvcnRzLicgKyBrZXkgKyAnID0gJyArIGtleSArICc7Jyk7XG5cdFx0XHR9XG5cdFx0fSwgW10pLmpvaW4oJ1xcbicpO1xuXHRcdGlmIChleHBvcnRzKSB7XG5cdFx0XHRjb2RlICs9ICdcXG4nICsgZXhwb3J0cztcblx0XHR9XG5cdFx0Y29kZSArPSAnXFxucmV0dXJuIG1vZHVsZS5leHBvcnRzOyc7XG5cdFx0dmFyIGFnZW50ID0gcGFwZXIuYWdlbnQ7XG5cdFx0aWYgKGRvY3VtZW50ICYmIChhZ2VudC5jaHJvbWVcblx0XHRcdFx0fHwgYWdlbnQuZmlyZWZveCAmJiBhZ2VudC52ZXJzaW9uTnVtYmVyIDwgNDApKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG5cdFx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdFx0XHRpZiAoYWdlbnQuZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J2RvY3VtZW50Ll9fcGFwZXJzY3JpcHRfXyA9IGZ1bmN0aW9uKCcgKyBwYXJhbXMgKyAnKSB7JyArXG5cdFx0XHRcdFx0Y29kZSArXG5cdFx0XHRcdCdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fO1xuXHRcdFx0ZGVsZXRlIGRvY3VtZW50Ll9fcGFwZXJzY3JpcHRfXztcblx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnVuYyA9IEZ1bmN0aW9uKHBhcmFtcywgY29kZSk7XG5cdFx0fVxuXHRcdHZhciBleHBvcnRzID0gZnVuYyAmJiBmdW5jLmFwcGx5KHNjb3BlLCBhcmdzKTtcblx0XHR2YXIgb2JqID0gZXhwb3J0cyB8fCB7fTtcblx0XHRCYXNlLmVhY2godG9vbEhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHR0b29sW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRpZiAodmlldykge1xuXHRcdFx0aWYgKG9iai5vblJlc2l6ZSlcblx0XHRcdFx0dmlldy5zZXRPblJlc2l6ZShvYmoub25SZXNpemUpO1xuXHRcdFx0dmlldy5lbWl0KCdyZXNpemUnLCB7XG5cdFx0XHRcdHNpemU6IHZpZXcuc2l6ZSxcblx0XHRcdFx0ZGVsdGE6IG5ldyBQb2ludCgpXG5cdFx0XHR9KTtcblx0XHRcdGlmIChvYmoub25GcmFtZSlcblx0XHRcdFx0dmlldy5zZXRPbkZyYW1lKG9iai5vbkZyYW1lKTtcblx0XHRcdHZpZXcucmVxdWVzdFVwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZXhwb3J0cztcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0KSB7XG5cdFx0aWYgKC9edGV4dFxcLyg/OngtfClwYXBlcnNjcmlwdCQvLnRlc3Qoc2NyaXB0LnR5cGUpXG5cdFx0XHRcdCYmIFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2lnbm9yZScpICE9PSAndHJ1ZScpIHtcblx0XHRcdHZhciBjYW52YXNJZCA9IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2NhbnZhcycpLFxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCksXG5cdFx0XHRcdHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSxcblx0XHRcdFx0YXN5bmMgPSBQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShzY3JpcHQsICdhc3luYycpLFxuXHRcdFx0XHRzY29wZUF0dHJpYnV0ZSA9ICdkYXRhLXBhcGVyLXNjb3BlJztcblx0XHRcdGlmICghY2FudmFzKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGNhbnZhcyB3aXRoIGlkIFwiJ1xuXHRcdFx0XHRcdFx0KyBjYW52YXNJZCArICdcIicpO1xuXHRcdFx0dmFyIHNjb3BlID0gUGFwZXJTY29wZS5nZXQoY2FudmFzLmdldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSkpXG5cdFx0XHRcdFx0XHR8fCBuZXcgUGFwZXJTY29wZSgpLnNldHVwKGNhbnZhcyk7XG5cdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlLCBzY29wZS5faWQpO1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRIdHRwLnJlcXVlc3Qoe1xuXHRcdFx0XHRcdHVybDogc3JjLFxuXHRcdFx0XHRcdGFzeW5jOiBhc3luYyxcblx0XHRcdFx0XHRtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuXHRcdFx0XHRcdG9uTG9hZDogZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRcdFx0ZXhlY3V0ZShjb2RlLCBzY29wZSwgc3JjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhlY3V0ZShzY3JpcHQuaW5uZXJIVE1MLCBzY29wZSwgc2NyaXB0LmJhc2VVUkkpO1xuXHRcdFx0fVxuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1pZ25vcmUnLCAndHJ1ZScpO1xuXHRcdFx0cmV0dXJuIHNjb3BlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRBbGwoKSB7XG5cdFx0QmFzZS5lYWNoKGRvY3VtZW50ICYmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcblx0XHRcdFx0bG9hZFNjcmlwdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkKHNjcmlwdCkge1xuXHRcdHJldHVybiBzY3JpcHQgPyBsb2FkU2NyaXB0KHNjcmlwdCkgOiBsb2FkQWxsKCk7XG5cdH1cblxuXHRpZiAod2luZG93KSB7XG5cdFx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0XHRcdHNldFRpbWVvdXQobG9hZEFsbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHsgbG9hZDogbG9hZEFsbCB9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNvbXBpbGU6IGNvbXBpbGUsXG5cdFx0ZXhlY3V0ZTogZXhlY3V0ZSxcblx0XHRsb2FkOiBsb2FkLFxuXHRcdHBhcnNlOiBwYXJzZSxcblx0XHRjYWxjdWxhdGVCaW5hcnk6IF9fJF9fLFxuXHRcdGNhbGN1bGF0ZVVuYXJ5OiAkX19cblx0fTtcblxufS5jYWxsKHRoaXMpO1xuXG52YXIgcGFwZXIgPSBuZXcgKFBhcGVyU2NvcGUuaW5qZWN0KEJhc2UuZXhwb3J0cywge1xuXHRCYXNlOiBCYXNlLFxuXHROdW1lcmljYWw6IE51bWVyaWNhbCxcblx0S2V5OiBLZXksXG5cdERvbUV2ZW50OiBEb21FdmVudCxcblx0RG9tRWxlbWVudDogRG9tRWxlbWVudCxcblx0ZG9jdW1lbnQ6IGRvY3VtZW50LFxuXHR3aW5kb3c6IHdpbmRvdyxcblx0U3ltYm9sOiBTeW1ib2xEZWZpbml0aW9uLFxuXHRQbGFjZWRTeW1ib2w6IFN5bWJvbEl0ZW1cbn0pKSgpO1xuXG5pZiAocGFwZXIuYWdlbnQubm9kZSkge1xuXHRyZXF1aXJlKCcuL25vZGUvZXh0ZW5kLmpzJykocGFwZXIpO1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdGRlZmluZSgncGFwZXInLCBwYXBlcik7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xufVxuXG5yZXR1cm4gcGFwZXI7XG59LmNhbGwodGhpcywgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IG51bGwpO1xuIiwiXHJcbmltcG9ydCBwYXBlciBmcm9tICdwYXBlcic7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQW5pQmFzZSB7XHJcblxyXG4gIHByb3RlY3RlZCByZWFkb25seSBfZWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgcHJvdGVjdGVkIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gIHByb3RlY3RlZCByZWFkb25seSBfcHJvamVjdDogcGFwZXIuUHJvamVjdDtcclxuXHJcbiAgcHJvdGVjdGVkIGdldCBXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy53aWR0aDtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgSGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLmhlaWdodDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgdGhpcy5fcHJvamVjdCA9IG5ldyBwYXBlci5Qcm9qZWN0KHRoaXMuX2NhbnZhcyk7XHJcbiAgICB0aGlzLkluaXRpYWxpemVDYW52YXMoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgSW5pdGlhbGl6ZUNhbnZhcygpOiB2b2lkIHtcclxuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX2VsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5fZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgU3RhcnRBbmkoKTogdm9pZDtcclxuXHJcblxyXG59IiwiaW1wb3J0IHsgQW5pQmFzZSB9IGZyb20gJy4vYWJzdHJhY3Rpb25zL2FuaS1iYXNlJztcclxuaW1wb3J0IHBhcGVyIGZyb20gJ3BhcGVyJztcclxuaW1wb3J0IHsgQW5pSGVscGVycyB9IGZyb20gJy4vaGVscGVycy9hbmktaGVscGVycyc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAncGFwZXIvZGlzdC9wYXBlci1jb3JlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDb25jZW50cmljQW5pIGV4dGVuZHMgQW5pQmFzZSB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBfY2lyY2xlczogcGFwZXIuUGF0aC5DaXJjbGVbXSA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgc3VwZXIoZWxlbWVudCk7XHJcbiAgICB0aGlzLlN0YXJ0QW5pKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIENyZWF0ZUVsZW1lbnRzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgbWF4UmFkaXVzOiBudW1iZXIgPSB0aGlzLkhlaWdodCA+PSB0aGlzLldpZHRoID8gKHRoaXMuSGVpZ2h0IC0gMTApIC8gMiA6ICh0aGlzLldpZHRoIC0gMTApIC8gMjtcclxuXHJcbiAgICBsZXQgY3VycmVudFJhZGl1czogbnVtYmVyID0gbWF4UmFkaXVzO1xyXG4gICAgY29uc3Qgc3Ryb2tlQ29sb3I6IHBhcGVyLkNvbG9yID0gbmV3IHBhcGVyLkNvbG9yKCdibGFjaycpO1xyXG5cclxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgY29uc3QgY2VudGVyOiBbeDogbnVtYmVyLCB5OiBudW1iZXJdID0gQW5pSGVscGVycy5HZXRDZW50ZXJGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgY29uc3QgcG9pbnQ6IHBhcGVyLlBvaW50ID0gbmV3IHBhcGVyLlBvaW50KGNlbnRlclswXSwgY2VudGVyWzFdKTtcclxuICAgICAgY29uc3QgY2lyY2xlOiBwYXBlci5QYXRoLkNpcmNsZSA9IG5ldyBwYXBlci5QYXRoLkNpcmNsZShwb2ludCwgY3VycmVudFJhZGl1cyk7XHJcbiAgICAgIGNpcmNsZS5zdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgIGNpcmNsZS5zdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yO1xyXG5cclxuICAgICAgdGhpcy5fY2lyY2xlcy5wdXNoKGNpcmNsZSk7XHJcblxyXG4gICAgICBjdXJyZW50UmFkaXVzIC09IG1heFJhZGl1cyAvIDQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJvamVjdC52aWV3LnZpZXdTaXplID0gbmV3IHBhcGVyLlNpemUodGhpcy5XaWR0aCwgdGhpcy5IZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIFN0YXJ0QW5pKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2NpcmNsZXMubGVuZ3RoID09PSAwKSB0aGlzLkNyZWF0ZUVsZW1lbnRzKCk7XHJcbiAgICB0aGlzLkRvQW5pbWF0aW9uKDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBEb0FuaW1hdGlvbihpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBsZXQgZGlyZWN0aW9uOiAndXAnIHwgJ2Rvd24nID0gJ3VwJztcclxuXHJcbiAgICBjb25zdCBpbnRlcnZhbDogbnVtYmVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGBBbmltYXRpbmc6ICR7aW5kZXh9IHwgJHtkaXJlY3Rpb259IHwgJHt0aGlzLl9jaXJjbGVzW2luZGV4XS5zdHJva2VXaWR0aH1gKTtcclxuXHJcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcclxuICAgICAgICB0aGlzLl9jaXJjbGVzW2luZGV4XS5zdHJva2VXaWR0aCArPSAwLjU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NpcmNsZXNbaW5kZXhdLnN0cm9rZVdpZHRoID09PSA0KSB7XHJcbiAgICAgICAgICBkaXJlY3Rpb24gPSAnZG93bic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2NpcmNsZXNbaW5kZXhdLnN0cm9rZVdpZHRoIC09IDAuNTtcclxuICAgICAgICBpZiAodGhpcy5fY2lyY2xlc1tpbmRleF0uc3Ryb2tlV2lkdGggPT09IDEpIHtcclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgdGhpcy5Eb0FuaW1hdGlvbihpbmRleCA9PT0gMyA/IDAgOiArK2luZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIDE2KTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIEFuaUhlbHBlcnMge1xyXG4gIHB1YmxpYyBzdGF0aWMgR2V0Q2VudGVyRnJvbUVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBbeDogbnVtYmVyLCB5OiBudW1iZXJdIHtcclxuICAgIGNvbnN0IHJlc3VsdDogW3g6IG51bWJlciwgeTogbnVtYmVyXSA9IFtlbGVtZW50LmNsaWVudFdpZHRoIC8gMiwgZWxlbWVudC5jbGllbnRIZWlnaHQgLyAyXTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcbiJdfQ==
